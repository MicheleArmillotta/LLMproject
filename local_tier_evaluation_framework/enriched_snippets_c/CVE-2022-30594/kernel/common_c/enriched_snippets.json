[
  {
    "function_name": "irqentry_nmi_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "455-470",
    "snippet": "void noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)\n{\n\tinstrumentation_begin();\n\tftrace_nmi_exit();\n\tif (irq_state.lockdep) {\n\t\ttrace_hardirqs_on_prepare();\n\t\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\t}\n\tinstrumentation_end();\n\n\trcu_nmi_exit();\n\tlockdep_hardirq_exit();\n\tif (irq_state.lockdep)\n\t\tlockdep_hardirqs_on(CALLER_ADDR0);\n\t__nmi_exit();\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nmi_exit",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4297-4358",
          "snippet": "void noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_exit",
          "args": [],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nmi_exit",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nmi_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "740-780",
          "snippet": "noinstr void rcu_nmi_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tinstrumentation_begin();\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2,\n\t\t\t\t  atomic_read(&rdp->dynticks));\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\tinstrumentation_end();\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, atomic_read(&rdp->dynticks));\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\tinstrumentation_end();\n\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\n\tif (!in_nmi())\n\t\trcu_dynticks_task_enter();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static noinline noinstr",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nnoinstr void rcu_nmi_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tinstrumentation_begin();\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2,\n\t\t\t\t  atomic_read(&rdp->dynticks));\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\tinstrumentation_end();\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, atomic_read(&rdp->dynticks));\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\tinstrumentation_end();\n\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\n\tif (!in_nmi())\n\t\trcu_dynticks_task_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on_prepare",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4244-4294",
          "snippet": "void lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on_prepare",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "28-36",
          "snippet": "void trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_nmi_exit",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nvoid noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)\n{\n\tinstrumentation_begin();\n\tftrace_nmi_exit();\n\tif (irq_state.lockdep) {\n\t\ttrace_hardirqs_on_prepare();\n\t\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\t}\n\tinstrumentation_end();\n\n\trcu_nmi_exit();\n\tlockdep_hardirq_exit();\n\tif (irq_state.lockdep)\n\t\tlockdep_hardirqs_on(CALLER_ADDR0);\n\t__nmi_exit();\n}"
  },
  {
    "function_name": "irqentry_nmi_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "436-453",
    "snippet": "irqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)\n{\n\tirqentry_state_t irq_state;\n\n\tirq_state.lockdep = lockdep_hardirqs_enabled();\n\n\t__nmi_enter();\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\tlockdep_hardirq_enter();\n\trcu_nmi_enter();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tftrace_nmi_enter();\n\tinstrumentation_end();\n\n\treturn irq_state;\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_nmi_enter",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_off_finish",
          "args": [],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hardirqs_off_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "61-70",
          "snippet": "void trace_hardirqs_off_finish(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_off_finish(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nmi_enter",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nmi_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "987-1033",
          "snippet": "noinstr void rcu_nmi_enter(void)\n{\n\tlong incby = 2;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (!in_nmi())\n\t\t\trcu_dynticks_task_exit();\n\n\t\t// RCU is not watching here ...\n\t\trcu_dynticks_eqs_exit();\n\t\t// ... but is watching here.\n\n\t\tinstrumentation_begin();\n\t\t// instrumentation for the noinstr rcu_dynticks_curr_cpu_in_eqs()\n\t\tinstrument_atomic_read(&rdp->dynticks, sizeof(rdp->dynticks));\n\t\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\t\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\t\tincby = 1;\n\t} else if (!in_nmi()) {\n\t\tinstrumentation_begin();\n\t\trcu_irq_enter_check_tick();\n\t} else  {\n\t\tinstrumentation_begin();\n\t}\n\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, atomic_read(&rdp->dynticks));\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static noinline noinstr",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic noinline noinstr;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nnoinstr void rcu_nmi_enter(void)\n{\n\tlong incby = 2;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (!in_nmi())\n\t\t\trcu_dynticks_task_exit();\n\n\t\t// RCU is not watching here ...\n\t\trcu_dynticks_eqs_exit();\n\t\t// ... but is watching here.\n\n\t\tinstrumentation_begin();\n\t\t// instrumentation for the noinstr rcu_dynticks_curr_cpu_in_eqs()\n\t\tinstrument_atomic_read(&rdp->dynticks, sizeof(rdp->dynticks));\n\t\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\t\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\t\tincby = 1;\n\t} else if (!in_nmi()) {\n\t\tinstrumentation_begin();\n\t\trcu_irq_enter_check_tick();\n\t} else  {\n\t\tinstrumentation_begin();\n\t}\n\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, atomic_read(&rdp->dynticks));\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hardirq_enter",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_off",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4364-4400",
          "snippet": "void noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nmi_enter",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_enabled",
          "args": [],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nirqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)\n{\n\tirqentry_state_t irq_state;\n\n\tirq_state.lockdep = lockdep_hardirqs_enabled();\n\n\t__nmi_enter();\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\tlockdep_hardirq_enter();\n\trcu_nmi_enter();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tftrace_nmi_enter();\n\tinstrumentation_end();\n\n\treturn irq_state;\n}"
  },
  {
    "function_name": "irqentry_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "391-434",
    "snippet": "noinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)\n{\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check whether this returns to user mode */\n\tif (user_mode(regs)) {\n\t\tirqentry_exit_to_user_mode(regs);\n\t} else if (!regs_irqs_disabled(regs)) {\n\t\t/*\n\t\t * If RCU was not watching on entry this needs to be done\n\t\t * carefully and needs the same ordering of lockdep/tracing\n\t\t * and RCU as the return to user mode path.\n\t\t */\n\t\tif (state.exit_rcu) {\n\t\t\tinstrumentation_begin();\n\t\t\t/* Tell the tracer that IRET will enable interrupts */\n\t\t\ttrace_hardirqs_on_prepare();\n\t\t\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\t\t\tinstrumentation_end();\n\t\t\trcu_irq_exit();\n\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);\n\t\t\treturn;\n\t\t}\n\n\t\tinstrumentation_begin();\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION)) {\n#ifdef CONFIG_PREEMPT_DYNAMIC\n\t\t\tstatic_call(irqentry_exit_cond_resched)();\n#else\n\t\t\tirqentry_exit_cond_resched();\n#endif\n\t\t}\n\t\t/* Covers both tracing and lockdep */\n\t\ttrace_hardirqs_on();\n\t\tinstrumentation_end();\n\t} else {\n\t\t/*\n\t\t * IRQ flags state is correct already. Just tell RCU if it\n\t\t * was not watching on entry.\n\t\t */\n\t\tif (state.exit_rcu)\n\t\t\trcu_irq_exit();\n\t}\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_irq_exit",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_exit_irqson",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "831-838",
          "snippet": "void rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "40-51",
          "snippet": "void trace_hardirqs_on(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_on(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqentry_exit_cond_resched",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "irqentry_exit_cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "376-386",
          "snippet": "void irqentry_exit_cond_resched(void)\n{\n\tif (!preempt_count()) {\n\t\t/* Sanity check RCU and thread stack */\n\t\trcu_irq_exit_check_preempt();\n\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))\n\t\t\tWARN_ON_ONCE(!on_thread_stack());\n\t\tif (need_resched())\n\t\t\tpreempt_schedule_irq();\n\t}\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nvoid irqentry_exit_cond_resched(void)\n{\n\tif (!preempt_count()) {\n\t\t/* Sanity check RCU and thread stack */\n\t\trcu_irq_exit_check_preempt();\n\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))\n\t\t\tWARN_ON_ONCE(!on_thread_stack());\n\t\tif (need_resched())\n\t\t\tpreempt_schedule_irq();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "test_static_call_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "531-545",
          "snippet": "static int __init test_static_call_init(void)\n{\n      int i;\n\n      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {\n\t      struct static_call_data *scd = &static_call_data[i];\n\n              if (scd->func)\n                      static_call_update(sc_selftest, scd->func);\n\n              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);\n      }\n\n      return 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic int __init test_static_call_init(void)\n{\n      int i;\n\n      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {\n\t      struct static_call_data *scd = &static_call_data[i];\n\n              if (scd->func)\n                      static_call_update(sc_selftest, scd->func);\n\n              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);\n      }\n\n      return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_call",
          "args": [
            "irqentry_exit_cond_resched"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_del_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "392-419",
          "snippet": "static void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPTION"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4297-4358",
          "snippet": "void noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on_prepare",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4244-4294",
          "snippet": "void lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on_prepare",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "28-36",
          "snippet": "void trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_irqs_disabled",
          "args": [
            "regs"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqentry_exit_to_user_mode",
          "args": [
            "regs"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "irqentry_exit_to_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "303-309",
          "snippet": "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)\n{\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check whether this returns to user mode */\n\tif (user_mode(regs)) {\n\t\tirqentry_exit_to_user_mode(regs);\n\t} else if (!regs_irqs_disabled(regs)) {\n\t\t/*\n\t\t * If RCU was not watching on entry this needs to be done\n\t\t * carefully and needs the same ordering of lockdep/tracing\n\t\t * and RCU as the return to user mode path.\n\t\t */\n\t\tif (state.exit_rcu) {\n\t\t\tinstrumentation_begin();\n\t\t\t/* Tell the tracer that IRET will enable interrupts */\n\t\t\ttrace_hardirqs_on_prepare();\n\t\t\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\t\t\tinstrumentation_end();\n\t\t\trcu_irq_exit();\n\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);\n\t\t\treturn;\n\t\t}\n\n\t\tinstrumentation_begin();\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION)) {\n#ifdef CONFIG_PREEMPT_DYNAMIC\n\t\t\tstatic_call(irqentry_exit_cond_resched)();\n#else\n\t\t\tirqentry_exit_cond_resched();\n#endif\n\t\t}\n\t\t/* Covers both tracing and lockdep */\n\t\ttrace_hardirqs_on();\n\t\tinstrumentation_end();\n\t} else {\n\t\t/*\n\t\t * IRQ flags state is correct already. Just tell RCU if it\n\t\t * was not watching on entry.\n\t\t */\n\t\tif (state.exit_rcu)\n\t\t\trcu_irq_exit();\n\t}\n}"
  },
  {
    "function_name": "irqentry_exit_cond_resched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "376-386",
    "snippet": "void irqentry_exit_cond_resched(void)\n{\n\tif (!preempt_count()) {\n\t\t/* Sanity check RCU and thread stack */\n\t\trcu_irq_exit_check_preempt();\n\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))\n\t\t\tWARN_ON_ONCE(!on_thread_stack());\n\t\tif (need_resched())\n\t\t\tpreempt_schedule_irq();\n\t}\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_schedule_irq",
          "args": [],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_schedule_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6699-6717",
          "snippet": "void __sched preempt_schedule_irq(void)\n{\n\tenum ctx_state prev_state;\n\n\t/* Catch callers which need to be fixed */\n\tBUG_ON(preempt_count() || !irqs_disabled());\n\n\tprev_state = exception_enter();\n\n\tdo {\n\t\tpreempt_disable();\n\t\tlocal_irq_enable();\n\t\t__schedule(SM_PREEMPT);\n\t\tlocal_irq_disable();\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n\n\texception_exit(prev_state);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [
            "#define SM_PREEMPT\t\t0x1"
          ],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\n#define SM_PREEMPT\t\t0x1\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched preempt_schedule_irq(void)\n{\n\tenum ctx_state prev_state;\n\n\t/* Catch callers which need to be fixed */\n\tBUG_ON(preempt_count() || !irqs_disabled());\n\n\tprev_state = exception_enter();\n\n\tdo {\n\t\tpreempt_disable();\n\t\tlocal_irq_enable();\n\t\t__schedule(SM_PREEMPT);\n\t\tlocal_irq_disable();\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n\n\texception_exit(prev_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!on_thread_stack()"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_thread_stack",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_ENTRY"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_irq_exit_check_preempt",
          "args": [],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_exit_check_preempt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "811-822",
          "snippet": "void rcu_irq_exit_check_preempt(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) <= 0,\n\t\t\t \"RCU dynticks_nesting counter underflow/zero!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) !=\n\t\t\t DYNTICK_IRQ_NONIDLE,\n\t\t\t \"Bad RCU  dynticks_nmi_nesting counter\\n\");\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"RCU in extended quiescent state!\");\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nvoid rcu_irq_exit_check_preempt(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) <= 0,\n\t\t\t \"RCU dynticks_nesting counter underflow/zero!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) !=\n\t\t\t DYNTICK_IRQ_NONIDLE,\n\t\t\t \"Bad RCU  dynticks_nmi_nesting counter\\n\");\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"RCU in extended quiescent state!\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nvoid irqentry_exit_cond_resched(void)\n{\n\tif (!preempt_count()) {\n\t\t/* Sanity check RCU and thread stack */\n\t\trcu_irq_exit_check_preempt();\n\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))\n\t\t\tWARN_ON_ONCE(!on_thread_stack());\n\t\tif (need_resched())\n\t\t\tpreempt_schedule_irq();\n\t}\n}"
  },
  {
    "function_name": "irqentry_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "311-374",
    "snippet": "noinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)\n{\n\tirqentry_state_t ret = {\n\t\t.exit_rcu = false,\n\t};\n\n\tif (user_mode(regs)) {\n\t\tirqentry_enter_from_user_mode(regs);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If this entry hit the idle task invoke rcu_irq_enter() whether\n\t * RCU is watching or not.\n\t *\n\t * Interrupts can nest when the first interrupt invokes softirq\n\t * processing on return which enables interrupts.\n\t *\n\t * Scheduler ticks in the idle task can mark quiescent state and\n\t * terminate a grace period, if and only if the timer interrupt is\n\t * not nested into another interrupt.\n\t *\n\t * Checking for rcu_is_watching() here would prevent the nesting\n\t * interrupt to invoke rcu_irq_enter(). If that nested interrupt is\n\t * the tick then rcu_flavor_sched_clock_irq() would wrongfully\n\t * assume that it is the first interrupt and eventually claim\n\t * quiescent state and end grace periods prematurely.\n\t *\n\t * Unconditionally invoke rcu_irq_enter() so RCU state stays\n\t * consistent.\n\t *\n\t * TINY_RCU does not support EQS, so let the compiler eliminate\n\t * this part when enabled.\n\t */\n\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {\n\t\t/*\n\t\t * If RCU is not watching then the same careful\n\t\t * sequence vs. lockdep and tracing is required\n\t\t * as in irqentry_enter_from_user_mode().\n\t\t */\n\t\tlockdep_hardirqs_off(CALLER_ADDR0);\n\t\trcu_irq_enter();\n\t\tinstrumentation_begin();\n\t\ttrace_hardirqs_off_finish();\n\t\tinstrumentation_end();\n\n\t\tret.exit_rcu = true;\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If RCU is watching then RCU only wants to check whether it needs\n\t * to restart the tick in NOHZ mode. rcu_irq_enter_check_tick()\n\t * already contains a warning when RCU is not watching, so no point\n\t * in having another one here.\n\t */\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\tinstrumentation_begin();\n\trcu_irq_enter_check_tick();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_off_finish",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hardirqs_off_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "61-70",
          "snippet": "void trace_hardirqs_off_finish(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_off_finish(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_irq_enter_check_tick",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_irq_enter_check_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "939-972",
          "snippet": "void __rcu_irq_enter_check_tick(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t// If we're here from NMI there's nothing to do.\n\tif (in_nmi())\n\t\treturn;\n\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"Illegal rcu_irq_enter_check_tick() from extended quiescent state\");\n\n\tif (!tick_nohz_full_cpu(rdp->cpu) ||\n\t    !READ_ONCE(rdp->rcu_urgent_qs) ||\n\t    READ_ONCE(rdp->rcu_forced_tick)) {\n\t\t// RCU doesn't need nohz_full help from this CPU, or it is\n\t\t// already getting that help.\n\t\treturn;\n\t}\n\n\t// We get here only when not in an extended quiescent state and\n\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is\n\t// already watching and (2) The fact that we are in an interrupt\n\t// handler and that the rcu_node lock is an irq-disabled lock\n\t// prevents self-deadlock.  So we can safely recheck under the lock.\n\t// Note that the nohz_full state currently cannot change.\n\traw_spin_lock_rcu_node(rdp->mynode);\n\tif (rdp->rcu_urgent_qs && !rdp->rcu_forced_tick) {\n\t\t// A nohz_full CPU is in the kernel and RCU needs a\n\t\t// quiescent state.  Turn on the tick!\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, true);\n\t\ttick_dep_set_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t}\n\traw_spin_unlock_rcu_node(rdp->mynode);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid __rcu_irq_enter_check_tick(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t// If we're here from NMI there's nothing to do.\n\tif (in_nmi())\n\t\treturn;\n\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"Illegal rcu_irq_enter_check_tick() from extended quiescent state\");\n\n\tif (!tick_nohz_full_cpu(rdp->cpu) ||\n\t    !READ_ONCE(rdp->rcu_urgent_qs) ||\n\t    READ_ONCE(rdp->rcu_forced_tick)) {\n\t\t// RCU doesn't need nohz_full help from this CPU, or it is\n\t\t// already getting that help.\n\t\treturn;\n\t}\n\n\t// We get here only when not in an extended quiescent state and\n\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is\n\t// already watching and (2) The fact that we are in an interrupt\n\t// handler and that the rcu_node lock is an irq-disabled lock\n\t// prevents self-deadlock.  So we can safely recheck under the lock.\n\t// Note that the nohz_full state currently cannot change.\n\traw_spin_lock_rcu_node(rdp->mynode);\n\tif (rdp->rcu_urgent_qs && !rdp->rcu_forced_tick) {\n\t\t// A nohz_full CPU is in the kernel and RCU needs a\n\t\t// quiescent state.  Turn on the tick!\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, true);\n\t\ttick_dep_set_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t}\n\traw_spin_unlock_rcu_node(rdp->mynode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_off",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4364-4400",
          "snippet": "void noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_irq_enter",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_enter_irqson",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1069-1076",
          "snippet": "void rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TINY_RCU"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqentry_enter_from_user_mode",
          "args": [
            "regs"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "irqentry_enter_from_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "298-301",
          "snippet": "noinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "irqentry_exit_to_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "303-309",
          "snippet": "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)\n{\n\tirqentry_state_t ret = {\n\t\t.exit_rcu = false,\n\t};\n\n\tif (user_mode(regs)) {\n\t\tirqentry_enter_from_user_mode(regs);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If this entry hit the idle task invoke rcu_irq_enter() whether\n\t * RCU is watching or not.\n\t *\n\t * Interrupts can nest when the first interrupt invokes softirq\n\t * processing on return which enables interrupts.\n\t *\n\t * Scheduler ticks in the idle task can mark quiescent state and\n\t * terminate a grace period, if and only if the timer interrupt is\n\t * not nested into another interrupt.\n\t *\n\t * Checking for rcu_is_watching() here would prevent the nesting\n\t * interrupt to invoke rcu_irq_enter(). If that nested interrupt is\n\t * the tick then rcu_flavor_sched_clock_irq() would wrongfully\n\t * assume that it is the first interrupt and eventually claim\n\t * quiescent state and end grace periods prematurely.\n\t *\n\t * Unconditionally invoke rcu_irq_enter() so RCU state stays\n\t * consistent.\n\t *\n\t * TINY_RCU does not support EQS, so let the compiler eliminate\n\t * this part when enabled.\n\t */\n\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {\n\t\t/*\n\t\t * If RCU is not watching then the same careful\n\t\t * sequence vs. lockdep and tracing is required\n\t\t * as in irqentry_enter_from_user_mode().\n\t\t */\n\t\tlockdep_hardirqs_off(CALLER_ADDR0);\n\t\trcu_irq_enter();\n\t\tinstrumentation_begin();\n\t\ttrace_hardirqs_off_finish();\n\t\tinstrumentation_end();\n\n\t\tret.exit_rcu = true;\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If RCU is watching then RCU only wants to check whether it needs\n\t * to restart the tick in NOHZ mode. rcu_irq_enter_check_tick()\n\t * already contains a warning when RCU is not watching, so no point\n\t * in having another one here.\n\t */\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\tinstrumentation_begin();\n\trcu_irq_enter_check_tick();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irqentry_exit_to_user_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "303-309",
    "snippet": "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__exit_to_user_mode",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__exit_to_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "124-134",
          "snippet": "static __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_to_user_mode_prepare",
          "args": [
            "regs"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_exit_to_user_mode_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "255-276",
          "snippet": "static void syscall_exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\tunsigned long nr = syscall_get_nr(current, regs);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_KERNEL);\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tif (WARN(irqs_disabled(), \"syscall %lu left IRQs disabled\", nr))\n\t\t\tlocal_irq_enable();\n\t}\n\n\trseq_syscall(regs);\n\n\t/*\n\t * Do one-time syscall specific work. If these work items are\n\t * enabled, we want to run them exactly once per syscall exit with\n\t * interrupts enabled.\n\t */\n\tif (unlikely(work & SYSCALL_WORK_EXIT))\n\t\tsyscall_exit_work(regs, work);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic void syscall_exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\tunsigned long nr = syscall_get_nr(current, regs);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_KERNEL);\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tif (WARN(irqs_disabled(), \"syscall %lu left IRQs disabled\", nr))\n\t\t\tlocal_irq_enable();\n\t}\n\n\trseq_syscall(regs);\n\n\t/*\n\t * Do one-time syscall specific work. If these work items are\n\t * enabled, we want to run them exactly once per syscall exit with\n\t * interrupts enabled.\n\t */\n\tif (unlikely(work & SYSCALL_WORK_EXIT))\n\t\tsyscall_exit_work(regs, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}"
  },
  {
    "function_name": "irqentry_enter_from_user_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "298-301",
    "snippet": "noinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__enter_from_user_mode",
          "args": [
            "regs"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "__enter_from_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "17-28",
          "snippet": "static __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n}"
  },
  {
    "function_name": "syscall_exit_to_user_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "290-296",
    "snippet": "void syscall_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\t__syscall_exit_to_user_mode_work(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__exit_to_user_mode",
          "args": [],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__exit_to_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "124-134",
          "snippet": "static __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__syscall_exit_to_user_mode_work",
          "args": [
            "regs"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "__syscall_exit_to_user_mode_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "278-283",
          "snippet": "static __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\tsyscall_exit_to_user_mode_prepare(regs);\n\tlocal_irq_disable_exit_to_user();\n\texit_to_user_mode_prepare(regs);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\tsyscall_exit_to_user_mode_prepare(regs);\n\tlocal_irq_disable_exit_to_user();\n\texit_to_user_mode_prepare(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nvoid syscall_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\t__syscall_exit_to_user_mode_work(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}"
  },
  {
    "function_name": "syscall_exit_to_user_mode_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "285-288",
    "snippet": "void syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\t__syscall_exit_to_user_mode_work(regs);\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__syscall_exit_to_user_mode_work",
          "args": [
            "regs"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__syscall_exit_to_user_mode_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "278-283",
          "snippet": "static __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\tsyscall_exit_to_user_mode_prepare(regs);\n\tlocal_irq_disable_exit_to_user();\n\texit_to_user_mode_prepare(regs);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\tsyscall_exit_to_user_mode_prepare(regs);\n\tlocal_irq_disable_exit_to_user();\n\texit_to_user_mode_prepare(regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nvoid syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\t__syscall_exit_to_user_mode_work(regs);\n}"
  },
  {
    "function_name": "__syscall_exit_to_user_mode_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "278-283",
    "snippet": "static __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\tsyscall_exit_to_user_mode_prepare(regs);\n\tlocal_irq_disable_exit_to_user();\n\texit_to_user_mode_prepare(regs);\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_to_user_mode_prepare",
          "args": [
            "regs"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_exit_to_user_mode_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "255-276",
          "snippet": "static void syscall_exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\tunsigned long nr = syscall_get_nr(current, regs);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_KERNEL);\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tif (WARN(irqs_disabled(), \"syscall %lu left IRQs disabled\", nr))\n\t\t\tlocal_irq_enable();\n\t}\n\n\trseq_syscall(regs);\n\n\t/*\n\t * Do one-time syscall specific work. If these work items are\n\t * enabled, we want to run them exactly once per syscall exit with\n\t * interrupts enabled.\n\t */\n\tif (unlikely(work & SYSCALL_WORK_EXIT))\n\t\tsyscall_exit_work(regs, work);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic void syscall_exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\tunsigned long nr = syscall_get_nr(current, regs);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_KERNEL);\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tif (WARN(irqs_disabled(), \"syscall %lu left IRQs disabled\", nr))\n\t\t\tlocal_irq_enable();\n\t}\n\n\trseq_syscall(regs);\n\n\t/*\n\t * Do one-time syscall specific work. If these work items are\n\t * enabled, we want to run them exactly once per syscall exit with\n\t * interrupts enabled.\n\t */\n\tif (unlikely(work & SYSCALL_WORK_EXIT))\n\t\tsyscall_exit_work(regs, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable_exit_to_user",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\tsyscall_exit_to_user_mode_prepare(regs);\n\tlocal_irq_disable_exit_to_user();\n\texit_to_user_mode_prepare(regs);\n}"
  },
  {
    "function_name": "syscall_exit_to_user_mode_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "255-276",
    "snippet": "static void syscall_exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\tunsigned long nr = syscall_get_nr(current, regs);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_KERNEL);\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tif (WARN(irqs_disabled(), \"syscall %lu left IRQs disabled\", nr))\n\t\t\tlocal_irq_enable();\n\t}\n\n\trseq_syscall(regs);\n\n\t/*\n\t * Do one-time syscall specific work. If these work items are\n\t * enabled, we want to run them exactly once per syscall exit with\n\t * interrupts enabled.\n\t */\n\tif (unlikely(work & SYSCALL_WORK_EXIT))\n\t\tsyscall_exit_work(regs, work);\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_exit_work",
          "args": [
            "regs",
            "work"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_exit_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "224-249",
          "snippet": "static void syscall_exit_work(struct pt_regs *regs, unsigned long work)\n{\n\tbool step;\n\n\t/*\n\t * If the syscall was rolled back due to syscall user dispatching,\n\t * then the tracers below are not invoked for the same reason as\n\t * the entry side was not invoked in syscall_trace_enter(): The ABI\n\t * of these syscalls is unknown.\n\t */\n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {\n\t\t\tcurrent->syscall_dispatch.on_dispatch = false;\n\t\t\treturn;\n\t\t}\n\t}\n\n\taudit_syscall_exit(regs);\n\n\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)\n\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));\n\n\tstep = report_single_step(work);\n\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)\n\t\tptrace_report_syscall_exit(regs, step);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic void syscall_exit_work(struct pt_regs *regs, unsigned long work)\n{\n\tbool step;\n\n\t/*\n\t * If the syscall was rolled back due to syscall user dispatching,\n\t * then the tracers below are not invoked for the same reason as\n\t * the entry side was not invoked in syscall_trace_enter(): The ABI\n\t * of these syscalls is unknown.\n\t */\n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {\n\t\t\tcurrent->syscall_dispatch.on_dispatch = false;\n\t\t\treturn;\n\t\t}\n\t}\n\n\taudit_syscall_exit(regs);\n\n\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)\n\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));\n\n\tstep = report_single_step(work);\n\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)\n\t\tptrace_report_syscall_exit(regs, step);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "work & SYSCALL_WORK_EXIT"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_syscall",
          "args": [
            "regs"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_syscall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "311-321",
          "snippet": "void rseq_syscall(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\n\tif (!t->rseq)\n\t\treturn;\n\tif (rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))\n\t\tforce_sig(SIGSEGV);\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nvoid rseq_syscall(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\n\tif (!t->rseq)\n\t\treturn;\n\tif (rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))\n\t\tforce_sig(SIGSEGV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "irqs_disabled()",
            "\"syscall %lu left IRQs disabled\"",
            "nr"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PROVE_LOCKING"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CT_WARN_ON",
          "args": [
            "ct_state() != CONTEXT_KERNEL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct_state",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current_thread_info()->syscall_work"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic void syscall_exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\tunsigned long nr = syscall_get_nr(current, regs);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_KERNEL);\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tif (WARN(irqs_disabled(), \"syscall %lu left IRQs disabled\", nr))\n\t\t\tlocal_irq_enable();\n\t}\n\n\trseq_syscall(regs);\n\n\t/*\n\t * Do one-time syscall specific work. If these work items are\n\t * enabled, we want to run them exactly once per syscall exit with\n\t * interrupts enabled.\n\t */\n\tif (unlikely(work & SYSCALL_WORK_EXIT))\n\t\tsyscall_exit_work(regs, work);\n}"
  },
  {
    "function_name": "syscall_exit_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "224-249",
    "snippet": "static void syscall_exit_work(struct pt_regs *regs, unsigned long work)\n{\n\tbool step;\n\n\t/*\n\t * If the syscall was rolled back due to syscall user dispatching,\n\t * then the tracers below are not invoked for the same reason as\n\t * the entry side was not invoked in syscall_trace_enter(): The ABI\n\t * of these syscalls is unknown.\n\t */\n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {\n\t\t\tcurrent->syscall_dispatch.on_dispatch = false;\n\t\t\treturn;\n\t\t}\n\t}\n\n\taudit_syscall_exit(regs);\n\n\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)\n\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));\n\n\tstep = report_single_step(work);\n\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)\n\t\tptrace_report_syscall_exit(regs, step);\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_report_syscall_exit",
          "args": [
            "regs",
            "step"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_single_step",
          "args": [
            "work"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "report_single_step",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "216-222",
          "snippet": "static inline bool report_single_step(unsigned long work)\n{\n\tif (work & SYSCALL_WORK_SYSCALL_EMU)\n\t\treturn false;\n\n\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic inline bool report_single_step(unsigned long work)\n{\n\tif (work & SYSCALL_WORK_SYSCALL_EMU)\n\t\treturn false;\n\n\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sys_exit",
          "args": [
            "regs",
            "syscall_get_return_value(current, regs)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_return_value",
          "args": [
            "current",
            "regs"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_syscall_exit",
          "args": [
            "regs"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->syscall_dispatch.on_dispatch"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic void syscall_exit_work(struct pt_regs *regs, unsigned long work)\n{\n\tbool step;\n\n\t/*\n\t * If the syscall was rolled back due to syscall user dispatching,\n\t * then the tracers below are not invoked for the same reason as\n\t * the entry side was not invoked in syscall_trace_enter(): The ABI\n\t * of these syscalls is unknown.\n\t */\n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {\n\t\t\tcurrent->syscall_dispatch.on_dispatch = false;\n\t\t\treturn;\n\t\t}\n\t}\n\n\taudit_syscall_exit(regs);\n\n\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)\n\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));\n\n\tstep = report_single_step(work);\n\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)\n\t\tptrace_report_syscall_exit(regs, step);\n}"
  },
  {
    "function_name": "report_single_step",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "216-222",
    "snippet": "static inline bool report_single_step(unsigned long work)\n{\n\tif (work & SYSCALL_WORK_SYSCALL_EMU)\n\t\treturn false;\n\n\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic inline bool report_single_step(unsigned long work)\n{\n\tif (work & SYSCALL_WORK_SYSCALL_EMU)\n\t\treturn false;\n\n\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;\n}"
  },
  {
    "function_name": "exit_to_user_mode_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "190-209",
    "snippet": "static void exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long ti_work = read_thread_flags();\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Flush pending rcuog wakeup before the last need_resched() check */\n\ttick_nohz_user_enter_prepare();\n\n\tif (unlikely(ti_work & EXIT_TO_USER_MODE_WORK))\n\t\tti_work = exit_to_user_mode_loop(regs, ti_work);\n\n\tarch_exit_to_user_mode_prepare(regs, ti_work);\n\n\t/* Ensure that the address limit is intact and no locks are held */\n\taddr_limit_user_check();\n\tkmap_assert_nomap();\n\tlockdep_assert_irqs_disabled();\n\tlockdep_sys_exit();\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_sys_exit",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_sys_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6496-6518",
          "snippet": "void lockdep_sys_exit(void)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(curr->lockdep_depth)) {\n\t\tif (!debug_locks_off())\n\t\t\treturn;\n\t\tpr_warn(\"\\n\");\n\t\tpr_warn(\"================================================\\n\");\n\t\tpr_warn(\"WARNING: lock held when returning to user space!\\n\");\n\t\tprint_kernel_ident();\n\t\tpr_warn(\"------------------------------------------------\\n\");\n\t\tpr_warn(\"%s/%d is leaving the kernel with locks still held!\\n\",\n\t\t\t\tcurr->comm, curr->pid);\n\t\tlockdep_print_held_locks(curr);\n\t}\n\n\t/*\n\t * The lock history for each syscall should be independent. So wipe the\n\t * slate clean on return to userspace.\n\t */\n\tlockdep_invariant_state(false);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_sys_exit(void)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(curr->lockdep_depth)) {\n\t\tif (!debug_locks_off())\n\t\t\treturn;\n\t\tpr_warn(\"\\n\");\n\t\tpr_warn(\"================================================\\n\");\n\t\tpr_warn(\"WARNING: lock held when returning to user space!\\n\");\n\t\tprint_kernel_ident();\n\t\tpr_warn(\"------------------------------------------------\\n\");\n\t\tpr_warn(\"%s/%d is leaving the kernel with locks still held!\\n\",\n\t\t\t\tcurr->comm, curr->pid);\n\t\tlockdep_print_held_locks(curr);\n\t}\n\n\t/*\n\t * The lock history for each syscall should be independent. So wipe the\n\t * slate clean on return to userspace.\n\t */\n\tlockdep_invariant_state(false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_assert_nomap",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_limit_user_check",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_exit_to_user_mode_prepare",
          "args": [
            "regs",
            "ti_work"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_to_user_mode_loop",
          "args": [
            "regs",
            "ti_work"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "exit_to_user_mode_loop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "144-188",
          "snippet": "static unsigned long exit_to_user_mode_loop(struct pt_regs *regs,\n\t\t\t\t\t    unsigned long ti_work)\n{\n\t/*\n\t * Before returning to user space ensure that all pending work\n\t * items have been completed.\n\t */\n\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {\n\n\t\tlocal_irq_enable_exit_to_user(ti_work);\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_UPROBE)\n\t\t\tuprobe_notify_resume(regs);\n\n\t\tif (ti_work & _TIF_PATCH_PENDING)\n\t\t\tklp_update_patch_state(current);\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))\n\t\t\tarch_do_signal_or_restart(regs);\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(regs);\n\n\t\t/* Architecture specific TIF work */\n\t\tarch_exit_to_user_mode_work(regs, ti_work);\n\n\t\t/*\n\t\t * Disable interrupts and reevaluate the work flags as they\n\t\t * might have changed while interrupts and preemption was\n\t\t * enabled above.\n\t\t */\n\t\tlocal_irq_disable_exit_to_user();\n\n\t\t/* Check if any of the above work has queued a deferred wakeup */\n\t\ttick_nohz_user_enter_prepare();\n\n\t\tti_work = read_thread_flags();\n\t}\n\n\t/* Return the latest work state for arch_exit_to_user_mode() */\n\treturn ti_work;\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic unsigned long exit_to_user_mode_loop(struct pt_regs *regs,\n\t\t\t\t\t    unsigned long ti_work)\n{\n\t/*\n\t * Before returning to user space ensure that all pending work\n\t * items have been completed.\n\t */\n\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {\n\n\t\tlocal_irq_enable_exit_to_user(ti_work);\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_UPROBE)\n\t\t\tuprobe_notify_resume(regs);\n\n\t\tif (ti_work & _TIF_PATCH_PENDING)\n\t\t\tklp_update_patch_state(current);\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))\n\t\t\tarch_do_signal_or_restart(regs);\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(regs);\n\n\t\t/* Architecture specific TIF work */\n\t\tarch_exit_to_user_mode_work(regs, ti_work);\n\n\t\t/*\n\t\t * Disable interrupts and reevaluate the work flags as they\n\t\t * might have changed while interrupts and preemption was\n\t\t * enabled above.\n\t\t */\n\t\tlocal_irq_disable_exit_to_user();\n\n\t\t/* Check if any of the above work has queued a deferred wakeup */\n\t\ttick_nohz_user_enter_prepare();\n\n\t\tti_work = read_thread_flags();\n\t}\n\n\t/* Return the latest work state for arch_exit_to_user_mode() */\n\treturn ti_work;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ti_work & EXIT_TO_USER_MODE_WORK"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_user_enter_prepare",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_thread_flags",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic void exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long ti_work = read_thread_flags();\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Flush pending rcuog wakeup before the last need_resched() check */\n\ttick_nohz_user_enter_prepare();\n\n\tif (unlikely(ti_work & EXIT_TO_USER_MODE_WORK))\n\t\tti_work = exit_to_user_mode_loop(regs, ti_work);\n\n\tarch_exit_to_user_mode_prepare(regs, ti_work);\n\n\t/* Ensure that the address limit is intact and no locks are held */\n\taddr_limit_user_check();\n\tkmap_assert_nomap();\n\tlockdep_assert_irqs_disabled();\n\tlockdep_sys_exit();\n}"
  },
  {
    "function_name": "exit_to_user_mode_loop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "144-188",
    "snippet": "static unsigned long exit_to_user_mode_loop(struct pt_regs *regs,\n\t\t\t\t\t    unsigned long ti_work)\n{\n\t/*\n\t * Before returning to user space ensure that all pending work\n\t * items have been completed.\n\t */\n\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {\n\n\t\tlocal_irq_enable_exit_to_user(ti_work);\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_UPROBE)\n\t\t\tuprobe_notify_resume(regs);\n\n\t\tif (ti_work & _TIF_PATCH_PENDING)\n\t\t\tklp_update_patch_state(current);\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))\n\t\t\tarch_do_signal_or_restart(regs);\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(regs);\n\n\t\t/* Architecture specific TIF work */\n\t\tarch_exit_to_user_mode_work(regs, ti_work);\n\n\t\t/*\n\t\t * Disable interrupts and reevaluate the work flags as they\n\t\t * might have changed while interrupts and preemption was\n\t\t * enabled above.\n\t\t */\n\t\tlocal_irq_disable_exit_to_user();\n\n\t\t/* Check if any of the above work has queued a deferred wakeup */\n\t\ttick_nohz_user_enter_prepare();\n\n\t\tti_work = read_thread_flags();\n\t}\n\n\t/* Return the latest work state for arch_exit_to_user_mode() */\n\treturn ti_work;\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_thread_flags",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_user_enter_prepare",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable_exit_to_user",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_exit_to_user_mode_work",
          "args": [
            "regs",
            "ti_work"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_user_mode_work",
          "args": [
            "regs"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_do_signal_or_restart",
          "args": [
            "regs"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "arch_do_signal_or_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "142-142",
          "snippet": "void __weak arch_do_signal_or_restart(struct pt_regs *regs) { }",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nvoid __weak arch_do_signal_or_restart(struct pt_regs *regs) { }"
        }
      },
      {
        "call_info": {
          "callee": "klp_update_patch_state",
          "args": [
            "current"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "klp_update_patch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "162-186",
          "snippet": "void klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_rcu() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_rcu() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_notify_resume",
          "args": [
            "regs"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_notify_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2300-2311",
          "snippet": "void uprobe_notify_resume(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\n\tclear_thread_flag(TIF_UPROBE);\n\n\tutask = current->utask;\n\tif (utask && utask->active_uprobe)\n\t\thandle_singlestep(utask, regs);\n\telse\n\t\thandle_swbp(regs);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_notify_resume(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\n\tclear_thread_flag(TIF_UPROBE);\n\n\tutask = current->utask;\n\tif (utask && utask->active_uprobe)\n\t\thandle_singlestep(utask, regs);\n\telse\n\t\thandle_swbp(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable_exit_to_user",
          "args": [
            "ti_work"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic unsigned long exit_to_user_mode_loop(struct pt_regs *regs,\n\t\t\t\t\t    unsigned long ti_work)\n{\n\t/*\n\t * Before returning to user space ensure that all pending work\n\t * items have been completed.\n\t */\n\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {\n\n\t\tlocal_irq_enable_exit_to_user(ti_work);\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_UPROBE)\n\t\t\tuprobe_notify_resume(regs);\n\n\t\tif (ti_work & _TIF_PATCH_PENDING)\n\t\t\tklp_update_patch_state(current);\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))\n\t\t\tarch_do_signal_or_restart(regs);\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(regs);\n\n\t\t/* Architecture specific TIF work */\n\t\tarch_exit_to_user_mode_work(regs, ti_work);\n\n\t\t/*\n\t\t * Disable interrupts and reevaluate the work flags as they\n\t\t * might have changed while interrupts and preemption was\n\t\t * enabled above.\n\t\t */\n\t\tlocal_irq_disable_exit_to_user();\n\n\t\t/* Check if any of the above work has queued a deferred wakeup */\n\t\ttick_nohz_user_enter_prepare();\n\n\t\tti_work = read_thread_flags();\n\t}\n\n\t/* Return the latest work state for arch_exit_to_user_mode() */\n\treturn ti_work;\n}"
  },
  {
    "function_name": "arch_do_signal_or_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "142-142",
    "snippet": "void __weak arch_do_signal_or_restart(struct pt_regs *regs) { }",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nvoid __weak arch_do_signal_or_restart(struct pt_regs *regs) { }"
  },
  {
    "function_name": "exit_to_user_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "136-139",
    "snippet": "void noinstr exit_to_user_mode(void)\n{\n\t__exit_to_user_mode();\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__exit_to_user_mode",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__exit_to_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "124-134",
          "snippet": "static __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nvoid noinstr exit_to_user_mode(void)\n{\n\t__exit_to_user_mode();\n}"
  },
  {
    "function_name": "__exit_to_user_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "124-134",
    "snippet": "static __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4297-4358",
          "snippet": "void noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_exit_to_user_mode",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_enter_irqoff",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on_prepare",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4244-4294",
          "snippet": "void lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on_prepare",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "28-36",
          "snippet": "void trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
  },
  {
    "function_name": "syscall_enter_from_user_mode_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "115-121",
    "snippet": "noinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n\tinstrumentation_begin();\n\tlocal_irq_enable();\n\tinstrumentation_end();\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__enter_from_user_mode",
          "args": [
            "regs"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__enter_from_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "17-28",
          "snippet": "static __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n\tinstrumentation_begin();\n\tlocal_irq_enable();\n\tinstrumentation_end();\n}"
  },
  {
    "function_name": "syscall_enter_from_user_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "101-113",
    "snippet": "noinstr long syscall_enter_from_user_mode(struct pt_regs *regs, long syscall)\n{\n\tlong ret;\n\n\t__enter_from_user_mode(regs);\n\n\tinstrumentation_begin();\n\tlocal_irq_enable();\n\tret = __syscall_enter_from_user_work(regs, syscall);\n\tinstrumentation_end();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__syscall_enter_from_user_work",
          "args": [
            "regs",
            "syscall"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__syscall_enter_from_user_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "85-94",
          "snippet": "static __always_inline long\n__syscall_enter_from_user_work(struct pt_regs *regs, long syscall)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\n\tif (work & SYSCALL_WORK_ENTER)\n\t\tsyscall = syscall_trace_enter(regs, syscall, work);\n\n\treturn syscall;\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline long\n__syscall_enter_from_user_work(struct pt_regs *regs, long syscall)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\n\tif (work & SYSCALL_WORK_ENTER)\n\t\tsyscall = syscall_trace_enter(regs, syscall, work);\n\n\treturn syscall;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__enter_from_user_mode",
          "args": [
            "regs"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "__enter_from_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "17-28",
          "snippet": "static __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr long syscall_enter_from_user_mode(struct pt_regs *regs, long syscall)\n{\n\tlong ret;\n\n\t__enter_from_user_mode(regs);\n\n\tinstrumentation_begin();\n\tlocal_irq_enable();\n\tret = __syscall_enter_from_user_work(regs, syscall);\n\tinstrumentation_end();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "syscall_enter_from_user_mode_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "96-99",
    "snippet": "long syscall_enter_from_user_mode_work(struct pt_regs *regs, long syscall)\n{\n\treturn __syscall_enter_from_user_work(regs, syscall);\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__syscall_enter_from_user_work",
          "args": [
            "regs",
            "syscall"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "__syscall_enter_from_user_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "85-94",
          "snippet": "static __always_inline long\n__syscall_enter_from_user_work(struct pt_regs *regs, long syscall)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\n\tif (work & SYSCALL_WORK_ENTER)\n\t\tsyscall = syscall_trace_enter(regs, syscall, work);\n\n\treturn syscall;\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline long\n__syscall_enter_from_user_work(struct pt_regs *regs, long syscall)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\n\tif (work & SYSCALL_WORK_ENTER)\n\t\tsyscall = syscall_trace_enter(regs, syscall, work);\n\n\treturn syscall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nlong syscall_enter_from_user_mode_work(struct pt_regs *regs, long syscall)\n{\n\treturn __syscall_enter_from_user_work(regs, syscall);\n}"
  },
  {
    "function_name": "__syscall_enter_from_user_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "85-94",
    "snippet": "static __always_inline long\n__syscall_enter_from_user_work(struct pt_regs *regs, long syscall)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\n\tif (work & SYSCALL_WORK_ENTER)\n\t\tsyscall = syscall_trace_enter(regs, syscall, work);\n\n\treturn syscall;\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_trace_enter",
          "args": [
            "regs",
            "syscall",
            "work"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_trace_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "45-83",
          "snippet": "static long syscall_trace_enter(struct pt_regs *regs, long syscall,\n\t\t\t\tunsigned long work)\n{\n\tlong ret = 0;\n\n\t/*\n\t * Handle Syscall User Dispatch.  This must comes first, since\n\t * the ABI here can be something that doesn't make sense for\n\t * other syscall_work features.\n\t */\n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (syscall_user_dispatch(regs))\n\t\t\treturn -1L;\n\t}\n\n\t/* Handle ptrace */\n\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {\n\t\tret = ptrace_report_syscall_entry(regs);\n\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))\n\t\t\treturn -1L;\n\t}\n\n\t/* Do seccomp after ptrace, to catch any tracer changes. */\n\tif (work & SYSCALL_WORK_SECCOMP) {\n\t\tret = __secure_computing(NULL);\n\t\tif (ret == -1L)\n\t\t\treturn ret;\n\t}\n\n\t/* Either of the above might have changed the syscall number */\n\tsyscall = syscall_get_nr(current, regs);\n\n\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT))\n\t\ttrace_sys_enter(regs, syscall);\n\n\tsyscall_enter_audit(regs, syscall);\n\n\treturn ret ? : syscall;\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic long syscall_trace_enter(struct pt_regs *regs, long syscall,\n\t\t\t\tunsigned long work)\n{\n\tlong ret = 0;\n\n\t/*\n\t * Handle Syscall User Dispatch.  This must comes first, since\n\t * the ABI here can be something that doesn't make sense for\n\t * other syscall_work features.\n\t */\n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (syscall_user_dispatch(regs))\n\t\t\treturn -1L;\n\t}\n\n\t/* Handle ptrace */\n\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {\n\t\tret = ptrace_report_syscall_entry(regs);\n\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))\n\t\t\treturn -1L;\n\t}\n\n\t/* Do seccomp after ptrace, to catch any tracer changes. */\n\tif (work & SYSCALL_WORK_SECCOMP) {\n\t\tret = __secure_computing(NULL);\n\t\tif (ret == -1L)\n\t\t\treturn ret;\n\t}\n\n\t/* Either of the above might have changed the syscall number */\n\tsyscall = syscall_get_nr(current, regs);\n\n\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT))\n\t\ttrace_sys_enter(regs, syscall);\n\n\tsyscall_enter_audit(regs, syscall);\n\n\treturn ret ? : syscall;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current_thread_info()->syscall_work"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline long\n__syscall_enter_from_user_work(struct pt_regs *regs, long syscall)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\n\tif (work & SYSCALL_WORK_ENTER)\n\t\tsyscall = syscall_trace_enter(regs, syscall, work);\n\n\treturn syscall;\n}"
  },
  {
    "function_name": "syscall_trace_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "45-83",
    "snippet": "static long syscall_trace_enter(struct pt_regs *regs, long syscall,\n\t\t\t\tunsigned long work)\n{\n\tlong ret = 0;\n\n\t/*\n\t * Handle Syscall User Dispatch.  This must comes first, since\n\t * the ABI here can be something that doesn't make sense for\n\t * other syscall_work features.\n\t */\n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (syscall_user_dispatch(regs))\n\t\t\treturn -1L;\n\t}\n\n\t/* Handle ptrace */\n\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {\n\t\tret = ptrace_report_syscall_entry(regs);\n\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))\n\t\t\treturn -1L;\n\t}\n\n\t/* Do seccomp after ptrace, to catch any tracer changes. */\n\tif (work & SYSCALL_WORK_SECCOMP) {\n\t\tret = __secure_computing(NULL);\n\t\tif (ret == -1L)\n\t\t\treturn ret;\n\t}\n\n\t/* Either of the above might have changed the syscall number */\n\tsyscall = syscall_get_nr(current, regs);\n\n\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT))\n\t\ttrace_sys_enter(regs, syscall);\n\n\tsyscall_enter_audit(regs, syscall);\n\n\treturn ret ? : syscall;\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_enter_audit",
          "args": [
            "regs",
            "syscall"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_enter_audit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "35-43",
          "snippet": "static inline void syscall_enter_audit(struct pt_regs *regs, long syscall)\n{\n\tif (unlikely(audit_context())) {\n\t\tunsigned long args[6];\n\n\t\tsyscall_get_arguments(current, regs, args);\n\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);\n\t}\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic inline void syscall_enter_audit(struct pt_regs *regs, long syscall)\n{\n\tif (unlikely(audit_context())) {\n\t\tunsigned long args[6];\n\n\t\tsyscall_get_arguments(current, regs, args);\n\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sys_enter",
          "args": [
            "regs",
            "syscall"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "work & SYSCALL_WORK_SYSCALL_TRACEPOINT"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__secure_computing",
          "args": [
            "NULL"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "__secure_computing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1293-1314",
          "snippet": "int __secure_computing(const struct seccomp_data *sd)\n{\n\tint mode = current->seccomp.mode;\n\tint this_syscall;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn 0;\n\n\tthis_syscall = sd ? sd->nr :\n\t\tsyscall_get_nr(current, current_pt_regs());\n\n\tswitch (mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */\n\t\treturn 0;\n\tcase SECCOMP_MODE_FILTER:\n\t\treturn __seccomp_filter(this_syscall, sd, false);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nint __secure_computing(const struct seccomp_data *sd)\n{\n\tint mode = current->seccomp.mode;\n\tint this_syscall;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn 0;\n\n\tthis_syscall = sd ? sd->nr :\n\t\tsyscall_get_nr(current, current_pt_regs());\n\n\tswitch (mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */\n\t\treturn 0;\n\tcase SECCOMP_MODE_FILTER:\n\t\treturn __seccomp_filter(this_syscall, sd, false);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_report_syscall_entry",
          "args": [
            "regs"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_user_dispatch",
          "args": [
            "regs"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_user_dispatch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/syscall_user_dispatch.c",
          "lines": "34-69",
          "snippet": "bool syscall_user_dispatch(struct pt_regs *regs)\n{\n\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;\n\tchar state;\n\n\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))\n\t\treturn false;\n\n\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))\n\t\treturn false;\n\n\tif (likely(sd->selector)) {\n\t\t/*\n\t\t * access_ok() is performed once, at prctl time, when\n\t\t * the selector is loaded by userspace.\n\t\t */\n\t\tif (unlikely(__get_user(state, sd->selector))) {\n\t\t\tforce_exit_sig(SIGSEGV);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))\n\t\t\treturn false;\n\n\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {\n\t\t\tforce_exit_sig(SIGSYS);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tsd->on_dispatch = true;\n\tsyscall_rollback(current, regs);\n\ttrigger_sigsys(regs);\n\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/elf.h>",
            "#include <linux/signal.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <asm/syscall.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/elf.h>\n#include <linux/signal.h>\n#include <linux/uaccess.h>\n#include <linux/syscall_user_dispatch.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n\nbool syscall_user_dispatch(struct pt_regs *regs)\n{\n\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;\n\tchar state;\n\n\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))\n\t\treturn false;\n\n\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))\n\t\treturn false;\n\n\tif (likely(sd->selector)) {\n\t\t/*\n\t\t * access_ok() is performed once, at prctl time, when\n\t\t * the selector is loaded by userspace.\n\t\t */\n\t\tif (unlikely(__get_user(state, sd->selector))) {\n\t\t\tforce_exit_sig(SIGSEGV);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))\n\t\t\treturn false;\n\n\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {\n\t\t\tforce_exit_sig(SIGSYS);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tsd->on_dispatch = true;\n\tsyscall_rollback(current, regs);\n\ttrigger_sigsys(regs);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic long syscall_trace_enter(struct pt_regs *regs, long syscall,\n\t\t\t\tunsigned long work)\n{\n\tlong ret = 0;\n\n\t/*\n\t * Handle Syscall User Dispatch.  This must comes first, since\n\t * the ABI here can be something that doesn't make sense for\n\t * other syscall_work features.\n\t */\n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (syscall_user_dispatch(regs))\n\t\t\treturn -1L;\n\t}\n\n\t/* Handle ptrace */\n\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {\n\t\tret = ptrace_report_syscall_entry(regs);\n\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))\n\t\t\treturn -1L;\n\t}\n\n\t/* Do seccomp after ptrace, to catch any tracer changes. */\n\tif (work & SYSCALL_WORK_SECCOMP) {\n\t\tret = __secure_computing(NULL);\n\t\tif (ret == -1L)\n\t\t\treturn ret;\n\t}\n\n\t/* Either of the above might have changed the syscall number */\n\tsyscall = syscall_get_nr(current, regs);\n\n\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT))\n\t\ttrace_sys_enter(regs, syscall);\n\n\tsyscall_enter_audit(regs, syscall);\n\n\treturn ret ? : syscall;\n}"
  },
  {
    "function_name": "syscall_enter_audit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "35-43",
    "snippet": "static inline void syscall_enter_audit(struct pt_regs *regs, long syscall)\n{\n\tif (unlikely(audit_context())) {\n\t\tunsigned long args[6];\n\n\t\tsyscall_get_arguments(current, regs, args);\n\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);\n\t}\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_syscall_entry",
          "args": [
            "syscall",
            "args[0]",
            "args[1]",
            "args[2]",
            "args[3]"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "__audit_syscall_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1974-2010",
          "snippet": "void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct audit_context *context = audit_context();\n\tenum audit_state     state;\n\n\tif (!audit_enabled || !context)\n\t\treturn;\n\n\tWARN_ON(context->context != AUDIT_CTX_UNUSED);\n\tWARN_ON(context->name_count);\n\tif (context->context != AUDIT_CTX_UNUSED || context->name_count) {\n\t\taudit_panic(\"unrecoverable error in audit_syscall_entry()\");\n\t\treturn;\n\t}\n\n\tstate = context->state;\n\tif (state == AUDIT_STATE_DISABLED)\n\t\treturn;\n\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_STATE_BUILD) {\n\t\tcontext->prio = 0;\n\t\tif (auditd_test_task(current))\n\t\t\treturn;\n\t}\n\n\tcontext->arch\t    = syscall_get_arch(current);\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\tcontext->context = AUDIT_CTX_SYSCALL;\n\tcontext->current_state  = state;\n\tktime_get_coarse_real_ts64(&context->ctime);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int audit_n_rules;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint audit_n_rules;\n\nvoid __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct audit_context *context = audit_context();\n\tenum audit_state     state;\n\n\tif (!audit_enabled || !context)\n\t\treturn;\n\n\tWARN_ON(context->context != AUDIT_CTX_UNUSED);\n\tWARN_ON(context->name_count);\n\tif (context->context != AUDIT_CTX_UNUSED || context->name_count) {\n\t\taudit_panic(\"unrecoverable error in audit_syscall_entry()\");\n\t\treturn;\n\t}\n\n\tstate = context->state;\n\tif (state == AUDIT_STATE_DISABLED)\n\t\treturn;\n\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_STATE_BUILD) {\n\t\tcontext->prio = 0;\n\t\tif (auditd_test_task(current))\n\t\t\treturn;\n\t}\n\n\tcontext->arch\t    = syscall_get_arch(current);\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\tcontext->context = AUDIT_CTX_SYSCALL;\n\tcontext->current_state  = state;\n\tktime_get_coarse_real_ts64(&context->ctime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_arguments",
          "args": [
            "current",
            "regs",
            "args"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "audit_context()"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic inline void syscall_enter_audit(struct pt_regs *regs, long syscall)\n{\n\tif (unlikely(audit_context())) {\n\t\tunsigned long args[6];\n\n\t\tsyscall_get_arguments(current, regs, args);\n\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);\n\t}\n}"
  },
  {
    "function_name": "enter_from_user_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "30-33",
    "snippet": "void noinstr enter_from_user_mode(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible noinstr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__enter_from_user_mode",
          "args": [
            "regs"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "__enter_from_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "17-28",
          "snippet": "static __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nvoid noinstr enter_from_user_mode(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n}"
  },
  {
    "function_name": "__enter_from_user_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
    "lines": "17-28",
    "snippet": "static __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}",
    "includes": [
      "#include <trace/events/syscalls.h>",
      "#include \"common.h\"",
      "#include <linux/tick.h>",
      "#include <linux/audit.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/resume_user_mode.h>",
      "#include <linux/entry-common.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_off_finish",
          "args": [],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hardirqs_off_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "61-70",
          "snippet": "void trace_hardirqs_off_finish(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_off_finish(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_exit_irqoff",
          "args": [],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CT_WARN_ON",
          "args": [
            "ct_state() != CONTEXT_USER"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ct_state",
          "args": [],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_off",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4364-4400",
          "snippet": "void noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_check_user_regs",
          "args": [
            "regs"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_check_user_regs(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}"
  }
]