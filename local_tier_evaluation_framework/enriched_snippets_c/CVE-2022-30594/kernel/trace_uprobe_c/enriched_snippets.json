[
  {
    "function_name": "init_uprobe_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1643-1661",
    "snippet": "static __init int init_uprobe_trace(void)\n{\n\tint ret;\n\n\tret = dyn_event_register(&trace_uprobe_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"uprobe_events\", TRACE_MODE_WRITE, NULL,\n\t\t\t\t    NULL, &uprobe_events_ops);\n\t/* Profile interface */\n\ttrace_create_file(\"uprobe_profile\", TRACE_MODE_READ, NULL,\n\t\t\t\t    NULL, &uprobe_profile_ops);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};",
      "static const struct file_operations uprobe_events_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= probes_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= probes_write,\n};",
      "static const struct file_operations uprobe_profile_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= profile_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"uprobe_profile\"",
            "TRACE_MODE_READ",
            "NULL",
            "NULL",
            "&uprobe_profile_ops"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_register",
          "args": [
            "&trace_uprobe_ops"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "59-70",
          "snippet": "int dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(dyn_event_ops_mutex);",
            "static LIST_HEAD(dyn_event_ops_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic DEFINE_MUTEX(dyn_event_ops_mutex);\nstatic LIST_HEAD(dyn_event_ops_list);\n\nint dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\nstatic const struct file_operations uprobe_events_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= probes_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= probes_write,\n};\nstatic const struct file_operations uprobe_profile_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= profile_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic __init int init_uprobe_trace(void)\n{\n\tint ret;\n\n\tret = dyn_event_register(&trace_uprobe_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"uprobe_events\", TRACE_MODE_WRITE, NULL,\n\t\t\t\t    NULL, &uprobe_events_ops);\n\t/* Profile interface */\n\ttrace_create_file(\"uprobe_profile\", TRACE_MODE_READ, NULL,\n\t\t\t\t    NULL, &uprobe_profile_ops);\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_local_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1632-1639",
    "snippet": "void destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\n\tfree_trace_uprobe(tu);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "362-371",
          "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_uprobe_primary_from_call",
          "args": [
            "event_call"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "320-330",
          "snippet": "trace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nvoid destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\n\tfree_trace_uprobe(tu);\n}"
  },
  {
    "function_name": "create_local_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1576-1630",
    "snippet": "struct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * local trace_kprobes are not added to dyn_event, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name \"DUMMY_EVENT\" here.\n\t */\n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tif (!tu->filename) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinit_trace_event_call(tu);\n\n\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tu->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn trace_probe_event_call(&tu->tp);\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [
      "#define UPROBE_EVENT_SYSTEM\t\"uprobes\""
    ],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "362-371",
          "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&tu->tp",
            "ptype"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "935-952",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_event_call",
          "args": [
            "tu"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1553-1561",
          "snippet": "static inline void init_trace_event_call(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->fields_array = uprobe_fields_array;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;\n\tcall->class->reg = trace_uprobe_register;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct",
            "static struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};",
            "static struct trace_event_fields uprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = uprobe_event_define_fields },\n\t{}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\nstatic struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};\nstatic struct trace_event_fields uprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = uprobe_event_define_fields },\n\t{}\n};\n\nstatic inline void init_trace_event_call(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->fields_array = uprobe_fields_array;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;\n\tcall->class->reg = trace_uprobe_register;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tu"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate trace_uprobe.(%d)\\n\"",
            "(int)PTR_ERR(tu)"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tu"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tu"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trace_uprobe",
          "args": [
            "UPROBE_EVENT_SYSTEM",
            "\"DUMMY_EVENT\"",
            "0",
            "is_return"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "335-360",
          "snippet": "static struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = kzalloc(struct_size(tu, tp.args, nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = trace_probe_init(&tu->tp, event, group, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tu->devent, &trace_uprobe_ops);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(tu->tp.event->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};",
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = kzalloc(struct_size(tu, tp.args, nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = trace_probe_init(&tu->tp, event, group, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tu->devent, &trace_uprobe_ops);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(tu->tp.event->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu);\n\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "path.dentry"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "name",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\n#define UPROBE_EVENT_SYSTEM\t\"uprobes\"\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstruct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * local trace_kprobes are not added to dyn_event, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name \"DUMMY_EVENT\" here.\n\t */\n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tif (!tu->filename) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinit_trace_event_call(tu);\n\n\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tu->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn trace_probe_event_call(&tu->tp);\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "unregister_uprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1570-1573",
    "snippet": "static int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\treturn trace_probe_unregister_event_call(&tu->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_unregister_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_unregister_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "321-325",
          "snippet": "static inline int trace_probe_unregister_event_call(struct trace_probe *tp)\n{\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\treturn trace_remove_event_call(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline int trace_probe_unregister_event_call(struct trace_probe *tp)\n{\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\treturn trace_remove_event_call(&tp->event->call);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\treturn trace_probe_unregister_event_call(&tu->tp);\n}"
  },
  {
    "function_name": "register_uprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1563-1568",
    "snippet": "static int register_uprobe_event(struct trace_uprobe *tu)\n{\n\tinit_trace_event_call(tu);\n\n\treturn trace_probe_register_event_call(&tu->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_register_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_register_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1083-1103",
          "snippet": "int trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_event_call",
          "args": [
            "tu"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1553-1561",
          "snippet": "static inline void init_trace_event_call(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->fields_array = uprobe_fields_array;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;\n\tcall->class->reg = trace_uprobe_register;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct",
            "static struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};",
            "static struct trace_event_fields uprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = uprobe_event_define_fields },\n\t{}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\nstatic struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};\nstatic struct trace_event_fields uprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = uprobe_event_define_fields },\n\t{}\n};\n\nstatic inline void init_trace_event_call(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->fields_array = uprobe_fields_array;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;\n\tcall->class->reg = trace_uprobe_register;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int register_uprobe_event(struct trace_uprobe *tu)\n{\n\tinit_trace_event_call(tu);\n\n\treturn trace_probe_register_event_call(&tu->tp);\n}"
  },
  {
    "function_name": "init_trace_event_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1553-1561",
    "snippet": "static inline void init_trace_event_call(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->fields_array = uprobe_fields_array;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;\n\tcall->class->reg = trace_uprobe_register;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct",
      "static struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};",
      "static struct trace_event_fields uprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = uprobe_event_define_fields },\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\nstatic struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};\nstatic struct trace_event_fields uprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = uprobe_event_define_fields },\n\t{}\n};\n\nstatic inline void init_trace_event_call(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->fields_array = uprobe_fields_array;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;\n\tcall->class->reg = trace_uprobe_register;\n}"
  },
  {
    "function_name": "uretprobe_dispatcher",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1508-1541",
    "snippet": "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\n\tudd.tu = tu;\n\tudd.bp_addr = func;\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_TRACE))\n\t\turetprobe_trace_func(tu, func, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_PROFILE))\n\t\turetprobe_perf_func(tu, func, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_buffer_put",
          "args": [
            "ucb"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "940-943",
          "snippet": "static void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uretprobe_perf_func",
          "args": [
            "tu",
            "func",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "uretprobe_perf_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1407-1412",
          "snippet": "static void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_test_flag",
          "args": [
            "&tu->tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_test_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "256-260",
          "snippet": "static inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uretprobe_trace_func",
          "args": [
            "tu",
            "func",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "uretprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1001-1011",
          "snippet": "static void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "ucb->buf",
            "&tu->tp",
            "regs",
            "esize",
            "dsize"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-214",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_buffer_get",
          "args": [],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "923-938",
          "snippet": "static struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "is_ret_probe(tu)"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tu->tp",
            "regs"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "171-187",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!uprobe_cpu_buffer"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "con",
            "structtrace_uprobe",
            "consumer"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\n\tudd.tu = tu;\n\tudd.bp_addr = func;\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_TRACE))\n\t\turetprobe_trace_func(tu, func, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_PROFILE))\n\t\turetprobe_perf_func(tu, func, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn 0;\n}"
  },
  {
    "function_name": "uprobe_dispatcher",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1471-1506",
    "snippet": "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\tint ret = 0;\n\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\ttu->nhit++;\n\n\tudd.tu = tu;\n\tudd.bp_addr = instruction_pointer(regs);\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_TRACE))\n\t\tret |= uprobe_trace_func(tu, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_PROFILE))\n\t\tret |= uprobe_perf_func(tu, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_buffer_put",
          "args": [
            "ucb"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "940-943",
          "snippet": "static void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_perf_func",
          "args": [
            "tu",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1396-1405",
          "snippet": "static int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_test_flag",
          "args": [
            "&tu->tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_test_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "256-260",
          "snippet": "static inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_trace_func",
          "args": [
            "tu",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "985-999",
          "snippet": "static int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "ucb->buf",
            "&tu->tp",
            "regs",
            "esize",
            "dsize"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-214",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_buffer_get",
          "args": [],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "923-938",
          "snippet": "static struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "is_ret_probe(tu)"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tu->tp",
            "regs"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "171-187",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!uprobe_cpu_buffer"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "con",
            "structtrace_uprobe",
            "consumer"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\tint ret = 0;\n\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\ttu->nhit++;\n\n\tudd.tu = tu;\n\tudd.bp_addr = instruction_pointer(regs);\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_TRACE))\n\t\tret |= uprobe_trace_func(tu, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_PROFILE))\n\t\tret |= uprobe_perf_func(tu, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_uprobe_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1437-1469",
    "snippet": "static int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(event, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(event, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(event, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(event, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(event, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(event, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_perf_close",
          "args": [
            "event",
            "data"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1268-1290",
          "snippet": "static int uprobe_perf_close(struct trace_event_call *call,\n\t\t\t     struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int uprobe_perf_close(struct trace_event_call *call,\n\t\t\t     struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_perf_open",
          "args": [
            "event",
            "data"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1292-1316",
          "snippet": "static int uprobe_perf_open(struct trace_event_call *call,\n\t\t\t    struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint err = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_add(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err) {\n\t\t\tuprobe_perf_close(call, event);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int uprobe_perf_open(struct trace_event_call *call,\n\t\t\t    struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint err = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_add(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err) {\n\t\t\tuprobe_perf_close(call, event);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_event_disable",
          "args": [
            "event",
            "NULL"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "probe_event_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1148-1171",
          "snippet": "static void probe_event_disable(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn;\n\n\tif (!trace_probe_is_enabled(tp))\n\t\treturn;\n\n\tif (file) {\n\t\tif (trace_probe_remove_file(tp, file) < 0)\n\t\t\treturn;\n\n\t\tif (trace_probe_is_enabled(tp))\n\t\t\treturn;\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\t__probe_event_disable(tp);\n\tuprobe_buffer_disable();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic void probe_event_disable(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn;\n\n\tif (!trace_probe_is_enabled(tp))\n\t\treturn;\n\n\tif (file) {\n\t\tif (trace_probe_remove_file(tp, file) < 0)\n\t\t\treturn;\n\n\t\tif (trace_probe_is_enabled(tp))\n\t\t\treturn;\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\t__probe_event_disable(tp);\n\tuprobe_buffer_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_event_enable",
          "args": [
            "event",
            "NULL",
            "uprobe_perf_filter"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "probe_event_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1088-1146",
          "snippet": "static int probe_event_enable(struct trace_event_call *call,\n\t\t\tstruct trace_event_file *file, filter_func_t filter)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tbool enabled;\n\tint ret;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This may also change \"enabled\" state */\n\tif (file) {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_PROFILE))\n\t\t\treturn -EINTR;\n\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_TRACE))\n\t\t\treturn -EINTR;\n\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = trace_uprobe_enable(tu, filter);\n\t\tif (ret) {\n\t\t\t__probe_event_disable(tp);\n\t\t\tgoto err_buffer;\n\t\t}\n\t}\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file)\n\t\ttrace_probe_remove_file(tp, file);\n\telse\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int probe_event_enable(struct trace_event_call *call,\n\t\t\tstruct trace_event_file *file, filter_func_t filter)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tbool enabled;\n\tint ret;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This may also change \"enabled\" state */\n\tif (file) {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_PROFILE))\n\t\t\treturn -EINTR;\n\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_TRACE))\n\t\t\treturn -EINTR;\n\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = trace_uprobe_enable(tu, filter);\n\t\tif (ret) {\n\t\t\t__probe_event_disable(tp);\n\t\t\tgoto err_buffer;\n\t\t}\n\t}\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file)\n\t\ttrace_probe_remove_file(tp, file);\n\telse\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(event, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(event, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(event, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(event, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(event, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(event, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "bpf_get_uprobe_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1414-1434",
    "snippet": "int bpf_get_uprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **filename, u64 *probe_offset,\n\t\t\tbool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_uprobe *tu;\n\n\tif (perf_type_tracepoint)\n\t\ttu = find_probe_event(pevent, group);\n\telse\n\t\ttu = trace_uprobe_primary_from_call(event->tp_event);\n\tif (!tu)\n\t\treturn -EINVAL;\n\n\t*fd_type = is_ret_probe(tu) ? BPF_FD_TYPE_URETPROBE\n\t\t\t\t    : BPF_FD_TYPE_UPROBE;\n\t*filename = tu->filename;\n\t*probe_offset = tu->offset;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_uprobe_primary_from_call",
          "args": [
            "event->tp_event"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "320-330",
          "snippet": "trace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_probe_event",
          "args": [
            "pevent",
            "group"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "find_probe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "373-384",
          "snippet": "static struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tu;\n\n\tfor_each_trace_uprobe(tu, pos)\n\t\tif (strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tu->tp), group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tu;\n\n\tfor_each_trace_uprobe(tu, pos)\n\t\tif (strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tu->tp), group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "event->tp_event"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nint bpf_get_uprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **filename, u64 *probe_offset,\n\t\t\tbool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_uprobe *tu;\n\n\tif (perf_type_tracepoint)\n\t\ttu = find_probe_event(pevent, group);\n\telse\n\t\ttu = trace_uprobe_primary_from_call(event->tp_event);\n\tif (!tu)\n\t\treturn -EINVAL;\n\n\t*fd_type = is_ret_probe(tu) ? BPF_FD_TYPE_URETPROBE\n\t\t\t\t    : BPF_FD_TYPE_UPROBE;\n\t*filename = tu->filename;\n\t*probe_offset = tu->offset;\n\treturn 0;\n}"
  },
  {
    "function_name": "uretprobe_perf_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1407-1412",
    "snippet": "static void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_perf_func",
          "args": [
            "tu",
            "func",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_perf_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1335-1393",
          "snippet": "static void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tu32 ret;\n\n\t\tpreempt_disable();\n\t\tret = trace_call_bpf(call, regs);\n\t\tpreempt_enable();\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tu32 ret;\n\n\t\tpreempt_disable();\n\t\tret = trace_call_bpf(call, regs);\n\t\tpreempt_enable();\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}"
  },
  {
    "function_name": "uprobe_perf_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1396-1405",
    "snippet": "static int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_perf_func",
          "args": [
            "tu",
            "0",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_perf_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1335-1393",
          "snippet": "static void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tu32 ret;\n\n\t\tpreempt_disable();\n\t\tret = trace_call_bpf(call, regs);\n\t\tpreempt_enable();\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tu32 ret;\n\n\t\tpreempt_disable();\n\t\tret = trace_call_bpf(call, regs);\n\t\tpreempt_enable();\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_perf_filter",
          "args": [
            "&tu->consumer",
            "0",
            "current->mm"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1318-1333",
          "snippet": "static bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe_filter *filter;\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tfilter = tu->tp.event->filter;\n\n\tread_lock(&filter->rwlock);\n\tret = __uprobe_perf_filter(filter, mm);\n\tread_unlock(&filter->rwlock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe_filter *filter;\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tfilter = tu->tp.event->filter;\n\n\tread_lock(&filter->rwlock);\n\tret = __uprobe_perf_filter(filter, mm);\n\tread_unlock(&filter->rwlock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}"
  },
  {
    "function_name": "__uprobe_perf_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1335-1393",
    "snippet": "static void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tu32 ret;\n\n\t\tpreempt_disable();\n\t\tret = trace_call_bpf(call, regs);\n\t\tpreempt_enable();\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "entry",
            "size",
            "rctx",
            "call->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data + len",
            "0",
            "size - esize - len"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "ucb->buf",
            "tu->tp.size + dsize"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "false"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "true"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "395-418",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "call->perf_events"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "size > PERF_MAX_TRACE_SIZE",
            "\"profile buffer not large enough\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "is_ret_probe(tu)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "regs"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "95-133",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "call"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tu32 ret;\n\n\t\tpreempt_disable();\n\t\tret = trace_call_bpf(call, regs);\n\t\tpreempt_enable();\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "uprobe_perf_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1318-1333",
    "snippet": "static bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe_filter *filter;\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tfilter = tu->tp.event->filter;\n\n\tread_lock(&filter->rwlock);\n\tret = __uprobe_perf_filter(filter, mm);\n\tread_unlock(&filter->rwlock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&filter->rwlock"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_perf_filter",
          "args": [
            "filter",
            "mm"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_perf_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1196-1210",
          "snippet": "static bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&filter->rwlock"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "uc",
            "structtrace_uprobe",
            "consumer"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe_filter *filter;\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tfilter = tu->tp.event->filter;\n\n\tread_lock(&filter->rwlock);\n\tret = __uprobe_perf_filter(filter, mm);\n\tread_unlock(&filter->rwlock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_perf_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1292-1316",
    "snippet": "static int uprobe_perf_open(struct trace_event_call *call,\n\t\t\t    struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint err = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_add(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err) {\n\t\t\tuprobe_perf_close(call, event);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_perf_close",
          "args": [
            "call",
            "event"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1268-1290",
          "snippet": "static int uprobe_perf_close(struct trace_event_call *call,\n\t\t\t     struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int uprobe_perf_close(struct trace_event_call *call,\n\t\t\t     struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_apply",
          "args": [
            "tu->inode",
            "tu->offset",
            "&tu->consumer",
            "true"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_apply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1216-1236",
          "snippet": "int uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tu",
            "trace_probe_probe_list(tp)",
            "tp.list"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_uprobe_filter_add",
          "args": [
            "tu->tp.event->filter",
            "event"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_filter_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1240-1266",
          "snippet": "static bool trace_uprobe_filter_add(struct trace_uprobe_filter *filter,\n\t\t\t\t    struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\t/*\n\t\t * event->parent != NULL means copy_process(), we can avoid\n\t\t * uprobe_apply(). current->mm must be probed and we can rely\n\t\t * on dup_mmap() which preserves the already installed bp's.\n\t\t *\n\t\t * attr.enable_on_exec means that exec/mmap will install the\n\t\t * breakpoints we need.\n\t\t */\n\t\tdone = filter->nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t\tlist_add(&event->hw.tp_list, &filter->perf_events);\n\t} else {\n\t\tdone = filter->nr_systemwide;\n\t\tfilter->nr_systemwide++;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_filter_add(struct trace_uprobe_filter *filter,\n\t\t\t\t    struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\t/*\n\t\t * event->parent != NULL means copy_process(), we can avoid\n\t\t * uprobe_apply(). current->mm must be probed and we can rely\n\t\t * on dup_mmap() which preserves the already installed bp's.\n\t\t *\n\t\t * attr.enable_on_exec means that exec/mmap will install the\n\t\t * breakpoints we need.\n\t\t */\n\t\tdone = filter->nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t\tlist_add(&event->hw.tp_list, &filter->perf_events);\n\t} else {\n\t\tdone = filter->nr_systemwide;\n\t\tfilter->nr_systemwide++;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "tp",
            "structtrace_uprobe",
            "tp"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int uprobe_perf_open(struct trace_event_call *call,\n\t\t\t    struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint err = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_add(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err) {\n\t\t\tuprobe_perf_close(call, event);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "uprobe_perf_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1268-1290",
    "snippet": "static int uprobe_perf_close(struct trace_event_call *call,\n\t\t\t     struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_apply",
          "args": [
            "tu->inode",
            "tu->offset",
            "&tu->consumer",
            "false"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_apply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1216-1236",
          "snippet": "int uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tu",
            "trace_probe_probe_list(tp)",
            "tp.list"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_uprobe_filter_remove",
          "args": [
            "tu->tp.event->filter",
            "event"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_filter_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1219-1237",
          "snippet": "static bool trace_uprobe_filter_remove(struct trace_uprobe_filter *filter,\n\t\t\t\t       struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = filter->nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t} else {\n\t\tfilter->nr_systemwide--;\n\t\tdone = filter->nr_systemwide;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_filter_remove(struct trace_uprobe_filter *filter,\n\t\t\t\t       struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = filter->nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t} else {\n\t\tfilter->nr_systemwide--;\n\t\tdone = filter->nr_systemwide;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "tp",
            "structtrace_uprobe",
            "tp"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int uprobe_perf_close(struct trace_event_call *call,\n\t\t\t     struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_uprobe_filter_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1240-1266",
    "snippet": "static bool trace_uprobe_filter_add(struct trace_uprobe_filter *filter,\n\t\t\t\t    struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\t/*\n\t\t * event->parent != NULL means copy_process(), we can avoid\n\t\t * uprobe_apply(). current->mm must be probed and we can rely\n\t\t * on dup_mmap() which preserves the already installed bp's.\n\t\t *\n\t\t * attr.enable_on_exec means that exec/mmap will install the\n\t\t * breakpoints we need.\n\t\t */\n\t\tdone = filter->nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t\tlist_add(&event->hw.tp_list, &filter->perf_events);\n\t} else {\n\t\tdone = filter->nr_systemwide;\n\t\tfilter->nr_systemwide++;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&filter->rwlock"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&event->hw.tp_list",
            "&filter->perf_events"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_uprobe_filter_event",
          "args": [
            "filter",
            "event"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_filter_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1212-1217",
          "snippet": "static inline bool\ntrace_uprobe_filter_event(struct trace_uprobe_filter *filter,\n\t\t\t  struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(filter, event->hw.target->mm);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic inline bool\ntrace_uprobe_filter_event(struct trace_uprobe_filter *filter,\n\t\t\t  struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(filter, event->hw.target->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&filter->rwlock"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_filter_add(struct trace_uprobe_filter *filter,\n\t\t\t\t    struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\t/*\n\t\t * event->parent != NULL means copy_process(), we can avoid\n\t\t * uprobe_apply(). current->mm must be probed and we can rely\n\t\t * on dup_mmap() which preserves the already installed bp's.\n\t\t *\n\t\t * attr.enable_on_exec means that exec/mmap will install the\n\t\t * breakpoints we need.\n\t\t */\n\t\tdone = filter->nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t\tlist_add(&event->hw.tp_list, &filter->perf_events);\n\t} else {\n\t\tdone = filter->nr_systemwide;\n\t\tfilter->nr_systemwide++;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}"
  },
  {
    "function_name": "trace_uprobe_filter_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1219-1237",
    "snippet": "static bool trace_uprobe_filter_remove(struct trace_uprobe_filter *filter,\n\t\t\t\t       struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = filter->nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t} else {\n\t\tfilter->nr_systemwide--;\n\t\tdone = filter->nr_systemwide;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&filter->rwlock"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_uprobe_filter_event",
          "args": [
            "filter",
            "event"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_filter_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1212-1217",
          "snippet": "static inline bool\ntrace_uprobe_filter_event(struct trace_uprobe_filter *filter,\n\t\t\t  struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(filter, event->hw.target->mm);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic inline bool\ntrace_uprobe_filter_event(struct trace_uprobe_filter *filter,\n\t\t\t  struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(filter, event->hw.target->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->hw.tp_list"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&filter->rwlock"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "rwsem_try_write_lock_unqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "646-659",
          "snippet": "static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)\n#define RWSEM_FLAG_HANDOFF\t(1UL << 2)\n#define RWSEM_WRITER_LOCKED\t(1UL << 0)\n\nstatic inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)\n{\n\tlong count = atomic_long_read(&sem->count);\n\n\twhile (!(count & (RWSEM_LOCK_MASK|RWSEM_FLAG_HANDOFF))) {\n\t\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &count,\n\t\t\t\t\tcount | RWSEM_WRITER_LOCKED)) {\n\t\t\trwsem_set_owner(sem);\n\t\t\tlockevent_inc(rwsem_opt_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_filter_remove(struct trace_uprobe_filter *filter,\n\t\t\t\t       struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = filter->nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t} else {\n\t\tfilter->nr_systemwide--;\n\t\tdone = filter->nr_systemwide;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}"
  },
  {
    "function_name": "trace_uprobe_filter_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1212-1217",
    "snippet": "static inline bool\ntrace_uprobe_filter_event(struct trace_uprobe_filter *filter,\n\t\t\t  struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(filter, event->hw.target->mm);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_perf_filter",
          "args": [
            "filter",
            "event->hw.target->mm"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_perf_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1196-1210",
          "snippet": "static bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic inline bool\ntrace_uprobe_filter_event(struct trace_uprobe_filter *filter,\n\t\t\t  struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(filter, event->hw.target->mm);\n}"
  },
  {
    "function_name": "__uprobe_perf_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1196-1210",
    "snippet": "static bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "event",
            "&filter->perf_events",
            "hw.tp_list"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "uprobe_event_define_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1173-1193",
    "snippet": "static int uprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret, size;\n\tstruct uprobe_trace_entry_head field;\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\tif (unlikely(!tu))\n\t\treturn -ENODEV;\n\n\tif (is_ret_probe(tu)) {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_FUNC, 0);\n\t\tDEFINE_FIELD(unsigned long, vaddr[1], FIELD_STRING_RETIP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(true);\n\t} else {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_IP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(false);\n\t}\n\n\treturn traceprobe_define_arg_fields(event_call, size, &tu->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceprobe_define_arg_fields",
          "args": [
            "event_call",
            "size",
            "&tu->tp"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_define_arg_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "954-977",
          "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "false"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "true"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tu"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_uprobe_primary_from_call",
          "args": [
            "event_call"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "320-330",
          "snippet": "trace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int uprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret, size;\n\tstruct uprobe_trace_entry_head field;\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\tif (unlikely(!tu))\n\t\treturn -ENODEV;\n\n\tif (is_ret_probe(tu)) {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_FUNC, 0);\n\t\tDEFINE_FIELD(unsigned long, vaddr[1], FIELD_STRING_RETIP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(true);\n\t} else {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_IP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(false);\n\t}\n\n\treturn traceprobe_define_arg_fields(event_call, size, &tu->tp);\n}"
  },
  {
    "function_name": "probe_event_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1148-1171",
    "snippet": "static void probe_event_disable(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn;\n\n\tif (!trace_probe_is_enabled(tp))\n\t\treturn;\n\n\tif (file) {\n\t\tif (trace_probe_remove_file(tp, file) < 0)\n\t\t\treturn;\n\n\t\tif (trace_probe_is_enabled(tp))\n\t\t\treturn;\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\t__probe_event_disable(tp);\n\tuprobe_buffer_disable();\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_buffer_disable",
          "args": [],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "907-921",
          "snippet": "static void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;",
            "static int uprobe_buffer_refcnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\nstatic int uprobe_buffer_refcnt;\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__probe_event_disable",
          "args": [
            "tp"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "__probe_event_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1072-1086",
          "snippet": "static void __probe_event_disable(struct trace_probe *tp)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!tu->inode)\n\t\t\tcontinue;\n\n\t\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\t\ttu->inode = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic void __probe_event_disable(struct trace_probe *tp)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!tu->inode)\n\t\t\tcontinue;\n\n\t\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\t\ttu->inode = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_clear_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_clear_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "268-272",
          "snippet": "static inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "tp"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_remove_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_remove_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1133-1149",
          "snippet": "int trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic void probe_event_disable(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn;\n\n\tif (!trace_probe_is_enabled(tp))\n\t\treturn;\n\n\tif (file) {\n\t\tif (trace_probe_remove_file(tp, file) < 0)\n\t\t\treturn;\n\n\t\tif (trace_probe_is_enabled(tp))\n\t\t\treturn;\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\t__probe_event_disable(tp);\n\tuprobe_buffer_disable();\n}"
  },
  {
    "function_name": "probe_event_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1088-1146",
    "snippet": "static int probe_event_enable(struct trace_event_call *call,\n\t\t\tstruct trace_event_file *file, filter_func_t filter)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tbool enabled;\n\tint ret;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This may also change \"enabled\" state */\n\tif (file) {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_PROFILE))\n\t\t\treturn -EINTR;\n\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_TRACE))\n\t\t\treturn -EINTR;\n\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = trace_uprobe_enable(tu, filter);\n\t\tif (ret) {\n\t\t\t__probe_event_disable(tp);\n\t\t\tgoto err_buffer;\n\t\t}\n\t}\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file)\n\t\ttrace_probe_remove_file(tp, file);\n\telse\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_clear_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_clear_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "268-272",
          "snippet": "static inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_remove_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_remove_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1133-1149",
          "snippet": "int trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_buffer_disable",
          "args": [],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "907-921",
          "snippet": "static void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;",
            "static int uprobe_buffer_refcnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\nstatic int uprobe_buffer_refcnt;\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__probe_event_disable",
          "args": [
            "tp"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "__probe_event_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1072-1086",
          "snippet": "static void __probe_event_disable(struct trace_probe *tp)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!tu->inode)\n\t\t\tcontinue;\n\n\t\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\t\ttu->inode = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic void __probe_event_disable(struct trace_probe *tp)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!tu->inode)\n\t\t\tcontinue;\n\n\t\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\t\ttu->inode = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_uprobe_enable",
          "args": [
            "tu",
            "filter"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1053-1070",
          "snippet": "static int trace_uprobe_enable(struct trace_uprobe *tu, filter_func_t filter)\n{\n\tint ret;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\n\tif (tu->ref_ctr_offset)\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\telse\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\n\tif (ret)\n\t\ttu->inode = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int trace_uprobe_enable(struct trace_uprobe *tu, filter_func_t filter)\n{\n\tint ret;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\n\tif (tu->ref_ctr_offset)\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\telse\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\n\tif (ret)\n\t\ttu->inode = NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tu",
            "trace_probe_probe_list(tp)",
            "tp.list"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_buffer_enable",
          "args": [],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "892-905",
          "snippet": "static int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int uprobe_buffer_refcnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int uprobe_buffer_refcnt;\n\nstatic int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe_filter_is_empty(tu->tp.event->filter)"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_filter_is_empty",
          "args": [
            "tu->tp.event->filter"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_filter_is_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "265-268",
          "snippet": "static inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "tp",
            "structtrace_uprobe",
            "tp"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_set_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_set_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "262-266",
          "snippet": "static inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_test_flag",
          "args": [
            "tp",
            "TP_FLAG_TRACE"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_test_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "256-260",
          "snippet": "static inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_add_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_add_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1105-1118",
          "snippet": "int trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "tp"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int probe_event_enable(struct trace_event_call *call,\n\t\t\tstruct trace_event_file *file, filter_func_t filter)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tbool enabled;\n\tint ret;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This may also change \"enabled\" state */\n\tif (file) {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_PROFILE))\n\t\t\treturn -EINTR;\n\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_TRACE))\n\t\t\treturn -EINTR;\n\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = trace_uprobe_enable(tu, filter);\n\t\tif (ret) {\n\t\t\t__probe_event_disable(tp);\n\t\t\tgoto err_buffer;\n\t\t}\n\t}\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file)\n\t\ttrace_probe_remove_file(tp, file);\n\telse\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__probe_event_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1072-1086",
    "snippet": "static void __probe_event_disable(struct trace_probe *tp)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!tu->inode)\n\t\t\tcontinue;\n\n\t\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\t\ttu->inode = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_unregister",
          "args": [
            "tu->inode",
            "tu->offset",
            "&tu->consumer"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1109-1121",
          "snippet": "void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tu",
            "trace_probe_probe_list(tp)",
            "tp.list"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe_filter_is_empty(tu->tp.event->filter)"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_filter_is_empty",
          "args": [
            "tu->tp.event->filter"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_filter_is_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "265-268",
          "snippet": "static inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "tp",
            "structtrace_uprobe",
            "tp"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic void __probe_event_disable(struct trace_probe *tp)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!tu->inode)\n\t\t\tcontinue;\n\n\t\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\t\ttu->inode = NULL;\n\t}\n}"
  },
  {
    "function_name": "trace_uprobe_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1053-1070",
    "snippet": "static int trace_uprobe_enable(struct trace_uprobe *tu, filter_func_t filter)\n{\n\tint ret;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\n\tif (tu->ref_ctr_offset)\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\telse\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\n\tif (ret)\n\t\ttu->inode = NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_register",
          "args": [
            "tu->inode",
            "tu->offset",
            "&tu->consumer"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1437-1469",
          "snippet": "static int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(event, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(event, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(event, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(event, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(event, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(event, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(event, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(event, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(event, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(event, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(event, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(event, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_register_refctr",
          "args": [
            "tu->inode",
            "tu->offset",
            "tu->ref_ctr_offset",
            "&tu->consumer"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_register_refctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1202-1206",
          "snippet": "int uprobe_register_refctr(struct inode *inode, loff_t offset,\n\t\t\t   loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, ref_ctr_offset, uc);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_register_refctr(struct inode *inode, loff_t offset,\n\t\t\t   loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, ref_ctr_offset, uc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_real_inode",
          "args": [
            "tu->path.dentry"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int trace_uprobe_enable(struct trace_uprobe *tu, filter_func_t filter)\n{\n\tint ret;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\n\tif (tu->ref_ctr_offset)\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\telse\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\n\tif (ret)\n\t\ttu->inode = NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "print_uprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1014-1047",
    "snippet": "static enum print_line_t\nprint_uprobe_event(struct trace_iterator *iter, int flags, struct trace_event *event)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_uprobe *tu;\n\tu8 *data;\n\n\tentry = (struct uprobe_trace_entry_head *)iter->ent;\n\ttu = trace_uprobe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (unlikely(!tu))\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx <- 0x%lx)\",\n\t\t\t\t trace_probe_name(&tu->tp),\n\t\t\t\t entry->vaddr[1], entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx)\",\n\t\t\t\t trace_probe_name(&tu->tp),\n\t\t\t\t entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tif (print_probe_args(s, tu->tp.args, tu->tp.nr_args, data, entry) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_probe_args",
          "args": [
            "s",
            "tu->tp.args",
            "tu->tp.nr_args",
            "data",
            "entry"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "print_probe_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "216-242",
          "snippet": "static inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "false"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: (0x%lx)\"",
            "trace_probe_name(&tu->tp)",
            "entry->vaddr[0]"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tu->tp"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "true"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tu"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_uprobe_primary_from_call",
          "args": [
            "container_of(event, struct trace_event_call, event)"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "320-330",
          "snippet": "trace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structtrace_event_call",
            "event"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic enum print_line_t\nprint_uprobe_event(struct trace_iterator *iter, int flags, struct trace_event *event)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_uprobe *tu;\n\tu8 *data;\n\n\tentry = (struct uprobe_trace_entry_head *)iter->ent;\n\ttu = trace_uprobe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (unlikely(!tu))\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx <- 0x%lx)\",\n\t\t\t\t trace_probe_name(&tu->tp),\n\t\t\t\t entry->vaddr[1], entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx)\",\n\t\t\t\t trace_probe_name(&tu->tp),\n\t\t\t\t entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tif (print_probe_args(s, tu->tp.args, tu->tp.nr_args, data, entry) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "uretprobe_trace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "1001-1011",
    "snippet": "static void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_trace_func",
          "args": [
            "tu",
            "func",
            "regs",
            "ucb",
            "dsize",
            "link->file"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "945-982",
          "snippet": "static void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, size);\n\tif (!entry)\n\t\treturn;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, size);\n\tif (!entry)\n\t\treturn;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_for_each_link_rcu",
          "args": [
            "link",
            "&tu->tp"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "uprobe_trace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "985-999",
    "snippet": "static int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_trace_func",
          "args": [
            "tu",
            "0",
            "regs",
            "ucb",
            "dsize",
            "link->file"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "945-982",
          "snippet": "static void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, size);\n\tif (!entry)\n\t\treturn;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, size);\n\tif (!entry)\n\t\treturn;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_for_each_link_rcu",
          "args": [
            "link",
            "&tu->tp"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__uprobe_trace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "945-982",
    "snippet": "static void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, size);\n\tif (!entry)\n\t\treturn;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_buffer_commit",
          "args": [
            "&fbuffer"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2893-2915",
          "snippet": "void trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);",
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);\nstatic __always_inline struct;\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "ucb->buf",
            "tu->tp.size + dsize"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "false"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "true"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_reserve",
          "args": [
            "&fbuffer",
            "trace_file",
            "size"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "462-491",
          "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "is_ret_probe(tu)"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tu->tp.size + dsize > PAGE_SIZE"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "call != trace_file->event_call"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, size);\n\tif (!entry)\n\t\treturn;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
  },
  {
    "function_name": "uprobe_buffer_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "940-943",
    "snippet": "static void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ucb->mutex"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}"
  },
  {
    "function_name": "uprobe_buffer_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "923-938",
    "snippet": "static struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ucb->mutex"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}"
  },
  {
    "function_name": "uprobe_buffer_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "907-921",
    "snippet": "static void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;",
      "static int uprobe_buffer_refcnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&event_mutex)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&event_mutex"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\nstatic int uprobe_buffer_refcnt;\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}"
  },
  {
    "function_name": "uprobe_buffer_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "892-905",
    "snippet": "static int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int uprobe_buffer_refcnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_buffer_init",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "860-890",
          "snippet": "static int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&event_mutex)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&event_mutex"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int uprobe_buffer_refcnt;\n\nstatic int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_buffer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "860-890",
    "snippet": "static int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "uprobe_cpu_buffer"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "cpu_to_node(cpu)",
            "GFP_KERNEL",
            "0"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structuprobe_cpu_buffer"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "profile_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "834-843",
    "snippet": "static int profile_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &profile_seq_op);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static const struct seq_operations profile_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show\t= probes_profile_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&profile_seq_op"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic const struct seq_operations profile_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show\t= probes_profile_seq_show\n};\n\nstatic int profile_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &profile_seq_op);\n}"
  },
  {
    "function_name": "probes_profile_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "813-825",
    "snippet": "static int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\tstruct trace_uprobe *tu;\n\n\tif (!is_trace_uprobe(ev))\n\t\treturn 0;\n\n\ttu = to_trace_uprobe(ev);\n\tseq_printf(m, \"  %s %-44s %15lu\\n\", tu->filename,\n\t\t\ttrace_probe_name(&tu->tp), tu->nhit);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_uprobe_release(struct dyn_event *ev);",
      "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %s %-44s %15lu\\n\"",
            "tu->filename",
            "trace_probe_name(&tu->tp)",
            "tu->nhit"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tu->tp"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_uprobe",
          "args": [
            "ev"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "73-76",
          "snippet": "static struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_uprobe_release(struct dyn_event *ev);",
            "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_trace_uprobe",
          "args": [
            "ev"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "is_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "68-71",
          "snippet": "static bool is_trace_uprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_uprobe_ops;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_uprobe_release(struct dyn_event *ev);",
            "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\nstatic nokprobe_inline struct;\n\nstatic bool is_trace_uprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_uprobe_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\tstruct trace_uprobe *tu;\n\n\tif (!is_trace_uprobe(ev))\n\t\treturn 0;\n\n\ttu = to_trace_uprobe(ev);\n\tseq_printf(m, \"  %s %-44s %15lu\\n\", tu->filename,\n\t\t\ttrace_probe_name(&tu->tp), tu->nhit);\n\treturn 0;\n}"
  },
  {
    "function_name": "probes_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "796-801",
    "snippet": "static ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t\tcreate_or_delete_trace_uprobe);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parse_run_command",
          "args": [
            "file",
            "buffer",
            "count",
            "ppos",
            "create_or_delete_trace_uprobe"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parse_run_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9922-9985",
          "snippet": "ssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(const char *))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = createfn(buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define WRITE_BUFSIZE  4096"
          ],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define WRITE_BUFSIZE  4096\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(const char *))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = createfn(buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t\tcreate_or_delete_trace_uprobe);\n}"
  },
  {
    "function_name": "probes_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "779-794",
    "snippet": "static int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(&trace_uprobe_ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};",
      "static nokprobe_inline struct",
      "static const struct seq_operations probes_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show   = probes_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&probes_seq_op"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_events_release_all",
          "args": [
            "&trace_uprobe_ops"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_events_release_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "195-220",
          "snippet": "int dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\nstatic nokprobe_inline struct;\nstatic const struct seq_operations probes_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show   = probes_seq_show\n};\n\nstatic int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(&trace_uprobe_ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}"
  },
  {
    "function_name": "probes_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "762-770",
    "snippet": "static int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (!is_trace_uprobe(ev))\n\t\treturn 0;\n\n\treturn trace_uprobe_show(m, ev);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_uprobe_release(struct dyn_event *ev);",
      "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_uprobe_show",
          "args": [
            "m",
            "ev"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "742-760",
          "snippet": "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\tchar c = is_ret_probe(tu) ? 'r' : 'p';\n\tint i;\n\n\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, trace_probe_group_name(&tu->tp),\n\t\t\ttrace_probe_name(&tu->tp), tu->filename,\n\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\n\tif (tu->ref_ctr_offset)\n\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_uprobe_release(struct dyn_event *ev);",
            "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\tchar c = is_ret_probe(tu) ? 'r' : 'p';\n\tint i;\n\n\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, trace_probe_group_name(&tu->tp),\n\t\t\ttrace_probe_name(&tu->tp), tu->filename,\n\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\n\tif (tu->ref_ctr_offset)\n\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_trace_uprobe",
          "args": [
            "ev"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "is_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "68-71",
          "snippet": "static bool is_trace_uprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_uprobe_ops;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_uprobe_release(struct dyn_event *ev);",
            "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\nstatic nokprobe_inline struct;\n\nstatic bool is_trace_uprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_uprobe_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (!is_trace_uprobe(ev))\n\t\treturn 0;\n\n\treturn trace_uprobe_show(m, ev);\n}"
  },
  {
    "function_name": "trace_uprobe_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "742-760",
    "snippet": "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\tchar c = is_ret_probe(tu) ? 'r' : 'p';\n\tint i;\n\n\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, trace_probe_group_name(&tu->tp),\n\t\t\ttrace_probe_name(&tu->tp), tu->filename,\n\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\n\tif (tu->ref_ctr_offset)\n\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_uprobe_release(struct dyn_event *ev);",
      "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %s=%s\"",
            "tu->tp.args[i].name",
            "tu->tp.args[i].comm"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tu->tp"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&tu->tp"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_uprobe",
          "args": [
            "ev"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "73-76",
          "snippet": "static struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_uprobe_release(struct dyn_event *ev);",
            "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\tchar c = is_ret_probe(tu) ? 'r' : 'p';\n\tint i;\n\n\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, trace_probe_group_name(&tu->tp),\n\t\t\ttrace_probe_name(&tu->tp), tu->filename,\n\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\n\tif (tu->ref_ctr_offset)\n\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_uprobe_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "734-739",
    "snippet": "static int trace_uprobe_release(struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn unregister_trace_uprobe(tu);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_uprobe_release(struct dyn_event *ev);",
      "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "387-407",
          "snippet": "static int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tif (trace_probe_has_sibling(&tu->tp))\n\t\tgoto unreg;\n\n\t/* If there's a reference to the dynamic event */\n\tif (trace_event_dyn_busy(trace_probe_event_call(&tu->tp)))\n\t\treturn -EBUSY;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\nunreg:\n\tdyn_event_remove(&tu->devent);\n\ttrace_probe_unlink(&tu->tp);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tif (trace_probe_has_sibling(&tu->tp))\n\t\tgoto unreg;\n\n\t/* If there's a reference to the dynamic event */\n\tif (trace_event_dyn_busy(trace_probe_event_call(&tu->tp)))\n\t\treturn -EBUSY;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\nunreg:\n\tdyn_event_remove(&tu->devent);\n\ttrace_probe_unlink(&tu->tp);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_uprobe",
          "args": [
            "ev"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "73-76",
          "snippet": "static struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_uprobe_release(struct dyn_event *ev);",
            "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int trace_uprobe_release(struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn unregister_trace_uprobe(tu);\n}"
  },
  {
    "function_name": "create_or_delete_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "723-732",
    "snippet": "static int create_or_delete_trace_uprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_uprobe_ops);\n\n\tret = trace_uprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_create(const char *raw_command);",
      "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_uprobe_create",
          "args": [
            "raw_command"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "718-721",
          "snippet": "int trace_uprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_uprobe_create);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_create(const char *raw_command);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_create(const char *raw_command);\n\nint trace_uprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_uprobe_create);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_release",
          "args": [
            "raw_command",
            "&trace_uprobe_ops"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "72-125",
          "snippet": "int dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_create(const char *raw_command);\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\n\nstatic int create_or_delete_trace_uprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_uprobe_ops);\n\n\tret = trace_uprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}"
  },
  {
    "function_name": "trace_uprobe_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "718-721",
    "snippet": "int trace_uprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_uprobe_create);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_create(const char *raw_command);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_create",
          "args": [
            "raw_command",
            "__trace_uprobe_create"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1194-1209",
          "snippet": "int trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_create(const char *raw_command);\n\nint trace_uprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_uprobe_create);\n}"
  },
  {
    "function_name": "__trace_uprobe_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "537-716",
    "snippet": "static int __trace_uprobe_create(int argc, const char **argv)\n{\n\tstruct trace_uprobe *tu;\n\tconst char *event = NULL, *group = UPROBE_EVENT_SYSTEM;\n\tchar *arg, *filename, *rctr, *rctr_end, *tmp;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tenum probe_print_type ptype;\n\tstruct path path;\n\tunsigned long offset, ref_ctr_offset;\n\tbool is_return = false;\n\tint i, ret;\n\n\tret = 0;\n\tref_ctr_offset = 0;\n\n\tswitch (argv[0][0]) {\n\tcase 'r':\n\t\tis_return = true;\n\t\tbreak;\n\tcase 'p':\n\t\tbreak;\n\tdefault:\n\t\treturn -ECANCELED;\n\t}\n\n\tif (argc < 2)\n\t\treturn -ECANCELED;\n\n\tif (argv[0][1] == ':')\n\t\tevent = &argv[0][2];\n\n\tif (!strchr(argv[1], '/'))\n\t\treturn -ECANCELED;\n\n\tfilename = kstrdup(argv[1], GFP_KERNEL);\n\tif (!filename)\n\t\treturn -ENOMEM;\n\n\t/* Find the last occurrence, in case the path contains ':' too. */\n\targ = strrchr(filename, ':');\n\tif (!arg || !isdigit(arg[1])) {\n\t\tkfree(filename);\n\t\treturn -ECANCELED;\n\t}\n\n\ttrace_probe_log_init(\"trace_uprobe\", argc, argv);\n\ttrace_probe_log_set_index(1);\t/* filename is the 2nd argument */\n\n\t*arg++ = '\\0';\n\tret = kern_path(filename, LOOKUP_FOLLOW, &path);\n\tif (ret) {\n\t\ttrace_probe_log_err(0, FILE_NOT_FOUND);\n\t\tkfree(filename);\n\t\ttrace_probe_log_clear();\n\t\treturn ret;\n\t}\n\tif (!d_is_reg(path.dentry)) {\n\t\ttrace_probe_log_err(0, NO_REGULAR_FILE);\n\t\tret = -EINVAL;\n\t\tgoto fail_address_parse;\n\t}\n\n\t/* Parse reference counter offset if specified. */\n\trctr = strchr(arg, '(');\n\tif (rctr) {\n\t\trctr_end = strchr(rctr, ')');\n\t\tif (!rctr_end) {\n\t\t\tret = -EINVAL;\n\t\t\trctr_end = rctr + strlen(rctr);\n\t\t\ttrace_probe_log_err(rctr_end - filename,\n\t\t\t\t\t    REFCNT_OPEN_BRACE);\n\t\t\tgoto fail_address_parse;\n\t\t} else if (rctr_end[1] != '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\ttrace_probe_log_err(rctr_end + 1 - filename,\n\t\t\t\t\t    BAD_REFCNT_SUFFIX);\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\t*rctr++ = '\\0';\n\t\t*rctr_end = '\\0';\n\t\tret = kstrtoul(rctr, 0, &ref_ctr_offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(rctr - filename, BAD_REFCNT);\n\t\t\tgoto fail_address_parse;\n\t\t}\n\t}\n\n\t/* Check if there is %return suffix */\n\ttmp = strchr(arg, '%');\n\tif (tmp) {\n\t\tif (!strcmp(tmp, \"%return\")) {\n\t\t\t*tmp = '\\0';\n\t\t\tis_return = true;\n\t\t} else {\n\t\t\ttrace_probe_log_err(tmp - filename, BAD_ADDR_SUFFIX);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_address_parse;\n\t\t}\n\t}\n\n\t/* Parse uprobe offset. */\n\tret = kstrtoul(arg, 0, &offset);\n\tif (ret) {\n\t\ttrace_probe_log_err(arg - filename, BAD_UPROBE_OFFS);\n\t\tgoto fail_address_parse;\n\t}\n\n\t/* setup a probe */\n\ttrace_probe_log_set_index(0);\n\tif (event) {\n\t\tret = traceprobe_parse_event_name(&event, &group, buf,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto fail_address_parse;\n\t} else {\n\t\tchar *tail;\n\t\tchar *ptr;\n\n\t\ttail = kstrdup(kbasename(filename), GFP_KERNEL);\n\t\tif (!tail) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\tptr = strpbrk(tail, \".-_\");\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_0x%lx\", 'p', tail, offset);\n\t\tevent = buf;\n\t\tkfree(tail);\n\t}\n\n\targc -= 2;\n\targv += 2;\n\n\ttu = alloc_trace_uprobe(group, event, argc, is_return);\n\tif (IS_ERR(tu)) {\n\t\tret = PTR_ERR(tu);\n\t\t/* This must return -ENOMEM otherwise there is a bug */\n\t\tWARN_ON_ONCE(ret != -ENOMEM);\n\t\tgoto fail_address_parse;\n\t}\n\ttu->offset = offset;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->path = path;\n\ttu->filename = filename;\n\n\t/* parse arguments */\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tret = traceprobe_parse_probe_arg(&tu->tp, i, argv[i],\n\t\t\t\t\tis_return ? TPARG_FL_RETURN : 0);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tret = traceprobe_set_print_fmt(&tu->tp, ptype);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = register_trace_uprobe(tu);\n\tif (!ret)\n\t\tgoto out;\n\nerror:\n\tfree_trace_uprobe(tu);\nout:\n\ttrace_probe_log_clear();\n\treturn ret;\n\nfail_address_parse:\n\ttrace_probe_log_clear();\n\tpath_put(&path);\n\tkfree(filename);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [
      "#define UPROBE_EVENT_SYSTEM\t\"uprobes\""
    ],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_log_clear",
          "args": [],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "153-156",
          "snippet": "void trace_probe_log_clear(void)\n{\n\tmemset(&trace_probe_log, 0, sizeof(trace_probe_log));\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_clear(void)\n{\n\tmemset(&trace_probe_log, 0, sizeof(trace_probe_log));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "362-371",
          "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "register_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "490-531",
          "snippet": "static int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = validate_ref_ctr_offset(tu);\n\tif (ret)\n\t\tgoto end;\n\n\t/* register as an event */\n\told_tu = find_probe_event(trace_probe_name(&tu->tp),\n\t\t\t\t  trace_probe_group_name(&tu->tp));\n\tif (old_tu) {\n\t\tif (is_ret_probe(tu) != is_ret_probe(old_tu)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_uprobe(tu, old_tu);\n\t\t}\n\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = validate_ref_ctr_offset(tu);\n\tif (ret)\n\t\tgoto end;\n\n\t/* register as an event */\n\told_tu = find_probe_event(trace_probe_name(&tu->tp),\n\t\t\t\t  trace_probe_group_name(&tu->tp));\n\tif (old_tu) {\n\t\tif (is_ret_probe(tu) != is_ret_probe(old_tu)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_uprobe(tu, old_tu);\n\t\t}\n\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&tu->tp",
            "ptype"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "935-952",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_parse_probe_arg",
          "args": [
            "&tu->tp",
            "i",
            "argv[i]",
            "is_return ? TPARG_FL_RETURN : 0"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_probe_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "770-809",
          "snippet": "int traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t\tunsigned int flags)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t/* Increment count for freeing args in error case */\n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\t/* If argument name is omitted, set \"argN\" */\n\t\tparg->name = kasprintf(GFP_KERNEL, \"arg%d\", i + 1);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\t/* Parse fetch argument */\n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, flags,\n\t\t\t\t\t       body - arg);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t\tunsigned int flags)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t/* Increment count for freeing args in error case */\n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\t/* If argument name is omitted, set \"argN\" */\n\t\tparg->name = kasprintf(GFP_KERNEL, \"arg%d\", i + 1);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\t/* Parse fetch argument */\n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, flags,\n\t\t\t\t\t       body - arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_set_index",
          "args": [
            "i + 2"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_set_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "158-161",
          "snippet": "void trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret != -ENOMEM"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tu"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tu"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trace_uprobe",
          "args": [
            "group",
            "event",
            "argc",
            "is_return"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "335-360",
          "snippet": "static struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = kzalloc(struct_size(tu, tp.args, nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = trace_probe_init(&tu->tp, event, group, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tu->devent, &trace_uprobe_ops);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(tu->tp.event->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};",
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = kzalloc(struct_size(tu, tp.args, nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = trace_probe_init(&tu->tp, event, group, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tu->devent, &trace_uprobe_ops);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(tu->tp.event->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu);\n\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"%c_%s_0x%lx\"",
            "'p'",
            "tail",
            "offset"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5994-6013",
          "snippet": "int btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "tail",
            "\".-_\""
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "kbasename(filename)",
            "GFP_KERNEL"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbasename",
          "args": [
            "filename"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traceprobe_parse_event_name",
          "args": [
            "&event",
            "&group",
            "buf",
            "event - argv[0]"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_event_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "229-271",
          "snippet": "int traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrlcpy(buf, event, slash - event + 1);\n\t\tif (!is_good_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrlcpy(buf, event, slash - event + 1);\n\t\tif (!is_good_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "arg - filename",
            "BAD_UPROBE_OFFS"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "arg",
            "0",
            "&offset"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp",
            "\"%return\""
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "'%'"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "rctr",
            "0",
            "&ref_ctr_offset"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rctr"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "198-202",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "rctr",
            "')'"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "'('"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "path.dentry"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "filename",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_log_init",
          "args": [
            "\"trace_uprobe\"",
            "argc",
            "argv"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "145-151",
          "snippet": "void trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "arg[1]"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "filename",
            "':'"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "argv[1]",
            "GFP_KERNEL"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[1]",
            "'/'"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\n#define UPROBE_EVENT_SYSTEM\t\"uprobes\"\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int __trace_uprobe_create(int argc, const char **argv)\n{\n\tstruct trace_uprobe *tu;\n\tconst char *event = NULL, *group = UPROBE_EVENT_SYSTEM;\n\tchar *arg, *filename, *rctr, *rctr_end, *tmp;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tenum probe_print_type ptype;\n\tstruct path path;\n\tunsigned long offset, ref_ctr_offset;\n\tbool is_return = false;\n\tint i, ret;\n\n\tret = 0;\n\tref_ctr_offset = 0;\n\n\tswitch (argv[0][0]) {\n\tcase 'r':\n\t\tis_return = true;\n\t\tbreak;\n\tcase 'p':\n\t\tbreak;\n\tdefault:\n\t\treturn -ECANCELED;\n\t}\n\n\tif (argc < 2)\n\t\treturn -ECANCELED;\n\n\tif (argv[0][1] == ':')\n\t\tevent = &argv[0][2];\n\n\tif (!strchr(argv[1], '/'))\n\t\treturn -ECANCELED;\n\n\tfilename = kstrdup(argv[1], GFP_KERNEL);\n\tif (!filename)\n\t\treturn -ENOMEM;\n\n\t/* Find the last occurrence, in case the path contains ':' too. */\n\targ = strrchr(filename, ':');\n\tif (!arg || !isdigit(arg[1])) {\n\t\tkfree(filename);\n\t\treturn -ECANCELED;\n\t}\n\n\ttrace_probe_log_init(\"trace_uprobe\", argc, argv);\n\ttrace_probe_log_set_index(1);\t/* filename is the 2nd argument */\n\n\t*arg++ = '\\0';\n\tret = kern_path(filename, LOOKUP_FOLLOW, &path);\n\tif (ret) {\n\t\ttrace_probe_log_err(0, FILE_NOT_FOUND);\n\t\tkfree(filename);\n\t\ttrace_probe_log_clear();\n\t\treturn ret;\n\t}\n\tif (!d_is_reg(path.dentry)) {\n\t\ttrace_probe_log_err(0, NO_REGULAR_FILE);\n\t\tret = -EINVAL;\n\t\tgoto fail_address_parse;\n\t}\n\n\t/* Parse reference counter offset if specified. */\n\trctr = strchr(arg, '(');\n\tif (rctr) {\n\t\trctr_end = strchr(rctr, ')');\n\t\tif (!rctr_end) {\n\t\t\tret = -EINVAL;\n\t\t\trctr_end = rctr + strlen(rctr);\n\t\t\ttrace_probe_log_err(rctr_end - filename,\n\t\t\t\t\t    REFCNT_OPEN_BRACE);\n\t\t\tgoto fail_address_parse;\n\t\t} else if (rctr_end[1] != '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\ttrace_probe_log_err(rctr_end + 1 - filename,\n\t\t\t\t\t    BAD_REFCNT_SUFFIX);\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\t*rctr++ = '\\0';\n\t\t*rctr_end = '\\0';\n\t\tret = kstrtoul(rctr, 0, &ref_ctr_offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(rctr - filename, BAD_REFCNT);\n\t\t\tgoto fail_address_parse;\n\t\t}\n\t}\n\n\t/* Check if there is %return suffix */\n\ttmp = strchr(arg, '%');\n\tif (tmp) {\n\t\tif (!strcmp(tmp, \"%return\")) {\n\t\t\t*tmp = '\\0';\n\t\t\tis_return = true;\n\t\t} else {\n\t\t\ttrace_probe_log_err(tmp - filename, BAD_ADDR_SUFFIX);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_address_parse;\n\t\t}\n\t}\n\n\t/* Parse uprobe offset. */\n\tret = kstrtoul(arg, 0, &offset);\n\tif (ret) {\n\t\ttrace_probe_log_err(arg - filename, BAD_UPROBE_OFFS);\n\t\tgoto fail_address_parse;\n\t}\n\n\t/* setup a probe */\n\ttrace_probe_log_set_index(0);\n\tif (event) {\n\t\tret = traceprobe_parse_event_name(&event, &group, buf,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto fail_address_parse;\n\t} else {\n\t\tchar *tail;\n\t\tchar *ptr;\n\n\t\ttail = kstrdup(kbasename(filename), GFP_KERNEL);\n\t\tif (!tail) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\tptr = strpbrk(tail, \".-_\");\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_0x%lx\", 'p', tail, offset);\n\t\tevent = buf;\n\t\tkfree(tail);\n\t}\n\n\targc -= 2;\n\targv += 2;\n\n\ttu = alloc_trace_uprobe(group, event, argc, is_return);\n\tif (IS_ERR(tu)) {\n\t\tret = PTR_ERR(tu);\n\t\t/* This must return -ENOMEM otherwise there is a bug */\n\t\tWARN_ON_ONCE(ret != -ENOMEM);\n\t\tgoto fail_address_parse;\n\t}\n\ttu->offset = offset;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->path = path;\n\ttu->filename = filename;\n\n\t/* parse arguments */\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tret = traceprobe_parse_probe_arg(&tu->tp, i, argv[i],\n\t\t\t\t\tis_return ? TPARG_FL_RETURN : 0);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tret = traceprobe_set_print_fmt(&tu->tp, ptype);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = register_trace_uprobe(tu);\n\tif (!ret)\n\t\tgoto out;\n\nerror:\n\tfree_trace_uprobe(tu);\nout:\n\ttrace_probe_log_clear();\n\treturn ret;\n\nfail_address_parse:\n\ttrace_probe_log_clear();\n\tpath_put(&path);\n\tkfree(filename);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "490-531",
    "snippet": "static int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = validate_ref_ctr_offset(tu);\n\tif (ret)\n\t\tgoto end;\n\n\t/* register as an event */\n\told_tu = find_probe_event(trace_probe_name(&tu->tp),\n\t\t\t\t  trace_probe_group_name(&tu->tp));\n\tif (old_tu) {\n\t\tif (is_ret_probe(tu) != is_ret_probe(old_tu)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_uprobe(tu, old_tu);\n\t\t}\n\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_add",
          "args": [
            "&tu->devent",
            "trace_probe_event_call(&tu->tp)"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "79-90",
          "snippet": "static inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register probe event(%d)\\n\"",
            "ret"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "0",
            "EVENT_EXIST"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_set_index",
          "args": [
            "0"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_set_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "158-161",
          "snippet": "void trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_uprobe_event",
          "args": [
            "tu"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_uprobe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1570-1573",
          "snippet": "static int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\treturn trace_probe_unregister_event_call(&tu->tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\treturn trace_probe_unregister_event_call(&tu->tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_trace_uprobe",
          "args": [
            "tu",
            "old_tu"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "append_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "438-461",
          "snippet": "static int append_trace_uprobe(struct trace_uprobe *tu, struct trace_uprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tu->tp, &to->tp);\n\tif (ret) {\n\t\t/* Note that argument starts index = 2 */\n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_uprobe_has_same_uprobe(to, tu)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Append to existing event */\n\tret = trace_probe_append(&tu->tp, &to->tp);\n\tif (!ret)\n\t\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int append_trace_uprobe(struct trace_uprobe *tu, struct trace_uprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tu->tp, &to->tp);\n\tif (ret) {\n\t\t/* Note that argument starts index = 2 */\n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_uprobe_has_same_uprobe(to, tu)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Append to existing event */\n\tret = trace_probe_append(&tu->tp, &to->tp);\n\tif (!ret)\n\t\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "old_tu"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "270-273",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_probe_event",
          "args": [
            "trace_probe_name(&tu->tp)",
            "trace_probe_group_name(&tu->tp)"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "find_probe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "373-384",
          "snippet": "static struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tu;\n\n\tfor_each_trace_uprobe(tu, pos)\n\t\tif (strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tu->tp), group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tu;\n\n\tfor_each_trace_uprobe(tu, pos)\n\t\tif (strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tu->tp), group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&tu->tp"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tu->tp"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_ref_ctr_offset",
          "args": [
            "tu"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "validate_ref_ctr_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "472-487",
          "snippet": "static int validate_ref_ctr_offset(struct trace_uprobe *new)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tmp;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\tfor_each_trace_uprobe(tmp, pos) {\n\t\tif (new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int validate_ref_ctr_offset(struct trace_uprobe *new)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tmp;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\tfor_each_trace_uprobe(tmp, pos) {\n\t\tif (new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = validate_ref_ctr_offset(tu);\n\tif (ret)\n\t\tgoto end;\n\n\t/* register as an event */\n\told_tu = find_probe_event(trace_probe_name(&tu->tp),\n\t\t\t\t  trace_probe_group_name(&tu->tp));\n\tif (old_tu) {\n\t\tif (is_ret_probe(tu) != is_ret_probe(old_tu)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_uprobe(tu, old_tu);\n\t\t}\n\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "validate_ref_ctr_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "472-487",
    "snippet": "static int validate_ref_ctr_offset(struct trace_uprobe *new)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tmp;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\tfor_each_trace_uprobe(tmp, pos) {\n\t\tif (new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Reference counter offset mismatch.\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_real_inode",
          "args": [
            "tmp->path.dentry"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_trace_uprobe",
          "args": [
            "tmp",
            "pos"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_real_inode",
          "args": [
            "new->path.dentry"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int validate_ref_ctr_offset(struct trace_uprobe *new)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tmp;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\tfor_each_trace_uprobe(tmp, pos) {\n\t\tif (new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "append_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "438-461",
    "snippet": "static int append_trace_uprobe(struct trace_uprobe *tu, struct trace_uprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tu->tp, &to->tp);\n\tif (ret) {\n\t\t/* Note that argument starts index = 2 */\n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_uprobe_has_same_uprobe(to, tu)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Append to existing event */\n\tret = trace_probe_append(&tu->tp, &to->tp);\n\tif (!ret)\n\t\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dyn_event_add",
          "args": [
            "&tu->devent",
            "trace_probe_event_call(&tu->tp)"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "79-90",
          "snippet": "static inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_append",
          "args": [
            "&tu->tp",
            "&to->tp"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_append",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "987-999",
          "snippet": "int trace_probe_append(struct trace_probe *tp, struct trace_probe *to)\n{\n\tif (trace_probe_has_sibling(tp))\n\t\treturn -EBUSY;\n\n\tlist_del_init(&tp->list);\n\ttrace_probe_event_free(tp->event);\n\n\ttp->event = to->event;\n\tlist_add_tail(&tp->list, trace_probe_probe_list(to));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_append(struct trace_probe *tp, struct trace_probe *to)\n{\n\tif (trace_probe_has_sibling(tp))\n\t\treturn -EBUSY;\n\n\tlist_del_init(&tp->list);\n\ttrace_probe_event_free(tp->event);\n\n\ttp->event = to->event;\n\tlist_add_tail(&tp->list, trace_probe_probe_list(to));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "0",
            "SAME_PROBE"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_set_index",
          "args": [
            "0"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_set_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "158-161",
          "snippet": "void trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_uprobe_has_same_uprobe",
          "args": [
            "to",
            "tu"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_has_same_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "409-436",
          "snippet": "static bool trace_uprobe_has_same_uprobe(struct trace_uprobe *orig,\n\t\t\t\t\t struct trace_uprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tstruct inode *comp_inode = d_real_inode(comp->path.dentry);\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (comp_inode != d_real_inode(orig->path.dentry) ||\n\t\t    comp->offset != orig->offset)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * trace_probe_compare_arg_type() ensured that nr_args and\n\t\t * each argument name and type are same. Let's compare comm.\n\t\t */\n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_has_same_uprobe(struct trace_uprobe *orig,\n\t\t\t\t\t struct trace_uprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tstruct inode *comp_inode = d_real_inode(comp->path.dentry);\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (comp_inode != d_real_inode(orig->path.dentry) ||\n\t\t    comp->offset != orig->offset)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * trace_probe_compare_arg_type() ensured that nr_args and\n\t\t * each argument name and type are same. Let's compare comm.\n\t\t */\n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_compare_arg_type",
          "args": [
            "&tu->tp",
            "&to->tp"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_compare_arg_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1155-1174",
          "snippet": "int trace_probe_compare_arg_type(struct trace_probe *a, struct trace_probe *b)\n{\n\tint i;\n\n\t/* In case of more arguments */\n\tif (a->nr_args < b->nr_args)\n\t\treturn a->nr_args + 1;\n\tif (a->nr_args > b->nr_args)\n\t\treturn b->nr_args + 1;\n\n\tfor (i = 0; i < a->nr_args; i++) {\n\t\tif ((b->nr_args <= i) ||\n\t\t    ((a->args[i].type != b->args[i].type) ||\n\t\t     (a->args[i].count != b->args[i].count) ||\n\t\t     strcmp(a->args[i].name, b->args[i].name)))\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_compare_arg_type(struct trace_probe *a, struct trace_probe *b)\n{\n\tint i;\n\n\t/* In case of more arguments */\n\tif (a->nr_args < b->nr_args)\n\t\treturn a->nr_args + 1;\n\tif (a->nr_args > b->nr_args)\n\t\treturn b->nr_args + 1;\n\n\tfor (i = 0; i < a->nr_args; i++) {\n\t\tif ((b->nr_args <= i) ||\n\t\t    ((a->args[i].type != b->args[i].type) ||\n\t\t     (a->args[i].count != b->args[i].count) ||\n\t\t     strcmp(a->args[i].name, b->args[i].name)))\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int append_trace_uprobe(struct trace_uprobe *tu, struct trace_uprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tu->tp, &to->tp);\n\tif (ret) {\n\t\t/* Note that argument starts index = 2 */\n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_uprobe_has_same_uprobe(to, tu)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Append to existing event */\n\tret = trace_probe_append(&tu->tp, &to->tp);\n\tif (!ret)\n\t\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_uprobe_has_same_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "409-436",
    "snippet": "static bool trace_uprobe_has_same_uprobe(struct trace_uprobe *orig,\n\t\t\t\t\t struct trace_uprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tstruct inode *comp_inode = d_real_inode(comp->path.dentry);\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (comp_inode != d_real_inode(orig->path.dentry) ||\n\t\t    comp->offset != orig->offset)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * trace_probe_compare_arg_type() ensured that nr_args and\n\t\t * each argument name and type are same. Let's compare comm.\n\t\t */\n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->tp.args[i].comm",
            "comp->tp.args[i].comm"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_real_inode",
          "args": [
            "orig->path.dentry"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "orig",
            "&tpe->probes",
            "tp.list"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_real_inode",
          "args": [
            "comp->path.dentry"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_has_same_uprobe(struct trace_uprobe *orig,\n\t\t\t\t\t struct trace_uprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tstruct inode *comp_inode = d_real_inode(comp->path.dentry);\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (comp_inode != d_real_inode(orig->path.dentry) ||\n\t\t    comp->offset != orig->offset)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * trace_probe_compare_arg_type() ensured that nr_args and\n\t\t * each argument name and type are same. Let's compare comm.\n\t\t */\n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "unregister_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "387-407",
    "snippet": "static int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tif (trace_probe_has_sibling(&tu->tp))\n\t\tgoto unreg;\n\n\t/* If there's a reference to the dynamic event */\n\tif (trace_event_dyn_busy(trace_probe_event_call(&tu->tp)))\n\t\treturn -EBUSY;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\nunreg:\n\tdyn_event_remove(&tu->devent);\n\ttrace_probe_unlink(&tu->tp);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "362-371",
          "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_unlink",
          "args": [
            "&tu->tp"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1001-1007",
          "snippet": "void trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_remove",
          "args": [
            "&tu->devent"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "92-96",
          "snippet": "static inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_uprobe_event",
          "args": [
            "tu"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_uprobe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1570-1573",
          "snippet": "static int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\treturn trace_probe_unregister_event_call(&tu->tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\treturn trace_probe_unregister_event_call(&tu->tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_dyn_busy",
          "args": [
            "trace_probe_event_call(&tu->tp)"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_dyn_busy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "54-57",
          "snippet": "bool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nbool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tu->tp"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_has_sibling",
          "args": [
            "&tu->tp"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_has_sibling",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "314-319",
          "snippet": "static inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tif (trace_probe_has_sibling(&tu->tp))\n\t\tgoto unreg;\n\n\t/* If there's a reference to the dynamic event */\n\tif (trace_event_dyn_busy(trace_probe_event_call(&tu->tp)))\n\t\treturn -EBUSY;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\nunreg:\n\tdyn_event_remove(&tu->devent);\n\ttrace_probe_unlink(&tu->tp);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}"
  },
  {
    "function_name": "find_probe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "373-384",
    "snippet": "static struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tu;\n\n\tfor_each_trace_uprobe(tu, pos)\n\t\tif (strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tu->tp), group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "trace_probe_group_name(&tu->tp)",
            "group"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&tu->tp"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tu->tp"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_trace_uprobe",
          "args": [
            "tu",
            "pos"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tu;\n\n\tfor_each_trace_uprobe(tu, pos)\n\t\tif (strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tu->tp), group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "362-371",
    "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tu"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_cleanup",
          "args": [
            "&tu->tp"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1009-1018",
          "snippet": "void trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&tu->path"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
  },
  {
    "function_name": "alloc_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "335-360",
    "snippet": "static struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = kzalloc(struct_size(tu, tp.args, nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = trace_probe_init(&tu->tp, event, group, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tu->devent, &trace_uprobe_ops);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(tu->tp.event->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu);\n\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};",
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tu"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_uprobe_filter",
          "args": [
            "tu->tp.event->filter"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_uprobe_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "256-263",
          "snippet": "NOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_init",
          "args": [
            "&tu->devent",
            "&trace_uprobe_ops"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "68-77",
          "snippet": "static inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_init",
          "args": [
            "&tu->tp",
            "event",
            "group",
            "true"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1020-1062",
          "snippet": "int trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(tu, tp.args, nargs)",
            "GFP_KERNEL"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "tu",
            "tp.args",
            "nargs"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = kzalloc(struct_size(tu, tp.args, nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = trace_probe_init(&tu->tp, event, group, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tu->devent, &trace_uprobe_ops);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(tu->tp.event->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu);\n\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "trace_uprobe_primary_from_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "320-330",
    "snippet": "trace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "tp",
            "structtrace_uprobe",
            "tp"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}"
  },
  {
    "function_name": "trace_uprobe_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "310-318",
    "snippet": "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t   (!system || strcmp(trace_probe_group_name(&tu->tp), system) == 0) &&\n\t   trace_uprobe_match_command_head(tu, argc, argv);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_uprobe_release(struct dyn_event *ev);",
      "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_uprobe_match_command_head",
          "args": [
            "tu",
            "argc",
            "argv"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_match_command_head",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "282-308",
          "snippet": "static bool trace_uprobe_match_command_head(struct trace_uprobe *tu,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint len;\n\n\tif (!argc)\n\t\treturn true;\n\n\tlen = strlen(tu->filename);\n\tif (strncmp(tu->filename, argv[0], len) || argv[0][len] != ':')\n\t\treturn false;\n\n\tif (tu->ref_ctr_offset == 0)\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx(0x%lx)\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset,\n\t\t\t\ttu->ref_ctr_offset);\n\tif (strcmp(buf, &argv[0][len + 1]))\n\t\treturn false;\n\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tu->tp, argc, argv);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_match_command_head(struct trace_uprobe *tu,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint len;\n\n\tif (!argc)\n\t\treturn true;\n\n\tlen = strlen(tu->filename);\n\tif (strncmp(tu->filename, argv[0], len) || argv[0][len] != ':')\n\t\treturn false;\n\n\tif (tu->ref_ctr_offset == 0)\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx(0x%lx)\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset,\n\t\t\t\ttu->ref_ctr_offset);\n\tif (strcmp(buf, &argv[0][len + 1]))\n\t\treturn false;\n\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tu->tp, argc, argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "trace_probe_group_name(&tu->tp)",
            "system"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&tu->tp"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tu->tp"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_uprobe",
          "args": [
            "ev"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "73-76",
          "snippet": "static struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_uprobe_release(struct dyn_event *ev);",
            "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t   (!system || strcmp(trace_probe_group_name(&tu->tp), system) == 0) &&\n\t   trace_uprobe_match_command_head(tu, argc, argv);\n}"
  },
  {
    "function_name": "trace_uprobe_match_command_head",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "282-308",
    "snippet": "static bool trace_uprobe_match_command_head(struct trace_uprobe *tu,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint len;\n\n\tif (!argc)\n\t\treturn true;\n\n\tlen = strlen(tu->filename);\n\tif (strncmp(tu->filename, argv[0], len) || argv[0][len] != ':')\n\t\treturn false;\n\n\tif (tu->ref_ctr_offset == 0)\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx(0x%lx)\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset,\n\t\t\t\ttu->ref_ctr_offset);\n\tif (strcmp(buf, &argv[0][len + 1]))\n\t\treturn false;\n\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tu->tp, argc, argv);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_match_command_args",
          "args": [
            "&tu->tp",
            "argc",
            "argv"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_match_command_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1176-1192",
          "snippet": "bool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nbool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "&argv[0][len + 1]"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"0x%0*lx(0x%lx)\"",
            "(int)(sizeof(void *) * 2)",
            "tu->offset",
            "tu->ref_ctr_offset"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5994-6013",
          "snippet": "int btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"0x%0*lx\"",
            "(int)(sizeof(void *) * 2)",
            "tu->offset"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "tu->filename",
            "argv[0]",
            "len"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tu->filename"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "198-202",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_match_command_head(struct trace_uprobe *tu,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint len;\n\n\tif (!argc)\n\t\treturn true;\n\n\tlen = strlen(tu->filename);\n\tif (strncmp(tu->filename, argv[0], len) || argv[0][len] != ':')\n\t\treturn false;\n\n\tif (tu->ref_ctr_offset == 0)\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx(0x%lx)\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset,\n\t\t\t\ttu->ref_ctr_offset);\n\tif (strcmp(buf, &argv[0][len + 1]))\n\t\treturn false;\n\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tu->tp, argc, argv);\n}"
  },
  {
    "function_name": "trace_uprobe_is_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "275-280",
    "snippet": "static bool trace_uprobe_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn trace_probe_is_enabled(&tu->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_uprobe_release(struct dyn_event *ev);",
      "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tu->tp"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_uprobe",
          "args": [
            "ev"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "73-76",
          "snippet": "static struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_uprobe_release(struct dyn_event *ev);",
            "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn trace_probe_is_enabled(&tu->tp);\n}"
  },
  {
    "function_name": "is_ret_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "270-273",
    "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
  },
  {
    "function_name": "uprobe_filter_is_empty",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "265-268",
    "snippet": "static inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&filter->perf_events"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}"
  },
  {
    "function_name": "init_trace_uprobe_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "256-263",
    "snippet": "NOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&filter->perf_events"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&filter->rwlock"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}"
  },
  {
    "function_name": "process_fetch_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "216-255",
    "snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tstruct pt_regs *regs = rec;\n\tunsigned long val;\n\n\t/* 1st stage: get value from context */\n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = get_user_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = user_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_IMM:\n\t\tval = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_COMM:\n\t\tval = FETCH_TOKEN_COMM;\n\t\tbreak;\n\tcase FETCH_OP_DATA:\n\t\tval = (unsigned long)code->data;\n\t\tbreak;\n\tcase FETCH_OP_FOFFS:\n\t\tval = translate_user_vaddr(code->immediate);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_fetch_insn_bottom",
          "args": [
            "code",
            "val",
            "dest",
            "base"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "process_fetch_insn_bottom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "71-168",
          "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "translate_user_vaddr",
          "args": [
            "code->immediate"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "translate_user_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "204-213",
          "snippet": "static unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regs_return_value",
          "args": [
            "regs"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_stack_pointer",
          "args": [
            "regs"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_stack_nth",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_stack_nth",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "111-122",
          "snippet": "static unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\n\nstatic unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regs_get_register",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\n\nstatic int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tstruct pt_regs *regs = rec;\n\tunsigned long val;\n\n\t/* 1st stage: get value from context */\n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = get_user_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = user_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_IMM:\n\t\tval = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_COMM:\n\t\tval = FETCH_TOKEN_COMM;\n\t\tbreak;\n\tcase FETCH_OP_DATA:\n\t\tval = (unsigned long)code->data;\n\t\tbreak;\n\tcase FETCH_OP_FOFFS:\n\t\tval = translate_user_vaddr(code->immediate);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}"
  },
  {
    "function_name": "translate_user_vaddr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "204-213",
    "snippet": "static unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstatic unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}"
  },
  {
    "function_name": "fetch_store_strlen_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "198-202",
    "snippet": "static nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fetch_store_strlen",
          "args": [
            "addr"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "198-202",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}"
  },
  {
    "function_name": "fetch_store_strlen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "184-196",
    "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tif (addr == FETCH_TOKEN_COMM)\n\t\tlen = strlen(current->comm) + 1;\n\telse\n\t\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "vaddr",
            "MAX_STRING_SIZE"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "current->comm"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "198-202",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tif (addr == FETCH_TOKEN_COMM)\n\t\tlen = strlen(current->comm) + 1;\n\telse\n\t\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
  },
  {
    "function_name": "fetch_store_string_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "177-181",
    "snippet": "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\treturn fetch_store_string(addr, dest, base);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fetch_store_string",
          "args": [
            "addr",
            "dest",
            "base"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_string_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "177-181",
          "snippet": "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\treturn fetch_store_string(addr, dest, base);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\treturn fetch_store_string(addr, dest, base);\n}"
  },
  {
    "function_name": "fetch_store_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "145-175",
    "snippet": "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tlong ret;\n\tu32 loc = *(u32 *)dest;\n\tint maxlen  = get_loc_len(loc);\n\tu8 *dst = get_loc_data(dest, base);\n\tvoid __user *src = (void __force __user *) addr;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\tif (addr == FETCH_TOKEN_COMM)\n\t\tret = strlcpy(dst, current->comm, maxlen);\n\telse\n\t\tret = strncpy_from_user(dst, src, maxlen);\n\tif (ret >= 0) {\n\t\tif (ret == maxlen)\n\t\t\tdst[ret - 1] = '\\0';\n\t\telse\n\t\t\t/*\n\t\t\t * Include the terminating null byte. In this case it\n\t\t\t * was copied by strncpy_from_user but not accounted\n\t\t\t * for in ret.\n\t\t\t */\n\t\t\tret++;\n\t\t*(u32 *)dest = make_data_loc(ret, (void *)dst - base);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "ret",
            "(void *)dst - base"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "dst",
            "src",
            "maxlen"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "dst",
            "current->comm",
            "maxlen"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!maxlen"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "dest",
            "base"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_loc_len",
          "args": [
            "loc"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tlong ret;\n\tu32 loc = *(u32 *)dest;\n\tint maxlen  = get_loc_len(loc);\n\tu8 *dst = get_loc_data(dest, base);\n\tvoid __user *src = (void __force __user *) addr;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\tif (addr == FETCH_TOKEN_COMM)\n\t\tret = strlcpy(dst, current->comm, maxlen);\n\telse\n\t\tret = strncpy_from_user(dst, src, maxlen);\n\tif (ret >= 0) {\n\t\tif (ret == maxlen)\n\t\t\tdst[ret - 1] = '\\0';\n\t\telse\n\t\t\t/*\n\t\t\t * Include the terminating null byte. In this case it\n\t\t\t * was copied by strncpy_from_user but not accounted\n\t\t\t * for in ret.\n\t\t\t */\n\t\t\tret++;\n\t\t*(u32 *)dest = make_data_loc(ret, (void *)dst - base);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "probe_mem_read_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "135-139",
    "snippet": "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\treturn probe_mem_read(dest, src, size);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_mem_read",
          "args": [
            "dest",
            "src",
            "size"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "probe_mem_read_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "135-139",
          "snippet": "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\treturn probe_mem_read(dest, src, size);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\treturn probe_mem_read(dest, src, size);\n}"
  },
  {
    "function_name": "probe_mem_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "127-133",
    "snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n\tvoid __user *vaddr = (void __force __user *)src;\n\n\treturn copy_from_user(dest, vaddr, size) ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "dest",
            "vaddr",
            "size"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n\tvoid __user *vaddr = (void __force __user *)src;\n\n\treturn copy_from_user(dest, vaddr, size) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "get_user_stack_nth",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "111-122",
    "snippet": "static unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ret",
            "(void __force __user *) addr",
            "sizeof(ret)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_stack_addr",
          "args": [
            "addr",
            "n"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_stack_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "105-108",
          "snippet": "static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_stack_pointer",
          "args": [
            "regs"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic nokprobe_inline struct;\n\nstatic unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "adjust_stack_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "105-108",
    "snippet": "static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}"
  },
  {
    "function_name": "adjust_stack_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "100-103",
    "snippet": "static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr - (n * sizeof(long));\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr - (n * sizeof(long));\n}"
  },
  {
    "function_name": "to_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "73-76",
    "snippet": "static struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_uprobe_release(struct dyn_event *ev);",
      "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ev",
            "structtrace_uprobe",
            "devent"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}"
  },
  {
    "function_name": "is_trace_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
    "lines": "68-71",
    "snippet": "static bool is_trace_uprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_uprobe_ops;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_uprobe_release(struct dyn_event *ev);",
      "static bool trace_uprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};",
      "static nokprobe_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\nstatic nokprobe_inline struct;\n\nstatic bool is_trace_uprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_uprobe_ops;\n}"
  }
]