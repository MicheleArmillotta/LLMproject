[
  {
    "function_name": "create_proc_profile",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "454-492",
    "snippet": "int __ref create_proc_profile(void)\n{\n\tstruct proc_dir_entry *entry;\n#ifdef CONFIG_SMP\n\tenum cpuhp_state online_state;\n#endif\n\n\tint err = 0;\n\n\tif (!prof_on)\n\t\treturn 0;\n#ifdef CONFIG_SMP\n\terr = cpuhp_setup_state(CPUHP_PROFILE_PREPARE, \"PROFILE_PREPARE\",\n\t\t\t\tprofile_prepare_cpu, profile_dead_cpu);\n\tif (err)\n\t\treturn err;\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"AP_PROFILE_ONLINE\",\n\t\t\t\tprofile_online_cpu, NULL);\n\tif (err < 0)\n\t\tgoto err_state_prep;\n\tonline_state = err;\n\terr = 0;\n#endif\n\tentry = proc_create(\"profile\", S_IWUSR | S_IRUGO,\n\t\t\t    NULL, &profile_proc_ops);\n\tif (!entry)\n\t\tgoto err_state_onl;\n\tproc_set_size(entry, (1 + prof_len) * sizeof(atomic_t));\n\n\treturn err;\nerr_state_onl:\n#ifdef CONFIG_SMP\n\tcpuhp_remove_state(online_state);\nerr_state_prep:\n\tcpuhp_remove_state(CPUHP_PROFILE_PREPARE);\n#endif\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long prof_len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_remove_state",
          "args": [
            "CPUHP_PROFILE_PREPARE"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_set_size",
          "args": [
            "entry",
            "(1 + prof_len) * sizeof(atomic_t)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"profile\"",
            "S_IWUSR | S_IRUGO",
            "NULL",
            "&profile_proc_ops"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"AP_PROFILE_ONLINE\"",
            "profile_online_cpu",
            "NULL"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_PROFILE_PREPARE",
            "\"PROFILE_PREPARE\"",
            "profile_prepare_cpu",
            "profile_dead_cpu"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic unsigned long prof_len;\n\nint __ref create_proc_profile(void)\n{\n\tstruct proc_dir_entry *entry;\n#ifdef CONFIG_SMP\n\tenum cpuhp_state online_state;\n#endif\n\n\tint err = 0;\n\n\tif (!prof_on)\n\t\treturn 0;\n#ifdef CONFIG_SMP\n\terr = cpuhp_setup_state(CPUHP_PROFILE_PREPARE, \"PROFILE_PREPARE\",\n\t\t\t\tprofile_prepare_cpu, profile_dead_cpu);\n\tif (err)\n\t\treturn err;\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"AP_PROFILE_ONLINE\",\n\t\t\t\tprofile_online_cpu, NULL);\n\tif (err < 0)\n\t\tgoto err_state_prep;\n\tonline_state = err;\n\terr = 0;\n#endif\n\tentry = proc_create(\"profile\", S_IWUSR | S_IRUGO,\n\t\t\t    NULL, &profile_proc_ops);\n\tif (!entry)\n\t\tgoto err_state_onl;\n\tproc_set_size(entry, (1 + prof_len) * sizeof(atomic_t));\n\n\treturn err;\nerr_state_onl:\n#ifdef CONFIG_SMP\n\tcpuhp_remove_state(online_state);\nerr_state_prep:\n\tcpuhp_remove_state(CPUHP_PROFILE_PREPARE);\n#endif\n\treturn err;\n}"
  },
  {
    "function_name": "write_profile",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "427-446",
    "snippet": "static ssize_t write_profile(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n#ifdef CONFIG_SMP\n\textern int setup_profiling_timer(unsigned int multiplier);\n\n\tif (count == sizeof(int)) {\n\t\tunsigned int multiplier;\n\n\t\tif (copy_from_user(&multiplier, buf, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (setup_profiling_timer(multiplier))\n\t\t\treturn -EINVAL;\n\t}\n#endif\n\tprofile_discard_flip_buffers();\n\tmemset(prof_buffer, 0, prof_len * sizeof(atomic_t));\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "prof_buffer",
            "0",
            "prof_len * sizeof(atomic_t)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_discard_flip_buffers",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "profile_discard_flip_buffers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
          "lines": "198-211",
          "snippet": "static void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n\nstatic void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_profiling_timer",
          "args": [
            "multiplier"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&multiplier",
            "buf",
            "sizeof(int)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len;\n\nstatic ssize_t write_profile(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n#ifdef CONFIG_SMP\n\textern int setup_profiling_timer(unsigned int multiplier);\n\n\tif (count == sizeof(int)) {\n\t\tunsigned int multiplier;\n\n\t\tif (copy_from_user(&multiplier, buf, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (setup_profiling_timer(multiplier))\n\t\t\treturn -EINVAL;\n\t}\n#endif\n\tprofile_discard_flip_buffers();\n\tmemset(prof_buffer, 0, prof_len * sizeof(atomic_t));\n\treturn count;\n}"
  },
  {
    "function_name": "read_profile",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "393-419",
    "snippet": "static ssize_t\nread_profile(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t read;\n\tchar *pnt;\n\tunsigned long sample_step = 1UL << prof_shift;\n\n\tprofile_flip_buffers();\n\tif (p >= (prof_len+1)*sizeof(unsigned int))\n\t\treturn 0;\n\tif (count > (prof_len+1)*sizeof(unsigned int) - p)\n\t\tcount = (prof_len+1)*sizeof(unsigned int) - p;\n\tread = 0;\n\n\twhile (p < sizeof(unsigned int) && count > 0) {\n\t\tif (put_user(*((char *)(&sample_step)+p), buf))\n\t\t\treturn -EFAULT;\n\t\tbuf++; p++; count--; read++;\n\t}\n\tpnt = (char *)prof_buffer + p - sizeof(atomic_t);\n\tif (copy_to_user(buf, (void *)pnt, count))\n\t\treturn -EFAULT;\n\tread += count;\n\t*ppos += read;\n\treturn read;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len;",
      "static unsigned short int prof_shift;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "(void *)pnt",
            "count"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "*((char *)(&sample_step)+p)",
            "buf"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_flip_buffers",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "profile_flip_buffers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
          "lines": "175-196",
          "snippet": "static void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))"
          ],
          "globals_used": [
            "static atomic_t *prof_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n\nstatic atomic_t *prof_buffer;\n\nstatic void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len;\nstatic unsigned short int prof_shift;\n\nstatic ssize_t\nread_profile(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t read;\n\tchar *pnt;\n\tunsigned long sample_step = 1UL << prof_shift;\n\n\tprofile_flip_buffers();\n\tif (p >= (prof_len+1)*sizeof(unsigned int))\n\t\treturn 0;\n\tif (count > (prof_len+1)*sizeof(unsigned int) - p)\n\t\tcount = (prof_len+1)*sizeof(unsigned int) - p;\n\tread = 0;\n\n\twhile (p < sizeof(unsigned int) && count > 0) {\n\t\tif (put_user(*((char *)(&sample_step)+p), buf))\n\t\t\treturn -EFAULT;\n\t\tbuf++; p++; count--; read++;\n\t}\n\tpnt = (char *)prof_buffer + p - sizeof(atomic_t);\n\tif (copy_to_user(buf, (void *)pnt, count))\n\t\treturn -EFAULT;\n\tread += count;\n\t*ppos += read;\n\treturn read;\n}"
  },
  {
    "function_name": "create_prof_cpu_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "381-385",
    "snippet": "void create_prof_cpu_mask(void)\n{\n\t/* create /proc/irq/prof_cpu_mask */\n\tproc_create(\"irq/prof_cpu_mask\", 0600, NULL, &prof_cpu_mask_proc_ops);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"irq/prof_cpu_mask\"",
            "0600",
            "NULL",
            "&prof_cpu_mask_proc_ops"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nvoid create_prof_cpu_mask(void)\n{\n\t/* create /proc/irq/prof_cpu_mask */\n\tproc_create(\"irq/prof_cpu_mask\", 0600, NULL, &prof_cpu_mask_proc_ops);\n}"
  },
  {
    "function_name": "prof_cpu_mask_proc_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "355-371",
    "snippet": "static ssize_t prof_cpu_mask_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (!err) {\n\t\tcpumask_copy(prof_cpu_mask, new_value);\n\t\terr = count;\n\t}\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_value"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "prof_cpu_mask",
            "new_value"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_parse_user",
          "args": [
            "buffer",
            "count",
            "new_value"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&new_value",
            "GFP_KERNEL"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic ssize_t prof_cpu_mask_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (!err) {\n\t\tcpumask_copy(prof_cpu_mask, new_value);\n\t\terr = count;\n\t}\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
  },
  {
    "function_name": "prof_cpu_mask_proc_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "350-353",
    "snippet": "static int prof_cpu_mask_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, prof_cpu_mask_proc_show, NULL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "prof_cpu_mask_proc_show",
            "NULL"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic int prof_cpu_mask_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, prof_cpu_mask_proc_show, NULL);\n}"
  },
  {
    "function_name": "prof_cpu_mask_proc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "344-348",
    "snippet": "static int prof_cpu_mask_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(prof_cpu_mask));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*pb\\n\"",
            "cpumask_pr_args(prof_cpu_mask)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "prof_cpu_mask"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic int prof_cpu_mask_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(prof_cpu_mask));\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "330-337",
    "snippet": "void profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && cpumask_available(prof_cpu_mask) &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_hit",
          "args": [
            "type",
            "(void *)profile_pc(regs)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_pc",
          "args": [
            "regs"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "smp_processor_id()",
            "prof_cpu_mask"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "prof_cpu_mask"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "irqentry_exit_to_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "303-309",
          "snippet": "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nvoid profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && cpumask_available(prof_cpu_mask) &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}"
  },
  {
    "function_name": "profile_hits",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "322-327",
    "snippet": "void profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tif (prof_on != type || !prof_buffer)\n\t\treturn;\n\tdo_profile_hits(type, __pc, nr_hits);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_profile_hits",
          "args": [
            "type",
            "__pc",
            "nr_hits"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "do_profile_hits",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
          "lines": "314-319",
          "snippet": "static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t *prof_buffer;",
            "static unsigned long prof_len;",
            "static unsigned short int prof_shift;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len;\nstatic unsigned short int prof_shift;\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\n\nvoid profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tif (prof_on != type || !prof_buffer)\n\t\treturn;\n\tdo_profile_hits(type, __pc, nr_hits);\n}"
  },
  {
    "function_name": "do_profile_hits",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "314-319",
    "snippet": "static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len;",
      "static unsigned short int prof_shift;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "nr_hits",
            "&prof_buffer[min(pc, prof_len - 1)]"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pc",
            "prof_len - 1"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len;\nstatic unsigned short int prof_shift;\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}"
  },
  {
    "function_name": "profile_online_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "302-308",
    "snippet": "static int profile_online_cpu(unsigned int cpu)\n{\n\tif (cpumask_available(prof_cpu_mask))\n\t\tcpumask_set_cpu(cpu, prof_cpu_mask);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "prof_cpu_mask"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "prof_cpu_mask"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic int profile_online_cpu(unsigned int cpu)\n{\n\tif (cpumask_available(prof_cpu_mask))\n\t\tcpumask_set_cpu(cpu, prof_cpu_mask);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_prepare_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "280-300",
    "snippet": "static int profile_prepare_cpu(unsigned int cpu)\n{\n\tint i, node = cpu_to_mem(cpu);\n\tstruct page *page;\n\n\tper_cpu(cpu_profile_flip, cpu) = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i])\n\t\t\tcontinue;\n\n\t\tpage = __alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\t\tif (!page) {\n\t\t\tprofile_dead_cpu(cpu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_cpu(cpu_profile_hits, cpu)[i] = page_address(page);\n\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_hits",
            "cpu"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_dead_cpu",
          "args": [
            "cpu"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "profile_dead_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
          "lines": "262-278",
          "snippet": "static int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (cpumask_available(prof_cpu_mask))\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t prof_cpu_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (cpumask_available(prof_cpu_mask))\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "node",
            "GFP_KERNEL | __GFP_ZERO",
            "0"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_mem",
          "args": [
            "cpu"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic int profile_prepare_cpu(unsigned int cpu)\n{\n\tint i, node = cpu_to_mem(cpu);\n\tstruct page *page;\n\n\tper_cpu(cpu_profile_flip, cpu) = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i])\n\t\t\tcontinue;\n\n\t\tpage = __alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\t\tif (!page) {\n\t\t\tprofile_dead_cpu(cpu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_cpu(cpu_profile_hits, cpu)[i] = page_address(page);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_dead_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "262-278",
    "snippet": "static int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (cpumask_available(prof_cpu_mask))\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_hits",
            "cpu"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "per_cpu(cpu_profile_hits, cpu)[i]"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "prof_cpu_mask"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "prof_cpu_mask"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (cpumask_available(prof_cpu_mask))\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_profile_hits",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "213-260",
    "snippet": "static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long primary, secondary, flags, pc = (unsigned long)__pc;\n\tint i, j, cpu;\n\tstruct profile_hit *hits;\n\n\tpc = min((pc - (unsigned long)_stext) >> prof_shift, prof_len - 1);\n\ti = primary = (pc & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tsecondary = (~(pc << 1) & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tcpu = get_cpu();\n\thits = per_cpu(cpu_profile_hits, cpu)[per_cpu(cpu_profile_flip, cpu)];\n\tif (!hits) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/*\n\t * We buffer the global profiler buffer into a per-CPU\n\t * queue and thus reduce the number of global (and possibly\n\t * NUMA-alien) accesses. The write-queue is self-coalescing:\n\t */\n\tlocal_irq_save(flags);\n\tdo {\n\t\tfor (j = 0; j < PROFILE_GRPSZ; ++j) {\n\t\t\tif (hits[i + j].pc == pc) {\n\t\t\t\thits[i + j].hits += nr_hits;\n\t\t\t\tgoto out;\n\t\t\t} else if (!hits[i + j].hits) {\n\t\t\t\thits[i + j].pc = pc;\n\t\t\t\thits[i + j].hits = nr_hits;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ti = (i + secondary) & (NR_PROFILE_HIT - 1);\n\t} while (i != primary);\n\n\t/*\n\t * Add the current hit(s) and flush the write-queue out\n\t * to the global buffer:\n\t */\n\tatomic_add(nr_hits, &prof_buffer[pc]);\n\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\thits[i].pc = hits[i].hits = 0;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\tput_cpu();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NR_PROFILE_GRP\t\t(NR_PROFILE_HIT/PROFILE_GRPSZ)",
      "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))",
      "#define PROFILE_GRPSZ\t\t(1 << PROFILE_GRPSHIFT)",
      "#define PROFILE_GRPSHIFT\t3"
    ],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len;",
      "static unsigned short int prof_shift;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "hits[i].hits",
            "&prof_buffer[hits[i].pc]"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "nr_hits",
            "&prof_buffer[pc]"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_flip",
            "cpu"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(pc - (unsigned long)_stext) >> prof_shift",
            "prof_len - 1"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_GRP\t\t(NR_PROFILE_HIT/PROFILE_GRPSZ)\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n#define PROFILE_GRPSZ\t\t(1 << PROFILE_GRPSHIFT)\n#define PROFILE_GRPSHIFT\t3\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len;\nstatic unsigned short int prof_shift;\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long primary, secondary, flags, pc = (unsigned long)__pc;\n\tint i, j, cpu;\n\tstruct profile_hit *hits;\n\n\tpc = min((pc - (unsigned long)_stext) >> prof_shift, prof_len - 1);\n\ti = primary = (pc & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tsecondary = (~(pc << 1) & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tcpu = get_cpu();\n\thits = per_cpu(cpu_profile_hits, cpu)[per_cpu(cpu_profile_flip, cpu)];\n\tif (!hits) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/*\n\t * We buffer the global profiler buffer into a per-CPU\n\t * queue and thus reduce the number of global (and possibly\n\t * NUMA-alien) accesses. The write-queue is self-coalescing:\n\t */\n\tlocal_irq_save(flags);\n\tdo {\n\t\tfor (j = 0; j < PROFILE_GRPSZ; ++j) {\n\t\t\tif (hits[i + j].pc == pc) {\n\t\t\t\thits[i + j].hits += nr_hits;\n\t\t\t\tgoto out;\n\t\t\t} else if (!hits[i + j].hits) {\n\t\t\t\thits[i + j].pc = pc;\n\t\t\t\thits[i + j].hits = nr_hits;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ti = (i + secondary) & (NR_PROFILE_HIT - 1);\n\t} while (i != primary);\n\n\t/*\n\t * Add the current hit(s) and flush the write-queue out\n\t * to the global buffer:\n\t */\n\tatomic_add(nr_hits, &prof_buffer[pc]);\n\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\thits[i].pc = hits[i].hits = 0;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\tput_cpu();\n}"
  },
  {
    "function_name": "profile_discard_flip_buffers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "198-211",
    "snippet": "static void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&profile_flip_mutex"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hits",
            "0",
            "NR_PROFILE_HIT*sizeof(struct profile_hit)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_hits",
            "cpu"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "__profile_flip_buffers",
            "NULL",
            "1"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&profile_flip_mutex"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n\nstatic void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}"
  },
  {
    "function_name": "profile_flip_buffers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "175-196",
    "snippet": "static void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))"
    ],
    "globals_used": [
      "static atomic_t *prof_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&profile_flip_mutex"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "hits[i].hits",
            "&prof_buffer[hits[i].pc]"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_hits",
            "cpu"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "__profile_flip_buffers",
            "NULL",
            "1"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&profile_flip_mutex"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n\nstatic atomic_t *prof_buffer;\n\nstatic void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}"
  },
  {
    "function_name": "__profile_flip_buffers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "168-173",
    "snippet": "static void __profile_flip_buffers(void *unused)\n{\n\tint cpu = smp_processor_id();\n\n\tper_cpu(cpu_profile_flip, cpu) = !per_cpu(cpu_profile_flip, cpu);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_flip",
            "cpu"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic void __profile_flip_buffers(void *unused)\n{\n\tint cpu = smp_processor_id();\n\n\tper_cpu(cpu_profile_flip, cpu) = !per_cpu(cpu_profile_flip, cpu);\n}"
  },
  {
    "function_name": "profile_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "104-134",
    "snippet": "int __ref profile_init(void)\n{\n\tint buffer_bytes;\n\tif (!prof_on)\n\t\treturn 0;\n\n\t/* only text is profiled */\n\tprof_len = (_etext - _stext) >> prof_shift;\n\tbuffer_bytes = prof_len*sizeof(atomic_t);\n\n\tif (!alloc_cpumask_var(&prof_cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(prof_cpu_mask, cpu_possible_mask);\n\n\tprof_buffer = kzalloc(buffer_bytes, GFP_KERNEL|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = alloc_pages_exact(buffer_bytes,\n\t\t\t\t\tGFP_KERNEL|__GFP_ZERO|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = vzalloc(buffer_bytes);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tfree_cpumask_var(prof_cpu_mask);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len;",
      "static unsigned short int prof_shift;",
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "prof_cpu_mask"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "buffer_bytes"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_exact",
          "args": [
            "buffer_bytes",
            "GFP_KERNEL|__GFP_ZERO|__GFP_NOWARN"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "buffer_bytes",
            "GFP_KERNEL|__GFP_NOWARN"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "prof_cpu_mask",
            "cpu_possible_mask"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&prof_cpu_mask",
            "GFP_KERNEL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len;\nstatic unsigned short int prof_shift;\nstatic cpumask_var_t prof_cpu_mask;\n\nint __ref profile_init(void)\n{\n\tint buffer_bytes;\n\tif (!prof_on)\n\t\treturn 0;\n\n\t/* only text is profiled */\n\tprof_len = (_etext - _stext) >> prof_shift;\n\tbuffer_bytes = prof_len*sizeof(atomic_t);\n\n\tif (!alloc_cpumask_var(&prof_cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(prof_cpu_mask, cpu_possible_mask);\n\n\tprof_buffer = kzalloc(buffer_bytes, GFP_KERNEL|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = alloc_pages_exact(buffer_bytes,\n\t\t\t\t\tGFP_KERNEL|__GFP_ZERO|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = vzalloc(buffer_bytes);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tfree_cpumask_var(prof_cpu_mask);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "profile_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
    "lines": "57-100",
    "snippet": "int profile_setup(char *str)\n{\n\tstatic const char schedstr[] = \"schedule\";\n\tstatic const char sleepstr[] = \"sleep\";\n\tstatic const char kvmstr[] = \"kvm\";\n\tint par;\n\n\tif (!strncmp(str, sleepstr, strlen(sleepstr))) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tforce_schedstat_enabled();\n\t\tprof_on = SLEEP_PROFILING;\n\t\tif (str[strlen(sleepstr)] == ',')\n\t\t\tstr += strlen(sleepstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tpr_info(\"kernel sleep profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n#else\n\t\tpr_warn(\"kernel sleep profiling requires CONFIG_SCHEDSTATS\\n\");\n#endif /* CONFIG_SCHEDSTATS */\n\t} else if (!strncmp(str, schedstr, strlen(schedstr))) {\n\t\tprof_on = SCHED_PROFILING;\n\t\tif (str[strlen(schedstr)] == ',')\n\t\t\tstr += strlen(schedstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tpr_info(\"kernel schedule profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n\t} else if (!strncmp(str, kvmstr, strlen(kvmstr))) {\n\t\tprof_on = KVM_PROFILING;\n\t\tif (str[strlen(kvmstr)] == ',')\n\t\t\tstr += strlen(kvmstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tpr_info(\"kernel KVM profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n\t} else if (get_option(&str, &par)) {\n\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tprof_on = CPU_PROFILING;\n\t\tpr_info(\"kernel profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short int prof_shift;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel profiling enabled (shift: %u)\\n\"",
            "prof_shift"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "par",
            "0",
            "BITS_PER_LONG - 1"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4254-4264",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&par"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel KVM profiling enabled (shift: %u)\\n\"",
            "prof_shift"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&par"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kvmstr"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "kvmstr",
            "strlen(kvmstr)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel schedule profiling enabled (shift: %u)\\n\"",
            "prof_shift"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&par"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "schedstr",
            "strlen(schedstr)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"kernel sleep profiling requires CONFIG_SCHEDSTATS\\n\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel sleep profiling enabled (shift: %u)\\n\"",
            "prof_shift"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&par"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_schedstat_enabled",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4325-4331",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "sleepstr",
            "strlen(sleepstr)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic unsigned short int prof_shift;\n\nint profile_setup(char *str)\n{\n\tstatic const char schedstr[] = \"schedule\";\n\tstatic const char sleepstr[] = \"sleep\";\n\tstatic const char kvmstr[] = \"kvm\";\n\tint par;\n\n\tif (!strncmp(str, sleepstr, strlen(sleepstr))) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tforce_schedstat_enabled();\n\t\tprof_on = SLEEP_PROFILING;\n\t\tif (str[strlen(sleepstr)] == ',')\n\t\t\tstr += strlen(sleepstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tpr_info(\"kernel sleep profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n#else\n\t\tpr_warn(\"kernel sleep profiling requires CONFIG_SCHEDSTATS\\n\");\n#endif /* CONFIG_SCHEDSTATS */\n\t} else if (!strncmp(str, schedstr, strlen(schedstr))) {\n\t\tprof_on = SCHED_PROFILING;\n\t\tif (str[strlen(schedstr)] == ',')\n\t\t\tstr += strlen(schedstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tpr_info(\"kernel schedule profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n\t} else if (!strncmp(str, kvmstr, strlen(kvmstr))) {\n\t\tprof_on = KVM_PROFILING;\n\t\tif (str[strlen(kvmstr)] == ',')\n\t\t\tstr += strlen(kvmstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tpr_info(\"kernel KVM profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n\t} else if (get_option(&str, &par)) {\n\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tprof_on = CPU_PROFILING;\n\t\tpr_info(\"kernel profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n\t}\n\treturn 1;\n}"
  }
]