[
  {
    "function_name": "ptracer_capable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "522-534",
    "snippet": "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n{\n\tint ret = 0;  /* An absent tracer adds no restrictions */\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = rcu_dereference(tsk->ptracer_cred);\n\tif (cred)\n\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,\n\t\t\t\t       CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\treturn (ret == 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "cred",
            "ns",
            "CAP_SYS_PTRACE",
            "CAP_OPT_NOAUDIT"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "tsk->ptracer_cred"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n{\n\tint ret = 0;  /* An absent tracer adds no restrictions */\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = rcu_dereference(tsk->ptracer_cred);\n\tif (cred)\n\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,\n\t\t\t\t       CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\treturn (ret == 0);\n}"
  },
  {
    "function_name": "capable_wrt_inode_uidgid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "504-511",
    "snippet": "bool capable_wrt_inode_uidgid(struct user_namespace *mnt_userns,\n\t\t\t      const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) &&\n\t       privileged_wrt_inode_uidgid(ns, mnt_userns, inode);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "privileged_wrt_inode_uidgid",
          "args": [
            "ns",
            "mnt_userns",
            "inode"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "privileged_wrt_inode_uidgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "487-493",
          "snippet": "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,\n\t\t\t\t struct user_namespace *mnt_userns,\n\t\t\t\t const struct inode *inode)\n{\n\treturn kuid_has_mapping(ns, i_uid_into_mnt(mnt_userns, inode)) &&\n\t       kgid_has_mapping(ns, i_gid_into_mnt(mnt_userns, inode));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool privileged_wrt_inode_uidgid(struct user_namespace *ns,\n\t\t\t\t struct user_namespace *mnt_userns,\n\t\t\t\t const struct inode *inode)\n{\n\treturn kuid_has_mapping(ns, i_uid_into_mnt(mnt_userns, inode)) &&\n\t       kgid_has_mapping(ns, i_gid_into_mnt(mnt_userns, inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns",
            "cap"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable_wrt_inode_uidgid(struct user_namespace *mnt_userns,\n\t\t\t      const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) &&\n\t       privileged_wrt_inode_uidgid(ns, mnt_userns, inode);\n}"
  },
  {
    "function_name": "privileged_wrt_inode_uidgid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "487-493",
    "snippet": "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,\n\t\t\t\t struct user_namespace *mnt_userns,\n\t\t\t\t const struct inode *inode)\n{\n\treturn kuid_has_mapping(ns, i_uid_into_mnt(mnt_userns, inode)) &&\n\t       kgid_has_mapping(ns, i_gid_into_mnt(mnt_userns, inode));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgid_has_mapping",
          "args": [
            "ns",
            "i_gid_into_mnt(mnt_userns, inode)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_into_mnt",
          "args": [
            "mnt_userns",
            "inode"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "ns",
            "i_uid_into_mnt(mnt_userns, inode)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_into_mnt",
          "args": [
            "mnt_userns",
            "inode"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool privileged_wrt_inode_uidgid(struct user_namespace *ns,\n\t\t\t\t struct user_namespace *mnt_userns,\n\t\t\t\t const struct inode *inode)\n{\n\treturn kuid_has_mapping(ns, i_uid_into_mnt(mnt_userns, inode)) &&\n\t       kgid_has_mapping(ns, i_gid_into_mnt(mnt_userns, inode));\n}"
  },
  {
    "function_name": "file_ns_capable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "466-477",
    "snippet": "bool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "file->f_cred",
            "ns",
            "cap",
            "CAP_OPT_NONE"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cap_valid(cap)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "cap"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "capable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "447-450",
    "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "&init_user_ns",
            "cap"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
  },
  {
    "function_name": "ns_capable_setid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "431-434",
    "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable_common",
          "args": [
            "ns",
            "cap",
            "CAP_OPT_INSETID"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "364-381",
          "snippet": "static bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
  },
  {
    "function_name": "ns_capable_noaudit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "412-415",
    "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable_common",
          "args": [
            "ns",
            "cap",
            "CAP_OPT_NOAUDIT"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "364-381",
          "snippet": "static bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);\n}"
  },
  {
    "function_name": "ns_capable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "394-397",
    "snippet": "bool ns_capable(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable_common",
          "args": [
            "ns",
            "cap",
            "CAP_OPT_NONE"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "364-381",
          "snippet": "static bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);\n}"
  },
  {
    "function_name": "ns_capable_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "364-381",
    "snippet": "static bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "current_cred()",
            "ns",
            "cap",
            "opts"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"capable() called with invalid cap=%u\\n\"",
            "cap"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cap_valid(cap)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "cap"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "has_capability_noaudit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "359-362",
    "snippet": "bool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_ns_capability_noaudit",
          "args": [
            "t",
            "&init_user_ns",
            "cap"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "has_ns_capability_noaudit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "335-345",
          "snippet": "bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}"
  },
  {
    "function_name": "has_ns_capability_noaudit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "335-345",
    "snippet": "bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "__task_cred(t)",
            "ns",
            "cap",
            "CAP_OPT_NOAUDIT"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "t"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
  },
  {
    "function_name": "has_capability",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "316-319",
    "snippet": "bool has_capability(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability(t, &init_user_ns, cap);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_ns_capability",
          "args": [
            "t",
            "&init_user_ns",
            "cap"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "has_ns_capability_noaudit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "335-345",
          "snippet": "bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_capability(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability(t, &init_user_ns, cap);\n}"
  },
  {
    "function_name": "has_ns_capability",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "294-304",
    "snippet": "bool has_ns_capability(struct task_struct *t,\n\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "__task_cred(t)",
            "ns",
            "cap",
            "CAP_OPT_NONE"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "t"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability(struct task_struct *t,\n\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
  },
  {
    "function_name": "cap_get_target_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "116-137",
    "snippet": "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,\n\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)\n{\n\tint ret;\n\n\tif (pid && (pid != task_pid_vnr(current))) {\n\t\tstruct task_struct *target;\n\n\t\trcu_read_lock();\n\n\t\ttarget = find_task_by_vpid(pid);\n\t\tif (!target)\n\t\t\tret = -ESRCH;\n\t\telse\n\t\t\tret = security_capget(target, pEp, pIp, pPp);\n\n\t\trcu_read_unlock();\n\t} else\n\t\tret = security_capget(current, pEp, pIp, pPp);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_capget",
          "args": [
            "current",
            "pEp",
            "pIp",
            "pPp"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_capget",
          "args": [
            "target",
            "pEp",
            "pIp",
            "pPp"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "420-423",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,\n\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)\n{\n\tint ret;\n\n\tif (pid && (pid != task_pid_vnr(current))) {\n\t\tstruct task_struct *target;\n\n\t\trcu_read_lock();\n\n\t\ttarget = find_task_by_vpid(pid);\n\t\tif (!target)\n\t\t\tret = -ESRCH;\n\t\telse\n\t\t\tret = security_capget(target, pEp, pIp, pPp);\n\n\t\trcu_read_unlock();\n\t} else\n\t\tret = security_capget(current, pEp, pIp, pPp);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cap_validate_magic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "82-107",
    "snippet": "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)\n{\n\t__u32 version;\n\n\tif (get_user(version, &header->version))\n\t\treturn -EFAULT;\n\n\tswitch (version) {\n\tcase _LINUX_CAPABILITY_VERSION_1:\n\t\twarn_legacy_capability_use();\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;\n\t\tbreak;\n\tcase _LINUX_CAPABILITY_VERSION_2:\n\t\twarn_deprecated_v2();\n\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */\n\tcase _LINUX_CAPABILITY_VERSION_3:\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;\n\t\tbreak;\n\tdefault:\n\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))\n\t\t\treturn -EFAULT;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(u32)_KERNEL_CAPABILITY_VERSION",
            "&header->version"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_deprecated_v2",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "warn_deprecated_v2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "70-76",
          "snippet": "static void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_legacy_capability_use",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "warn_legacy_capability_use",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "46-52",
          "snippet": "static void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "version",
            "&header->version"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)\n{\n\t__u32 version;\n\n\tif (get_user(version, &header->version))\n\t\treturn -EFAULT;\n\n\tswitch (version) {\n\tcase _LINUX_CAPABILITY_VERSION_1:\n\t\twarn_legacy_capability_use();\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;\n\t\tbreak;\n\tcase _LINUX_CAPABILITY_VERSION_2:\n\t\twarn_deprecated_v2();\n\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */\n\tcase _LINUX_CAPABILITY_VERSION_3:\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;\n\t\tbreak;\n\tdefault:\n\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))\n\t\t\treturn -EFAULT;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "warn_deprecated_v2",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "70-76",
    "snippet": "static void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info_once",
          "args": [
            "\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\"",
            "get_task_comm(name, current)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "name",
            "current"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}"
  },
  {
    "function_name": "warn_legacy_capability_use",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "46-52",
    "snippet": "static void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info_once",
          "args": [
            "\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\"",
            "get_task_comm(name, current)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "name",
            "current"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}"
  },
  {
    "function_name": "file_caps_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "32-36",
    "snippet": "static int __init file_caps_disable(char *str)\n{\n\tfile_caps_enabled = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int file_caps_enabled = 1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nint file_caps_enabled = 1;\n\nstatic int __init file_caps_disable(char *str)\n{\n\tfile_caps_enabled = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "capget",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "148-202",
    "snippet": "SYSCALL_DEFINE2(capget, cap_user_header_t, header, cap_user_data_t, dataptr)\n{\n\tint ret = 0;\n\tpid_t pid;\n\tunsigned tocopy;\n\tkernel_cap_t pE, pI, pP;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif ((dataptr == NULL) || (ret != 0))\n\t\treturn ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tret = cap_get_target_pid(pid, &pE, &pI, &pP);\n\tif (!ret) {\n\t\tstruct __user_cap_data_struct kdata[_KERNEL_CAPABILITY_U32S];\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < tocopy; i++) {\n\t\t\tkdata[i].effective = pE.cap[i];\n\t\t\tkdata[i].permitted = pP.cap[i];\n\t\t\tkdata[i].inheritable = pI.cap[i];\n\t\t}\n\n\t\t/*\n\t\t * Note, in the case, tocopy < _KERNEL_CAPABILITY_U32S,\n\t\t * we silently drop the upper capabilities here. This\n\t\t * has the effect of making older libcap\n\t\t * implementations implicitly drop upper capability\n\t\t * bits when they perform a: capget/modify/capset\n\t\t * sequence.\n\t\t *\n\t\t * This behavior is considered fail-safe\n\t\t * behavior. Upgrading the application to a newer\n\t\t * version of libcap will enable access to the newer\n\t\t * capabilities.\n\t\t *\n\t\t * An alternative would be to return an error here\n\t\t * (-ERANGE), but that causes legacy applications to\n\t\t * unexpectedly fail; the capget/modify/capset aborts\n\t\t * before modification is attempted and the application\n\t\t * fails.\n\t\t */\n\t\tif (copy_to_user(dataptr, kdata, tocopy\n\t\t\t\t * sizeof(struct __user_cap_data_struct))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nSYSCALL_DEFINE2(capget, cap_user_header_t, header, cap_user_data_t, dataptr)\n{\n\tint ret = 0;\n\tpid_t pid;\n\tunsigned tocopy;\n\tkernel_cap_t pE, pI, pP;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif ((dataptr == NULL) || (ret != 0))\n\t\treturn ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tret = cap_get_target_pid(pid, &pE, &pI, &pP);\n\tif (!ret) {\n\t\tstruct __user_cap_data_struct kdata[_KERNEL_CAPABILITY_U32S];\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < tocopy; i++) {\n\t\t\tkdata[i].effective = pE.cap[i];\n\t\t\tkdata[i].permitted = pP.cap[i];\n\t\t\tkdata[i].inheritable = pI.cap[i];\n\t\t}\n\n\t\t/*\n\t\t * Note, in the case, tocopy < _KERNEL_CAPABILITY_U32S,\n\t\t * we silently drop the upper capabilities here. This\n\t\t * has the effect of making older libcap\n\t\t * implementations implicitly drop upper capability\n\t\t * bits when they perform a: capget/modify/capset\n\t\t * sequence.\n\t\t *\n\t\t * This behavior is considered fail-safe\n\t\t * behavior. Upgrading the application to a newer\n\t\t * version of libcap will enable access to the newer\n\t\t * capabilities.\n\t\t *\n\t\t * An alternative would be to return an error here\n\t\t * (-ERANGE), but that causes legacy applications to\n\t\t * unexpectedly fail; the capget/modify/capset aborts\n\t\t * before modification is attempted and the application\n\t\t * fails.\n\t\t */\n\t\tif (copy_to_user(dataptr, kdata, tocopy\n\t\t\t\t * sizeof(struct __user_cap_data_struct))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "capset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
    "lines": "222-281",
    "snippet": "SYSCALL_DEFINE2(capset, cap_user_header_t, header, const cap_user_data_t, data)\n{\n\tstruct __user_cap_data_struct kdata[_KERNEL_CAPABILITY_U32S];\n\tunsigned i, tocopy, copybytes;\n\tkernel_cap_t inheritable, permitted, effective;\n\tstruct cred *new;\n\tint ret;\n\tpid_t pid;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\t/* may only affect current now */\n\tif (pid != 0 && pid != task_pid_vnr(current))\n\t\treturn -EPERM;\n\n\tcopybytes = tocopy * sizeof(struct __user_cap_data_struct);\n\tif (copybytes > sizeof(kdata))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&kdata, data, copybytes))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < tocopy; i++) {\n\t\teffective.cap[i] = kdata[i].effective;\n\t\tpermitted.cap[i] = kdata[i].permitted;\n\t\tinheritable.cap[i] = kdata[i].inheritable;\n\t}\n\twhile (i < _KERNEL_CAPABILITY_U32S) {\n\t\teffective.cap[i] = 0;\n\t\tpermitted.cap[i] = 0;\n\t\tinheritable.cap[i] = 0;\n\t\ti++;\n\t}\n\n\teffective.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tpermitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tinheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = security_capset(new, current_cred(),\n\t\t\t      &effective, &inheritable, &permitted);\n\tif (ret < 0)\n\t\tgoto error;\n\n\taudit_log_capset(new, current_cred());\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nSYSCALL_DEFINE2(capset, cap_user_header_t, header, const cap_user_data_t, data)\n{\n\tstruct __user_cap_data_struct kdata[_KERNEL_CAPABILITY_U32S];\n\tunsigned i, tocopy, copybytes;\n\tkernel_cap_t inheritable, permitted, effective;\n\tstruct cred *new;\n\tint ret;\n\tpid_t pid;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\t/* may only affect current now */\n\tif (pid != 0 && pid != task_pid_vnr(current))\n\t\treturn -EPERM;\n\n\tcopybytes = tocopy * sizeof(struct __user_cap_data_struct);\n\tif (copybytes > sizeof(kdata))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&kdata, data, copybytes))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < tocopy; i++) {\n\t\teffective.cap[i] = kdata[i].effective;\n\t\tpermitted.cap[i] = kdata[i].permitted;\n\t\tinheritable.cap[i] = kdata[i].inheritable;\n\t}\n\twhile (i < _KERNEL_CAPABILITY_U32S) {\n\t\teffective.cap[i] = 0;\n\t\tpermitted.cap[i] = 0;\n\t\tinheritable.cap[i] = 0;\n\t\ti++;\n\t}\n\n\teffective.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tpermitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tinheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = security_capset(new, current_cred(),\n\t\t\t      &effective, &inheritable, &permitted);\n\tif (ret < 0)\n\t\tgoto error;\n\n\taudit_log_capset(new, current_cred());\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn ret;\n}"
  }
]