[
  {
    "function_name": "init_hwlat_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "874-889",
    "snippet": "__init static int init_hwlat_tracer(void)\n{\n\tint ret;\n\n\tmutex_init(&hwlat_data.lock);\n\n\tret = register_tracer(&hwlat_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\thwlat_init_hotplug_support();\n\n\tinit_tracefs();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_tracefs",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "init_tracefs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "768-807",
          "snippet": "static int init_tracefs(void)\n{\n\tint ret;\n\tstruct dentry *top_dir;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"hwlat_detector\", NULL);\n\tif (!top_dir)\n\t\treturn -ENOMEM;\n\n\thwlat_sample_window = tracefs_create_file(\"window\", TRACE_MODE_WRITE,\n\t\t\t\t\t\t  top_dir,\n\t\t\t\t\t\t  &hwlat_window,\n\t\t\t\t\t\t  &trace_min_max_fops);\n\tif (!hwlat_sample_window)\n\t\tgoto err;\n\n\thwlat_sample_width = tracefs_create_file(\"width\", TRACE_MODE_WRITE,\n\t\t\t\t\t\t top_dir,\n\t\t\t\t\t\t &hwlat_width,\n\t\t\t\t\t\t &trace_min_max_fops);\n\tif (!hwlat_sample_width)\n\t\tgoto err;\n\n\thwlat_thread_mode = trace_create_file(\"mode\", TRACE_MODE_WRITE,\n\t\t\t\t\t      top_dir,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      &thread_mode_fops);\n\tif (!hwlat_thread_mode)\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *hwlat_sample_width;",
            "static struct dentry *hwlat_sample_window;",
            "static struct dentry *hwlat_thread_mode;",
            "static struct trace_min_max_param hwlat_width = {\n\t.lock\t\t= &hwlat_data.lock,\n\t.val\t\t= &hwlat_data.sample_width,\n\t.max\t\t= &hwlat_data.sample_window,\n\t.min\t\t= NULL,\n};",
            "static struct trace_min_max_param hwlat_window = {\n\t.lock\t\t= &hwlat_data.lock,\n\t.val\t\t= &hwlat_data.sample_window,\n\t.max\t\t= NULL,\n\t.min\t\t= &hwlat_data.sample_width,\n};",
            "static const struct file_operations thread_mode_fops = {\n\t.open\t\t= hwlat_mode_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= hwlat_mode_write\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct dentry *hwlat_sample_width;\nstatic struct dentry *hwlat_sample_window;\nstatic struct dentry *hwlat_thread_mode;\nstatic struct trace_min_max_param hwlat_width = {\n\t.lock\t\t= &hwlat_data.lock,\n\t.val\t\t= &hwlat_data.sample_width,\n\t.max\t\t= &hwlat_data.sample_window,\n\t.min\t\t= NULL,\n};\nstatic struct trace_min_max_param hwlat_window = {\n\t.lock\t\t= &hwlat_data.lock,\n\t.val\t\t= &hwlat_data.sample_window,\n\t.max\t\t= NULL,\n\t.min\t\t= &hwlat_data.sample_width,\n};\nstatic const struct file_operations thread_mode_fops = {\n\t.open\t\t= hwlat_mode_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= hwlat_mode_write\n};\n\nstatic int init_tracefs(void)\n{\n\tint ret;\n\tstruct dentry *top_dir;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"hwlat_detector\", NULL);\n\tif (!top_dir)\n\t\treturn -ENOMEM;\n\n\thwlat_sample_window = tracefs_create_file(\"window\", TRACE_MODE_WRITE,\n\t\t\t\t\t\t  top_dir,\n\t\t\t\t\t\t  &hwlat_window,\n\t\t\t\t\t\t  &trace_min_max_fops);\n\tif (!hwlat_sample_window)\n\t\tgoto err;\n\n\thwlat_sample_width = tracefs_create_file(\"width\", TRACE_MODE_WRITE,\n\t\t\t\t\t\t top_dir,\n\t\t\t\t\t\t &hwlat_width,\n\t\t\t\t\t\t &trace_min_max_fops);\n\tif (!hwlat_sample_width)\n\t\tgoto err;\n\n\thwlat_thread_mode = trace_create_file(\"mode\", TRACE_MODE_WRITE,\n\t\t\t\t\t      top_dir,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      &thread_mode_fops);\n\tif (!hwlat_thread_mode)\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwlat_init_hotplug_support",
          "args": [],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "hwlat_init_hotplug_support",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "562-565",
          "snippet": "static void hwlat_init_hotplug_support(void)\n{\n\treturn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void hwlat_init_hotplug_support(void)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&hwlat_tracer"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&hwlat_data.lock"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\n__init static int init_hwlat_tracer(void)\n{\n\tint ret;\n\n\tmutex_init(&hwlat_data.lock);\n\n\tret = register_tracer(&hwlat_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\thwlat_init_hotplug_support();\n\n\tinit_tracefs();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hwlat_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "853-862",
    "snippet": "static void hwlat_tracer_reset(struct trace_array *tr)\n{\n\thwlat_tracer_stop(tr);\n\n\t/* the tracing threshold is static between runs */\n\tlast_tracing_thresh = tracing_thresh;\n\n\ttracing_thresh = save_tracing_thresh;\n\thwlat_busy = false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long save_tracing_thresh;",
      "static u64 last_tracing_thresh = DEFAULT_LAT_THRESHOLD * NSEC_PER_USEC;",
      "static bool hwlat_busy;",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hwlat_tracer_stop",
          "args": [
            "tr"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "hwlat_tracer_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "821-827",
          "snippet": "static void hwlat_tracer_stop(struct trace_array *tr)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\tstop_per_cpu_kthreads();\n\telse\n\t\tstop_single_kthread();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void hwlat_tracer_stop(struct trace_array *tr)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\tstop_per_cpu_kthreads();\n\telse\n\t\tstop_single_kthread();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic unsigned long save_tracing_thresh;\nstatic u64 last_tracing_thresh = DEFAULT_LAT_THRESHOLD * NSEC_PER_USEC;\nstatic bool hwlat_busy;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void hwlat_tracer_reset(struct trace_array *tr)\n{\n\thwlat_tracer_stop(tr);\n\n\t/* the tracing threshold is static between runs */\n\tlast_tracing_thresh = tracing_thresh;\n\n\ttracing_thresh = save_tracing_thresh;\n\thwlat_busy = false;\n}"
  },
  {
    "function_name": "hwlat_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "829-851",
    "snippet": "static int hwlat_tracer_init(struct trace_array *tr)\n{\n\t/* Only allow one instance to enable this */\n\tif (hwlat_busy)\n\t\treturn -EBUSY;\n\n\thwlat_trace = tr;\n\n\thwlat_data.count = 0;\n\ttr->max_latency = 0;\n\tsave_tracing_thresh = tracing_thresh;\n\n\t/* tracing_thresh is in nsecs, we speak in usecs */\n\tif (!tracing_thresh)\n\t\ttracing_thresh = last_tracing_thresh;\n\n\tif (tracer_tracing_is_on(tr))\n\t\thwlat_tracer_start(tr);\n\n\thwlat_busy = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*hwlat_trace;",
      "static unsigned long save_tracing_thresh;",
      "static u64 last_tracing_thresh = DEFAULT_LAT_THRESHOLD * NSEC_PER_USEC;",
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
      "static bool hwlat_busy;",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hwlat_tracer_start",
          "args": [
            "tr"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "hwlat_tracer_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "809-819",
          "snippet": "static void hwlat_tracer_start(struct trace_array *tr)\n{\n\tint err;\n\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\terr = start_per_cpu_kthreads(tr);\n\telse\n\t\terr = start_single_kthread(tr);\n\tif (err)\n\t\tpr_err(BANNER \"Cannot start hwlat kthread\\n\");\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"hwlat_detector: \""
          ],
          "globals_used": [
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void hwlat_tracer_start(struct trace_array *tr)\n{\n\tint err;\n\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\terr = start_per_cpu_kthreads(tr);\n\telse\n\t\terr = start_single_kthread(tr);\n\tif (err)\n\t\tpr_err(BANNER \"Cannot start hwlat kthread\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_is_on",
          "args": [
            "tr"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1450-1455",
          "snippet": "bool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct trace_array\t*hwlat_trace;\nstatic unsigned long save_tracing_thresh;\nstatic u64 last_tracing_thresh = DEFAULT_LAT_THRESHOLD * NSEC_PER_USEC;\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic bool hwlat_busy;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic int hwlat_tracer_init(struct trace_array *tr)\n{\n\t/* Only allow one instance to enable this */\n\tif (hwlat_busy)\n\t\treturn -EBUSY;\n\n\thwlat_trace = tr;\n\n\thwlat_data.count = 0;\n\ttr->max_latency = 0;\n\tsave_tracing_thresh = tracing_thresh;\n\n\t/* tracing_thresh is in nsecs, we speak in usecs */\n\tif (!tracing_thresh)\n\t\ttracing_thresh = last_tracing_thresh;\n\n\tif (tracer_tracing_is_on(tr))\n\t\thwlat_tracer_start(tr);\n\n\thwlat_busy = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hwlat_tracer_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "821-827",
    "snippet": "static void hwlat_tracer_stop(struct trace_array *tr)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\tstop_per_cpu_kthreads();\n\telse\n\t\tstop_single_kthread();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_single_kthread",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "stop_single_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "396-412",
          "snippet": "static void stop_single_kthread(void)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct task_struct *kthread;\n\n\tcpus_read_lock();\n\tkthread = kdata->kthread;\n\n\tif (!kthread)\n\t\tgoto out_put_cpus;\n\n\tkthread_stop(kthread);\n\tkdata->kthread = NULL;\n\nout_put_cpus:\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_single_kthread(void)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct task_struct *kthread;\n\n\tcpus_read_lock();\n\tkthread = kdata->kthread;\n\n\tif (!kthread)\n\t\tgoto out_put_cpus;\n\n\tkthread_stop(kthread);\n\tkdata->kthread = NULL;\n\nout_put_cpus:\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_per_cpu_kthreads",
          "args": [],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "stop_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "478-486",
          "snippet": "static void stop_per_cpu_kthreads(void)\n{\n\tunsigned int cpu;\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu)\n\t\tstop_cpu_kthread(cpu);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_per_cpu_kthreads(void)\n{\n\tunsigned int cpu;\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu)\n\t\tstop_cpu_kthread(cpu);\n\tcpus_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void hwlat_tracer_stop(struct trace_array *tr)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\tstop_per_cpu_kthreads();\n\telse\n\t\tstop_single_kthread();\n}"
  },
  {
    "function_name": "hwlat_tracer_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "809-819",
    "snippet": "static void hwlat_tracer_start(struct trace_array *tr)\n{\n\tint err;\n\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\terr = start_per_cpu_kthreads(tr);\n\telse\n\t\terr = start_single_kthread(tr);\n\tif (err)\n\t\tpr_err(BANNER \"Cannot start hwlat kthread\\n\");\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"hwlat_detector: \""
    ],
    "globals_used": [
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "BANNER \"Cannot start hwlat kthread\\n\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_single_kthread",
          "args": [
            "tr"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "start_single_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "421-457",
          "snippet": "static int start_single_kthread(struct trace_array *tr)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct cpumask *current_mask = &save_cpumask;\n\tstruct task_struct *kthread;\n\tint next_cpu;\n\n\tcpus_read_lock();\n\tif (kdata->kthread)\n\t\tgoto out_put_cpus;\n\n\tkthread = kthread_create(kthread_fn, NULL, \"hwlatd\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tcpus_read_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Just pick the first CPU on first iteration */\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\n\tif (hwlat_data.thread_mode == MODE_ROUND_ROBIN) {\n\t\tnext_cpu = cpumask_first(current_mask);\n\t\tcpumask_clear(current_mask);\n\t\tcpumask_set_cpu(next_cpu, current_mask);\n\n\t}\n\n\tsched_setaffinity(kthread->pid, current_mask);\n\n\tkdata->kthread = kthread;\n\twake_up_process(kthread);\n\nout_put_cpus:\n\tcpus_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"hwlat_detector: \""
          ],
          "globals_used": [
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
            "static struct cpumask save_cpumask;",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic struct cpumask save_cpumask;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic int start_single_kthread(struct trace_array *tr)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct cpumask *current_mask = &save_cpumask;\n\tstruct task_struct *kthread;\n\tint next_cpu;\n\n\tcpus_read_lock();\n\tif (kdata->kthread)\n\t\tgoto out_put_cpus;\n\n\tkthread = kthread_create(kthread_fn, NULL, \"hwlatd\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tcpus_read_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Just pick the first CPU on first iteration */\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\n\tif (hwlat_data.thread_mode == MODE_ROUND_ROBIN) {\n\t\tnext_cpu = cpumask_first(current_mask);\n\t\tcpumask_clear(current_mask);\n\t\tcpumask_set_cpu(next_cpu, current_mask);\n\n\t}\n\n\tsched_setaffinity(kthread->pid, current_mask);\n\n\tkdata->kthread = kthread;\n\twake_up_process(kthread);\n\nout_put_cpus:\n\tcpus_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_per_cpu_kthreads",
          "args": [
            "tr"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "start_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "575-603",
          "snippet": "static int start_per_cpu_kthreads(struct trace_array *tr)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tunsigned int cpu;\n\tint retval;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on CPUs in which hwlat is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu(hwlat_per_cpu_data, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_cpu_kthread(cpu);\n\t\tif (retval)\n\t\t\tgoto out_error;\n\t}\n\tcpus_read_unlock();\n\n\treturn 0;\n\nout_error:\n\tcpus_read_unlock();\n\tstop_per_cpu_kthreads();\n\treturn retval;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct cpumask save_cpumask;",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct cpumask save_cpumask;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic int start_per_cpu_kthreads(struct trace_array *tr)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tunsigned int cpu;\n\tint retval;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on CPUs in which hwlat is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu(hwlat_per_cpu_data, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_cpu_kthread(cpu);\n\t\tif (retval)\n\t\t\tgoto out_error;\n\t}\n\tcpus_read_unlock();\n\n\treturn 0;\n\nout_error:\n\tcpus_read_unlock();\n\tstop_per_cpu_kthreads();\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void hwlat_tracer_start(struct trace_array *tr)\n{\n\tint err;\n\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\terr = start_per_cpu_kthreads(tr);\n\telse\n\t\terr = start_single_kthread(tr);\n\tif (err)\n\t\tpr_err(BANNER \"Cannot start hwlat kthread\\n\");\n}"
  },
  {
    "function_name": "init_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "768-807",
    "snippet": "static int init_tracefs(void)\n{\n\tint ret;\n\tstruct dentry *top_dir;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"hwlat_detector\", NULL);\n\tif (!top_dir)\n\t\treturn -ENOMEM;\n\n\thwlat_sample_window = tracefs_create_file(\"window\", TRACE_MODE_WRITE,\n\t\t\t\t\t\t  top_dir,\n\t\t\t\t\t\t  &hwlat_window,\n\t\t\t\t\t\t  &trace_min_max_fops);\n\tif (!hwlat_sample_window)\n\t\tgoto err;\n\n\thwlat_sample_width = tracefs_create_file(\"width\", TRACE_MODE_WRITE,\n\t\t\t\t\t\t top_dir,\n\t\t\t\t\t\t &hwlat_width,\n\t\t\t\t\t\t &trace_min_max_fops);\n\tif (!hwlat_sample_width)\n\t\tgoto err;\n\n\thwlat_thread_mode = trace_create_file(\"mode\", TRACE_MODE_WRITE,\n\t\t\t\t\t      top_dir,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      &thread_mode_fops);\n\tif (!hwlat_thread_mode)\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *hwlat_sample_width;",
      "static struct dentry *hwlat_sample_window;",
      "static struct dentry *hwlat_thread_mode;",
      "static struct trace_min_max_param hwlat_width = {\n\t.lock\t\t= &hwlat_data.lock,\n\t.val\t\t= &hwlat_data.sample_width,\n\t.max\t\t= &hwlat_data.sample_window,\n\t.min\t\t= NULL,\n};",
      "static struct trace_min_max_param hwlat_window = {\n\t.lock\t\t= &hwlat_data.lock,\n\t.val\t\t= &hwlat_data.sample_window,\n\t.max\t\t= NULL,\n\t.min\t\t= &hwlat_data.sample_width,\n};",
      "static const struct file_operations thread_mode_fops = {\n\t.open\t\t= hwlat_mode_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= hwlat_mode_write\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracefs_remove",
          "args": [
            "top_dir"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"mode\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "NULL",
            "&thread_mode_fops"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"width\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "&hwlat_width",
            "&trace_min_max_fops"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"window\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "&hwlat_window",
            "&trace_min_max_fops"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "\"hwlat_detector\"",
            "NULL"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct dentry *hwlat_sample_width;\nstatic struct dentry *hwlat_sample_window;\nstatic struct dentry *hwlat_thread_mode;\nstatic struct trace_min_max_param hwlat_width = {\n\t.lock\t\t= &hwlat_data.lock,\n\t.val\t\t= &hwlat_data.sample_width,\n\t.max\t\t= &hwlat_data.sample_window,\n\t.min\t\t= NULL,\n};\nstatic struct trace_min_max_param hwlat_window = {\n\t.lock\t\t= &hwlat_data.lock,\n\t.val\t\t= &hwlat_data.sample_window,\n\t.max\t\t= NULL,\n\t.min\t\t= &hwlat_data.sample_width,\n};\nstatic const struct file_operations thread_mode_fops = {\n\t.open\t\t= hwlat_mode_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= hwlat_mode_write\n};\n\nstatic int init_tracefs(void)\n{\n\tint ret;\n\tstruct dentry *top_dir;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"hwlat_detector\", NULL);\n\tif (!top_dir)\n\t\treturn -ENOMEM;\n\n\thwlat_sample_window = tracefs_create_file(\"window\", TRACE_MODE_WRITE,\n\t\t\t\t\t\t  top_dir,\n\t\t\t\t\t\t  &hwlat_window,\n\t\t\t\t\t\t  &trace_min_max_fops);\n\tif (!hwlat_sample_window)\n\t\tgoto err;\n\n\thwlat_sample_width = tracefs_create_file(\"width\", TRACE_MODE_WRITE,\n\t\t\t\t\t\t top_dir,\n\t\t\t\t\t\t &hwlat_width,\n\t\t\t\t\t\t &trace_min_max_fops);\n\tif (!hwlat_sample_width)\n\t\tgoto err;\n\n\thwlat_thread_mode = trace_create_file(\"mode\", TRACE_MODE_WRITE,\n\t\t\t\t\t      top_dir,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      &thread_mode_fops);\n\tif (!hwlat_thread_mode)\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "hwlat_mode_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "679-727",
    "snippet": "static ssize_t hwlat_mode_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = hwlat_trace;\n\tconst char *mode;\n\tchar buf[64];\n\tint ret, i;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\tmode = strstrip(buf);\n\n\tret = -EINVAL;\n\n\t/*\n\t * trace_types_lock is taken to avoid concurrency on start/stop\n\t * and hwlat_busy.\n\t */\n\tmutex_lock(&trace_types_lock);\n\tif (hwlat_busy)\n\t\thwlat_tracer_stop(tr);\n\n\tmutex_lock(&hwlat_data.lock);\n\n\tfor (i = 0; i < MODE_MAX; i++) {\n\t\tif (strcmp(mode, thread_mode_str[i]) == 0) {\n\t\t\thwlat_data.thread_mode = i;\n\t\t\tret = cnt;\n\t\t}\n\t}\n\n\tmutex_unlock(&hwlat_data.lock);\n\n\tif (hwlat_busy)\n\t\thwlat_tracer_start(tr);\n\tmutex_unlock(&trace_types_lock);\n\n\t*ppos += cnt;\n\n\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*hwlat_trace;",
      "static char *thread_mode_str[] = { \"none\", \"round-robin\", \"per-cpu\" };",
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
      "static bool hwlat_busy;",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwlat_tracer_start",
          "args": [
            "tr"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "hwlat_tracer_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "809-819",
          "snippet": "static void hwlat_tracer_start(struct trace_array *tr)\n{\n\tint err;\n\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\terr = start_per_cpu_kthreads(tr);\n\telse\n\t\terr = start_single_kthread(tr);\n\tif (err)\n\t\tpr_err(BANNER \"Cannot start hwlat kthread\\n\");\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"hwlat_detector: \""
          ],
          "globals_used": [
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void hwlat_tracer_start(struct trace_array *tr)\n{\n\tint err;\n\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\terr = start_per_cpu_kthreads(tr);\n\telse\n\t\terr = start_single_kthread(tr);\n\tif (err)\n\t\tpr_err(BANNER \"Cannot start hwlat kthread\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "thread_mode_str[i]"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hwlat_data.lock"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwlat_tracer_stop",
          "args": [
            "tr"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "hwlat_tracer_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "821-827",
          "snippet": "static void hwlat_tracer_stop(struct trace_array *tr)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\tstop_per_cpu_kthreads();\n\telse\n\t\tstop_single_kthread();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void hwlat_tracer_stop(struct trace_array *tr)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\tstop_per_cpu_kthreads();\n\telse\n\t\tstop_single_kthread();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "ubuf",
            "cnt"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct trace_array\t*hwlat_trace;\nstatic char *thread_mode_str[] = { \"none\", \"round-robin\", \"per-cpu\" };\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic bool hwlat_busy;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic ssize_t hwlat_mode_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = hwlat_trace;\n\tconst char *mode;\n\tchar buf[64];\n\tint ret, i;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\tmode = strstrip(buf);\n\n\tret = -EINVAL;\n\n\t/*\n\t * trace_types_lock is taken to avoid concurrency on start/stop\n\t * and hwlat_busy.\n\t */\n\tmutex_lock(&trace_types_lock);\n\tif (hwlat_busy)\n\t\thwlat_tracer_stop(tr);\n\n\tmutex_lock(&hwlat_data.lock);\n\n\tfor (i = 0; i < MODE_MAX; i++) {\n\t\tif (strcmp(mode, thread_mode_str[i]) == 0) {\n\t\t\thwlat_data.thread_mode = i;\n\t\t\tret = cnt;\n\t\t}\n\t}\n\n\tmutex_unlock(&hwlat_data.lock);\n\n\tif (hwlat_busy)\n\t\thwlat_tracer_start(tr);\n\tmutex_unlock(&trace_types_lock);\n\n\t*ppos += cnt;\n\n\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hwlat_mode_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "656-659",
    "snippet": "static int hwlat_mode_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &thread_mode_seq_ops);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations thread_mode_seq_ops = {\n\t.start\t\t= s_mode_start,\n\t.next\t\t= s_mode_next,\n\t.show\t\t= s_mode_show,\n\t.stop\t\t= s_mode_stop\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&thread_mode_seq_ops"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic const struct seq_operations thread_mode_seq_ops = {\n\t.start\t\t= s_mode_start,\n\t.next\t\t= s_mode_next,\n\t.show\t\t= s_mode_show,\n\t.stop\t\t= s_mode_stop\n};\n\nstatic int hwlat_mode_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &thread_mode_seq_ops);\n}"
  },
  {
    "function_name": "s_mode_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "643-647",
    "snippet": "static void s_mode_stop(struct seq_file *s, void *v)\n{\n\tseq_puts(s, \"\\n\");\n\tmutex_unlock(&hwlat_data.lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hwlat_data.lock"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"\\n\""
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic void s_mode_stop(struct seq_file *s, void *v)\n{\n\tseq_puts(s, \"\\n\");\n\tmutex_unlock(&hwlat_data.lock);\n}"
  },
  {
    "function_name": "s_mode_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "627-641",
    "snippet": "static int s_mode_show(struct seq_file *s, void *v)\n{\n\tloff_t *pos = v;\n\tint mode = *pos;\n\n\tif (mode == hwlat_data.thread_mode)\n\t\tseq_printf(s, \"[%s]\", thread_mode_str[mode]);\n\telse\n\t\tseq_printf(s, \"%s\", thread_mode_str[mode]);\n\n\tif (mode != MODE_MAX)\n\t\tseq_puts(s, \" \");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *thread_mode_str[] = { \"none\", \"round-robin\", \"per-cpu\" };",
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\" \""
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%s\"",
            "thread_mode_str[mode]"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic char *thread_mode_str[] = { \"none\", \"round-robin\", \"per-cpu\" };\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic int s_mode_show(struct seq_file *s, void *v)\n{\n\tloff_t *pos = v;\n\tint mode = *pos;\n\n\tif (mode == hwlat_data.thread_mode)\n\t\tseq_printf(s, \"[%s]\", thread_mode_str[mode]);\n\telse\n\t\tseq_printf(s, \"%s\", thread_mode_str[mode]);\n\n\tif (mode != MODE_MAX)\n\t\tseq_puts(s, \" \");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "s_mode_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "617-625",
    "snippet": "static void *s_mode_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tint mode = ++(*pos);\n\n\tif (mode >= MODE_MAX)\n\t\treturn NULL;\n\n\treturn pos;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void *s_mode_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tint mode = ++(*pos);\n\n\tif (mode >= MODE_MAX)\n\t\treturn NULL;\n\n\treturn pos;\n}"
  },
  {
    "function_name": "s_mode_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "605-615",
    "snippet": "static void *s_mode_start(struct seq_file *s, loff_t *pos)\n{\n\tint mode = *pos;\n\n\tmutex_lock(&hwlat_data.lock);\n\n\tif (mode >= MODE_MAX)\n\t\treturn NULL;\n\n\treturn pos;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hwlat_data.lock"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic void *s_mode_start(struct seq_file *s, loff_t *pos)\n{\n\tint mode = *pos;\n\n\tmutex_lock(&hwlat_data.lock);\n\n\tif (mode >= MODE_MAX)\n\t\treturn NULL;\n\n\treturn pos;\n}"
  },
  {
    "function_name": "start_per_cpu_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "575-603",
    "snippet": "static int start_per_cpu_kthreads(struct trace_array *tr)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tunsigned int cpu;\n\tint retval;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on CPUs in which hwlat is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu(hwlat_per_cpu_data, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_cpu_kthread(cpu);\n\t\tif (retval)\n\t\t\tgoto out_error;\n\t}\n\tcpus_read_unlock();\n\n\treturn 0;\n\nout_error:\n\tcpus_read_unlock();\n\tstop_per_cpu_kthreads();\n\treturn retval;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
      "static struct cpumask save_cpumask;",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_per_cpu_kthreads",
          "args": [],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "stop_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "478-486",
          "snippet": "static void stop_per_cpu_kthreads(void)\n{\n\tunsigned int cpu;\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu)\n\t\tstop_cpu_kthread(cpu);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_per_cpu_kthreads(void)\n{\n\tunsigned int cpu;\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu)\n\t\tstop_cpu_kthread(cpu);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_cpu_kthread",
          "args": [
            "cpu"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "start_cpu_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "491-504",
          "snippet": "static int start_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = kthread_run_on_cpu(kthread_fn, NULL, cpu, \"hwlatd/%u\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = kthread;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"hwlat_detector: \""
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\n\nstatic int start_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = kthread_run_on_cpu(kthread_fn, NULL, cpu, \"hwlatd/%u\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = kthread;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "current_mask",
            "cpu_online_mask",
            "tr->tracing_cpumask"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct cpumask save_cpumask;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic int start_per_cpu_kthreads(struct trace_array *tr)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tunsigned int cpu;\n\tint retval;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on CPUs in which hwlat is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu(hwlat_per_cpu_data, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_cpu_kthread(cpu);\n\t\tif (retval)\n\t\t\tgoto out_error;\n\t}\n\tcpus_read_unlock();\n\n\treturn 0;\n\nout_error:\n\tcpus_read_unlock();\n\tstop_per_cpu_kthreads();\n\treturn retval;\n}"
  },
  {
    "function_name": "hwlat_init_hotplug_support",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "562-565",
    "snippet": "static void hwlat_init_hotplug_support(void)\n{\n\treturn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void hwlat_init_hotplug_support(void)\n{\n\treturn;\n}"
  },
  {
    "function_name": "hwlat_init_hotplug_support",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "550-560",
    "snippet": "static void hwlat_init_hotplug_support(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"trace/hwlat:online\",\n\t\t\t\thwlat_cpu_init, hwlat_cpu_die);\n\tif (ret < 0)\n\t\tpr_warn(BANNER \"Error to init cpu hotplug support\\n\");\n\n\treturn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"hwlat_detector: \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "BANNER \"Error to init cpu hotplug support\\n\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"trace/hwlat:online\"",
            "hwlat_cpu_init",
            "hwlat_cpu_die"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic void hwlat_init_hotplug_support(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"trace/hwlat:online\",\n\t\t\t\thwlat_cpu_init, hwlat_cpu_die);\n\tif (ret < 0)\n\t\tpr_warn(BANNER \"Error to init cpu hotplug support\\n\");\n\n\treturn;\n}"
  },
  {
    "function_name": "hwlat_cpu_die",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "544-548",
    "snippet": "static int hwlat_cpu_die(unsigned int cpu)\n{\n\tstop_cpu_kthread(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_cpu_kthread",
          "args": [
            "cpu"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "stop_cpu_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "462-470",
          "snippet": "static void stop_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(hwlat_per_cpu_data, cpu).kthread;\n\tif (kthread)\n\t\tkthread_stop(kthread);\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\n\nstatic void stop_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(hwlat_per_cpu_data, cpu).kthread;\n\tif (kthread)\n\t\tkthread_stop(kthread);\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int hwlat_cpu_die(unsigned int cpu)\n{\n\tstop_cpu_kthread(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "hwlat_cpu_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "535-539",
    "snippet": "static int hwlat_cpu_init(unsigned int cpu)\n{\n\tschedule_work_on(cpu, &hwlat_hotplug_work);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work_on",
          "args": [
            "cpu",
            "&hwlat_hotplug_work"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int hwlat_cpu_init(unsigned int cpu)\n{\n\tschedule_work_on(cpu, &hwlat_hotplug_work);\n\treturn 0;\n}"
  },
  {
    "function_name": "hwlat_hotplug_workfn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "507-528",
    "snippet": "static void hwlat_hotplug_workfn(struct work_struct *dummy)\n{\n\tstruct trace_array *tr = hwlat_trace;\n\tunsigned int cpu = smp_processor_id();\n\n\tmutex_lock(&trace_types_lock);\n\tmutex_lock(&hwlat_data.lock);\n\tcpus_read_lock();\n\n\tif (!hwlat_busy || hwlat_data.thread_mode != MODE_PER_CPU)\n\t\tgoto out_unlock;\n\n\tif (!cpumask_test_cpu(cpu, tr->tracing_cpumask))\n\t\tgoto out_unlock;\n\n\tstart_cpu_kthread(cpu);\n\nout_unlock:\n\tcpus_read_unlock();\n\tmutex_unlock(&hwlat_data.lock);\n\tmutex_unlock(&trace_types_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*hwlat_trace;",
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
      "static bool hwlat_busy;",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_cpu_kthread",
          "args": [
            "cpu"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "start_cpu_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "491-504",
          "snippet": "static int start_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = kthread_run_on_cpu(kthread_fn, NULL, cpu, \"hwlatd/%u\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = kthread;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"hwlat_detector: \""
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\n\nstatic int start_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = kthread_run_on_cpu(kthread_fn, NULL, cpu, \"hwlatd/%u\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = kthread;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tr->tracing_cpumask"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hwlat_data.lock"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct trace_array\t*hwlat_trace;\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic bool hwlat_busy;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void hwlat_hotplug_workfn(struct work_struct *dummy)\n{\n\tstruct trace_array *tr = hwlat_trace;\n\tunsigned int cpu = smp_processor_id();\n\n\tmutex_lock(&trace_types_lock);\n\tmutex_lock(&hwlat_data.lock);\n\tcpus_read_lock();\n\n\tif (!hwlat_busy || hwlat_data.thread_mode != MODE_PER_CPU)\n\t\tgoto out_unlock;\n\n\tif (!cpumask_test_cpu(cpu, tr->tracing_cpumask))\n\t\tgoto out_unlock;\n\n\tstart_cpu_kthread(cpu);\n\nout_unlock:\n\tcpus_read_unlock();\n\tmutex_unlock(&hwlat_data.lock);\n\tmutex_unlock(&trace_types_lock);\n}"
  },
  {
    "function_name": "start_cpu_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "491-504",
    "snippet": "static int start_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = kthread_run_on_cpu(kthread_fn, NULL, cpu, \"hwlatd/%u\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = kthread;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"hwlat_detector: \""
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hwlat_per_cpu_data",
            "cpu"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "BANNER \"could not start sampling thread\\n\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kthread"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run_on_cpu",
          "args": [
            "kthread_fn",
            "NULL",
            "cpu",
            "\"hwlatd/%u\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\n\nstatic int start_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = kthread_run_on_cpu(kthread_fn, NULL, cpu, \"hwlatd/%u\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = kthread;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stop_per_cpu_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "478-486",
    "snippet": "static void stop_per_cpu_kthreads(void)\n{\n\tunsigned int cpu;\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu)\n\t\tstop_cpu_kthread(cpu);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_per_cpu_kthreads(void)\n{\n\tunsigned int cpu;\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu)\n\t\tstop_cpu_kthread(cpu);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "stop_cpu_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "462-470",
    "snippet": "static void stop_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(hwlat_per_cpu_data, cpu).kthread;\n\tif (kthread)\n\t\tkthread_stop(kthread);\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hwlat_per_cpu_data",
            "cpu"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "kthread"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\n\nstatic void stop_cpu_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(hwlat_per_cpu_data, cpu).kthread;\n\tif (kthread)\n\t\tkthread_stop(kthread);\n\tper_cpu(hwlat_per_cpu_data, cpu).kthread = NULL;\n}"
  },
  {
    "function_name": "start_single_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "421-457",
    "snippet": "static int start_single_kthread(struct trace_array *tr)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct cpumask *current_mask = &save_cpumask;\n\tstruct task_struct *kthread;\n\tint next_cpu;\n\n\tcpus_read_lock();\n\tif (kdata->kthread)\n\t\tgoto out_put_cpus;\n\n\tkthread = kthread_create(kthread_fn, NULL, \"hwlatd\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tcpus_read_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Just pick the first CPU on first iteration */\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\n\tif (hwlat_data.thread_mode == MODE_ROUND_ROBIN) {\n\t\tnext_cpu = cpumask_first(current_mask);\n\t\tcpumask_clear(current_mask);\n\t\tcpumask_set_cpu(next_cpu, current_mask);\n\n\t}\n\n\tsched_setaffinity(kthread->pid, current_mask);\n\n\tkdata->kthread = kthread;\n\twake_up_process(kthread);\n\nout_put_cpus:\n\tcpus_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"hwlat_detector: \""
    ],
    "globals_used": [
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
      "static struct cpumask save_cpumask;",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "kthread"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_setaffinity",
          "args": [
            "kthread->pid",
            "current_mask"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setaffinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7999-8039",
          "snippet": "long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\trcu_read_lock();\n\n\tp = find_process_by_pid(pid);\n\tif (!p) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/* Prevent p going away */\n\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tretval = -EINVAL;\n\t\tgoto out_put_task;\n\t}\n\n\tif (!check_same_owner(p)) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tretval = -EPERM;\n\t\t\tgoto out_put_task;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tretval = security_task_setscheduler(p);\n\tif (retval)\n\t\tgoto out_put_task;\n\n\tretval = __sched_setaffinity(p, in_mask);\nout_put_task:\n\tput_task_struct(p);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nlong sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\trcu_read_lock();\n\n\tp = find_process_by_pid(pid);\n\tif (!p) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/* Prevent p going away */\n\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tretval = -EINVAL;\n\t\tgoto out_put_task;\n\t}\n\n\tif (!check_same_owner(p)) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tretval = -EPERM;\n\t\t\tgoto out_put_task;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tretval = security_task_setscheduler(p);\n\tif (retval)\n\t\tgoto out_put_task;\n\n\tretval = __sched_setaffinity(p, in_mask);\nout_put_task:\n\tput_task_struct(p);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "next_cpu",
            "current_mask"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "current_mask"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "current_mask"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "current_mask",
            "cpu_online_mask",
            "tr->tracing_cpumask"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "BANNER \"could not start sampling thread\\n\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kthread"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "kthread_fn",
            "NULL",
            "\"hwlatd\""
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "882-893",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_data",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic struct cpumask save_cpumask;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic int start_single_kthread(struct trace_array *tr)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct cpumask *current_mask = &save_cpumask;\n\tstruct task_struct *kthread;\n\tint next_cpu;\n\n\tcpus_read_lock();\n\tif (kdata->kthread)\n\t\tgoto out_put_cpus;\n\n\tkthread = kthread_create(kthread_fn, NULL, \"hwlatd\");\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tcpus_read_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Just pick the first CPU on first iteration */\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\n\tif (hwlat_data.thread_mode == MODE_ROUND_ROBIN) {\n\t\tnext_cpu = cpumask_first(current_mask);\n\t\tcpumask_clear(current_mask);\n\t\tcpumask_set_cpu(next_cpu, current_mask);\n\n\t}\n\n\tsched_setaffinity(kthread->pid, current_mask);\n\n\tkdata->kthread = kthread;\n\twake_up_process(kthread);\n\nout_put_cpus:\n\tcpus_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "stop_single_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "396-412",
    "snippet": "static void stop_single_kthread(void)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct task_struct *kthread;\n\n\tcpus_read_lock();\n\tkthread = kdata->kthread;\n\n\tif (!kthread)\n\t\tgoto out_put_cpus;\n\n\tkthread_stop(kthread);\n\tkdata->kthread = NULL;\n\nout_put_cpus:\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "kthread"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_data",
          "args": [],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_single_kthread(void)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct task_struct *kthread;\n\n\tcpus_read_lock();\n\tkthread = kdata->kthread;\n\n\tif (!kthread)\n\t\tgoto out_put_cpus;\n\n\tkthread_stop(kthread);\n\tkdata->kthread = NULL;\n\nout_put_cpus:\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "kthread_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "360-388",
    "snippet": "static int kthread_fn(void *data)\n{\n\tu64 interval;\n\n\twhile (!kthread_should_stop()) {\n\n\t\tif (hwlat_data.thread_mode == MODE_ROUND_ROBIN)\n\t\t\tmove_to_next_cpu();\n\n\t\tlocal_irq_disable();\n\t\tget_sample();\n\t\tlocal_irq_enable();\n\n\t\tmutex_lock(&hwlat_data.lock);\n\t\tinterval = hwlat_data.sample_window - hwlat_data.sample_width;\n\t\tmutex_unlock(&hwlat_data.lock);\n\n\t\tdo_div(interval, USEC_PER_MSEC); /* modifies interval value */\n\n\t\t/* Always sleep for at least 1ms */\n\t\tif (interval < 1)\n\t\t\tinterval = 1;\n\n\t\tif (msleep_interruptible(interval))\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep_interruptible",
          "args": [
            "interval"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "interval",
            "USEC_PER_MSEC"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hwlat_data.lock"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hwlat_data.lock"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sample",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "get_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "201-310",
          "snippet": "static int get_sample(void)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct trace_array *tr = hwlat_trace;\n\tstruct hwlat_sample s;\n\ttime_type start, t1, t2, last_t2;\n\ts64 diff, outer_diff, total, last_total = 0;\n\tu64 sample = 0;\n\tu64 thresh = tracing_thresh;\n\tu64 outer_sample = 0;\n\tint ret = -1;\n\tunsigned int count = 0;\n\n\tdo_div(thresh, NSEC_PER_USEC); /* modifies interval value */\n\n\tkdata->nmi_total_ts = 0;\n\tkdata->nmi_count = 0;\n\t/* Make sure NMIs see this first */\n\tbarrier();\n\n\ttrace_hwlat_callback_enabled = true;\n\n\tinit_time(last_t2, 0);\n\tstart = time_get(); /* start timestamp */\n\touter_diff = 0;\n\n\tdo {\n\n\t\tt1 = time_get();\t/* we'll look for a discontinuity */\n\t\tt2 = time_get();\n\n\t\tif (time_u64(last_t2)) {\n\t\t\t/* Check the delta from outer loop (t2 to next t1) */\n\t\t\touter_diff = time_to_us(time_sub(t1, last_t2));\n\t\t\t/* This shouldn't happen */\n\t\t\tif (outer_diff < 0) {\n\t\t\t\thwlat_err(BANNER \"time running backwards\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (outer_diff > outer_sample)\n\t\t\t\touter_sample = outer_diff;\n\t\t}\n\t\tlast_t2 = t2;\n\n\t\ttotal = time_to_us(time_sub(t2, start)); /* sample width */\n\n\t\t/* Check for possible overflows */\n\t\tif (total < last_total) {\n\t\t\thwlat_err(\"Time total overflowed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlast_total = total;\n\n\t\t/* This checks the inner loop (t1 to t2) */\n\t\tdiff = time_to_us(time_sub(t2, t1));     /* current diff */\n\n\t\tif (diff > thresh || outer_diff > thresh) {\n\t\t\tif (!count)\n\t\t\t\tktime_get_real_ts64(&s.timestamp);\n\t\t\tcount++;\n\t\t}\n\n\t\t/* This shouldn't happen */\n\t\tif (diff < 0) {\n\t\t\thwlat_err(BANNER \"time running backwards\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (diff > sample)\n\t\t\tsample = diff; /* only want highest value */\n\n\t} while (total <= hwlat_data.sample_width);\n\n\tbarrier(); /* finish the above in the view for NMIs */\n\ttrace_hwlat_callback_enabled = false;\n\tbarrier(); /* Make sure nmi_total_ts is no longer updated */\n\n\tret = 0;\n\n\t/* If we exceed the threshold value, we have found a hardware latency */\n\tif (sample > thresh || outer_sample > thresh) {\n\t\tu64 latency;\n\n\t\tret = 1;\n\n\t\t/* We read in microseconds */\n\t\tif (kdata->nmi_total_ts)\n\t\t\tdo_div(kdata->nmi_total_ts, NSEC_PER_USEC);\n\n\t\thwlat_data.count++;\n\t\ts.seqnum = hwlat_data.count;\n\t\ts.duration = sample;\n\t\ts.outer_duration = outer_sample;\n\t\ts.nmi_total_ts = kdata->nmi_total_ts;\n\t\ts.nmi_count = kdata->nmi_count;\n\t\ts.count = count;\n\t\ttrace_hwlat_sample(&s);\n\n\t\tlatency = max(sample, outer_sample);\n\n\t\t/* Keep a running maximum ever recorded hardware latency */\n\t\tif (latency > tr->max_latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define time_type\tu64",
            "#define BANNER\t\t\t\"hwlat_detector: \""
          ],
          "globals_used": [
            "static struct trace_array\t*hwlat_trace;",
            "bool trace_hwlat_callback_enabled;",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define time_type\tu64\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct trace_array\t*hwlat_trace;\nbool trace_hwlat_callback_enabled;\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic int get_sample(void)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct trace_array *tr = hwlat_trace;\n\tstruct hwlat_sample s;\n\ttime_type start, t1, t2, last_t2;\n\ts64 diff, outer_diff, total, last_total = 0;\n\tu64 sample = 0;\n\tu64 thresh = tracing_thresh;\n\tu64 outer_sample = 0;\n\tint ret = -1;\n\tunsigned int count = 0;\n\n\tdo_div(thresh, NSEC_PER_USEC); /* modifies interval value */\n\n\tkdata->nmi_total_ts = 0;\n\tkdata->nmi_count = 0;\n\t/* Make sure NMIs see this first */\n\tbarrier();\n\n\ttrace_hwlat_callback_enabled = true;\n\n\tinit_time(last_t2, 0);\n\tstart = time_get(); /* start timestamp */\n\touter_diff = 0;\n\n\tdo {\n\n\t\tt1 = time_get();\t/* we'll look for a discontinuity */\n\t\tt2 = time_get();\n\n\t\tif (time_u64(last_t2)) {\n\t\t\t/* Check the delta from outer loop (t2 to next t1) */\n\t\t\touter_diff = time_to_us(time_sub(t1, last_t2));\n\t\t\t/* This shouldn't happen */\n\t\t\tif (outer_diff < 0) {\n\t\t\t\thwlat_err(BANNER \"time running backwards\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (outer_diff > outer_sample)\n\t\t\t\touter_sample = outer_diff;\n\t\t}\n\t\tlast_t2 = t2;\n\n\t\ttotal = time_to_us(time_sub(t2, start)); /* sample width */\n\n\t\t/* Check for possible overflows */\n\t\tif (total < last_total) {\n\t\t\thwlat_err(\"Time total overflowed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlast_total = total;\n\n\t\t/* This checks the inner loop (t1 to t2) */\n\t\tdiff = time_to_us(time_sub(t2, t1));     /* current diff */\n\n\t\tif (diff > thresh || outer_diff > thresh) {\n\t\t\tif (!count)\n\t\t\t\tktime_get_real_ts64(&s.timestamp);\n\t\t\tcount++;\n\t\t}\n\n\t\t/* This shouldn't happen */\n\t\tif (diff < 0) {\n\t\t\thwlat_err(BANNER \"time running backwards\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (diff > sample)\n\t\t\tsample = diff; /* only want highest value */\n\n\t} while (total <= hwlat_data.sample_width);\n\n\tbarrier(); /* finish the above in the view for NMIs */\n\ttrace_hwlat_callback_enabled = false;\n\tbarrier(); /* Make sure nmi_total_ts is no longer updated */\n\n\tret = 0;\n\n\t/* If we exceed the threshold value, we have found a hardware latency */\n\tif (sample > thresh || outer_sample > thresh) {\n\t\tu64 latency;\n\n\t\tret = 1;\n\n\t\t/* We read in microseconds */\n\t\tif (kdata->nmi_total_ts)\n\t\t\tdo_div(kdata->nmi_total_ts, NSEC_PER_USEC);\n\n\t\thwlat_data.count++;\n\t\ts.seqnum = hwlat_data.count;\n\t\ts.duration = sample;\n\t\ts.outer_duration = outer_sample;\n\t\ts.nmi_total_ts = kdata->nmi_total_ts;\n\t\ts.nmi_count = kdata->nmi_count;\n\t\ts.count = count;\n\t\ttrace_hwlat_sample(&s);\n\n\t\tlatency = max(sample, outer_sample);\n\n\t\t/* Keep a running maximum ever recorded hardware latency */\n\t\tif (latency > tr->max_latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_to_next_cpu",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_next_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "314-348",
          "snippet": "static void move_to_next_cpu(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tstruct trace_array *tr = hwlat_trace;\n\tint next_cpu;\n\n\t/*\n\t * If for some reason the user modifies the CPU affinity\n\t * of this thread, then stop migrating for the duration\n\t * of the current test.\n\t */\n\tif (!cpumask_equal(current_mask, current->cpus_ptr))\n\t\tgoto change_mode;\n\n\tcpus_read_lock();\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), current_mask);\n\tcpus_read_unlock();\n\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(current_mask);\n\n\tif (next_cpu >= nr_cpu_ids) /* Shouldn't happen! */\n\t\tgoto change_mode;\n\n\tcpumask_clear(current_mask);\n\tcpumask_set_cpu(next_cpu, current_mask);\n\n\tsched_setaffinity(0, current_mask);\n\treturn;\n\n change_mode:\n\thwlat_data.thread_mode = MODE_NONE;\n\tpr_info(BANNER \"cpumask changed while in round-robin mode, switching to mode none\\n\");\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"hwlat_detector: \""
          ],
          "globals_used": [
            "static struct trace_array\t*hwlat_trace;",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
            "static struct cpumask save_cpumask;",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct trace_array\t*hwlat_trace;\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic struct cpumask save_cpumask;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void move_to_next_cpu(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tstruct trace_array *tr = hwlat_trace;\n\tint next_cpu;\n\n\t/*\n\t * If for some reason the user modifies the CPU affinity\n\t * of this thread, then stop migrating for the duration\n\t * of the current test.\n\t */\n\tif (!cpumask_equal(current_mask, current->cpus_ptr))\n\t\tgoto change_mode;\n\n\tcpus_read_lock();\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), current_mask);\n\tcpus_read_unlock();\n\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(current_mask);\n\n\tif (next_cpu >= nr_cpu_ids) /* Shouldn't happen! */\n\t\tgoto change_mode;\n\n\tcpumask_clear(current_mask);\n\tcpumask_set_cpu(next_cpu, current_mask);\n\n\tsched_setaffinity(0, current_mask);\n\treturn;\n\n change_mode:\n\thwlat_data.thread_mode = MODE_NONE;\n\tpr_info(BANNER \"cpumask changed while in round-robin mode, switching to mode none\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic int kthread_fn(void *data)\n{\n\tu64 interval;\n\n\twhile (!kthread_should_stop()) {\n\n\t\tif (hwlat_data.thread_mode == MODE_ROUND_ROBIN)\n\t\t\tmove_to_next_cpu();\n\n\t\tlocal_irq_disable();\n\t\tget_sample();\n\t\tlocal_irq_enable();\n\n\t\tmutex_lock(&hwlat_data.lock);\n\t\tinterval = hwlat_data.sample_window - hwlat_data.sample_width;\n\t\tmutex_unlock(&hwlat_data.lock);\n\n\t\tdo_div(interval, USEC_PER_MSEC); /* modifies interval value */\n\n\t\t/* Always sleep for at least 1ms */\n\t\tif (interval < 1)\n\t\t\tinterval = 1;\n\n\t\tif (msleep_interruptible(interval))\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "move_to_next_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "314-348",
    "snippet": "static void move_to_next_cpu(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tstruct trace_array *tr = hwlat_trace;\n\tint next_cpu;\n\n\t/*\n\t * If for some reason the user modifies the CPU affinity\n\t * of this thread, then stop migrating for the duration\n\t * of the current test.\n\t */\n\tif (!cpumask_equal(current_mask, current->cpus_ptr))\n\t\tgoto change_mode;\n\n\tcpus_read_lock();\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), current_mask);\n\tcpus_read_unlock();\n\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(current_mask);\n\n\tif (next_cpu >= nr_cpu_ids) /* Shouldn't happen! */\n\t\tgoto change_mode;\n\n\tcpumask_clear(current_mask);\n\tcpumask_set_cpu(next_cpu, current_mask);\n\n\tsched_setaffinity(0, current_mask);\n\treturn;\n\n change_mode:\n\thwlat_data.thread_mode = MODE_NONE;\n\tpr_info(BANNER \"cpumask changed while in round-robin mode, switching to mode none\\n\");\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"hwlat_detector: \""
    ],
    "globals_used": [
      "static struct trace_array\t*hwlat_trace;",
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
      "static struct cpumask save_cpumask;",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "BANNER \"cpumask changed while in round-robin mode, switching to mode none\\n\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_setaffinity",
          "args": [
            "0",
            "current_mask"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setaffinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7999-8039",
          "snippet": "long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\trcu_read_lock();\n\n\tp = find_process_by_pid(pid);\n\tif (!p) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/* Prevent p going away */\n\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tretval = -EINVAL;\n\t\tgoto out_put_task;\n\t}\n\n\tif (!check_same_owner(p)) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tretval = -EPERM;\n\t\t\tgoto out_put_task;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tretval = security_task_setscheduler(p);\n\tif (retval)\n\t\tgoto out_put_task;\n\n\tretval = __sched_setaffinity(p, in_mask);\nout_put_task:\n\tput_task_struct(p);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nlong sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\trcu_read_lock();\n\n\tp = find_process_by_pid(pid);\n\tif (!p) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/* Prevent p going away */\n\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tretval = -EINVAL;\n\t\tgoto out_put_task;\n\t}\n\n\tif (!check_same_owner(p)) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tretval = -EPERM;\n\t\t\tgoto out_put_task;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tretval = security_task_setscheduler(p);\n\tif (retval)\n\t\tgoto out_put_task;\n\n\tretval = __sched_setaffinity(p, in_mask);\nout_put_task:\n\tput_task_struct(p);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "next_cpu",
            "current_mask"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "current_mask"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "current_mask"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "raw_smp_processor_id()",
            "current_mask"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "current_mask",
            "cpu_online_mask",
            "tr->tracing_cpumask"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "current_mask",
            "current->cpus_ptr"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct trace_array\t*hwlat_trace;\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic struct cpumask save_cpumask;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void move_to_next_cpu(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tstruct trace_array *tr = hwlat_trace;\n\tint next_cpu;\n\n\t/*\n\t * If for some reason the user modifies the CPU affinity\n\t * of this thread, then stop migrating for the duration\n\t * of the current test.\n\t */\n\tif (!cpumask_equal(current_mask, current->cpus_ptr))\n\t\tgoto change_mode;\n\n\tcpus_read_lock();\n\tcpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), current_mask);\n\tcpus_read_unlock();\n\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(current_mask);\n\n\tif (next_cpu >= nr_cpu_ids) /* Shouldn't happen! */\n\t\tgoto change_mode;\n\n\tcpumask_clear(current_mask);\n\tcpumask_set_cpu(next_cpu, current_mask);\n\n\tsched_setaffinity(0, current_mask);\n\treturn;\n\n change_mode:\n\thwlat_data.thread_mode = MODE_NONE;\n\tpr_info(BANNER \"cpumask changed while in round-robin mode, switching to mode none\\n\");\n}"
  },
  {
    "function_name": "get_sample",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "201-310",
    "snippet": "static int get_sample(void)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct trace_array *tr = hwlat_trace;\n\tstruct hwlat_sample s;\n\ttime_type start, t1, t2, last_t2;\n\ts64 diff, outer_diff, total, last_total = 0;\n\tu64 sample = 0;\n\tu64 thresh = tracing_thresh;\n\tu64 outer_sample = 0;\n\tint ret = -1;\n\tunsigned int count = 0;\n\n\tdo_div(thresh, NSEC_PER_USEC); /* modifies interval value */\n\n\tkdata->nmi_total_ts = 0;\n\tkdata->nmi_count = 0;\n\t/* Make sure NMIs see this first */\n\tbarrier();\n\n\ttrace_hwlat_callback_enabled = true;\n\n\tinit_time(last_t2, 0);\n\tstart = time_get(); /* start timestamp */\n\touter_diff = 0;\n\n\tdo {\n\n\t\tt1 = time_get();\t/* we'll look for a discontinuity */\n\t\tt2 = time_get();\n\n\t\tif (time_u64(last_t2)) {\n\t\t\t/* Check the delta from outer loop (t2 to next t1) */\n\t\t\touter_diff = time_to_us(time_sub(t1, last_t2));\n\t\t\t/* This shouldn't happen */\n\t\t\tif (outer_diff < 0) {\n\t\t\t\thwlat_err(BANNER \"time running backwards\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (outer_diff > outer_sample)\n\t\t\t\touter_sample = outer_diff;\n\t\t}\n\t\tlast_t2 = t2;\n\n\t\ttotal = time_to_us(time_sub(t2, start)); /* sample width */\n\n\t\t/* Check for possible overflows */\n\t\tif (total < last_total) {\n\t\t\thwlat_err(\"Time total overflowed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlast_total = total;\n\n\t\t/* This checks the inner loop (t1 to t2) */\n\t\tdiff = time_to_us(time_sub(t2, t1));     /* current diff */\n\n\t\tif (diff > thresh || outer_diff > thresh) {\n\t\t\tif (!count)\n\t\t\t\tktime_get_real_ts64(&s.timestamp);\n\t\t\tcount++;\n\t\t}\n\n\t\t/* This shouldn't happen */\n\t\tif (diff < 0) {\n\t\t\thwlat_err(BANNER \"time running backwards\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (diff > sample)\n\t\t\tsample = diff; /* only want highest value */\n\n\t} while (total <= hwlat_data.sample_width);\n\n\tbarrier(); /* finish the above in the view for NMIs */\n\ttrace_hwlat_callback_enabled = false;\n\tbarrier(); /* Make sure nmi_total_ts is no longer updated */\n\n\tret = 0;\n\n\t/* If we exceed the threshold value, we have found a hardware latency */\n\tif (sample > thresh || outer_sample > thresh) {\n\t\tu64 latency;\n\n\t\tret = 1;\n\n\t\t/* We read in microseconds */\n\t\tif (kdata->nmi_total_ts)\n\t\t\tdo_div(kdata->nmi_total_ts, NSEC_PER_USEC);\n\n\t\thwlat_data.count++;\n\t\ts.seqnum = hwlat_data.count;\n\t\ts.duration = sample;\n\t\ts.outer_duration = outer_sample;\n\t\ts.nmi_total_ts = kdata->nmi_total_ts;\n\t\ts.nmi_count = kdata->nmi_count;\n\t\ts.count = count;\n\t\ttrace_hwlat_sample(&s);\n\n\t\tlatency = max(sample, outer_sample);\n\n\t\t/* Keep a running maximum ever recorded hardware latency */\n\t\tif (latency > tr->max_latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define time_type\tu64",
      "#define BANNER\t\t\t\"hwlat_detector: \""
    ],
    "globals_used": [
      "static struct trace_array\t*hwlat_trace;",
      "bool trace_hwlat_callback_enabled;",
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "latency_fsnotify",
          "args": [
            "tr"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "latency_fsnotify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1714-1724",
          "snippet": "void latency_fsnotify(struct trace_array *tr)\n{\n\tif (!fsnotify_wq)\n\t\treturn;\n\t/*\n\t * We cannot call queue_work(&tr->fsnotify_work) from here because it's\n\t * possible that we are called from __schedule() or do_idle(), which\n\t * could cause a deadlock.\n\t */\n\tirq_work_queue(&tr->fsnotify_irqwork);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid latency_fsnotify(struct trace_array *tr)\n{\n\tif (!fsnotify_wq)\n\t\treturn;\n\t/*\n\t * We cannot call queue_work(&tr->fsnotify_work) from here because it's\n\t * possible that we are called from __schedule() or do_idle(), which\n\t * could cause a deadlock.\n\t */\n\tirq_work_queue(&tr->fsnotify_irqwork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "sample",
            "outer_sample"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "check_track_val_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3212-3218",
          "snippet": "static bool check_track_val_max(u64 track_val, u64 var_val)\n{\n\tif (var_val <= track_val)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_track_val_max(u64 track_val, u64 var_val)\n{\n\tif (var_val <= track_val)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hwlat_sample",
          "args": [
            "&s"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hwlat_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "130-153",
          "snippet": "static void trace_hwlat_sample(struct hwlat_sample *sample)\n{\n\tstruct trace_array *tr = hwlat_trace;\n\tstruct trace_event_call *call = &event_hwlat;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct hwlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_HWLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->duration\t\t\t= sample->duration;\n\tentry->outer_duration\t\t= sample->outer_duration;\n\tentry->timestamp\t\t= sample->timestamp;\n\tentry->nmi_total_ts\t\t= sample->nmi_total_ts;\n\tentry->nmi_count\t\t= sample->nmi_count;\n\tentry->count\t\t\t= sample->count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*hwlat_trace;",
            "static void hwlat_tracer_start(struct trace_array *tr);",
            "static void hwlat_tracer_stop(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct trace_array\t*hwlat_trace;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void trace_hwlat_sample(struct hwlat_sample *sample)\n{\n\tstruct trace_array *tr = hwlat_trace;\n\tstruct trace_event_call *call = &event_hwlat;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct hwlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_HWLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->duration\t\t\t= sample->duration;\n\tentry->outer_duration\t\t= sample->outer_duration;\n\tentry->timestamp\t\t= sample->timestamp;\n\tentry->nmi_total_ts\t\t= sample->nmi_total_ts;\n\tentry->nmi_count\t\t= sample->nmi_count;\n\tentry->count\t\t\t= sample->count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "kdata->nmi_total_ts",
            "NSEC_PER_USEC"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwlat_err",
          "args": [
            "BANNER \"time running backwards\\n\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&s.timestamp"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "796-814",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "time_sub(t2, t1)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_sub",
          "args": [
            "t2",
            "t1"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwlat_err",
          "args": [
            "\"Time total overflowed\\n\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "time_sub(t2, start)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_sub",
          "args": [
            "t2",
            "start"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwlat_err",
          "args": [
            "BANNER \"time running backwards\\n\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "time_sub(t1, last_t2)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_sub",
          "args": [
            "t1",
            "last_t2"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_u64",
          "args": [
            "last_t2"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_time",
          "args": [
            "last_t2",
            "0"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "thresh",
            "NSEC_PER_USEC"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_data",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define time_type\tu64\n#define BANNER\t\t\t\"hwlat_detector: \"\n\nstatic struct trace_array\t*hwlat_trace;\nbool trace_hwlat_callback_enabled;\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic int get_sample(void)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\tstruct trace_array *tr = hwlat_trace;\n\tstruct hwlat_sample s;\n\ttime_type start, t1, t2, last_t2;\n\ts64 diff, outer_diff, total, last_total = 0;\n\tu64 sample = 0;\n\tu64 thresh = tracing_thresh;\n\tu64 outer_sample = 0;\n\tint ret = -1;\n\tunsigned int count = 0;\n\n\tdo_div(thresh, NSEC_PER_USEC); /* modifies interval value */\n\n\tkdata->nmi_total_ts = 0;\n\tkdata->nmi_count = 0;\n\t/* Make sure NMIs see this first */\n\tbarrier();\n\n\ttrace_hwlat_callback_enabled = true;\n\n\tinit_time(last_t2, 0);\n\tstart = time_get(); /* start timestamp */\n\touter_diff = 0;\n\n\tdo {\n\n\t\tt1 = time_get();\t/* we'll look for a discontinuity */\n\t\tt2 = time_get();\n\n\t\tif (time_u64(last_t2)) {\n\t\t\t/* Check the delta from outer loop (t2 to next t1) */\n\t\t\touter_diff = time_to_us(time_sub(t1, last_t2));\n\t\t\t/* This shouldn't happen */\n\t\t\tif (outer_diff < 0) {\n\t\t\t\thwlat_err(BANNER \"time running backwards\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (outer_diff > outer_sample)\n\t\t\t\touter_sample = outer_diff;\n\t\t}\n\t\tlast_t2 = t2;\n\n\t\ttotal = time_to_us(time_sub(t2, start)); /* sample width */\n\n\t\t/* Check for possible overflows */\n\t\tif (total < last_total) {\n\t\t\thwlat_err(\"Time total overflowed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlast_total = total;\n\n\t\t/* This checks the inner loop (t1 to t2) */\n\t\tdiff = time_to_us(time_sub(t2, t1));     /* current diff */\n\n\t\tif (diff > thresh || outer_diff > thresh) {\n\t\t\tif (!count)\n\t\t\t\tktime_get_real_ts64(&s.timestamp);\n\t\t\tcount++;\n\t\t}\n\n\t\t/* This shouldn't happen */\n\t\tif (diff < 0) {\n\t\t\thwlat_err(BANNER \"time running backwards\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (diff > sample)\n\t\t\tsample = diff; /* only want highest value */\n\n\t} while (total <= hwlat_data.sample_width);\n\n\tbarrier(); /* finish the above in the view for NMIs */\n\ttrace_hwlat_callback_enabled = false;\n\tbarrier(); /* Make sure nmi_total_ts is no longer updated */\n\n\tret = 0;\n\n\t/* If we exceed the threshold value, we have found a hardware latency */\n\tif (sample > thresh || outer_sample > thresh) {\n\t\tu64 latency;\n\n\t\tret = 1;\n\n\t\t/* We read in microseconds */\n\t\tif (kdata->nmi_total_ts)\n\t\t\tdo_div(kdata->nmi_total_ts, NSEC_PER_USEC);\n\n\t\thwlat_data.count++;\n\t\ts.seqnum = hwlat_data.count;\n\t\ts.duration = sample;\n\t\ts.outer_duration = outer_sample;\n\t\ts.nmi_total_ts = kdata->nmi_total_ts;\n\t\ts.nmi_count = kdata->nmi_count;\n\t\ts.count = count;\n\t\ttrace_hwlat_sample(&s);\n\n\t\tlatency = max(sample, outer_sample);\n\n\t\t/* Keep a running maximum ever recorded hardware latency */\n\t\tif (latency > tr->max_latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_hwlat_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "163-183",
    "snippet": "void trace_hwlat_callback(bool enter)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\n\tif (!kdata->kthread)\n\t\treturn;\n\n\t/*\n\t * Currently trace_clock_local() calls sched_clock() and the\n\t * generic version is not NMI safe.\n\t */\n\tif (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK)) {\n\t\tif (enter)\n\t\t\tkdata->nmi_ts_start = time_get();\n\t\telse\n\t\t\tkdata->nmi_total_ts += time_get() - kdata->nmi_ts_start;\n\t}\n\n\tif (enter)\n\t\tkdata->nmi_count++;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_GENERIC_SCHED_CLOCK"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_data",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nvoid trace_hwlat_callback(bool enter)\n{\n\tstruct hwlat_kthread_data *kdata = get_cpu_data();\n\n\tif (!kdata->kthread)\n\t\treturn;\n\n\t/*\n\t * Currently trace_clock_local() calls sched_clock() and the\n\t * generic version is not NMI safe.\n\t */\n\tif (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK)) {\n\t\tif (enter)\n\t\t\tkdata->nmi_ts_start = time_get();\n\t\telse\n\t\t\tkdata->nmi_total_ts += time_get() - kdata->nmi_ts_start;\n\t}\n\n\tif (enter)\n\t\tkdata->nmi_count++;\n}"
  },
  {
    "function_name": "trace_hwlat_sample",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "130-153",
    "snippet": "static void trace_hwlat_sample(struct hwlat_sample *sample)\n{\n\tstruct trace_array *tr = hwlat_trace;\n\tstruct trace_event_call *call = &event_hwlat;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct hwlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_HWLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->duration\t\t\t= sample->duration;\n\tentry->outer_duration\t\t= sample->outer_duration;\n\tentry->timestamp\t\t= sample->timestamp;\n\tentry->nmi_total_ts\t\t= sample->nmi_total_ts;\n\tentry->nmi_count\t\t= sample->nmi_count;\n\tentry->count\t\t\t= sample->count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*hwlat_trace;",
      "static void hwlat_tracer_start(struct trace_array *tr);",
      "static void hwlat_tracer_stop(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2948-2953",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_HWLAT",
            "sizeof(*entry)",
            "tracing_gen_ctx()"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct trace_array\t*hwlat_trace;\nstatic void hwlat_tracer_start(struct trace_array *tr);\nstatic void hwlat_tracer_stop(struct trace_array *tr);\n\nstatic void trace_hwlat_sample(struct hwlat_sample *sample)\n{\n\tstruct trace_array *tr = hwlat_trace;\n\tstruct trace_event_call *call = &event_hwlat;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct hwlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_HWLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->duration\t\t\t= sample->duration;\n\tentry->outer_duration\t\t= sample->outer_duration;\n\tentry->timestamp\t\t= sample->timestamp;\n\tentry->nmi_total_ts\t\t= sample->nmi_total_ts;\n\tentry->nmi_count\t\t= sample->nmi_count;\n\tentry->count\t\t\t= sample->count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
  },
  {
    "function_name": "get_cpu_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
    "lines": "120-126",
    "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hwlat_kthread_data hwlat_single_cpu_data;",
      "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
      "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hwlat_per_cpu_data"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
  }
]