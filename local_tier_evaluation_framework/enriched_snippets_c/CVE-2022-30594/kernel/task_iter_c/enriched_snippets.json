[
  {
    "function_name": "task_iter_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "645-669",
    "snippet": "static int __init task_iter_init(void)\n{\n\tstruct mmap_unlock_irq_work *work;\n\tint ret, cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\twork = per_cpu_ptr(&mmap_unlock_work, cpu);\n\t\tinit_irq_work(&work->irq_work, do_mmap_read_unlock);\n\t}\n\n\ttask_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\tret = bpf_iter_reg_target(&task_reg_info);\n\tif (ret)\n\t\treturn ret;\n\n\ttask_file_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\ttask_file_reg_info.ctx_arg_info[1].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_FILE];\n\tret =  bpf_iter_reg_target(&task_file_reg_info);\n\tif (ret)\n\t\treturn ret;\n\n\ttask_vma_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\ttask_vma_reg_info.ctx_arg_info[1].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_VMA];\n\treturn bpf_iter_reg_target(&task_vma_reg_info);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_iter_reg task_reg_info = {\n\t.target\t\t\t= \"task\",\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 1,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_seq_info,\n};",
      "static struct bpf_iter_reg task_file_reg_info = {\n\t.target\t\t\t= \"task_file\",\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 2,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task_file, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t\t{ offsetof(struct bpf_iter__task_file, file),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_file_seq_info,\n};",
      "static struct bpf_iter_reg task_vma_reg_info = {\n\t.target\t\t\t= \"task_vma\",\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 2,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task_vma, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t\t{ offsetof(struct bpf_iter__task_vma, vma),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_vma_seq_info,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_iter_reg_target",
          "args": [
            "&task_vma_reg_info"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_reg_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "286-302",
          "snippet": "int bpf_iter_reg_target(const struct bpf_iter_reg *reg_info)\n{\n\tstruct bpf_iter_target_info *tinfo;\n\n\ttinfo = kzalloc(sizeof(*tinfo), GFP_KERNEL);\n\tif (!tinfo)\n\t\treturn -ENOMEM;\n\n\ttinfo->reg_info = reg_info;\n\tINIT_LIST_HEAD(&tinfo->list);\n\n\tmutex_lock(&targets_mutex);\n\tlist_add(&tinfo->list, &targets);\n\tmutex_unlock(&targets_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head targets = LIST_HEAD_INIT(targets);",
            "static DEFINE_MUTEX(targets_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic struct list_head targets = LIST_HEAD_INIT(targets);\nstatic DEFINE_MUTEX(targets_mutex);\n\nint bpf_iter_reg_target(const struct bpf_iter_reg *reg_info)\n{\n\tstruct bpf_iter_target_info *tinfo;\n\n\ttinfo = kzalloc(sizeof(*tinfo), GFP_KERNEL);\n\tif (!tinfo)\n\t\treturn -ENOMEM;\n\n\ttinfo->reg_info = reg_info;\n\tINIT_LIST_HEAD(&tinfo->list);\n\n\tmutex_lock(&targets_mutex);\n\tlist_add(&tinfo->list, &targets);\n\tmutex_unlock(&targets_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&work->irq_work",
            "do_mmap_read_unlock"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&mmap_unlock_work",
            "cpu"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct bpf_iter_reg task_reg_info = {\n\t.target\t\t\t= \"task\",\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 1,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_seq_info,\n};\nstatic struct bpf_iter_reg task_file_reg_info = {\n\t.target\t\t\t= \"task_file\",\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 2,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task_file, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t\t{ offsetof(struct bpf_iter__task_file, file),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_file_seq_info,\n};\nstatic struct bpf_iter_reg task_vma_reg_info = {\n\t.target\t\t\t= \"task_vma\",\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 2,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task_vma, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t\t{ offsetof(struct bpf_iter__task_vma, vma),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_vma_seq_info,\n};\n\nstatic int __init task_iter_init(void)\n{\n\tstruct mmap_unlock_irq_work *work;\n\tint ret, cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\twork = per_cpu_ptr(&mmap_unlock_work, cpu);\n\t\tinit_irq_work(&work->irq_work, do_mmap_read_unlock);\n\t}\n\n\ttask_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\tret = bpf_iter_reg_target(&task_reg_info);\n\tif (ret)\n\t\treturn ret;\n\n\ttask_file_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\ttask_file_reg_info.ctx_arg_info[1].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_FILE];\n\tret =  bpf_iter_reg_target(&task_file_reg_info);\n\tif (ret)\n\t\treturn ret;\n\n\ttask_vma_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\ttask_vma_reg_info.ctx_arg_info[1].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_VMA];\n\treturn bpf_iter_reg_target(&task_vma_reg_info);\n}"
  },
  {
    "function_name": "do_mmap_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "634-643",
    "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmap_read_unlock_non_owner",
          "args": [
            "work->mm"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "entry",
            "structmmap_unlock_irq_work",
            "irq_work"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_PREEMPT_RT)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
  },
  {
    "function_name": "task_vma_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "499-519",
    "snippet": "static void task_vma_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\n\tif (!v) {\n\t\t(void)__task_vma_seq_show(seq, true);\n\t} else {\n\t\t/* info->vma has not been seen by the BPF program. If the\n\t\t * user space reads more, task_vma_seq_get_next should\n\t\t * return this vma again. Set prev_vm_start to ~0UL,\n\t\t * so that we don't skip the vma returned by the next\n\t\t * find_vma() (case task_vma_iter_find_vma in\n\t\t * task_vma_seq_get_next()).\n\t\t */\n\t\tinfo->prev_vm_start = ~0UL;\n\t\tinfo->prev_vm_end = info->vma->vm_end;\n\t\tmmap_read_unlock(info->task->mm);\n\t\tput_task_struct(info->task);\n\t\tinfo->task = NULL;\n\t}\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "info->task"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmap_read_unlock",
          "args": [
            "info->task->mm"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_vma_seq_show",
          "args": [
            "seq",
            "true"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "__task_vma_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "476-492",
          "snippet": "static int __task_vma_seq_show(struct seq_file *seq, bool in_stop)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct bpf_iter__task_vma ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.vma = info->vma;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_vma_seq_show(struct seq_file *seq, bool in_stop)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct bpf_iter__task_vma ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.vma = info->vma;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void task_vma_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\n\tif (!v) {\n\t\t(void)__task_vma_seq_show(seq, true);\n\t} else {\n\t\t/* info->vma has not been seen by the BPF program. If the\n\t\t * user space reads more, task_vma_seq_get_next should\n\t\t * return this vma again. Set prev_vm_start to ~0UL,\n\t\t * so that we don't skip the vma returned by the next\n\t\t * find_vma() (case task_vma_iter_find_vma in\n\t\t * task_vma_seq_get_next()).\n\t\t */\n\t\tinfo->prev_vm_start = ~0UL;\n\t\tinfo->prev_vm_end = info->vma->vm_end;\n\t\tmmap_read_unlock(info->task->mm);\n\t\tput_task_struct(info->task);\n\t\tinfo->task = NULL;\n\t}\n}"
  },
  {
    "function_name": "task_vma_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "494-497",
    "snippet": "static int task_vma_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_vma_seq_show(seq, false);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__task_vma_seq_show",
          "args": [
            "seq",
            "false"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "__task_vma_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "476-492",
          "snippet": "static int __task_vma_seq_show(struct seq_file *seq, bool in_stop)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct bpf_iter__task_vma ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.vma = info->vma;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_vma_seq_show(struct seq_file *seq, bool in_stop)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct bpf_iter__task_vma ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.vma = info->vma;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int task_vma_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_vma_seq_show(seq, false);\n}"
  },
  {
    "function_name": "__task_vma_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "476-492",
    "snippet": "static int __task_vma_seq_show(struct seq_file *seq, bool in_stop)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct bpf_iter__task_vma ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.vma = info->vma;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_iter_run_prog",
          "args": [
            "prog",
            "&ctx"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_run_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "683-700",
          "snippet": "int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nint bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_iter_get_info",
          "args": [
            "&meta",
            "in_stop"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_get_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "660-681",
          "snippet": "struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic64_t session_id;",
            "const struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic atomic64_t session_id;\nconst struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};\n\nstruct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_vma_seq_show(struct seq_file *seq, bool in_stop)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct bpf_iter__task_vma ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.vma = info->vma;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
  },
  {
    "function_name": "task_vma_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "459-465",
    "snippet": "static void *task_vma_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\n\t++*pos;\n\treturn task_vma_seq_get_next(info);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_vma_seq_get_next",
          "args": [
            "info"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "task_vma_seq_get_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "308-445",
          "snippet": "static struct vm_area_struct *\ntask_vma_seq_get_next(struct bpf_iter_seq_task_vma_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tenum bpf_task_vma_iter_find_op op;\n\tstruct vm_area_struct *curr_vma;\n\tstruct task_struct *curr_task;\n\tu32 curr_tid = info->tid;\n\n\t/* If this function returns a non-NULL vma, it holds a reference to\n\t * the task_struct, and holds read lock on vma->mm->mmap_lock.\n\t * If this function returns NULL, it does not hold any reference or\n\t * lock.\n\t */\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_vma = info->vma;\n\t\t/* In case of lock contention, drop mmap_lock to unblock\n\t\t * the writer.\n\t\t *\n\t\t * After relock, call find(mm, prev_vm_end - 1) to find\n\t\t * new vma to process.\n\t\t *\n\t\t *   +------+------+-----------+\n\t\t *   | VMA1 | VMA2 | VMA3      |\n\t\t *   +------+------+-----------+\n\t\t *   |      |      |           |\n\t\t *  4k     8k     16k         400k\n\t\t *\n\t\t * For example, curr_vma == VMA2. Before unlock, we set\n\t\t *\n\t\t *    prev_vm_start = 8k\n\t\t *    prev_vm_end   = 16k\n\t\t *\n\t\t * There are a few cases:\n\t\t *\n\t\t * 1) VMA2 is freed, but VMA3 exists.\n\t\t *\n\t\t *    find_vma() will return VMA3, just process VMA3.\n\t\t *\n\t\t * 2) VMA2 still exists.\n\t\t *\n\t\t *    find_vma() will return VMA2, process VMA2->next.\n\t\t *\n\t\t * 3) no more vma in this mm.\n\t\t *\n\t\t *    Process the next task.\n\t\t *\n\t\t * 4) find_vma() returns a different vma, VMA2'.\n\t\t *\n\t\t *    4.1) If VMA2 covers same range as VMA2', skip VMA2',\n\t\t *         because we already covered the range;\n\t\t *    4.2) VMA2 and VMA2' covers different ranges, process\n\t\t *         VMA2'.\n\t\t */\n\t\tif (mmap_lock_is_contended(curr_task->mm)) {\n\t\t\tinfo->prev_vm_start = curr_vma->vm_start;\n\t\t\tinfo->prev_vm_end = curr_vma->vm_end;\n\t\t\top = task_vma_iter_find_vma;\n\t\t\tmmap_read_unlock(curr_task->mm);\n\t\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\t\tgoto finish;\n\t\t} else {\n\t\t\top = task_vma_iter_next_vma;\n\t\t}\n\t} else {\nagain:\n\t\tcurr_task = task_seq_get_next(ns, &curr_tid, true);\n\t\tif (!curr_task) {\n\t\t\tinfo->tid = curr_tid + 1;\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (curr_tid != info->tid) {\n\t\t\tinfo->tid = curr_tid;\n\t\t\t/* new task, process the first vma */\n\t\t\top = task_vma_iter_first_vma;\n\t\t} else {\n\t\t\t/* Found the same tid, which means the user space\n\t\t\t * finished data in previous buffer and read more.\n\t\t\t * We dropped mmap_lock before returning to user\n\t\t\t * space, so it is necessary to use find_vma() to\n\t\t\t * find the next vma to process.\n\t\t\t */\n\t\t\top = task_vma_iter_find_vma;\n\t\t}\n\n\t\tif (!curr_task->mm)\n\t\t\tgoto next_task;\n\n\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\tgoto finish;\n\t}\n\n\tswitch (op) {\n\tcase task_vma_iter_first_vma:\n\t\tcurr_vma = curr_task->mm->mmap;\n\t\tbreak;\n\tcase task_vma_iter_next_vma:\n\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\tcase task_vma_iter_find_vma:\n\t\t/* We dropped mmap_lock so it is necessary to use find_vma\n\t\t * to find the next vma. This is similar to the  mechanism\n\t\t * in show_smaps_rollup().\n\t\t */\n\t\tcurr_vma = find_vma(curr_task->mm, info->prev_vm_end - 1);\n\t\t/* case 1) and 4.2) above just use curr_vma */\n\n\t\t/* check for case 2) or case 4.1) above */\n\t\tif (curr_vma &&\n\t\t    curr_vma->vm_start == info->prev_vm_start &&\n\t\t    curr_vma->vm_end == info->prev_vm_end)\n\t\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\t}\n\tif (!curr_vma) {\n\t\t/* case 3) above, or case 2) 4.1) with vma->next == NULL */\n\t\tmmap_read_unlock(curr_task->mm);\n\t\tgoto next_task;\n\t}\n\tinfo->task = curr_task;\n\tinfo->vma = curr_vma;\n\treturn curr_vma;\n\nnext_task:\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tcurr_tid++;\n\tgoto again;\n\nfinish:\n\tif (curr_task)\n\t\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->vma = NULL;\n\treturn NULL;\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct vm_area_struct *\ntask_vma_seq_get_next(struct bpf_iter_seq_task_vma_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tenum bpf_task_vma_iter_find_op op;\n\tstruct vm_area_struct *curr_vma;\n\tstruct task_struct *curr_task;\n\tu32 curr_tid = info->tid;\n\n\t/* If this function returns a non-NULL vma, it holds a reference to\n\t * the task_struct, and holds read lock on vma->mm->mmap_lock.\n\t * If this function returns NULL, it does not hold any reference or\n\t * lock.\n\t */\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_vma = info->vma;\n\t\t/* In case of lock contention, drop mmap_lock to unblock\n\t\t * the writer.\n\t\t *\n\t\t * After relock, call find(mm, prev_vm_end - 1) to find\n\t\t * new vma to process.\n\t\t *\n\t\t *   +------+------+-----------+\n\t\t *   | VMA1 | VMA2 | VMA3      |\n\t\t *   +------+------+-----------+\n\t\t *   |      |      |           |\n\t\t *  4k     8k     16k         400k\n\t\t *\n\t\t * For example, curr_vma == VMA2. Before unlock, we set\n\t\t *\n\t\t *    prev_vm_start = 8k\n\t\t *    prev_vm_end   = 16k\n\t\t *\n\t\t * There are a few cases:\n\t\t *\n\t\t * 1) VMA2 is freed, but VMA3 exists.\n\t\t *\n\t\t *    find_vma() will return VMA3, just process VMA3.\n\t\t *\n\t\t * 2) VMA2 still exists.\n\t\t *\n\t\t *    find_vma() will return VMA2, process VMA2->next.\n\t\t *\n\t\t * 3) no more vma in this mm.\n\t\t *\n\t\t *    Process the next task.\n\t\t *\n\t\t * 4) find_vma() returns a different vma, VMA2'.\n\t\t *\n\t\t *    4.1) If VMA2 covers same range as VMA2', skip VMA2',\n\t\t *         because we already covered the range;\n\t\t *    4.2) VMA2 and VMA2' covers different ranges, process\n\t\t *         VMA2'.\n\t\t */\n\t\tif (mmap_lock_is_contended(curr_task->mm)) {\n\t\t\tinfo->prev_vm_start = curr_vma->vm_start;\n\t\t\tinfo->prev_vm_end = curr_vma->vm_end;\n\t\t\top = task_vma_iter_find_vma;\n\t\t\tmmap_read_unlock(curr_task->mm);\n\t\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\t\tgoto finish;\n\t\t} else {\n\t\t\top = task_vma_iter_next_vma;\n\t\t}\n\t} else {\nagain:\n\t\tcurr_task = task_seq_get_next(ns, &curr_tid, true);\n\t\tif (!curr_task) {\n\t\t\tinfo->tid = curr_tid + 1;\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (curr_tid != info->tid) {\n\t\t\tinfo->tid = curr_tid;\n\t\t\t/* new task, process the first vma */\n\t\t\top = task_vma_iter_first_vma;\n\t\t} else {\n\t\t\t/* Found the same tid, which means the user space\n\t\t\t * finished data in previous buffer and read more.\n\t\t\t * We dropped mmap_lock before returning to user\n\t\t\t * space, so it is necessary to use find_vma() to\n\t\t\t * find the next vma to process.\n\t\t\t */\n\t\t\top = task_vma_iter_find_vma;\n\t\t}\n\n\t\tif (!curr_task->mm)\n\t\t\tgoto next_task;\n\n\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\tgoto finish;\n\t}\n\n\tswitch (op) {\n\tcase task_vma_iter_first_vma:\n\t\tcurr_vma = curr_task->mm->mmap;\n\t\tbreak;\n\tcase task_vma_iter_next_vma:\n\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\tcase task_vma_iter_find_vma:\n\t\t/* We dropped mmap_lock so it is necessary to use find_vma\n\t\t * to find the next vma. This is similar to the  mechanism\n\t\t * in show_smaps_rollup().\n\t\t */\n\t\tcurr_vma = find_vma(curr_task->mm, info->prev_vm_end - 1);\n\t\t/* case 1) and 4.2) above just use curr_vma */\n\n\t\t/* check for case 2) or case 4.1) above */\n\t\tif (curr_vma &&\n\t\t    curr_vma->vm_start == info->prev_vm_start &&\n\t\t    curr_vma->vm_end == info->prev_vm_end)\n\t\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\t}\n\tif (!curr_vma) {\n\t\t/* case 3) above, or case 2) 4.1) with vma->next == NULL */\n\t\tmmap_read_unlock(curr_task->mm);\n\t\tgoto next_task;\n\t}\n\tinfo->task = curr_task;\n\tinfo->vma = curr_vma;\n\treturn curr_vma;\n\nnext_task:\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tcurr_tid++;\n\tgoto again;\n\nfinish:\n\tif (curr_task)\n\t\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->vma = NULL;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void *task_vma_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\n\t++*pos;\n\treturn task_vma_seq_get_next(info);\n}"
  },
  {
    "function_name": "task_vma_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "447-457",
    "snippet": "static void *task_vma_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct vm_area_struct *vma;\n\n\tvma = task_vma_seq_get_next(info);\n\tif (vma && *pos == 0)\n\t\t++*pos;\n\n\treturn vma;\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_vma_seq_get_next",
          "args": [
            "info"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "task_vma_seq_get_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "308-445",
          "snippet": "static struct vm_area_struct *\ntask_vma_seq_get_next(struct bpf_iter_seq_task_vma_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tenum bpf_task_vma_iter_find_op op;\n\tstruct vm_area_struct *curr_vma;\n\tstruct task_struct *curr_task;\n\tu32 curr_tid = info->tid;\n\n\t/* If this function returns a non-NULL vma, it holds a reference to\n\t * the task_struct, and holds read lock on vma->mm->mmap_lock.\n\t * If this function returns NULL, it does not hold any reference or\n\t * lock.\n\t */\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_vma = info->vma;\n\t\t/* In case of lock contention, drop mmap_lock to unblock\n\t\t * the writer.\n\t\t *\n\t\t * After relock, call find(mm, prev_vm_end - 1) to find\n\t\t * new vma to process.\n\t\t *\n\t\t *   +------+------+-----------+\n\t\t *   | VMA1 | VMA2 | VMA3      |\n\t\t *   +------+------+-----------+\n\t\t *   |      |      |           |\n\t\t *  4k     8k     16k         400k\n\t\t *\n\t\t * For example, curr_vma == VMA2. Before unlock, we set\n\t\t *\n\t\t *    prev_vm_start = 8k\n\t\t *    prev_vm_end   = 16k\n\t\t *\n\t\t * There are a few cases:\n\t\t *\n\t\t * 1) VMA2 is freed, but VMA3 exists.\n\t\t *\n\t\t *    find_vma() will return VMA3, just process VMA3.\n\t\t *\n\t\t * 2) VMA2 still exists.\n\t\t *\n\t\t *    find_vma() will return VMA2, process VMA2->next.\n\t\t *\n\t\t * 3) no more vma in this mm.\n\t\t *\n\t\t *    Process the next task.\n\t\t *\n\t\t * 4) find_vma() returns a different vma, VMA2'.\n\t\t *\n\t\t *    4.1) If VMA2 covers same range as VMA2', skip VMA2',\n\t\t *         because we already covered the range;\n\t\t *    4.2) VMA2 and VMA2' covers different ranges, process\n\t\t *         VMA2'.\n\t\t */\n\t\tif (mmap_lock_is_contended(curr_task->mm)) {\n\t\t\tinfo->prev_vm_start = curr_vma->vm_start;\n\t\t\tinfo->prev_vm_end = curr_vma->vm_end;\n\t\t\top = task_vma_iter_find_vma;\n\t\t\tmmap_read_unlock(curr_task->mm);\n\t\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\t\tgoto finish;\n\t\t} else {\n\t\t\top = task_vma_iter_next_vma;\n\t\t}\n\t} else {\nagain:\n\t\tcurr_task = task_seq_get_next(ns, &curr_tid, true);\n\t\tif (!curr_task) {\n\t\t\tinfo->tid = curr_tid + 1;\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (curr_tid != info->tid) {\n\t\t\tinfo->tid = curr_tid;\n\t\t\t/* new task, process the first vma */\n\t\t\top = task_vma_iter_first_vma;\n\t\t} else {\n\t\t\t/* Found the same tid, which means the user space\n\t\t\t * finished data in previous buffer and read more.\n\t\t\t * We dropped mmap_lock before returning to user\n\t\t\t * space, so it is necessary to use find_vma() to\n\t\t\t * find the next vma to process.\n\t\t\t */\n\t\t\top = task_vma_iter_find_vma;\n\t\t}\n\n\t\tif (!curr_task->mm)\n\t\t\tgoto next_task;\n\n\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\tgoto finish;\n\t}\n\n\tswitch (op) {\n\tcase task_vma_iter_first_vma:\n\t\tcurr_vma = curr_task->mm->mmap;\n\t\tbreak;\n\tcase task_vma_iter_next_vma:\n\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\tcase task_vma_iter_find_vma:\n\t\t/* We dropped mmap_lock so it is necessary to use find_vma\n\t\t * to find the next vma. This is similar to the  mechanism\n\t\t * in show_smaps_rollup().\n\t\t */\n\t\tcurr_vma = find_vma(curr_task->mm, info->prev_vm_end - 1);\n\t\t/* case 1) and 4.2) above just use curr_vma */\n\n\t\t/* check for case 2) or case 4.1) above */\n\t\tif (curr_vma &&\n\t\t    curr_vma->vm_start == info->prev_vm_start &&\n\t\t    curr_vma->vm_end == info->prev_vm_end)\n\t\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\t}\n\tif (!curr_vma) {\n\t\t/* case 3) above, or case 2) 4.1) with vma->next == NULL */\n\t\tmmap_read_unlock(curr_task->mm);\n\t\tgoto next_task;\n\t}\n\tinfo->task = curr_task;\n\tinfo->vma = curr_vma;\n\treturn curr_vma;\n\nnext_task:\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tcurr_tid++;\n\tgoto again;\n\nfinish:\n\tif (curr_task)\n\t\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->vma = NULL;\n\treturn NULL;\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct vm_area_struct *\ntask_vma_seq_get_next(struct bpf_iter_seq_task_vma_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tenum bpf_task_vma_iter_find_op op;\n\tstruct vm_area_struct *curr_vma;\n\tstruct task_struct *curr_task;\n\tu32 curr_tid = info->tid;\n\n\t/* If this function returns a non-NULL vma, it holds a reference to\n\t * the task_struct, and holds read lock on vma->mm->mmap_lock.\n\t * If this function returns NULL, it does not hold any reference or\n\t * lock.\n\t */\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_vma = info->vma;\n\t\t/* In case of lock contention, drop mmap_lock to unblock\n\t\t * the writer.\n\t\t *\n\t\t * After relock, call find(mm, prev_vm_end - 1) to find\n\t\t * new vma to process.\n\t\t *\n\t\t *   +------+------+-----------+\n\t\t *   | VMA1 | VMA2 | VMA3      |\n\t\t *   +------+------+-----------+\n\t\t *   |      |      |           |\n\t\t *  4k     8k     16k         400k\n\t\t *\n\t\t * For example, curr_vma == VMA2. Before unlock, we set\n\t\t *\n\t\t *    prev_vm_start = 8k\n\t\t *    prev_vm_end   = 16k\n\t\t *\n\t\t * There are a few cases:\n\t\t *\n\t\t * 1) VMA2 is freed, but VMA3 exists.\n\t\t *\n\t\t *    find_vma() will return VMA3, just process VMA3.\n\t\t *\n\t\t * 2) VMA2 still exists.\n\t\t *\n\t\t *    find_vma() will return VMA2, process VMA2->next.\n\t\t *\n\t\t * 3) no more vma in this mm.\n\t\t *\n\t\t *    Process the next task.\n\t\t *\n\t\t * 4) find_vma() returns a different vma, VMA2'.\n\t\t *\n\t\t *    4.1) If VMA2 covers same range as VMA2', skip VMA2',\n\t\t *         because we already covered the range;\n\t\t *    4.2) VMA2 and VMA2' covers different ranges, process\n\t\t *         VMA2'.\n\t\t */\n\t\tif (mmap_lock_is_contended(curr_task->mm)) {\n\t\t\tinfo->prev_vm_start = curr_vma->vm_start;\n\t\t\tinfo->prev_vm_end = curr_vma->vm_end;\n\t\t\top = task_vma_iter_find_vma;\n\t\t\tmmap_read_unlock(curr_task->mm);\n\t\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\t\tgoto finish;\n\t\t} else {\n\t\t\top = task_vma_iter_next_vma;\n\t\t}\n\t} else {\nagain:\n\t\tcurr_task = task_seq_get_next(ns, &curr_tid, true);\n\t\tif (!curr_task) {\n\t\t\tinfo->tid = curr_tid + 1;\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (curr_tid != info->tid) {\n\t\t\tinfo->tid = curr_tid;\n\t\t\t/* new task, process the first vma */\n\t\t\top = task_vma_iter_first_vma;\n\t\t} else {\n\t\t\t/* Found the same tid, which means the user space\n\t\t\t * finished data in previous buffer and read more.\n\t\t\t * We dropped mmap_lock before returning to user\n\t\t\t * space, so it is necessary to use find_vma() to\n\t\t\t * find the next vma to process.\n\t\t\t */\n\t\t\top = task_vma_iter_find_vma;\n\t\t}\n\n\t\tif (!curr_task->mm)\n\t\t\tgoto next_task;\n\n\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\tgoto finish;\n\t}\n\n\tswitch (op) {\n\tcase task_vma_iter_first_vma:\n\t\tcurr_vma = curr_task->mm->mmap;\n\t\tbreak;\n\tcase task_vma_iter_next_vma:\n\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\tcase task_vma_iter_find_vma:\n\t\t/* We dropped mmap_lock so it is necessary to use find_vma\n\t\t * to find the next vma. This is similar to the  mechanism\n\t\t * in show_smaps_rollup().\n\t\t */\n\t\tcurr_vma = find_vma(curr_task->mm, info->prev_vm_end - 1);\n\t\t/* case 1) and 4.2) above just use curr_vma */\n\n\t\t/* check for case 2) or case 4.1) above */\n\t\tif (curr_vma &&\n\t\t    curr_vma->vm_start == info->prev_vm_start &&\n\t\t    curr_vma->vm_end == info->prev_vm_end)\n\t\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\t}\n\tif (!curr_vma) {\n\t\t/* case 3) above, or case 2) 4.1) with vma->next == NULL */\n\t\tmmap_read_unlock(curr_task->mm);\n\t\tgoto next_task;\n\t}\n\tinfo->task = curr_task;\n\tinfo->vma = curr_vma;\n\treturn curr_vma;\n\nnext_task:\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tcurr_tid++;\n\tgoto again;\n\nfinish:\n\tif (curr_task)\n\t\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->vma = NULL;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void *task_vma_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct vm_area_struct *vma;\n\n\tvma = task_vma_seq_get_next(info);\n\tif (vma && *pos == 0)\n\t\t++*pos;\n\n\treturn vma;\n}"
  },
  {
    "function_name": "task_vma_seq_get_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "308-445",
    "snippet": "static struct vm_area_struct *\ntask_vma_seq_get_next(struct bpf_iter_seq_task_vma_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tenum bpf_task_vma_iter_find_op op;\n\tstruct vm_area_struct *curr_vma;\n\tstruct task_struct *curr_task;\n\tu32 curr_tid = info->tid;\n\n\t/* If this function returns a non-NULL vma, it holds a reference to\n\t * the task_struct, and holds read lock on vma->mm->mmap_lock.\n\t * If this function returns NULL, it does not hold any reference or\n\t * lock.\n\t */\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_vma = info->vma;\n\t\t/* In case of lock contention, drop mmap_lock to unblock\n\t\t * the writer.\n\t\t *\n\t\t * After relock, call find(mm, prev_vm_end - 1) to find\n\t\t * new vma to process.\n\t\t *\n\t\t *   +------+------+-----------+\n\t\t *   | VMA1 | VMA2 | VMA3      |\n\t\t *   +------+------+-----------+\n\t\t *   |      |      |           |\n\t\t *  4k     8k     16k         400k\n\t\t *\n\t\t * For example, curr_vma == VMA2. Before unlock, we set\n\t\t *\n\t\t *    prev_vm_start = 8k\n\t\t *    prev_vm_end   = 16k\n\t\t *\n\t\t * There are a few cases:\n\t\t *\n\t\t * 1) VMA2 is freed, but VMA3 exists.\n\t\t *\n\t\t *    find_vma() will return VMA3, just process VMA3.\n\t\t *\n\t\t * 2) VMA2 still exists.\n\t\t *\n\t\t *    find_vma() will return VMA2, process VMA2->next.\n\t\t *\n\t\t * 3) no more vma in this mm.\n\t\t *\n\t\t *    Process the next task.\n\t\t *\n\t\t * 4) find_vma() returns a different vma, VMA2'.\n\t\t *\n\t\t *    4.1) If VMA2 covers same range as VMA2', skip VMA2',\n\t\t *         because we already covered the range;\n\t\t *    4.2) VMA2 and VMA2' covers different ranges, process\n\t\t *         VMA2'.\n\t\t */\n\t\tif (mmap_lock_is_contended(curr_task->mm)) {\n\t\t\tinfo->prev_vm_start = curr_vma->vm_start;\n\t\t\tinfo->prev_vm_end = curr_vma->vm_end;\n\t\t\top = task_vma_iter_find_vma;\n\t\t\tmmap_read_unlock(curr_task->mm);\n\t\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\t\tgoto finish;\n\t\t} else {\n\t\t\top = task_vma_iter_next_vma;\n\t\t}\n\t} else {\nagain:\n\t\tcurr_task = task_seq_get_next(ns, &curr_tid, true);\n\t\tif (!curr_task) {\n\t\t\tinfo->tid = curr_tid + 1;\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (curr_tid != info->tid) {\n\t\t\tinfo->tid = curr_tid;\n\t\t\t/* new task, process the first vma */\n\t\t\top = task_vma_iter_first_vma;\n\t\t} else {\n\t\t\t/* Found the same tid, which means the user space\n\t\t\t * finished data in previous buffer and read more.\n\t\t\t * We dropped mmap_lock before returning to user\n\t\t\t * space, so it is necessary to use find_vma() to\n\t\t\t * find the next vma to process.\n\t\t\t */\n\t\t\top = task_vma_iter_find_vma;\n\t\t}\n\n\t\tif (!curr_task->mm)\n\t\t\tgoto next_task;\n\n\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\tgoto finish;\n\t}\n\n\tswitch (op) {\n\tcase task_vma_iter_first_vma:\n\t\tcurr_vma = curr_task->mm->mmap;\n\t\tbreak;\n\tcase task_vma_iter_next_vma:\n\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\tcase task_vma_iter_find_vma:\n\t\t/* We dropped mmap_lock so it is necessary to use find_vma\n\t\t * to find the next vma. This is similar to the  mechanism\n\t\t * in show_smaps_rollup().\n\t\t */\n\t\tcurr_vma = find_vma(curr_task->mm, info->prev_vm_end - 1);\n\t\t/* case 1) and 4.2) above just use curr_vma */\n\n\t\t/* check for case 2) or case 4.1) above */\n\t\tif (curr_vma &&\n\t\t    curr_vma->vm_start == info->prev_vm_start &&\n\t\t    curr_vma->vm_end == info->prev_vm_end)\n\t\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\t}\n\tif (!curr_vma) {\n\t\t/* case 3) above, or case 2) 4.1) with vma->next == NULL */\n\t\tmmap_read_unlock(curr_task->mm);\n\t\tgoto next_task;\n\t}\n\tinfo->task = curr_task;\n\tinfo->vma = curr_vma;\n\treturn curr_vma;\n\nnext_task:\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tcurr_tid++;\n\tgoto again;\n\nfinish:\n\tif (curr_task)\n\t\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->vma = NULL;\n\treturn NULL;\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "curr_task"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmap_read_unlock",
          "args": [
            "curr_task->mm"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "curr_task->mm",
            "info->prev_vm_end - 1"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_read_lock_killable",
          "args": [
            "curr_task->mm"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_seq_get_next",
          "args": [
            "ns",
            "&curr_tid",
            "true"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "task_seq_get_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "25-52",
          "snippet": "static struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmap_read_lock_killable",
          "args": [
            "curr_task->mm"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_lock_is_contended",
          "args": [
            "curr_task->mm"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct vm_area_struct *\ntask_vma_seq_get_next(struct bpf_iter_seq_task_vma_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tenum bpf_task_vma_iter_find_op op;\n\tstruct vm_area_struct *curr_vma;\n\tstruct task_struct *curr_task;\n\tu32 curr_tid = info->tid;\n\n\t/* If this function returns a non-NULL vma, it holds a reference to\n\t * the task_struct, and holds read lock on vma->mm->mmap_lock.\n\t * If this function returns NULL, it does not hold any reference or\n\t * lock.\n\t */\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_vma = info->vma;\n\t\t/* In case of lock contention, drop mmap_lock to unblock\n\t\t * the writer.\n\t\t *\n\t\t * After relock, call find(mm, prev_vm_end - 1) to find\n\t\t * new vma to process.\n\t\t *\n\t\t *   +------+------+-----------+\n\t\t *   | VMA1 | VMA2 | VMA3      |\n\t\t *   +------+------+-----------+\n\t\t *   |      |      |           |\n\t\t *  4k     8k     16k         400k\n\t\t *\n\t\t * For example, curr_vma == VMA2. Before unlock, we set\n\t\t *\n\t\t *    prev_vm_start = 8k\n\t\t *    prev_vm_end   = 16k\n\t\t *\n\t\t * There are a few cases:\n\t\t *\n\t\t * 1) VMA2 is freed, but VMA3 exists.\n\t\t *\n\t\t *    find_vma() will return VMA3, just process VMA3.\n\t\t *\n\t\t * 2) VMA2 still exists.\n\t\t *\n\t\t *    find_vma() will return VMA2, process VMA2->next.\n\t\t *\n\t\t * 3) no more vma in this mm.\n\t\t *\n\t\t *    Process the next task.\n\t\t *\n\t\t * 4) find_vma() returns a different vma, VMA2'.\n\t\t *\n\t\t *    4.1) If VMA2 covers same range as VMA2', skip VMA2',\n\t\t *         because we already covered the range;\n\t\t *    4.2) VMA2 and VMA2' covers different ranges, process\n\t\t *         VMA2'.\n\t\t */\n\t\tif (mmap_lock_is_contended(curr_task->mm)) {\n\t\t\tinfo->prev_vm_start = curr_vma->vm_start;\n\t\t\tinfo->prev_vm_end = curr_vma->vm_end;\n\t\t\top = task_vma_iter_find_vma;\n\t\t\tmmap_read_unlock(curr_task->mm);\n\t\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\t\tgoto finish;\n\t\t} else {\n\t\t\top = task_vma_iter_next_vma;\n\t\t}\n\t} else {\nagain:\n\t\tcurr_task = task_seq_get_next(ns, &curr_tid, true);\n\t\tif (!curr_task) {\n\t\t\tinfo->tid = curr_tid + 1;\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (curr_tid != info->tid) {\n\t\t\tinfo->tid = curr_tid;\n\t\t\t/* new task, process the first vma */\n\t\t\top = task_vma_iter_first_vma;\n\t\t} else {\n\t\t\t/* Found the same tid, which means the user space\n\t\t\t * finished data in previous buffer and read more.\n\t\t\t * We dropped mmap_lock before returning to user\n\t\t\t * space, so it is necessary to use find_vma() to\n\t\t\t * find the next vma to process.\n\t\t\t */\n\t\t\top = task_vma_iter_find_vma;\n\t\t}\n\n\t\tif (!curr_task->mm)\n\t\t\tgoto next_task;\n\n\t\tif (mmap_read_lock_killable(curr_task->mm))\n\t\t\tgoto finish;\n\t}\n\n\tswitch (op) {\n\tcase task_vma_iter_first_vma:\n\t\tcurr_vma = curr_task->mm->mmap;\n\t\tbreak;\n\tcase task_vma_iter_next_vma:\n\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\tcase task_vma_iter_find_vma:\n\t\t/* We dropped mmap_lock so it is necessary to use find_vma\n\t\t * to find the next vma. This is similar to the  mechanism\n\t\t * in show_smaps_rollup().\n\t\t */\n\t\tcurr_vma = find_vma(curr_task->mm, info->prev_vm_end - 1);\n\t\t/* case 1) and 4.2) above just use curr_vma */\n\n\t\t/* check for case 2) or case 4.1) above */\n\t\tif (curr_vma &&\n\t\t    curr_vma->vm_start == info->prev_vm_start &&\n\t\t    curr_vma->vm_end == info->prev_vm_end)\n\t\t\tcurr_vma = curr_vma->vm_next;\n\t\tbreak;\n\t}\n\tif (!curr_vma) {\n\t\t/* case 3) above, or case 2) 4.1) with vma->next == NULL */\n\t\tmmap_read_unlock(curr_task->mm);\n\t\tgoto next_task;\n\t}\n\tinfo->task = curr_task;\n\tinfo->vma = curr_vma;\n\treturn curr_vma;\n\nnext_task:\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tcurr_tid++;\n\tgoto again;\n\nfinish:\n\tif (curr_task)\n\t\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->vma = NULL;\n\treturn NULL;\n}"
  },
  {
    "function_name": "fini_seq_pidns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "276-281",
    "snippet": "static void fini_seq_pidns(void *priv_data)\n{\n\tstruct bpf_iter_seq_task_common *common = priv_data;\n\n\tput_pid_ns(common->ns);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "common->ns"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid_namespace.c",
          "lines": "152-163",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void fini_seq_pidns(void *priv_data)\n{\n\tstruct bpf_iter_seq_task_common *common = priv_data;\n\n\tput_pid_ns(common->ns);\n}"
  },
  {
    "function_name": "init_seq_pidns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "268-274",
    "snippet": "static int init_seq_pidns(void *priv_data, struct bpf_iter_aux_info *aux)\n{\n\tstruct bpf_iter_seq_task_common *common = priv_data;\n\n\tcommon->ns = get_pid_ns(task_active_pid_ns(current));\n\treturn 0;\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "task_active_pid_ns(current)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int init_seq_pidns(void *priv_data, struct bpf_iter_aux_info *aux)\n{\n\tstruct bpf_iter_seq_task_common *common = priv_data;\n\n\tcommon->ns = get_pid_ns(task_active_pid_ns(current));\n\treturn 0;\n}"
  },
  {
    "function_name": "task_file_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "255-266",
    "snippet": "static void task_file_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\n\tif (!v) {\n\t\t(void)__task_file_seq_show(seq, v, true);\n\t} else {\n\t\tfput((struct file *)v);\n\t\tput_task_struct(info->task);\n\t\tinfo->task = NULL;\n\t}\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "info->task"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "(struct file *)v"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_file_seq_show",
          "args": [
            "seq",
            "v",
            "true"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__task_file_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "230-248",
          "snippet": "static int __task_file_seq_show(struct seq_file *seq, struct file *file,\n\t\t\t\tbool in_stop)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct bpf_iter__task_file ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.fd = info->fd;\n\tctx.file = file;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_file_seq_show(struct seq_file *seq, struct file *file,\n\t\t\t\tbool in_stop)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct bpf_iter__task_file ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.fd = info->fd;\n\tctx.file = file;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void task_file_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\n\tif (!v) {\n\t\t(void)__task_file_seq_show(seq, v, true);\n\t} else {\n\t\tfput((struct file *)v);\n\t\tput_task_struct(info->task);\n\t\tinfo->task = NULL;\n\t}\n}"
  },
  {
    "function_name": "task_file_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "250-253",
    "snippet": "static int task_file_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_file_seq_show(seq, v, false);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__task_file_seq_show",
          "args": [
            "seq",
            "v",
            "false"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "__task_file_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "230-248",
          "snippet": "static int __task_file_seq_show(struct seq_file *seq, struct file *file,\n\t\t\t\tbool in_stop)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct bpf_iter__task_file ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.fd = info->fd;\n\tctx.file = file;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_file_seq_show(struct seq_file *seq, struct file *file,\n\t\t\t\tbool in_stop)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct bpf_iter__task_file ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.fd = info->fd;\n\tctx.file = file;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int task_file_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_file_seq_show(seq, v, false);\n}"
  },
  {
    "function_name": "__task_file_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "230-248",
    "snippet": "static int __task_file_seq_show(struct seq_file *seq, struct file *file,\n\t\t\t\tbool in_stop)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct bpf_iter__task_file ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.fd = info->fd;\n\tctx.file = file;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_iter_run_prog",
          "args": [
            "prog",
            "&ctx"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_run_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "683-700",
          "snippet": "int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nint bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_iter_get_info",
          "args": [
            "&meta",
            "in_stop"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_get_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "660-681",
          "snippet": "struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic64_t session_id;",
            "const struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic atomic64_t session_id;\nconst struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};\n\nstruct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_file_seq_show(struct seq_file *seq, struct file *file,\n\t\t\t\tbool in_stop)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct bpf_iter__task_file ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.fd = info->fd;\n\tctx.file = file;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
  },
  {
    "function_name": "task_file_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "209-217",
    "snippet": "static void *task_file_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\n\t++*pos;\n\t++info->fd;\n\tfput((struct file *)v);\n\treturn task_file_seq_get_next(info);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_file_seq_get_next",
          "args": [
            "info"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "task_file_seq_get_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "138-194",
          "snippet": "static struct file *\ntask_file_seq_get_next(struct bpf_iter_seq_task_file_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tu32 curr_tid = info->tid;\n\tstruct task_struct *curr_task;\n\tunsigned int curr_fd = info->fd;\n\n\t/* If this function returns a non-NULL file object,\n\t * it held a reference to the task/file.\n\t * Otherwise, it does not hold any reference.\n\t */\nagain:\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_fd = info->fd;\n\t} else {\n                curr_task = task_seq_get_next(ns, &curr_tid, true);\n                if (!curr_task) {\n                        info->task = NULL;\n                        info->tid = curr_tid;\n                        return NULL;\n                }\n\n                /* set info->task and info->tid */\n\t\tinfo->task = curr_task;\n\t\tif (curr_tid == info->tid) {\n\t\t\tcurr_fd = info->fd;\n\t\t} else {\n\t\t\tinfo->tid = curr_tid;\n\t\t\tcurr_fd = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tfor (;; curr_fd++) {\n\t\tstruct file *f;\n\t\tf = task_lookup_next_fd_rcu(curr_task, &curr_fd);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tif (!get_file_rcu(f))\n\t\t\tcontinue;\n\n\t\t/* set info->fd */\n\t\tinfo->fd = curr_fd;\n\t\trcu_read_unlock();\n\t\treturn f;\n\t}\n\n\t/* the current task is done, go to the next task */\n\trcu_read_unlock();\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->fd = 0;\n\tcurr_tid = ++(info->tid);\n\tgoto again;\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct file *\ntask_file_seq_get_next(struct bpf_iter_seq_task_file_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tu32 curr_tid = info->tid;\n\tstruct task_struct *curr_task;\n\tunsigned int curr_fd = info->fd;\n\n\t/* If this function returns a non-NULL file object,\n\t * it held a reference to the task/file.\n\t * Otherwise, it does not hold any reference.\n\t */\nagain:\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_fd = info->fd;\n\t} else {\n                curr_task = task_seq_get_next(ns, &curr_tid, true);\n                if (!curr_task) {\n                        info->task = NULL;\n                        info->tid = curr_tid;\n                        return NULL;\n                }\n\n                /* set info->task and info->tid */\n\t\tinfo->task = curr_task;\n\t\tif (curr_tid == info->tid) {\n\t\t\tcurr_fd = info->fd;\n\t\t} else {\n\t\t\tinfo->tid = curr_tid;\n\t\t\tcurr_fd = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tfor (;; curr_fd++) {\n\t\tstruct file *f;\n\t\tf = task_lookup_next_fd_rcu(curr_task, &curr_fd);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tif (!get_file_rcu(f))\n\t\t\tcontinue;\n\n\t\t/* set info->fd */\n\t\tinfo->fd = curr_fd;\n\t\trcu_read_unlock();\n\t\treturn f;\n\t}\n\n\t/* the current task is done, go to the next task */\n\trcu_read_unlock();\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->fd = 0;\n\tcurr_tid = ++(info->tid);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "(struct file *)v"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void *task_file_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\n\t++*pos;\n\t++info->fd;\n\tfput((struct file *)v);\n\treturn task_file_seq_get_next(info);\n}"
  },
  {
    "function_name": "task_file_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "196-207",
    "snippet": "static void *task_file_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct file *file;\n\n\tinfo->task = NULL;\n\tfile = task_file_seq_get_next(info);\n\tif (file && *pos == 0)\n\t\t++*pos;\n\n\treturn file;\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_file_seq_get_next",
          "args": [
            "info"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "task_file_seq_get_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "138-194",
          "snippet": "static struct file *\ntask_file_seq_get_next(struct bpf_iter_seq_task_file_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tu32 curr_tid = info->tid;\n\tstruct task_struct *curr_task;\n\tunsigned int curr_fd = info->fd;\n\n\t/* If this function returns a non-NULL file object,\n\t * it held a reference to the task/file.\n\t * Otherwise, it does not hold any reference.\n\t */\nagain:\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_fd = info->fd;\n\t} else {\n                curr_task = task_seq_get_next(ns, &curr_tid, true);\n                if (!curr_task) {\n                        info->task = NULL;\n                        info->tid = curr_tid;\n                        return NULL;\n                }\n\n                /* set info->task and info->tid */\n\t\tinfo->task = curr_task;\n\t\tif (curr_tid == info->tid) {\n\t\t\tcurr_fd = info->fd;\n\t\t} else {\n\t\t\tinfo->tid = curr_tid;\n\t\t\tcurr_fd = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tfor (;; curr_fd++) {\n\t\tstruct file *f;\n\t\tf = task_lookup_next_fd_rcu(curr_task, &curr_fd);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tif (!get_file_rcu(f))\n\t\t\tcontinue;\n\n\t\t/* set info->fd */\n\t\tinfo->fd = curr_fd;\n\t\trcu_read_unlock();\n\t\treturn f;\n\t}\n\n\t/* the current task is done, go to the next task */\n\trcu_read_unlock();\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->fd = 0;\n\tcurr_tid = ++(info->tid);\n\tgoto again;\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct file *\ntask_file_seq_get_next(struct bpf_iter_seq_task_file_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tu32 curr_tid = info->tid;\n\tstruct task_struct *curr_task;\n\tunsigned int curr_fd = info->fd;\n\n\t/* If this function returns a non-NULL file object,\n\t * it held a reference to the task/file.\n\t * Otherwise, it does not hold any reference.\n\t */\nagain:\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_fd = info->fd;\n\t} else {\n                curr_task = task_seq_get_next(ns, &curr_tid, true);\n                if (!curr_task) {\n                        info->task = NULL;\n                        info->tid = curr_tid;\n                        return NULL;\n                }\n\n                /* set info->task and info->tid */\n\t\tinfo->task = curr_task;\n\t\tif (curr_tid == info->tid) {\n\t\t\tcurr_fd = info->fd;\n\t\t} else {\n\t\t\tinfo->tid = curr_tid;\n\t\t\tcurr_fd = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tfor (;; curr_fd++) {\n\t\tstruct file *f;\n\t\tf = task_lookup_next_fd_rcu(curr_task, &curr_fd);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tif (!get_file_rcu(f))\n\t\t\tcontinue;\n\n\t\t/* set info->fd */\n\t\tinfo->fd = curr_fd;\n\t\trcu_read_unlock();\n\t\treturn f;\n\t}\n\n\t/* the current task is done, go to the next task */\n\trcu_read_unlock();\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->fd = 0;\n\tcurr_tid = ++(info->tid);\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void *task_file_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct file *file;\n\n\tinfo->task = NULL;\n\tfile = task_file_seq_get_next(info);\n\tif (file && *pos == 0)\n\t\t++*pos;\n\n\treturn file;\n}"
  },
  {
    "function_name": "task_file_seq_get_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "138-194",
    "snippet": "static struct file *\ntask_file_seq_get_next(struct bpf_iter_seq_task_file_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tu32 curr_tid = info->tid;\n\tstruct task_struct *curr_task;\n\tunsigned int curr_fd = info->fd;\n\n\t/* If this function returns a non-NULL file object,\n\t * it held a reference to the task/file.\n\t * Otherwise, it does not hold any reference.\n\t */\nagain:\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_fd = info->fd;\n\t} else {\n                curr_task = task_seq_get_next(ns, &curr_tid, true);\n                if (!curr_task) {\n                        info->task = NULL;\n                        info->tid = curr_tid;\n                        return NULL;\n                }\n\n                /* set info->task and info->tid */\n\t\tinfo->task = curr_task;\n\t\tif (curr_tid == info->tid) {\n\t\t\tcurr_fd = info->fd;\n\t\t} else {\n\t\t\tinfo->tid = curr_tid;\n\t\t\tcurr_fd = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tfor (;; curr_fd++) {\n\t\tstruct file *f;\n\t\tf = task_lookup_next_fd_rcu(curr_task, &curr_fd);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tif (!get_file_rcu(f))\n\t\t\tcontinue;\n\n\t\t/* set info->fd */\n\t\tinfo->fd = curr_fd;\n\t\trcu_read_unlock();\n\t\treturn f;\n\t}\n\n\t/* the current task is done, go to the next task */\n\trcu_read_unlock();\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->fd = 0;\n\tcurr_tid = ++(info->tid);\n\tgoto again;\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "curr_task"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file_rcu",
          "args": [
            "f"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lookup_next_fd_rcu",
          "args": [
            "curr_task",
            "&curr_fd"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_seq_get_next",
          "args": [
            "ns",
            "&curr_tid",
            "true"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "task_seq_get_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "25-52",
          "snippet": "static struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct file *\ntask_file_seq_get_next(struct bpf_iter_seq_task_file_info *info)\n{\n\tstruct pid_namespace *ns = info->common.ns;\n\tu32 curr_tid = info->tid;\n\tstruct task_struct *curr_task;\n\tunsigned int curr_fd = info->fd;\n\n\t/* If this function returns a non-NULL file object,\n\t * it held a reference to the task/file.\n\t * Otherwise, it does not hold any reference.\n\t */\nagain:\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_fd = info->fd;\n\t} else {\n                curr_task = task_seq_get_next(ns, &curr_tid, true);\n                if (!curr_task) {\n                        info->task = NULL;\n                        info->tid = curr_tid;\n                        return NULL;\n                }\n\n                /* set info->task and info->tid */\n\t\tinfo->task = curr_task;\n\t\tif (curr_tid == info->tid) {\n\t\t\tcurr_fd = info->fd;\n\t\t} else {\n\t\t\tinfo->tid = curr_tid;\n\t\t\tcurr_fd = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tfor (;; curr_fd++) {\n\t\tstruct file *f;\n\t\tf = task_lookup_next_fd_rcu(curr_task, &curr_fd);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tif (!get_file_rcu(f))\n\t\t\tcontinue;\n\n\t\t/* set info->fd */\n\t\tinfo->fd = curr_fd;\n\t\trcu_read_unlock();\n\t\treturn f;\n\t}\n\n\t/* the current task is done, go to the next task */\n\trcu_read_unlock();\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->fd = 0;\n\tcurr_tid = ++(info->tid);\n\tgoto again;\n}"
  },
  {
    "function_name": "task_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "113-119",
    "snippet": "static void task_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (!v)\n\t\t(void)__task_seq_show(seq, v, true);\n\telse\n\t\tput_task_struct((struct task_struct *)v);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "(struct task_struct *)v"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_seq_show",
          "args": [
            "seq",
            "v",
            "true"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__task_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "90-106",
          "snippet": "static int __task_seq_show(struct seq_file *seq, struct task_struct *task,\n\t\t\t   bool in_stop)\n{\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_iter__task ctx;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tmeta.seq = seq;\n\tctx.meta = &meta;\n\tctx.task = task;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_seq_show(struct seq_file *seq, struct task_struct *task,\n\t\t\t   bool in_stop)\n{\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_iter__task ctx;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tmeta.seq = seq;\n\tctx.meta = &meta;\n\tctx.task = task;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void task_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (!v)\n\t\t(void)__task_seq_show(seq, v, true);\n\telse\n\t\tput_task_struct((struct task_struct *)v);\n}"
  },
  {
    "function_name": "task_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "108-111",
    "snippet": "static int task_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_seq_show(seq, v, false);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__task_seq_show",
          "args": [
            "seq",
            "v",
            "false"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__task_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "90-106",
          "snippet": "static int __task_seq_show(struct seq_file *seq, struct task_struct *task,\n\t\t\t   bool in_stop)\n{\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_iter__task ctx;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tmeta.seq = seq;\n\tctx.meta = &meta;\n\tctx.task = task;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_seq_show(struct seq_file *seq, struct task_struct *task,\n\t\t\t   bool in_stop)\n{\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_iter__task ctx;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tmeta.seq = seq;\n\tctx.meta = &meta;\n\tctx.task = task;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int task_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_seq_show(seq, v, false);\n}"
  },
  {
    "function_name": "__task_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "90-106",
    "snippet": "static int __task_seq_show(struct seq_file *seq, struct task_struct *task,\n\t\t\t   bool in_stop)\n{\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_iter__task ctx;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tmeta.seq = seq;\n\tctx.meta = &meta;\n\tctx.task = task;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_iter_run_prog",
          "args": [
            "prog",
            "&ctx"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_run_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "683-700",
          "snippet": "int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nint bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_iter_get_info",
          "args": [
            "&meta",
            "in_stop"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_get_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "660-681",
          "snippet": "struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic64_t session_id;",
            "const struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic atomic64_t session_id;\nconst struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};\n\nstruct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic int __task_seq_show(struct seq_file *seq, struct task_struct *task,\n\t\t\t   bool in_stop)\n{\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_iter__task ctx;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tmeta.seq = seq;\n\tctx.meta = &meta;\n\tctx.task = task;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
  },
  {
    "function_name": "task_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "68-81",
    "snippet": "static void *task_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_info *info = seq->private;\n\tstruct task_struct *task;\n\n\t++*pos;\n\t++info->tid;\n\tput_task_struct((struct task_struct *)v);\n\ttask = task_seq_get_next(info->common.ns, &info->tid, false);\n\tif (!task)\n\t\treturn NULL;\n\n\treturn task;\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_seq_get_next",
          "args": [
            "info->common.ns",
            "&info->tid",
            "false"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "task_seq_get_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "25-52",
          "snippet": "static struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "(struct task_struct *)v"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void *task_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_info *info = seq->private;\n\tstruct task_struct *task;\n\n\t++*pos;\n\t++info->tid;\n\tput_task_struct((struct task_struct *)v);\n\ttask = task_seq_get_next(info->common.ns, &info->tid, false);\n\tif (!task)\n\t\treturn NULL;\n\n\treturn task;\n}"
  },
  {
    "function_name": "task_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "54-66",
    "snippet": "static void *task_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_info *info = seq->private;\n\tstruct task_struct *task;\n\n\ttask = task_seq_get_next(info->common.ns, &info->tid, false);\n\tif (!task)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\t++*pos;\n\treturn task;\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_seq_get_next",
          "args": [
            "info->common.ns",
            "&info->tid",
            "false"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "task_seq_get_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "25-52",
          "snippet": "static struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void *task_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_info *info = seq->private;\n\tstruct task_struct *task;\n\n\ttask = task_seq_get_next(info->common.ns, &info->tid, false);\n\tif (!task)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\t++*pos;\n\treturn task;\n}"
  },
  {
    "function_name": "task_seq_get_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
    "lines": "25-52",
    "snippet": "static struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}",
    "includes": [
      "#include \"mmap_unlock_work.h\"",
      "#include <linux/btf_ids.h>",
      "#include <linux/filter.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "task"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_nr_ns",
          "args": [
            "pid",
            "ns"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "pid_nr_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "472-483",
          "snippet": "pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_ge_pid",
          "args": [
            "*tid",
            "ns"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "find_ge_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "518-521",
          "snippet": "struct pid *find_ge_pid(int nr, struct pid_namespace *ns)\n{\n\treturn idr_get_next(&ns->idr, &nr);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_ge_pid(int nr, struct pid_namespace *ns)\n{\n\treturn idr_get_next(&ns->idr, &nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic struct task_struct *task_seq_get_next(struct pid_namespace *ns,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}"
  }
]