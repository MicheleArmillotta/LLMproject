[
  {
    "function_name": "syscall_exit_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "797-823",
    "snippet": "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_exit(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_exit(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysexit_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysexit_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_sysexit_disable",
          "args": [
            "event"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "perf_sysexit_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "753-765",
          "snippet": "static void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_sysexit_enable",
          "args": [
            "event"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "perf_sysexit_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "733-751",
          "snippet": "static int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreg_event_syscall_exit",
          "args": [
            "file",
            "event"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "unreg_event_syscall_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "442-457",
          "snippet": "static void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_exit(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_exit(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysexit_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysexit_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "syscall_enter_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "769-795",
    "snippet": "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_enter(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_enter(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysenter_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysenter_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_sysenter_disable",
          "args": [
            "event"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "perf_sysenter_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "657-669",
          "snippet": "static void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_sysenter_enable",
          "args": [
            "event"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "perf_sysenter_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "637-655",
          "snippet": "static int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreg_event_syscall_enter",
          "args": [
            "file",
            "event"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "unreg_event_syscall_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "404-419",
          "snippet": "static void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_enter(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_enter(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysenter_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysenter_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "perf_sysexit_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "753-765",
    "snippet": "static void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sys_exit",
          "args": [
            "perf_syscall_exit",
            "NULL"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "num",
            "enabled_perf_exit_syscalls"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}"
  },
  {
    "function_name": "perf_sysexit_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "733-751",
    "snippet": "static int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "num",
            "enabled_perf_exit_syscalls"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"event trace: Could not activate syscall exit trace point\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sys_exit",
          "args": [
            "perf_syscall_exit",
            "NULL"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_syscall_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "686-731",
    "snippet": "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->exit_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t/* We can probably do that at build time */\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_exit(sys_data->exit_event, regs, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx, sys_data->exit_event->event.type,\n\t\t\t      1, regs, head, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "rec",
            "size",
            "rctx",
            "sys_data->exit_event->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_swevent_put_recursion_context",
          "args": [
            "rctx"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "perf_swevent_put_recursion_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "9461-9466",
          "snippet": "void perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic DEFINE_PER_CPU(struct swevent_htable, swevent_htable);\n\nvoid perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_call_bpf_exit",
          "args": [
            "sys_data->exit_event",
            "regs",
            "rec"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "perf_call_bpf_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "671-684",
          "snippet": "static int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} param;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} param;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_return_value",
          "args": [
            "current",
            "regs"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "395-418",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(*rec) + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "sys_data->exit_event"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "sys_data->exit_event->perf_events"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall_nr"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "104-113",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "syscall_nr",
            "enabled_perf_exit_syscalls"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_syscall_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_syscall_nr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "75-79",
          "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->exit_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t/* We can probably do that at build time */\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_exit(sys_data->exit_event, regs, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx, sys_data->exit_event->event.type,\n\t\t\t      1, regs, head, NULL);\n}"
  },
  {
    "function_name": "perf_call_bpf_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "671-684",
    "snippet": "static int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} param;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "&param"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "95-133",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} param;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}"
  },
  {
    "function_name": "perf_sysenter_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "657-669",
    "snippet": "static void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sys_enter",
          "args": [
            "perf_syscall_enter",
            "NULL"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "num",
            "enabled_perf_enter_syscalls"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}"
  },
  {
    "function_name": "perf_sysenter_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "637-655",
    "snippet": "static int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "num",
            "enabled_perf_enter_syscalls"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"event trace: Could not activate syscall entry trace point\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sys_enter",
          "args": [
            "perf_syscall_enter",
            "NULL"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_syscall_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "586-635",
    "snippet": "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tunsigned long args[6];\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->enter_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t/* get the size after alignment with the u32 buffer size field */\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, args);\n\tmemcpy(&rec->args, args, sizeof(unsigned long) * sys_data->nb_args);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_enter(sys_data->enter_event, regs, sys_data, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx,\n\t\t\t      sys_data->enter_event->event.type, 1, regs,\n\t\t\t      head, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "rec",
            "size",
            "rctx",
            "sys_data->enter_event->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_swevent_put_recursion_context",
          "args": [
            "rctx"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "perf_swevent_put_recursion_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "9461-9466",
          "snippet": "void perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic DEFINE_PER_CPU(struct swevent_htable, swevent_htable);\n\nvoid perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_call_bpf_enter",
          "args": [
            "sys_data->enter_event",
            "regs",
            "sys_data",
            "rec"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "perf_call_bpf_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "568-584",
          "snippet": "static int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} param;\n\tint i;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} param;\n\tint i;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&rec->args",
            "args",
            "sizeof(unsigned long) * sys_data->nb_args"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_arguments",
          "args": [
            "current",
            "regs",
            "args"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "395-418",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "sys_data->enter_event"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "sys_data->enter_event->perf_events"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall_nr"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "104-113",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "syscall_nr",
            "enabled_perf_enter_syscalls"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_syscall_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_syscall_nr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "75-79",
          "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tunsigned long args[6];\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->enter_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t/* get the size after alignment with the u32 buffer size field */\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, args);\n\tmemcpy(&rec->args, args, sizeof(unsigned long) * sys_data->nb_args);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_enter(sys_data->enter_event, regs, sys_data, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx,\n\t\t\t      sys_data->enter_event->event.type, 1, regs,\n\t\t\t      head, NULL);\n}"
  },
  {
    "function_name": "perf_call_bpf_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "568-584",
    "snippet": "static int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} param;\n\tint i;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "&param"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "95-133",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} param;\n\tint i;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}"
  },
  {
    "function_name": "init_ftrace_syscalls",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "524-559",
    "snippet": "void __init init_ftrace_syscalls(void)\n{\n\tstruct syscall_metadata *meta;\n\tunsigned long addr;\n\tint i;\n\tvoid *ret;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {\n\t\tsyscalls_metadata = kcalloc(NR_syscalls,\n\t\t\t\t\tsizeof(*syscalls_metadata),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!syscalls_metadata) {\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n\t\taddr = arch_syscall_addr(i);\n\t\tmeta = find_syscall_meta(addr);\n\t\tif (!meta)\n\t\t\tcontinue;\n\n\t\tmeta->syscall_nr = i;\n\n\t\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {\n\t\t\tsyscalls_metadata[i] = meta;\n\t\t} else {\n\t\t\tret = xa_store(&syscalls_metadata_sparse, i, meta,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tWARN(xa_is_err(ret),\n\t\t\t\t\"Syscall memory allocation failed\\n\");\n\t\t}\n\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_XARRAY(syscalls_metadata_sparse);",
      "static struct syscall_metadata **syscalls_metadata;",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "xa_is_err(ret)",
            "\"Syscall memory allocation failed\\n\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_err",
          "args": [
            "ret"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_store",
          "args": [
            "&syscalls_metadata_sparse",
            "i",
            "meta",
            "GFP_KERNEL"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HAVE_SPARSE_SYSCALL_NR"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_syscall_meta",
          "args": [
            "addr"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "find_syscall_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "82-102",
          "snippet": "syscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct syscall_metadata *__start_syscalls_metadata[];",
            "extern struct syscall_metadata *__stop_syscalls_metadata[];",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nextern struct syscall_metadata *__start_syscalls_metadata[];\nextern struct syscall_metadata *__stop_syscalls_metadata[];\nstatic __init struct;\n\nsyscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_syscall_addr",
          "args": [
            "i"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "arch_syscall_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "519-522",
          "snippet": "unsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nunsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "NR_syscalls",
            "sizeof(*syscalls_metadata)",
            "GFP_KERNEL"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HAVE_SPARSE_SYSCALL_NR"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nvoid __init init_ftrace_syscalls(void)\n{\n\tstruct syscall_metadata *meta;\n\tunsigned long addr;\n\tint i;\n\tvoid *ret;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {\n\t\tsyscalls_metadata = kcalloc(NR_syscalls,\n\t\t\t\t\tsizeof(*syscalls_metadata),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!syscalls_metadata) {\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n\t\taddr = arch_syscall_addr(i);\n\t\tmeta = find_syscall_meta(addr);\n\t\tif (!meta)\n\t\t\tcontinue;\n\n\t\tmeta->syscall_nr = i;\n\n\t\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {\n\t\t\tsyscalls_metadata[i] = meta;\n\t\t} else {\n\t\t\tret = xa_store(&syscalls_metadata_sparse, i, meta,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tWARN(xa_is_err(ret),\n\t\t\t\t\"Syscall memory allocation failed\\n\");\n\t\t}\n\n\t}\n}"
  },
  {
    "function_name": "arch_syscall_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "519-522",
    "snippet": "unsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nunsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}"
  },
  {
    "function_name": "init_syscall_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "459-482",
    "snippet": "static int __init init_syscall_trace(struct trace_event_call *call)\n{\n\tint id;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (num < 0 || num >= NR_syscalls) {\n\t\tpr_debug(\"syscall %s metadata not mapped, disabling ftrace event\\n\",\n\t\t\t\t((struct syscall_metadata *)call->data)->name);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (set_syscall_print_fmt(call) < 0)\n\t\treturn -ENOMEM;\n\n\tid = trace_event_raw_init(call);\n\n\tif (id < 0) {\n\t\tfree_syscall_print_fmt(call);\n\t\treturn id;\n\t}\n\n\treturn id;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_syscall_print_fmt",
          "args": [
            "call"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "free_syscall_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "264-270",
          "snippet": "static void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_raw_init",
          "args": [
            "call"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_raw_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "429-440",
          "snippet": "int trace_event_raw_init(struct trace_event_call *call)\n{\n\tint id;\n\n\tid = register_trace_event(&call->event);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\ttest_event_printk(call);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_event_raw_init(struct trace_event_call *call)\n{\n\tint id;\n\n\tid = register_trace_event(&call->event);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\ttest_event_printk(call);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_syscall_print_fmt",
          "args": [
            "call"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "set_syscall_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "239-262",
          "snippet": "static int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"syscall %s metadata not mapped, disabling ftrace event\\n\"",
            "((struct syscall_metadata *)call->data)->name"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int __init init_syscall_trace(struct trace_event_call *call)\n{\n\tint id;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (num < 0 || num >= NR_syscalls) {\n\t\tpr_debug(\"syscall %s metadata not mapped, disabling ftrace event\\n\",\n\t\t\t\t((struct syscall_metadata *)call->data)->name);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (set_syscall_print_fmt(call) < 0)\n\t\treturn -ENOMEM;\n\n\tid = trace_event_raw_init(call);\n\n\tif (id < 0) {\n\t\tfree_syscall_print_fmt(call);\n\t\treturn id;\n\t}\n\n\treturn id;\n}"
  },
  {
    "function_name": "unreg_event_syscall_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "442-457",
    "snippet": "static void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sys_exit",
          "args": [
            "ftrace_syscall_exit",
            "tr"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "tr->exit_syscall_files[num]",
            "NULL"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "num < 0 || num >= NR_syscalls"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}"
  },
  {
    "function_name": "reg_event_syscall_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "421-440",
    "snippet": "static int reg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t  struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_exit)\n\t\tret = register_trace_sys_exit(ftrace_syscall_exit, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->exit_syscall_files[num], file);\n\t\ttr->sys_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->exit_syscall_files[num]",
            "file"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sys_exit",
          "args": [
            "ftrace_syscall_exit",
            "tr"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "num < 0 || num >= NR_syscalls"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int reg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t  struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_exit)\n\t\tret = register_trace_sys_exit(ftrace_syscall_exit, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->exit_syscall_files[num], file);\n\t\ttr->sys_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "unreg_event_syscall_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "404-419",
    "snippet": "static void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sys_enter",
          "args": [
            "ftrace_syscall_enter",
            "tr"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "tr->enter_syscall_files[num]",
            "NULL"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "num < 0 || num >= NR_syscalls"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}"
  },
  {
    "function_name": "reg_event_syscall_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "383-402",
    "snippet": "static int reg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t   struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_enter)\n\t\tret = register_trace_sys_enter(ftrace_syscall_enter, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->enter_syscall_files[num], file);\n\t\ttr->sys_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->enter_syscall_files[num]",
            "file"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sys_enter",
          "args": [
            "ftrace_syscall_enter",
            "tr"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "num < 0 || num >= NR_syscalls"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int reg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t   struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_enter)\n\t\tret = register_trace_sys_enter(ftrace_syscall_enter, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->enter_syscall_files[num], file);\n\t\ttr->sys_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_syscall_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "340-381",
    "snippet": "static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer;\n\tunsigned int trace_ctx;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\ttrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\ttrace_ctx);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry,\n\t\t\t\t    trace_ctx);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit",
          "args": [
            "trace_file",
            "buffer",
            "event",
            "entry",
            "trace_ctx"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1408-1421",
          "snippet": "static inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned int trace_ctx)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, trace_ctx);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned int trace_ctx)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, trace_ctx);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_return_value",
          "args": [
            "current",
            "regs"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&buffer",
            "trace_file",
            "sys_data->exit_event->event.type",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2739-2819",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\tstruct ring_buffer_event *entry;\n\tstruct trace_array *tr = trace_file->tr;\n\tint val;\n\n\t*current_rb = tr->array_buffer.buffer;\n\n\tif (!tr->no_filter_buffering_ref &&\n\t    (trace_file->flags & (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED))) {\n\t\tpreempt_disable_notrace();\n\t\t/*\n\t\t * Filtering is on, so try to use the per cpu buffer first.\n\t\t * This buffer will simulate a ring_buffer_event,\n\t\t * where the type_len is zero and the array[0] will\n\t\t * hold the full length.\n\t\t * (see include/linux/ring-buffer.h for details on\n\t\t *  how the ring_buffer_event is structured).\n\t\t *\n\t\t * Using a temp buffer during filtering and copying it\n\t\t * on a matched filter is quicker than writing directly\n\t\t * into the ring buffer and then discarding it when\n\t\t * it doesn't match. That is because the discard\n\t\t * requires several atomic operations to get right.\n\t\t * Copying on match and doing nothing on a failed match\n\t\t * is still quicker than no copy on match, but having\n\t\t * to discard out of the ring buffer on a failed match.\n\t\t */\n\t\tif ((entry = __this_cpu_read(trace_buffered_event))) {\n\t\t\tint max_len = PAGE_SIZE - struct_size(entry, array, 1);\n\n\t\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\n\t\t\t/*\n\t\t\t * Preemption is disabled, but interrupts and NMIs\n\t\t\t * can still come in now. If that happens after\n\t\t\t * the above increment, then it will have to go\n\t\t\t * back to the old method of allocating the event\n\t\t\t * on the ring buffer, and if the filter fails, it\n\t\t\t * will have to call ring_buffer_discard_commit()\n\t\t\t * to remove it.\n\t\t\t *\n\t\t\t * Need to also check the unlikely case that the\n\t\t\t * length is bigger than the temp buffer size.\n\t\t\t * If that happens, then the reserve is pretty much\n\t\t\t * guaranteed to fail, as the ring buffer currently\n\t\t\t * only allows events less than a page. But that may\n\t\t\t * change in the future, so let the ring buffer reserve\n\t\t\t * handle the failure in that case.\n\t\t\t */\n\t\t\tif (val == 1 && likely(len <= max_len)) {\n\t\t\t\ttrace_event_setup(entry, type, trace_ctx);\n\t\t\t\tentry->array[0] = len;\n\t\t\t\t/* Return with preemption disabled */\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t\t}\n\t\t/* __trace_buffer_lock_reserve() disables preemption */\n\t\tpreempt_enable_notrace();\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t    trace_ctx);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t\t    trace_ctx);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static struct trace_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic struct trace_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\tstruct ring_buffer_event *entry;\n\tstruct trace_array *tr = trace_file->tr;\n\tint val;\n\n\t*current_rb = tr->array_buffer.buffer;\n\n\tif (!tr->no_filter_buffering_ref &&\n\t    (trace_file->flags & (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED))) {\n\t\tpreempt_disable_notrace();\n\t\t/*\n\t\t * Filtering is on, so try to use the per cpu buffer first.\n\t\t * This buffer will simulate a ring_buffer_event,\n\t\t * where the type_len is zero and the array[0] will\n\t\t * hold the full length.\n\t\t * (see include/linux/ring-buffer.h for details on\n\t\t *  how the ring_buffer_event is structured).\n\t\t *\n\t\t * Using a temp buffer during filtering and copying it\n\t\t * on a matched filter is quicker than writing directly\n\t\t * into the ring buffer and then discarding it when\n\t\t * it doesn't match. That is because the discard\n\t\t * requires several atomic operations to get right.\n\t\t * Copying on match and doing nothing on a failed match\n\t\t * is still quicker than no copy on match, but having\n\t\t * to discard out of the ring buffer on a failed match.\n\t\t */\n\t\tif ((entry = __this_cpu_read(trace_buffered_event))) {\n\t\t\tint max_len = PAGE_SIZE - struct_size(entry, array, 1);\n\n\t\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\n\t\t\t/*\n\t\t\t * Preemption is disabled, but interrupts and NMIs\n\t\t\t * can still come in now. If that happens after\n\t\t\t * the above increment, then it will have to go\n\t\t\t * back to the old method of allocating the event\n\t\t\t * on the ring buffer, and if the filter fails, it\n\t\t\t * will have to call ring_buffer_discard_commit()\n\t\t\t * to remove it.\n\t\t\t *\n\t\t\t * Need to also check the unlikely case that the\n\t\t\t * length is bigger than the temp buffer size.\n\t\t\t * If that happens, then the reserve is pretty much\n\t\t\t * guaranteed to fail, as the ring buffer currently\n\t\t\t * only allows events less than a page. But that may\n\t\t\t * change in the future, so let the ring buffer reserve\n\t\t\t * handle the failure in that case.\n\t\t\t */\n\t\t\tif (val == 1 && likely(len <= max_len)) {\n\t\t\t\ttrace_event_setup(entry, type, trace_ctx);\n\t\t\t\tentry->array[0] = len;\n\t\t\t\t/* Return with preemption disabled */\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t\t}\n\t\t/* __trace_buffer_lock_reserve() disables preemption */\n\t\tpreempt_enable_notrace();\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t    trace_ctx);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t\t    trace_ctx);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall_nr"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "104-113",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->exit_syscall_files[syscall_nr]"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_syscall_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_syscall_nr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "75-79",
          "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer;\n\tunsigned int trace_ctx;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\ttrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\ttrace_ctx);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry,\n\t\t\t\t    trace_ctx);\n}"
  },
  {
    "function_name": "ftrace_syscall_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "293-338",
    "snippet": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer;\n\tunsigned int trace_ctx;\n\tunsigned long args[6];\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\ttrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\tsys_data->enter_event->event.type, size, trace_ctx);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, args);\n\tmemcpy(entry->args, args, sizeof(unsigned long) * sys_data->nb_args);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry,\n\t\t\t\t    trace_ctx);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit",
          "args": [
            "trace_file",
            "buffer",
            "event",
            "entry",
            "trace_ctx"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1408-1421",
          "snippet": "static inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned int trace_ctx)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, trace_ctx);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned int trace_ctx)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, trace_ctx);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->args",
            "args",
            "sizeof(unsigned long) * sys_data->nb_args"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_arguments",
          "args": [
            "current",
            "regs",
            "args"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&buffer",
            "trace_file",
            "sys_data->enter_event->event.type",
            "size",
            "trace_ctx"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2739-2819",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\tstruct ring_buffer_event *entry;\n\tstruct trace_array *tr = trace_file->tr;\n\tint val;\n\n\t*current_rb = tr->array_buffer.buffer;\n\n\tif (!tr->no_filter_buffering_ref &&\n\t    (trace_file->flags & (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED))) {\n\t\tpreempt_disable_notrace();\n\t\t/*\n\t\t * Filtering is on, so try to use the per cpu buffer first.\n\t\t * This buffer will simulate a ring_buffer_event,\n\t\t * where the type_len is zero and the array[0] will\n\t\t * hold the full length.\n\t\t * (see include/linux/ring-buffer.h for details on\n\t\t *  how the ring_buffer_event is structured).\n\t\t *\n\t\t * Using a temp buffer during filtering and copying it\n\t\t * on a matched filter is quicker than writing directly\n\t\t * into the ring buffer and then discarding it when\n\t\t * it doesn't match. That is because the discard\n\t\t * requires several atomic operations to get right.\n\t\t * Copying on match and doing nothing on a failed match\n\t\t * is still quicker than no copy on match, but having\n\t\t * to discard out of the ring buffer on a failed match.\n\t\t */\n\t\tif ((entry = __this_cpu_read(trace_buffered_event))) {\n\t\t\tint max_len = PAGE_SIZE - struct_size(entry, array, 1);\n\n\t\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\n\t\t\t/*\n\t\t\t * Preemption is disabled, but interrupts and NMIs\n\t\t\t * can still come in now. If that happens after\n\t\t\t * the above increment, then it will have to go\n\t\t\t * back to the old method of allocating the event\n\t\t\t * on the ring buffer, and if the filter fails, it\n\t\t\t * will have to call ring_buffer_discard_commit()\n\t\t\t * to remove it.\n\t\t\t *\n\t\t\t * Need to also check the unlikely case that the\n\t\t\t * length is bigger than the temp buffer size.\n\t\t\t * If that happens, then the reserve is pretty much\n\t\t\t * guaranteed to fail, as the ring buffer currently\n\t\t\t * only allows events less than a page. But that may\n\t\t\t * change in the future, so let the ring buffer reserve\n\t\t\t * handle the failure in that case.\n\t\t\t */\n\t\t\tif (val == 1 && likely(len <= max_len)) {\n\t\t\t\ttrace_event_setup(entry, type, trace_ctx);\n\t\t\t\tentry->array[0] = len;\n\t\t\t\t/* Return with preemption disabled */\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t\t}\n\t\t/* __trace_buffer_lock_reserve() disables preemption */\n\t\tpreempt_enable_notrace();\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t    trace_ctx);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t\t    trace_ctx);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static struct trace_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic struct trace_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\tstruct ring_buffer_event *entry;\n\tstruct trace_array *tr = trace_file->tr;\n\tint val;\n\n\t*current_rb = tr->array_buffer.buffer;\n\n\tif (!tr->no_filter_buffering_ref &&\n\t    (trace_file->flags & (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED))) {\n\t\tpreempt_disable_notrace();\n\t\t/*\n\t\t * Filtering is on, so try to use the per cpu buffer first.\n\t\t * This buffer will simulate a ring_buffer_event,\n\t\t * where the type_len is zero and the array[0] will\n\t\t * hold the full length.\n\t\t * (see include/linux/ring-buffer.h for details on\n\t\t *  how the ring_buffer_event is structured).\n\t\t *\n\t\t * Using a temp buffer during filtering and copying it\n\t\t * on a matched filter is quicker than writing directly\n\t\t * into the ring buffer and then discarding it when\n\t\t * it doesn't match. That is because the discard\n\t\t * requires several atomic operations to get right.\n\t\t * Copying on match and doing nothing on a failed match\n\t\t * is still quicker than no copy on match, but having\n\t\t * to discard out of the ring buffer on a failed match.\n\t\t */\n\t\tif ((entry = __this_cpu_read(trace_buffered_event))) {\n\t\t\tint max_len = PAGE_SIZE - struct_size(entry, array, 1);\n\n\t\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\n\t\t\t/*\n\t\t\t * Preemption is disabled, but interrupts and NMIs\n\t\t\t * can still come in now. If that happens after\n\t\t\t * the above increment, then it will have to go\n\t\t\t * back to the old method of allocating the event\n\t\t\t * on the ring buffer, and if the filter fails, it\n\t\t\t * will have to call ring_buffer_discard_commit()\n\t\t\t * to remove it.\n\t\t\t *\n\t\t\t * Need to also check the unlikely case that the\n\t\t\t * length is bigger than the temp buffer size.\n\t\t\t * If that happens, then the reserve is pretty much\n\t\t\t * guaranteed to fail, as the ring buffer currently\n\t\t\t * only allows events less than a page. But that may\n\t\t\t * change in the future, so let the ring buffer reserve\n\t\t\t * handle the failure in that case.\n\t\t\t */\n\t\t\tif (val == 1 && likely(len <= max_len)) {\n\t\t\t\ttrace_event_setup(entry, type, trace_ctx);\n\t\t\t\tentry->array[0] = len;\n\t\t\t\t/* Return with preemption disabled */\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t\t}\n\t\t/* __trace_buffer_lock_reserve() disables preemption */\n\t\tpreempt_enable_notrace();\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t    trace_ctx);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t\t    trace_ctx);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall_nr"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "104-113",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->enter_syscall_files[syscall_nr]"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_syscall_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_syscall_nr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "75-79",
          "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer;\n\tunsigned int trace_ctx;\n\tunsigned long args[6];\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\ttrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\tsys_data->enter_event->event.type, size, trace_ctx);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, args);\n\tmemcpy(entry->args, args, sizeof(unsigned long) * sys_data->nb_args);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry,\n\t\t\t\t    trace_ctx);\n}"
  },
  {
    "function_name": "syscall_enter_define_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "272-291",
    "snippet": "static int __init syscall_enter_define_fields(struct trace_event_call *call)\n{\n\tstruct syscall_trace_enter trace;\n\tstruct syscall_metadata *meta = call->data;\n\tint offset = offsetof(typeof(trace), args);\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < meta->nb_args; i++) {\n\t\tret = trace_define_field(call, meta->types[i],\n\t\t\t\t\t meta->args[i], offset,\n\t\t\t\t\t sizeof(unsigned long), 0,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += sizeof(unsigned long);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "call",
            "meta->types[i]",
            "meta->args[i]",
            "offset",
            "sizeof(unsigned long)",
            "0",
            "FILTER_OTHER"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "134-146",
          "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int __init syscall_enter_define_fields(struct trace_event_call *call)\n{\n\tstruct syscall_trace_enter trace;\n\tstruct syscall_metadata *meta = call->data;\n\tint offset = offsetof(typeof(trace), args);\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < meta->nb_args; i++) {\n\t\tret = trace_define_field(call, meta->types[i],\n\t\t\t\t\t meta->args[i], offset,\n\t\t\t\t\t sizeof(unsigned long), 0,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += sizeof(unsigned long);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "free_syscall_print_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "264-270",
    "snippet": "static void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->print_fmt"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}"
  },
  {
    "function_name": "set_syscall_print_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "239-262",
    "snippet": "static int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_enter_print_fmt",
          "args": [
            "entry",
            "print_fmt",
            "len + 1"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "__set_enter_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "211-237",
          "snippet": "static int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [
            "#define LEN_OR_ZERO (len ? len - pos : 0)"
          ],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nstatic __init struct;\n\nstatic int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_enter_print_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "211-237",
    "snippet": "static int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [
      "#define LEN_OR_ZERO (len ? len - pos : 0)"
    ],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\", ((unsigned long)(REC->%s))\"",
            "entry->args[i]"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\"\""
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "btf_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5972-5992",
          "snippet": "static void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"%s: 0x%%0%zulx%s\"",
            "entry->args[i]",
            "sizeof(unsigned long)",
            "i == entry->nb_args - 1 ? \"\" : \", \""
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5994-6013",
          "snippet": "int btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nstatic __init struct;\n\nstatic int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
  },
  {
    "function_name": "print_syscall_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "173-202",
    "snippet": "static enum print_line_t\nprint_syscall_exit(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_exit *trace;\n\tint syscall;\n\tstruct syscall_metadata *entry;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry) {\n\t\ttrace_seq_putc(s, '\\n');\n\t\tgoto out;\n\t}\n\n\tif (entry->exit_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\ttrace_seq_printf(s, \"%s -> 0x%lx\\n\", entry->name,\n\t\t\t\ttrace->ret);\n\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s -> 0x%lx\\n\"",
            "entry->name",
            "trace->ret"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "104-113",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic enum print_line_t\nprint_syscall_exit(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_exit *trace;\n\tint syscall;\n\tstruct syscall_metadata *entry;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry) {\n\t\ttrace_seq_putc(s, '\\n');\n\t\tgoto out;\n\t}\n\n\tif (entry->exit_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\ttrace_seq_printf(s, \"%s -> 0x%lx\\n\", entry->name,\n\t\t\t\ttrace->ret);\n\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_syscall_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "126-171",
    "snippet": "static enum print_line_t\nprint_syscall_enter(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_enter *trace;\n\tstruct syscall_metadata *entry;\n\tint i, syscall;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry)\n\t\tgoto end;\n\n\tif (entry->enter_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto end;\n\t}\n\n\ttrace_seq_printf(s, \"%s(\", entry->name);\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\t/* parameter types */\n\t\tif (tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", entry->types[i]);\n\n\t\t/* parameter values */\n\t\ttrace_seq_printf(s, \"%s: %lx%s\", entry->args[i],\n\t\t\t\t trace->args[i],\n\t\t\t\t i == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\n\ttrace_seq_putc(s, ')');\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: %lx%s\"",
            "entry->args[i]",
            "trace->args[i]",
            "i == entry->nb_args - 1 ? \"\" : \", \""
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "104-113",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic enum print_line_t\nprint_syscall_enter(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_enter *trace;\n\tstruct syscall_metadata *entry;\n\tint i, syscall;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry)\n\t\tgoto end;\n\n\tif (entry->enter_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto end;\n\t}\n\n\ttrace_seq_printf(s, \"%s(\", entry->name);\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\t/* parameter types */\n\t\tif (tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", entry->types[i]);\n\n\t\t/* parameter values */\n\t\ttrace_seq_printf(s, \"%s: %lx%s\", entry->args[i],\n\t\t\t\t trace->args[i],\n\t\t\t\t i == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\n\ttrace_seq_putc(s, ')');\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "get_syscall_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "115-124",
    "snippet": "const char *get_syscall_name(int syscall)\n{\n\tstruct syscall_metadata *entry;\n\n\tentry = syscall_nr_to_meta(syscall);\n\tif (!entry)\n\t\treturn NULL;\n\n\treturn entry->name;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "104-113",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nconst char *get_syscall_name(int syscall)\n{\n\tstruct syscall_metadata *entry;\n\n\tentry = syscall_nr_to_meta(syscall);\n\tif (!entry)\n\t\treturn NULL;\n\n\treturn entry->name;\n}"
  },
  {
    "function_name": "syscall_nr_to_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "104-113",
    "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_XARRAY(syscalls_metadata_sparse);",
      "static struct syscall_metadata **syscalls_metadata;",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_load",
          "args": [
            "&syscalls_metadata_sparse",
            "(unsigned long)nr"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HAVE_SPARSE_SYSCALL_NR"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
  },
  {
    "function_name": "find_syscall_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "82-102",
    "snippet": "syscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct syscall_metadata *__start_syscalls_metadata[];",
      "extern struct syscall_metadata *__stop_syscalls_metadata[];",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_syscall_match_sym_name",
          "args": [
            "str",
            "(*start)->name"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "arch_syscall_match_sym_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
          "lines": "38-47",
          "snippet": "static inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t/*\n\t * Only compare after the \"sys\" prefix. Archs that use\n\t * syscall wrappers may have syscalls symbols aliases prefixed\n\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted\n\t * mismatch.\n\t */\n\treturn !strcmp(sym + 3, name + 3);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/xarray.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t/*\n\t * Only compare after the \"sys\" prefix. Archs that use\n\t * syscall wrappers may have syscalls symbols aliases prefixed\n\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted\n\t * mismatch.\n\t */\n\treturn !strcmp(sym + 3, name + 3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "syscall",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nextern struct syscall_metadata *__start_syscalls_metadata[];\nextern struct syscall_metadata *__stop_syscalls_metadata[];\nstatic __init struct;\n\nsyscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "trace_get_syscall_nr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "75-79",
    "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "task",
            "regs"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
  },
  {
    "function_name": "trace_get_syscall_nr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "66-73",
    "snippet": "static int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\tif (unlikely(arch_trace_is_compat_syscall(regs)))\n\t\treturn -1;\n\n\treturn syscall_get_nr(task, regs);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "task",
            "regs"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "arch_trace_is_compat_syscall(regs)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_trace_is_compat_syscall",
          "args": [
            "regs"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\tif (unlikely(arch_trace_is_compat_syscall(regs)))\n\t\treturn -1;\n\n\treturn syscall_get_nr(task, regs);\n}"
  },
  {
    "function_name": "arch_syscall_match_sym_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "38-47",
    "snippet": "static inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t/*\n\t * Only compare after the \"sys\" prefix. Archs that use\n\t * syscall wrappers may have syscalls symbols aliases prefixed\n\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted\n\t * mismatch.\n\t */\n\treturn !strcmp(sym + 3, name + 3);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sym + 3",
            "name + 3"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t/*\n\t * Only compare after the \"sys\" prefix. Archs that use\n\t * syscall wrappers may have syscalls symbols aliases prefixed\n\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted\n\t * mismatch.\n\t */\n\treturn !strcmp(sym + 3, name + 3);\n}"
  },
  {
    "function_name": "syscall_get_enter_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_syscalls.c",
    "lines": "23-29",
    "snippet": "static struct list_head *\nsyscall_get_enter_fields(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\treturn &entry->enter_fields;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/xarray.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/xarray.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic struct list_head *\nsyscall_get_enter_fields(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\treturn &entry->enter_fields;\n}"
  }
]