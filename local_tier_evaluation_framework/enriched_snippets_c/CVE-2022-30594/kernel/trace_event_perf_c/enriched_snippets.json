[
  {
    "function_name": "perf_ftrace_event_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "502-527",
    "snippet": "int perf_ftrace_event_register(struct trace_event_call *call,\n\t\t\t       enum trace_reg type, void *data)\n{\n\tstruct perf_event *event = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\tcase TRACE_REG_UNREGISTER:\n\t\tbreak;\n\tcase TRACE_REG_PERF_REGISTER:\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn perf_ftrace_function_register(data);\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn perf_ftrace_function_unregister(data);\n\tcase TRACE_REG_PERF_ADD:\n\t\tevent->ftrace_ops.private = (void *)(unsigned long)smp_processor_id();\n\t\treturn 1;\n\tcase TRACE_REG_PERF_DEL:\n\t\tevent->ftrace_ops.private = (void *)(unsigned long)nr_cpu_ids;\n\t\treturn 1;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_ftrace_function_unregister",
          "args": [
            "data"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "perf_ftrace_function_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "494-500",
          "snippet": "static int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\tint ret = unregister_ftrace_function(ops);\n\tftrace_free_filter(ops);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\tint ret = unregister_ftrace_function(ops);\n\tftrace_free_filter(ops);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_ftrace_function_register",
          "args": [
            "data"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "perf_ftrace_function_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "484-492",
          "snippet": "static int perf_ftrace_function_register(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\n\tops->func    = perf_ftrace_function_call;\n\tops->private = (void *)(unsigned long)nr_cpu_ids;\n\n\treturn register_ftrace_function(ops);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_ftrace_function_register(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\n\tops->func    = perf_ftrace_function_call;\n\tops->private = (void *)(unsigned long)nr_cpu_ids;\n\n\treturn register_ftrace_function(ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_ftrace_event_register(struct trace_event_call *call,\n\t\t\t       enum trace_reg type, void *data)\n{\n\tstruct perf_event *event = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\tcase TRACE_REG_UNREGISTER:\n\t\tbreak;\n\tcase TRACE_REG_PERF_REGISTER:\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn perf_ftrace_function_register(data);\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn perf_ftrace_function_unregister(data);\n\tcase TRACE_REG_PERF_ADD:\n\t\tevent->ftrace_ops.private = (void *)(unsigned long)smp_processor_id();\n\t\treturn 1;\n\tcase TRACE_REG_PERF_DEL:\n\t\tevent->ftrace_ops.private = (void *)(unsigned long)nr_cpu_ids;\n\t\treturn 1;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "perf_ftrace_function_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "494-500",
    "snippet": "static int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\tint ret = unregister_ftrace_function(ops);\n\tftrace_free_filter(ops);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_free_filter",
          "args": [
            "ops"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1252-1257",
          "snippet": "void ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\tint ret = unregister_ftrace_function(ops);\n\tftrace_free_filter(ops);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_ftrace_function_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "484-492",
    "snippet": "static int perf_ftrace_function_register(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\n\tops->func    = perf_ftrace_function_call;\n\tops->private = (void *)(unsigned long)nr_cpu_ids;\n\n\treturn register_ftrace_function(ops);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_ftrace_function_register(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\n\tops->func    = perf_ftrace_function_call;\n\tops->private = (void *)(unsigned long)nr_cpu_ids;\n\n\treturn register_ftrace_function(ops);\n}"
  },
  {
    "function_name": "perf_ftrace_function_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "431-482",
    "snippet": "static void\nperf_ftrace_function_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *ops,  struct ftrace_regs *fregs)\n{\n\tstruct ftrace_entry *entry;\n\tstruct perf_event *event;\n\tstruct hlist_head head;\n\tstruct pt_regs regs;\n\tint rctx;\n\tint bit;\n\n\tif (!rcu_is_watching())\n\t\treturn;\n\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0)\n\t\treturn;\n\n\tif ((unsigned long)ops->private != smp_processor_id())\n\t\tgoto out;\n\n\tevent = container_of(ops, struct perf_event, ftrace_ops);\n\n\t/*\n\t * @event->hlist entry is NULL (per INIT_HLIST_NODE), and all\n\t * the perf code does is hlist_for_each_entry_rcu(), so we can\n\t * get away with simply setting the @head.first pointer in order\n\t * to create a singular list.\n\t */\n\thead.first = &event->hlist_entry;\n\n#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))\n\n\tBUILD_BUG_ON(ENTRY_SIZE > PERF_MAX_TRACE_SIZE);\n\n\tmemset(&regs, 0, sizeof(regs));\n\tperf_fetch_caller_regs(&regs);\n\n\tentry = perf_trace_buf_alloc(ENTRY_SIZE, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tentry->ip = ip;\n\tentry->parent_ip = parent_ip;\n\tperf_trace_buf_submit(entry, ENTRY_SIZE, rctx, TRACE_FN,\n\t\t\t      1, &regs, &head, NULL);\n\nout:\n\tftrace_test_recursion_unlock(bit);\n#undef ENTRY_SIZE\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_test_recursion_unlock",
          "args": [
            "bit"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "entry",
            "ENTRY_SIZE",
            "rctx",
            "TRACE_FN",
            "1",
            "&regs",
            "&head",
            "NULL"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "ENTRY_SIZE",
            "NULL",
            "&rctx"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "395-418",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_fetch_caller_regs",
          "args": [
            "&regs"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&regs",
            "0",
            "sizeof(regs)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ENTRY_SIZE > PERF_MAX_TRACE_SIZE"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ops",
            "structperf_event",
            "ftrace_ops"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_test_recursion_trylock",
          "args": [
            "ip",
            "parent_ip"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\n#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))\n\nstatic void\nperf_ftrace_function_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *ops,  struct ftrace_regs *fregs)\n{\n\tstruct ftrace_entry *entry;\n\tstruct perf_event *event;\n\tstruct hlist_head head;\n\tstruct pt_regs regs;\n\tint rctx;\n\tint bit;\n\n\tif (!rcu_is_watching())\n\t\treturn;\n\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0)\n\t\treturn;\n\n\tif ((unsigned long)ops->private != smp_processor_id())\n\t\tgoto out;\n\n\tevent = container_of(ops, struct perf_event, ftrace_ops);\n\n\t/*\n\t * @event->hlist entry is NULL (per INIT_HLIST_NODE), and all\n\t * the perf code does is hlist_for_each_entry_rcu(), so we can\n\t * get away with simply setting the @head.first pointer in order\n\t * to create a singular list.\n\t */\n\thead.first = &event->hlist_entry;\n\n#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))\n\n\tBUILD_BUG_ON(ENTRY_SIZE > PERF_MAX_TRACE_SIZE);\n\n\tmemset(&regs, 0, sizeof(regs));\n\tperf_fetch_caller_regs(&regs);\n\n\tentry = perf_trace_buf_alloc(ENTRY_SIZE, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tentry->ip = ip;\n\tentry->parent_ip = parent_ip;\n\tperf_trace_buf_submit(entry, ENTRY_SIZE, rctx, TRACE_FN,\n\t\t\t      1, &regs, &head, NULL);\n\nout:\n\tftrace_test_recursion_unlock(bit);\n#undef ENTRY_SIZE\n}"
  },
  {
    "function_name": "perf_trace_buf_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "422-427",
    "snippet": "void perf_trace_buf_update(void *record, u16 type)\n{\n\tstruct trace_entry *entry = record;\n\n\ttracing_generic_entry_update(entry, type, tracing_gen_ctx());\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_generic_entry_update",
          "args": [
            "entry",
            "type",
            "tracing_gen_ctx()"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_trace_buf_update(void *record, u16 type)\n{\n\tstruct trace_entry *entry = record;\n\n\ttracing_generic_entry_update(entry, type, tracing_gen_ctx());\n}"
  },
  {
    "function_name": "perf_trace_buf_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "395-418",
    "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&raw_data[size - sizeof(u64)]",
            "0",
            "sizeof(u64)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "perf_trace_buf[rctx]"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&__perf_regs[rctx]"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_swevent_get_recursion_context",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "perf_swevent_get_recursion_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "9453-9458",
          "snippet": "int perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic DEFINE_PER_CPU(struct swevent_htable, swevent_htable);\n\nint perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "size > PERF_MAX_TRACE_SIZE",
            "\"perf buffer not large enough, wanted %d, have %d\"",
            "size",
            "PERF_MAX_TRACE_SIZE"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PERF_MAX_TRACE_SIZE % sizeof(unsigned long)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
  },
  {
    "function_name": "perf_trace_del",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "382-393",
    "snippet": "void perf_trace_del(struct perf_event *p_event, int flags)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\n\t/*\n\t * If TRACE_REG_PERF_DEL returns false; no custom action was performed\n\t * and we need to take the default action of dequeueing our event from\n\t * the right per-cpu hlist.\n\t */\n\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_DEL, p_event))\n\t\thlist_del_rcu(&p_event->hlist_entry);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&p_event->hlist_entry"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_DEL",
            "p_event"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_trace_del(struct perf_event *p_event, int flags)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\n\t/*\n\t * If TRACE_REG_PERF_DEL returns false; no custom action was performed\n\t * and we need to take the default action of dequeueing our event from\n\t * the right per-cpu hlist.\n\t */\n\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_DEL, p_event))\n\t\thlist_del_rcu(&p_event->hlist_entry);\n}"
  },
  {
    "function_name": "perf_trace_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "355-380",
    "snippet": "int perf_trace_add(struct perf_event *p_event, int flags)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\n\tif (!(flags & PERF_EF_START))\n\t\tp_event->hw.state = PERF_HES_STOPPED;\n\n\t/*\n\t * If TRACE_REG_PERF_ADD returns false; no custom action was performed\n\t * and we need to take the default action of enqueueing our event on\n\t * the right per-cpu hlist.\n\t */\n\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_ADD, p_event)) {\n\t\tstruct hlist_head __percpu *pcpu_list;\n\t\tstruct hlist_head *list;\n\n\t\tpcpu_list = tp_event->perf_events;\n\t\tif (WARN_ON_ONCE(!pcpu_list))\n\t\t\treturn -EINVAL;\n\n\t\tlist = this_cpu_ptr(pcpu_list);\n\t\thlist_add_head_rcu(&p_event->hlist_entry, list);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&p_event->hlist_entry",
            "list"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "pcpu_list"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pcpu_list"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_ADD",
            "p_event"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_trace_add(struct perf_event *p_event, int flags)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\n\tif (!(flags & PERF_EF_START))\n\t\tp_event->hw.state = PERF_HES_STOPPED;\n\n\t/*\n\t * If TRACE_REG_PERF_ADD returns false; no custom action was performed\n\t * and we need to take the default action of enqueueing our event on\n\t * the right per-cpu hlist.\n\t */\n\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_ADD, p_event)) {\n\t\tstruct hlist_head __percpu *pcpu_list;\n\t\tstruct hlist_head *list;\n\n\t\tpcpu_list = tp_event->perf_events;\n\t\tif (WARN_ON_ONCE(!pcpu_list))\n\t\t\treturn -EINVAL;\n\n\t\tlist = this_cpu_ptr(pcpu_list);\n\t\thlist_add_head_rcu(&p_event->hlist_entry, list);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "perf_uprobe_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "345-352",
    "snippet": "void perf_uprobe_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n\tdestroy_local_trace_uprobe(p_event->tp_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_local_trace_uprobe",
          "args": [
            "p_event->tp_event"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_local_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1632-1639",
          "snippet": "void destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\n\tfree_trace_uprobe(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nvoid destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\n\tfree_trace_uprobe(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_unreg",
          "args": [
            "p_event"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_unreg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "154-181",
          "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_close",
          "args": [
            "p_event"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "189-193",
          "snippet": "static void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_uprobe_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n\tdestroy_local_trace_uprobe(p_event->tp_event);\n}"
  },
  {
    "function_name": "perf_uprobe_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "302-343",
    "snippet": "int perf_uprobe_init(struct perf_event *p_event,\n\t\t     unsigned long ref_ctr_offset, bool is_retprobe)\n{\n\tint ret;\n\tchar *path = NULL;\n\tstruct trace_event_call *tp_event;\n\n\tif (!p_event->attr.uprobe_path)\n\t\treturn -EINVAL;\n\n\tpath = strndup_user(u64_to_user_ptr(p_event->attr.uprobe_path),\n\t\t\t    PATH_MAX);\n\tif (IS_ERR(path)) {\n\t\tret = PTR_ERR(path);\n\t\treturn (ret == -EINVAL) ? -E2BIG : ret;\n\t}\n\tif (path[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttp_event = create_local_trace_uprobe(path, p_event->attr.probe_offset,\n\t\t\t\t\t     ref_ctr_offset, is_retprobe);\n\tif (IS_ERR(tp_event)) {\n\t\tret = PTR_ERR(tp_event);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * local trace_uprobe need to hold event_mutex to call\n\t * uprobe_buffer_enable() and uprobe_buffer_disable().\n\t * event_mutex is not required for local trace_kprobes.\n\t */\n\tmutex_lock(&event_mutex);\n\tret = perf_trace_event_init(tp_event, p_event);\n\tif (ret)\n\t\tdestroy_local_trace_uprobe(tp_event);\n\tmutex_unlock(&event_mutex);\nout:\n\tkfree(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_local_trace_uprobe",
          "args": [
            "tp_event"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_local_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1632-1639",
          "snippet": "void destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\n\tfree_trace_uprobe(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nvoid destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\n\tfree_trace_uprobe(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_init",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "195-215",
          "snippet": "static int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tp_event"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tp_event"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_local_trace_uprobe",
          "args": [
            "path",
            "p_event->attr.probe_offset",
            "ref_ctr_offset",
            "is_retprobe"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "create_local_trace_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_uprobe.c",
          "lines": "1576-1630",
          "snippet": "struct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * local trace_kprobes are not added to dyn_event, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name \"DUMMY_EVENT\" here.\n\t */\n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tif (!tu->filename) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinit_trace_event_call(tu);\n\n\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tu->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn trace_probe_event_call(&tu->tp);\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [
            "#define UPROBE_EVENT_SYSTEM\t\"uprobes\""
          ],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\n#define UPROBE_EVENT_SYSTEM\t\"uprobes\"\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic nokprobe_inline struct;\n\nstruct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * local trace_kprobes are not added to dyn_event, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name \"DUMMY_EVENT\" here.\n\t */\n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tif (!tu->filename) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinit_trace_event_call(tu);\n\n\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tu->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn trace_probe_event_call(&tu->tp);\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strndup_user",
          "args": [
            "u64_to_user_ptr(p_event->attr.uprobe_path)",
            "PATH_MAX"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "p_event->attr.uprobe_path"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_uprobe_init(struct perf_event *p_event,\n\t\t     unsigned long ref_ctr_offset, bool is_retprobe)\n{\n\tint ret;\n\tchar *path = NULL;\n\tstruct trace_event_call *tp_event;\n\n\tif (!p_event->attr.uprobe_path)\n\t\treturn -EINVAL;\n\n\tpath = strndup_user(u64_to_user_ptr(p_event->attr.uprobe_path),\n\t\t\t    PATH_MAX);\n\tif (IS_ERR(path)) {\n\t\tret = PTR_ERR(path);\n\t\treturn (ret == -EINVAL) ? -E2BIG : ret;\n\t}\n\tif (path[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttp_event = create_local_trace_uprobe(path, p_event->attr.probe_offset,\n\t\t\t\t\t     ref_ctr_offset, is_retprobe);\n\tif (IS_ERR(tp_event)) {\n\t\tret = PTR_ERR(tp_event);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * local trace_uprobe need to hold event_mutex to call\n\t * uprobe_buffer_enable() and uprobe_buffer_disable().\n\t * event_mutex is not required for local trace_kprobes.\n\t */\n\tmutex_lock(&event_mutex);\n\tret = perf_trace_event_init(tp_event, p_event);\n\tif (ret)\n\t\tdestroy_local_trace_uprobe(tp_event);\n\tmutex_unlock(&event_mutex);\nout:\n\tkfree(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_kprobe_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "290-298",
    "snippet": "void perf_kprobe_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n\n\tdestroy_local_trace_kprobe(p_event->tp_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_local_trace_kprobe",
          "args": [
            "p_event->tp_event"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_local_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1830-1846",
          "snippet": "void destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = trace_kprobe_primary_from_call(event_call);\n\tif (unlikely(!tk))\n\t\treturn;\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tfree_trace_kprobe(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nvoid destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = trace_kprobe_primary_from_call(event_call);\n\tif (unlikely(!tk))\n\t\treturn;\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tfree_trace_kprobe(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_unreg",
          "args": [
            "p_event"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_unreg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "154-181",
          "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_close",
          "args": [
            "p_event"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "189-193",
          "snippet": "static void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_kprobe_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n\n\tdestroy_local_trace_kprobe(p_event->tp_event);\n}"
  },
  {
    "function_name": "perf_kprobe_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "248-288",
    "snippet": "int perf_kprobe_init(struct perf_event *p_event, bool is_retprobe)\n{\n\tint ret;\n\tchar *func = NULL;\n\tstruct trace_event_call *tp_event;\n\n\tif (p_event->attr.kprobe_func) {\n\t\tfunc = kzalloc(KSYM_NAME_LEN, GFP_KERNEL);\n\t\tif (!func)\n\t\t\treturn -ENOMEM;\n\t\tret = strncpy_from_user(\n\t\t\tfunc, u64_to_user_ptr(p_event->attr.kprobe_func),\n\t\t\tKSYM_NAME_LEN);\n\t\tif (ret == KSYM_NAME_LEN)\n\t\t\tret = -E2BIG;\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (func[0] == '\\0') {\n\t\t\tkfree(func);\n\t\t\tfunc = NULL;\n\t\t}\n\t}\n\n\ttp_event = create_local_trace_kprobe(\n\t\tfunc, (void *)(unsigned long)(p_event->attr.kprobe_addr),\n\t\tp_event->attr.probe_offset, is_retprobe);\n\tif (IS_ERR(tp_event)) {\n\t\tret = PTR_ERR(tp_event);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tret = perf_trace_event_init(tp_event, p_event);\n\tif (ret)\n\t\tdestroy_local_trace_kprobe(tp_event);\n\tmutex_unlock(&event_mutex);\nout:\n\tkfree(func);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "func"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_local_trace_kprobe",
          "args": [
            "tp_event"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_local_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1830-1846",
          "snippet": "void destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = trace_kprobe_primary_from_call(event_call);\n\tif (unlikely(!tk))\n\t\treturn;\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tfree_trace_kprobe(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nvoid destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = trace_kprobe_primary_from_call(event_call);\n\tif (unlikely(!tk))\n\t\treturn;\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tfree_trace_kprobe(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_init",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "195-215",
          "snippet": "static int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tp_event"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tp_event"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_local_trace_kprobe",
          "args": [
            "func",
            "(void *)(unsigned long)(p_event->attr.kprobe_addr)",
            "p_event->attr.probe_offset",
            "is_retprobe"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "create_local_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1785-1828",
          "snippet": "struct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_kprobe *tk;\n\tint ret;\n\tchar *event;\n\n\t/*\n\t * local trace_kprobes are not added to dyn_event, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name here.\n\t */\n\tevent = func ? func : \"DUMMY_EVENT\";\n\n\ttk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,\n\t\t\t\toffs, 0 /* maxactive */, 0 /* nargs */,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn ERR_CAST(tk);\n\t}\n\n\tinit_trace_event_call(tk);\n\n\tptype = trace_kprobe_is_return(tk) ?\n\t\tPROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tk->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn trace_probe_event_call(&tk->tp);\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [
            "#define KPROBE_EVENT_SYSTEM \"kprobes\""
          ],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\n#define KPROBE_EVENT_SYSTEM \"kprobes\"\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstruct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_kprobe *tk;\n\tint ret;\n\tchar *event;\n\n\t/*\n\t * local trace_kprobes are not added to dyn_event, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name here.\n\t */\n\tevent = func ? func : \"DUMMY_EVENT\";\n\n\ttk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,\n\t\t\t\toffs, 0 /* maxactive */, 0 /* nargs */,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn ERR_CAST(tk);\n\t}\n\n\tinit_trace_event_call(tk);\n\n\tptype = trace_kprobe_is_return(tk) ?\n\t\tPROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tk->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn trace_probe_event_call(&tk->tp);\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "func",
            "u64_to_user_ptr(p_event->attr.kprobe_func)",
            "KSYM_NAME_LEN"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "p_event->attr.kprobe_func"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "KSYM_NAME_LEN",
            "GFP_KERNEL"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_kprobe_init(struct perf_event *p_event, bool is_retprobe)\n{\n\tint ret;\n\tchar *func = NULL;\n\tstruct trace_event_call *tp_event;\n\n\tif (p_event->attr.kprobe_func) {\n\t\tfunc = kzalloc(KSYM_NAME_LEN, GFP_KERNEL);\n\t\tif (!func)\n\t\t\treturn -ENOMEM;\n\t\tret = strncpy_from_user(\n\t\t\tfunc, u64_to_user_ptr(p_event->attr.kprobe_func),\n\t\t\tKSYM_NAME_LEN);\n\t\tif (ret == KSYM_NAME_LEN)\n\t\t\tret = -E2BIG;\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (func[0] == '\\0') {\n\t\t\tkfree(func);\n\t\t\tfunc = NULL;\n\t\t}\n\t}\n\n\ttp_event = create_local_trace_kprobe(\n\t\tfunc, (void *)(unsigned long)(p_event->attr.kprobe_addr),\n\t\tp_event->attr.probe_offset, is_retprobe);\n\tif (IS_ERR(tp_event)) {\n\t\tret = PTR_ERR(tp_event);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tret = perf_trace_event_init(tp_event, p_event);\n\tif (ret)\n\t\tdestroy_local_trace_kprobe(tp_event);\n\tmutex_unlock(&event_mutex);\nout:\n\tkfree(func);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_trace_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "239-245",
    "snippet": "void perf_trace_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_unreg",
          "args": [
            "p_event"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_unreg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "154-181",
          "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_close",
          "args": [
            "p_event"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "189-193",
          "snippet": "static void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_trace_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "perf_trace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "217-237",
    "snippet": "int perf_trace_init(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event;\n\tu64 event_id = p_event->attr.config;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (tp_event->event.type == event_id &&\n\t\t    tp_event->class && tp_event->class->reg &&\n\t\t    trace_event_try_get_ref(tp_event)) {\n\t\t\tret = perf_trace_event_init(tp_event, p_event);\n\t\t\tif (ret)\n\t\t\t\ttrace_event_put_ref(tp_event);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "tp_event"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_event_init",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "195-215",
          "snippet": "static int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_try_get_ref",
          "args": [
            "tp_event"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_event",
            "&ftrace_events",
            "list"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_trace_init(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event;\n\tu64 event_id = p_event->attr.config;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (tp_event->event.type == event_id &&\n\t\t    tp_event->class && tp_event->class->reg &&\n\t\t    trace_event_try_get_ref(tp_event)) {\n\t\t\tret = perf_trace_event_init(tp_event, p_event);\n\t\t\tif (ret)\n\t\t\t\ttrace_event_put_ref(tp_event);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_trace_event_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "195-215",
    "snippet": "static int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_event_unreg",
          "args": [
            "p_event"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_unreg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "154-181",
          "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_open",
          "args": [
            "p_event"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "183-187",
          "snippet": "static int perf_trace_event_open(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_open(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_reg",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_reg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "96-152",
          "snippet": "static int perf_trace_event_reg(struct trace_event_call *tp_event,\n\t\t\t\tstruct perf_event *p_event)\n{\n\tstruct hlist_head __percpu *list;\n\tint ret = -ENOMEM;\n\tint cpu;\n\n\tp_event->tp_event = tp_event;\n\tif (tp_event->perf_refcount++ > 0)\n\t\treturn 0;\n\n\tlist = alloc_percpu(struct hlist_head);\n\tif (!list)\n\t\tgoto fail;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));\n\n\ttp_event->perf_events = list;\n\n\tif (!total_ref_count) {\n\t\tchar __percpu *buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\ttotal_ref_count++;\n\treturn 0;\n\nfail:\n\tif (!total_ref_count) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\n\n\tif (!--tp_event->perf_refcount) {\n\t\tfree_percpu(tp_event->perf_events);\n\t\ttp_event->perf_events = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic int perf_trace_event_reg(struct trace_event_call *tp_event,\n\t\t\t\tstruct perf_event *p_event)\n{\n\tstruct hlist_head __percpu *list;\n\tint ret = -ENOMEM;\n\tint cpu;\n\n\tp_event->tp_event = tp_event;\n\tif (tp_event->perf_refcount++ > 0)\n\t\treturn 0;\n\n\tlist = alloc_percpu(struct hlist_head);\n\tif (!list)\n\t\tgoto fail;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));\n\n\ttp_event->perf_events = list;\n\n\tif (!total_ref_count) {\n\t\tchar __percpu *buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\ttotal_ref_count++;\n\treturn 0;\n\nfail:\n\tif (!total_ref_count) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\n\n\tif (!--tp_event->perf_refcount) {\n\t\tfree_percpu(tp_event->perf_events);\n\t\ttp_event->perf_events = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_perm",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_perm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "27-94",
          "snippet": "static int perf_trace_event_perm(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tif (tp_event->perf_perm) {\n\t\tret = tp_event->perf_perm(tp_event, p_event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We checked and allowed to create parent,\n\t * allow children without checking.\n\t */\n\tif (p_event->parent)\n\t\treturn 0;\n\n\t/*\n\t * It's ok to check current process (owner) permissions in here,\n\t * because code below is called only via perf_event_open syscall.\n\t */\n\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event)) {\n\t\tret = perf_allow_tracepoint(&p_event->attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!is_sampling_event(p_event))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * We don't allow user space callchains for  function trace\n\t\t * event, due to issues with page faults while tracing page\n\t\t * fault handler and its overall trickiness nature.\n\t\t */\n\t\tif (!p_event->attr.exclude_callchain_user)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Same reason to disable user stack dump as for user space\n\t\t * callchains above.\n\t\t */\n\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tret = perf_allow_tracepoint(&p_event->attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_perm(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tif (tp_event->perf_perm) {\n\t\tret = tp_event->perf_perm(tp_event, p_event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We checked and allowed to create parent,\n\t * allow children without checking.\n\t */\n\tif (p_event->parent)\n\t\treturn 0;\n\n\t/*\n\t * It's ok to check current process (owner) permissions in here,\n\t * because code below is called only via perf_event_open syscall.\n\t */\n\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event)) {\n\t\tret = perf_allow_tracepoint(&p_event->attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!is_sampling_event(p_event))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * We don't allow user space callchains for  function trace\n\t\t * event, due to issues with page faults while tracing page\n\t\t * fault handler and its overall trickiness nature.\n\t\t */\n\t\tif (!p_event->attr.exclude_callchain_user)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Same reason to disable user stack dump as for user space\n\t\t * callchains above.\n\t\t */\n\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tret = perf_allow_tracepoint(&p_event->attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "perf_trace_event_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "189-193",
    "snippet": "static void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_CLOSE",
            "p_event"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}"
  },
  {
    "function_name": "perf_trace_event_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "183-187",
    "snippet": "static int perf_trace_event_open(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_OPEN",
            "p_event"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_open(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);\n}"
  },
  {
    "function_name": "perf_trace_event_unreg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "154-181",
    "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
      "static int\ttotal_ref_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "tp_event"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "perf_trace_buf[i]"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_UNREGISTER",
            "NULL"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\ttrace_event_put_ref(tp_event);\n}"
  },
  {
    "function_name": "perf_trace_event_reg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "96-152",
    "snippet": "static int perf_trace_event_reg(struct trace_event_call *tp_event,\n\t\t\t\tstruct perf_event *p_event)\n{\n\tstruct hlist_head __percpu *list;\n\tint ret = -ENOMEM;\n\tint cpu;\n\n\tp_event->tp_event = tp_event;\n\tif (tp_event->perf_refcount++ > 0)\n\t\treturn 0;\n\n\tlist = alloc_percpu(struct hlist_head);\n\tif (!list)\n\t\tgoto fail;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));\n\n\ttp_event->perf_events = list;\n\n\tif (!total_ref_count) {\n\t\tchar __percpu *buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\ttotal_ref_count++;\n\treturn 0;\n\nfail:\n\tif (!total_ref_count) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\n\n\tif (!--tp_event->perf_refcount) {\n\t\tfree_percpu(tp_event->perf_events);\n\t\ttp_event->perf_events = NULL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
      "static int\ttotal_ref_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "tp_event->perf_events"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_REGISTER",
            "NULL"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "perf_trace_t"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic int perf_trace_event_reg(struct trace_event_call *tp_event,\n\t\t\t\tstruct perf_event *p_event)\n{\n\tstruct hlist_head __percpu *list;\n\tint ret = -ENOMEM;\n\tint cpu;\n\n\tp_event->tp_event = tp_event;\n\tif (tp_event->perf_refcount++ > 0)\n\t\treturn 0;\n\n\tlist = alloc_percpu(struct hlist_head);\n\tif (!list)\n\t\tgoto fail;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));\n\n\ttp_event->perf_events = list;\n\n\tif (!total_ref_count) {\n\t\tchar __percpu *buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\ttotal_ref_count++;\n\treturn 0;\n\nfail:\n\tif (!total_ref_count) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\n\n\tif (!--tp_event->perf_refcount) {\n\t\tfree_percpu(tp_event->perf_events);\n\t\ttp_event->perf_events = NULL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_trace_event_perm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
    "lines": "27-94",
    "snippet": "static int perf_trace_event_perm(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tif (tp_event->perf_perm) {\n\t\tret = tp_event->perf_perm(tp_event, p_event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We checked and allowed to create parent,\n\t * allow children without checking.\n\t */\n\tif (p_event->parent)\n\t\treturn 0;\n\n\t/*\n\t * It's ok to check current process (owner) permissions in here,\n\t * because code below is called only via perf_event_open syscall.\n\t */\n\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event)) {\n\t\tret = perf_allow_tracepoint(&p_event->attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!is_sampling_event(p_event))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * We don't allow user space callchains for  function trace\n\t\t * event, due to issues with page faults while tracing page\n\t\t * fault handler and its overall trickiness nature.\n\t\t */\n\t\tif (!p_event->attr.exclude_callchain_user)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Same reason to disable user stack dump as for user space\n\t\t * callchains above.\n\t\t */\n\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tret = perf_allow_tracepoint(&p_event->attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/security.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_allow_tracepoint",
          "args": [
            "&p_event->attr"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sampling_event",
          "args": [
            "p_event"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_allow_tracepoint",
          "args": [
            "&p_event->attr"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_event_is_function",
          "args": [
            "tp_event"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_is_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_export.c",
          "lines": "186-189",
          "snippet": "bool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_output.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stringify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_output.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stringify.h>\n\nbool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_event->perf_perm",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_perm(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tif (tp_event->perf_perm) {\n\t\tret = tp_event->perf_perm(tp_event, p_event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We checked and allowed to create parent,\n\t * allow children without checking.\n\t */\n\tif (p_event->parent)\n\t\treturn 0;\n\n\t/*\n\t * It's ok to check current process (owner) permissions in here,\n\t * because code below is called only via perf_event_open syscall.\n\t */\n\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event)) {\n\t\tret = perf_allow_tracepoint(&p_event->attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!is_sampling_event(p_event))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * We don't allow user space callchains for  function trace\n\t\t * event, due to issues with page faults while tracing page\n\t\t * fault handler and its overall trickiness nature.\n\t\t */\n\t\tif (!p_event->attr.exclude_callchain_user)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Same reason to disable user stack dump as for user space\n\t\t * callchains above.\n\t\t */\n\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tret = perf_allow_tracepoint(&p_event->attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}"
  }
]