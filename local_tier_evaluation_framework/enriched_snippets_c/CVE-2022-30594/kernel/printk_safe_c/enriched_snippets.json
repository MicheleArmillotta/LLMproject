[
  {
    "function_name": "vprintk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_safe.c",
    "lines": "29-51",
    "snippet": "asmlinkage int vprintk(const char *fmt, va_list args)\n{\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow to pass printk() to kdb but avoid a recursion. */\n\tif (unlikely(kdb_trap_printk && kdb_printf_cpu < 0))\n\t\treturn vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);\n#endif\n\n\t/*\n\t * Use the main logbuf even in NMI. But avoid calling console\n\t * drivers that might have their own locks.\n\t */\n\tif (this_cpu_read(printk_context) || in_nmi()) {\n\t\tint len;\n\n\t\tlen = vprintk_store(0, LOGLEVEL_DEFAULT, NULL, fmt, args);\n\t\tdefer_console_output();\n\t\treturn len;\n\t}\n\n\t/* No obstacles. */\n\treturn vprintk_default(fmt, args);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/printk.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/kdb.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vprintk_default",
          "args": [
            "fmt",
            "args"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_default",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2254-2257",
          "snippet": "int vprintk_default(const char *fmt, va_list args)\n{\n\treturn vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, fmt, args);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint vprintk_default(const char *fmt, va_list args)\n{\n\treturn vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "defer_console_output",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "defer_console_output",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3259-3268",
          "snippet": "void defer_console_output(void)\n{\n\tif (!printk_percpu_data_ready())\n\t\treturn;\n\n\tpreempt_disable();\n\t__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PRINTK_PENDING_OUTPUT\t0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PRINTK_PENDING_OUTPUT\t0x02\n\nvoid defer_console_output(void)\n{\n\tif (!printk_percpu_data_ready())\n\t\treturn;\n\n\tpreempt_disable();\n\t__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "vprintk_store",
          "args": [
            "0",
            "LOGLEVEL_DEFAULT",
            "NULL",
            "fmt",
            "args"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_store",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2099-2208",
          "snippet": "int vprintk_store(int facility, int level,\n\t\t  const struct dev_printk_info *dev_info,\n\t\t  const char *fmt, va_list args)\n{\n\tconst u32 caller_id = printk_caller_id();\n\tstruct prb_reserved_entry e;\n\tenum printk_info_flags flags = 0;\n\tstruct printk_record r;\n\tunsigned long irqflags;\n\tu16 trunc_msg_len = 0;\n\tchar prefix_buf[8];\n\tu8 *recursion_ptr;\n\tu16 reserve_size;\n\tva_list args2;\n\tu16 text_len;\n\tint ret = 0;\n\tu64 ts_nsec;\n\n\t/*\n\t * Since the duration of printk() can vary depending on the message\n\t * and state of the ringbuffer, grab the timestamp now so that it is\n\t * close to the call of printk(). This provides a more deterministic\n\t * timestamp with respect to the caller.\n\t */\n\tts_nsec = local_clock();\n\n\tif (!printk_enter_irqsave(recursion_ptr, irqflags))\n\t\treturn 0;\n\n\t/*\n\t * The sprintf needs to come first since the syslog prefix might be\n\t * passed in as a parameter. An extra byte must be reserved so that\n\t * later the vscnprintf() into the reserved buffer has room for the\n\t * terminating '\\0', which is not counted by vsnprintf().\n\t */\n\tva_copy(args2, args);\n\treserve_size = vsnprintf(&prefix_buf[0], sizeof(prefix_buf), fmt, args2) + 1;\n\tva_end(args2);\n\n\tif (reserve_size > LOG_LINE_MAX)\n\t\treserve_size = LOG_LINE_MAX;\n\n\t/* Extract log level or control flags. */\n\tif (facility == 0)\n\t\tprintk_parse_prefix(&prefix_buf[0], &level, &flags);\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dev_info)\n\t\tflags |= LOG_NEWLINE;\n\n\tif (flags & LOG_CONT) {\n\t\tprb_rec_init_wr(&r, reserve_size);\n\t\tif (prb_reserve_in_last(&e, prb, &r, caller_id, LOG_LINE_MAX)) {\n\t\t\ttext_len = printk_sprint(&r.text_buf[r.info->text_len], reserve_size,\n\t\t\t\t\t\t facility, &flags, fmt, args);\n\t\t\tr.info->text_len += text_len;\n\n\t\t\tif (flags & LOG_NEWLINE) {\n\t\t\t\tr.info->flags |= LOG_NEWLINE;\n\t\t\t\tprb_final_commit(&e);\n\t\t\t} else {\n\t\t\t\tprb_commit(&e);\n\t\t\t}\n\n\t\t\tret = text_len;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Explicitly initialize the record before every prb_reserve() call.\n\t * prb_reserve_in_last() and prb_reserve() purposely invalidate the\n\t * structure when they fail.\n\t */\n\tprb_rec_init_wr(&r, reserve_size);\n\tif (!prb_reserve(&e, prb, &r)) {\n\t\t/* truncate the message if it is too long for empty buffer */\n\t\ttruncate_msg(&reserve_size, &trunc_msg_len);\n\n\t\tprb_rec_init_wr(&r, reserve_size + trunc_msg_len);\n\t\tif (!prb_reserve(&e, prb, &r))\n\t\t\tgoto out;\n\t}\n\n\t/* fill message */\n\ttext_len = printk_sprint(&r.text_buf[0], reserve_size, facility, &flags, fmt, args);\n\tif (trunc_msg_len)\n\t\tmemcpy(&r.text_buf[text_len], trunc_msg, trunc_msg_len);\n\tr.info->text_len = text_len + trunc_msg_len;\n\tr.info->facility = facility;\n\tr.info->level = level & 7;\n\tr.info->flags = flags & 0x1f;\n\tr.info->ts_nsec = ts_nsec;\n\tr.info->caller_id = caller_id;\n\tif (dev_info)\n\t\tmemcpy(&r.info->dev_info, dev_info, sizeof(r.info->dev_info));\n\n\t/* A message without a trailing newline can be continued. */\n\tif (!(flags & LOG_NEWLINE))\n\t\tprb_commit(&e);\n\telse\n\t\tprb_final_commit(&e);\n\n\tret = text_len + trunc_msg_len;\nout:\n\tprintk_exit_irqrestore(recursion_ptr, irqflags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LOG_LINE_MAX\t\t(CONSOLE_LOG_MAX - PREFIX_MAX)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_LINE_MAX\t\t(CONSOLE_LOG_MAX - PREFIX_MAX)\n\nint vprintk_store(int facility, int level,\n\t\t  const struct dev_printk_info *dev_info,\n\t\t  const char *fmt, va_list args)\n{\n\tconst u32 caller_id = printk_caller_id();\n\tstruct prb_reserved_entry e;\n\tenum printk_info_flags flags = 0;\n\tstruct printk_record r;\n\tunsigned long irqflags;\n\tu16 trunc_msg_len = 0;\n\tchar prefix_buf[8];\n\tu8 *recursion_ptr;\n\tu16 reserve_size;\n\tva_list args2;\n\tu16 text_len;\n\tint ret = 0;\n\tu64 ts_nsec;\n\n\t/*\n\t * Since the duration of printk() can vary depending on the message\n\t * and state of the ringbuffer, grab the timestamp now so that it is\n\t * close to the call of printk(). This provides a more deterministic\n\t * timestamp with respect to the caller.\n\t */\n\tts_nsec = local_clock();\n\n\tif (!printk_enter_irqsave(recursion_ptr, irqflags))\n\t\treturn 0;\n\n\t/*\n\t * The sprintf needs to come first since the syslog prefix might be\n\t * passed in as a parameter. An extra byte must be reserved so that\n\t * later the vscnprintf() into the reserved buffer has room for the\n\t * terminating '\\0', which is not counted by vsnprintf().\n\t */\n\tva_copy(args2, args);\n\treserve_size = vsnprintf(&prefix_buf[0], sizeof(prefix_buf), fmt, args2) + 1;\n\tva_end(args2);\n\n\tif (reserve_size > LOG_LINE_MAX)\n\t\treserve_size = LOG_LINE_MAX;\n\n\t/* Extract log level or control flags. */\n\tif (facility == 0)\n\t\tprintk_parse_prefix(&prefix_buf[0], &level, &flags);\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dev_info)\n\t\tflags |= LOG_NEWLINE;\n\n\tif (flags & LOG_CONT) {\n\t\tprb_rec_init_wr(&r, reserve_size);\n\t\tif (prb_reserve_in_last(&e, prb, &r, caller_id, LOG_LINE_MAX)) {\n\t\t\ttext_len = printk_sprint(&r.text_buf[r.info->text_len], reserve_size,\n\t\t\t\t\t\t facility, &flags, fmt, args);\n\t\t\tr.info->text_len += text_len;\n\n\t\t\tif (flags & LOG_NEWLINE) {\n\t\t\t\tr.info->flags |= LOG_NEWLINE;\n\t\t\t\tprb_final_commit(&e);\n\t\t\t} else {\n\t\t\t\tprb_commit(&e);\n\t\t\t}\n\n\t\t\tret = text_len;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Explicitly initialize the record before every prb_reserve() call.\n\t * prb_reserve_in_last() and prb_reserve() purposely invalidate the\n\t * structure when they fail.\n\t */\n\tprb_rec_init_wr(&r, reserve_size);\n\tif (!prb_reserve(&e, prb, &r)) {\n\t\t/* truncate the message if it is too long for empty buffer */\n\t\ttruncate_msg(&reserve_size, &trunc_msg_len);\n\n\t\tprb_rec_init_wr(&r, reserve_size + trunc_msg_len);\n\t\tif (!prb_reserve(&e, prb, &r))\n\t\t\tgoto out;\n\t}\n\n\t/* fill message */\n\ttext_len = printk_sprint(&r.text_buf[0], reserve_size, facility, &flags, fmt, args);\n\tif (trunc_msg_len)\n\t\tmemcpy(&r.text_buf[text_len], trunc_msg, trunc_msg_len);\n\tr.info->text_len = text_len + trunc_msg_len;\n\tr.info->facility = facility;\n\tr.info->level = level & 7;\n\tr.info->flags = flags & 0x1f;\n\tr.info->ts_nsec = ts_nsec;\n\tr.info->caller_id = caller_id;\n\tif (dev_info)\n\t\tmemcpy(&r.info->dev_info, dev_info, sizeof(r.info->dev_info));\n\n\t/* A message without a trailing newline can be continued. */\n\tif (!(flags & LOG_NEWLINE))\n\t\tprb_commit(&e);\n\telse\n\t\tprb_final_commit(&e);\n\n\tret = text_len + trunc_msg_len;\nout:\n\tprintk_exit_irqrestore(recursion_ptr, irqflags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "printk_context"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vkdb_printf",
          "args": [
            "KDB_MSGSRC_PRINTK",
            "fmt",
            "args"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "vkdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "583-857",
          "snippet": "int vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tunsigned long flags;\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH) {\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Replace the \\0 with\n\t\t\t * its original value to ensure multi-line strings\n\t\t\t * are handled properly, and return to normal mode.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tkdb_grepping_flag = 0;\n\t\t}\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected)\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\telse\n\t\tkdb_msg_write(cp, retlen - (cp - kdb_buffer));\n\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar ch;\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tkdb_msg_write(moreprompt, strlen(moreprompt));\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tch = kdb_getchar();\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((ch == 'q') || (ch == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (ch == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '\\n' || ch == '\\r') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch) {\n\t\t\t/* user hit something unexpected */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (ch != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];",
            "int kdb_printf_cpu = -1;",
            "static char kdb_buffer[256];",
            "static char *next_avail = kdb_buffer;",
            "static int  size_avail;",
            "static int  suspend_grep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nchar kdb_prompt_str[CMD_BUFLEN];\nint kdb_printf_cpu = -1;\nstatic char kdb_buffer[256];\nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tunsigned long flags;\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH) {\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Replace the \\0 with\n\t\t\t * its original value to ensure multi-line strings\n\t\t\t * are handled properly, and return to normal mode.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tkdb_grepping_flag = 0;\n\t\t}\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected)\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\telse\n\t\tkdb_msg_write(cp, retlen - (cp - kdb_buffer));\n\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar ch;\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tkdb_msg_write(moreprompt, strlen(moreprompt));\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tch = kdb_getchar();\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((ch == 'q') || (ch == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (ch == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '\\n' || ch == '\\r') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch) {\n\t\t\t/* user hit something unexpected */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (ch != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kdb_trap_printk && kdb_printf_cpu < 0"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/kprobes.h>\n#include <linux/printk.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/kdb.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nasmlinkage int vprintk(const char *fmt, va_list args)\n{\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow to pass printk() to kdb but avoid a recursion. */\n\tif (unlikely(kdb_trap_printk && kdb_printf_cpu < 0))\n\t\treturn vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);\n#endif\n\n\t/*\n\t * Use the main logbuf even in NMI. But avoid calling console\n\t * drivers that might have their own locks.\n\t */\n\tif (this_cpu_read(printk_context) || in_nmi()) {\n\t\tint len;\n\n\t\tlen = vprintk_store(0, LOGLEVEL_DEFAULT, NULL, fmt, args);\n\t\tdefer_console_output();\n\t\treturn len;\n\t}\n\n\t/* No obstacles. */\n\treturn vprintk_default(fmt, args);\n}"
  },
  {
    "function_name": "__printk_safe_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_safe.c",
    "lines": "24-27",
    "snippet": "void __printk_safe_exit(void)\n{\n\tthis_cpu_dec(printk_context);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/printk.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/kdb.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "printk_context"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/kprobes.h>\n#include <linux/printk.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/kdb.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nvoid __printk_safe_exit(void)\n{\n\tthis_cpu_dec(printk_context);\n}"
  },
  {
    "function_name": "__printk_safe_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_safe.c",
    "lines": "18-21",
    "snippet": "void __printk_safe_enter(void)\n{\n\tthis_cpu_inc(printk_context);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/printk.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/kdb.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "printk_context"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/kprobes.h>\n#include <linux/printk.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/kdb.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nvoid __printk_safe_enter(void)\n{\n\tthis_cpu_inc(printk_context);\n}"
  }
]