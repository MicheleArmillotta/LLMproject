[
  {
    "function_name": "klp_is_patch_compatible",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/state.c",
    "lines": "106-119",
    "snippet": "bool klp_is_patch_compatible(struct klp_patch *patch)\n{\n\tstruct klp_patch *old_patch;\n\tstruct klp_state *old_state;\n\n\tklp_for_each_patch(old_patch) {\n\t\tklp_for_each_state(old_patch, old_state) {\n\t\t\tif (!klp_is_state_compatible(patch, old_state))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"state.h\"",
      "#include \"core.h\"",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_is_state_compatible",
          "args": [
            "patch",
            "old_state"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_state_compatible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/state.c",
          "lines": "87-99",
          "snippet": "static bool klp_is_state_compatible(struct klp_patch *patch,\n\t\t\t\t    struct klp_state *old_state)\n{\n\tstruct klp_state *state;\n\n\tstate = klp_get_state(patch, old_state->id);\n\n\t/* A cumulative livepatch must handle all already modified states. */\n\tif (!state)\n\t\treturn !patch->replace;\n\n\treturn state->version >= old_state->version;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"state.h\"",
            "#include \"core.h\"",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"core.h\"\n#include <linux/livepatch.h>\n\nstatic bool klp_is_state_compatible(struct klp_patch *patch,\n\t\t\t\t    struct klp_state *old_state)\n{\n\tstruct klp_state *state;\n\n\tstate = klp_get_state(patch, old_state->id);\n\n\t/* A cumulative livepatch must handle all already modified states. */\n\tif (!state)\n\t\treturn !patch->replace;\n\n\treturn state->version >= old_state->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_state",
          "args": [
            "old_patch",
            "old_state"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"core.h\"\n#include <linux/livepatch.h>\n\nbool klp_is_patch_compatible(struct klp_patch *patch)\n{\n\tstruct klp_patch *old_patch;\n\tstruct klp_state *old_state;\n\n\tklp_for_each_patch(old_patch) {\n\t\tklp_for_each_state(old_patch, old_state) {\n\t\t\tif (!klp_is_state_compatible(patch, old_state))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "klp_is_state_compatible",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/state.c",
    "lines": "87-99",
    "snippet": "static bool klp_is_state_compatible(struct klp_patch *patch,\n\t\t\t\t    struct klp_state *old_state)\n{\n\tstruct klp_state *state;\n\n\tstate = klp_get_state(patch, old_state->id);\n\n\t/* A cumulative livepatch must handle all already modified states. */\n\tif (!state)\n\t\treturn !patch->replace;\n\n\treturn state->version >= old_state->version;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"state.h\"",
      "#include \"core.h\"",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_get_state",
          "args": [
            "patch",
            "old_state->id"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "klp_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/state.c",
          "lines": "31-41",
          "snippet": "struct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id)\n{\n\tstruct klp_state *state;\n\n\tklp_for_each_state(patch, state) {\n\t\tif (state->id == id)\n\t\t\treturn state;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"state.h\"",
            "#include \"core.h\"",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"core.h\"\n#include <linux/livepatch.h>\n\nstruct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id)\n{\n\tstruct klp_state *state;\n\n\tklp_for_each_state(patch, state) {\n\t\tif (state->id == id)\n\t\t\treturn state;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"core.h\"\n#include <linux/livepatch.h>\n\nstatic bool klp_is_state_compatible(struct klp_patch *patch,\n\t\t\t\t    struct klp_state *old_state)\n{\n\tstruct klp_state *state;\n\n\tstate = klp_get_state(patch, old_state->id);\n\n\t/* A cumulative livepatch must handle all already modified states. */\n\tif (!state)\n\t\treturn !patch->replace;\n\n\treturn state->version >= old_state->version;\n}"
  },
  {
    "function_name": "klp_get_prev_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/state.c",
    "lines": "64-83",
    "snippet": "struct klp_state *klp_get_prev_state(unsigned long id)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_state *state, *last_state = NULL;\n\n\tif (WARN_ON_ONCE(!klp_transition_patch))\n\t\treturn NULL;\n\n\tklp_for_each_patch(patch) {\n\t\tif (patch == klp_transition_patch)\n\t\t\tgoto out;\n\n\t\tstate = klp_get_state(patch, id);\n\t\tif (state)\n\t\t\tlast_state = state;\n\t}\n\nout:\n\treturn last_state;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"state.h\"",
      "#include \"core.h\"",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_get_state",
          "args": [
            "patch",
            "id"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "klp_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/state.c",
          "lines": "31-41",
          "snippet": "struct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id)\n{\n\tstruct klp_state *state;\n\n\tklp_for_each_state(patch, state) {\n\t\tif (state->id == id)\n\t\t\treturn state;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"state.h\"",
            "#include \"core.h\"",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"core.h\"\n#include <linux/livepatch.h>\n\nstruct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id)\n{\n\tstruct klp_state *state;\n\n\tklp_for_each_state(patch, state) {\n\t\tif (state->id == id)\n\t\t\treturn state;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!klp_transition_patch"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"core.h\"\n#include <linux/livepatch.h>\n\nstruct klp_state *klp_get_prev_state(unsigned long id)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_state *state, *last_state = NULL;\n\n\tif (WARN_ON_ONCE(!klp_transition_patch))\n\t\treturn NULL;\n\n\tklp_for_each_patch(patch) {\n\t\tif (patch == klp_transition_patch)\n\t\t\tgoto out;\n\n\t\tstate = klp_get_state(patch, id);\n\t\tif (state)\n\t\t\tlast_state = state;\n\t}\n\nout:\n\treturn last_state;\n}"
  },
  {
    "function_name": "klp_get_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/state.c",
    "lines": "31-41",
    "snippet": "struct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id)\n{\n\tstruct klp_state *state;\n\n\tklp_for_each_state(patch, state) {\n\t\tif (state->id == id)\n\t\t\treturn state;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"state.h\"",
      "#include \"core.h\"",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_for_each_state",
          "args": [
            "patch",
            "state"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"core.h\"\n#include <linux/livepatch.h>\n\nstruct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id)\n{\n\tstruct klp_state *state;\n\n\tklp_for_each_state(patch, state) {\n\t\tif (state->id == id)\n\t\t\treturn state;\n\t}\n\n\treturn NULL;\n}"
  }
]