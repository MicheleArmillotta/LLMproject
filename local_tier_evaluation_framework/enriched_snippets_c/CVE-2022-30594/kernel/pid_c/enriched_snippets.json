[
  {
    "function_name": "pidfd_getfd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "686-705",
    "snippet": "static int pidfd_getfd(struct pid *pid, int fd)\n{\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint ret;\n\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tfile = __pidfd_fget(task, fd);\n\tput_task_struct(task);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tret = receive_fd(file, O_CLOEXEC);\n\tfput(file);\n\n\treturn ret;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_fd",
          "args": [
            "file",
            "O_CLOEXEC"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pidfd_fget",
          "args": [
            "task",
            "fd"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__pidfd_fget",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "667-684",
          "snippet": "static struct file *__pidfd_fget(struct task_struct *task, int fd)\n{\n\tstruct file *file;\n\tint ret;\n\n\tret = down_read_killable(&task->signal->exec_update_lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS))\n\t\tfile = fget_task(task, fd);\n\telse\n\t\tfile = ERR_PTR(-EPERM);\n\n\tup_read(&task->signal->exec_update_lock);\n\n\treturn file ?: ERR_PTR(-EBADF);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic struct file *__pidfd_fget(struct task_struct *task, int fd)\n{\n\tstruct file *file;\n\tint ret;\n\n\tret = down_read_killable(&task->signal->exec_update_lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS))\n\t\tfile = fget_task(task, fd);\n\telse\n\t\tfile = ERR_PTR(-EPERM);\n\n\tup_read(&task->signal->exec_update_lock);\n\n\treturn file ?: ERR_PTR(-EBADF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic int pidfd_getfd(struct pid *pid, int fd)\n{\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint ret;\n\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tfile = __pidfd_fget(task, fd);\n\tput_task_struct(task);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tret = receive_fd(file, O_CLOEXEC);\n\tfput(file);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__pidfd_fget",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "667-684",
    "snippet": "static struct file *__pidfd_fget(struct task_struct *task, int fd)\n{\n\tstruct file *file;\n\tint ret;\n\n\tret = down_read_killable(&task->signal->exec_update_lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS))\n\t\tfile = fget_task(task, fd);\n\telse\n\t\tfile = ERR_PTR(-EPERM);\n\n\tup_read(&task->signal->exec_update_lock);\n\n\treturn file ?: ERR_PTR(-EBADF);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&task->signal->exec_update_lock"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget_task",
          "args": [
            "task",
            "fd"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_ATTACH_REALCREDS"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_may_access",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ptrace.c",
          "lines": "365-372",
          "snippet": "bool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}",
          "includes": [
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <linux/minmax.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <linux/minmax.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nbool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_killable",
          "args": [
            "&task->signal->exec_update_lock"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_killable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "1481-1492",
          "snippet": "int __sched down_read_killable(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);\n\n\tif (LOCK_CONTENDED_RETURN(sem, __down_read_trylock, __down_read_killable)) {\n\t\trwsem_release(&sem->dep_map, _RET_IP_);\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint __sched down_read_killable(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);\n\n\tif (LOCK_CONTENDED_RETURN(sem, __down_read_trylock, __down_read_killable)) {\n\t\trwsem_release(&sem->dep_map, _RET_IP_);\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic struct file *__pidfd_fget(struct task_struct *task, int fd)\n{\n\tstruct file *file;\n\tint ret;\n\n\tret = down_read_killable(&task->signal->exec_update_lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS))\n\t\tfile = fget_task(task, fd);\n\telse\n\t\tfile = ERR_PTR(-EPERM);\n\n\tup_read(&task->signal->exec_update_lock);\n\n\treturn file ?: ERR_PTR(-EBADF);\n}"
  },
  {
    "function_name": "pid_idr_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "649-665",
    "snippet": "void __init pid_idr_init(void)\n{\n\t/* Verify no one has done anything silly: */\n\tBUILD_BUG_ON(PID_MAX_LIMIT >= PIDNS_ADDING);\n\n\t/* bump default and minimum pid_max based on number of cpus */\n\tpid_max = min(pid_max_max, max_t(int, pid_max,\n\t\t\t\tPIDS_PER_CPU_DEFAULT * num_possible_cpus()));\n\tpid_max_min = max_t(int, pid_max_min,\n\t\t\t\tPIDS_PER_CPU_MIN * num_possible_cpus());\n\tpr_info(\"pid_max: default: %u minimum: %u\\n\", pid_max, pid_max_min);\n\n\tidr_init(&init_pid_ns.idr);\n\n\tinit_pid_ns.pid_cachep = KMEM_CACHE(pid,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pid_max = PID_MAX_DEFAULT;",
      "int pid_max_min = RESERVED_PIDS + 1;",
      "int pid_max_max = PID_MAX_LIMIT;",
      "struct pid_namespace init_pid_ns = {\n\t.ns.count = REFCOUNT_INIT(2),\n\t.idr = IDR_INIT(init_pid_ns.idr),\n\t.pid_allocated = PIDNS_ADDING,\n\t.level = 0,\n\t.child_reaper = &init_task,\n\t.user_ns = &init_user_ns,\n\t.ns.inum = PROC_PID_INIT_INO,\n#ifdef CONFIG_PID_NS\n\t.ns.ops = &pidns_operations,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "pid",
            "SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&init_pid_ns.idr"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"pid_max: default: %u minimum: %u\\n\"",
            "pid_max",
            "pid_max_min"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "pid_max_min",
            "PIDS_PER_CPU_MIN * num_possible_cpus()"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1831-1865",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pid_max_max",
            "max_t(int, pid_max,\n\t\t\t\tPIDS_PER_CPU_DEFAULT * num_possible_cpus())"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PID_MAX_LIMIT >= PIDNS_ADDING"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nint pid_max = PID_MAX_DEFAULT;\nint pid_max_min = RESERVED_PIDS + 1;\nint pid_max_max = PID_MAX_LIMIT;\nstruct pid_namespace init_pid_ns = {\n\t.ns.count = REFCOUNT_INIT(2),\n\t.idr = IDR_INIT(init_pid_ns.idr),\n\t.pid_allocated = PIDNS_ADDING,\n\t.level = 0,\n\t.child_reaper = &init_task,\n\t.user_ns = &init_user_ns,\n\t.ns.inum = PROC_PID_INIT_INO,\n#ifdef CONFIG_PID_NS\n\t.ns.ops = &pidns_operations,\n#endif\n};\n\nvoid __init pid_idr_init(void)\n{\n\t/* Verify no one has done anything silly: */\n\tBUILD_BUG_ON(PID_MAX_LIMIT >= PIDNS_ADDING);\n\n\t/* bump default and minimum pid_max based on number of cpus */\n\tpid_max = min(pid_max_max, max_t(int, pid_max,\n\t\t\t\tPIDS_PER_CPU_DEFAULT * num_possible_cpus()));\n\tpid_max_min = max_t(int, pid_max_min,\n\t\t\t\tPIDS_PER_CPU_MIN * num_possible_cpus());\n\tpr_info(\"pid_max: default: %u minimum: %u\\n\", pid_max, pid_max_min);\n\n\tidr_init(&init_pid_ns.idr);\n\n\tinit_pid_ns.pid_cachep = KMEM_CACHE(pid,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT);\n}"
  },
  {
    "function_name": "pidfd_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "594-610",
    "snippet": "int pidfd_create(struct pid *pid, unsigned int flags)\n{\n\tint fd;\n\n\tif (!pid || !pid_has_task(pid, PIDTYPE_TGID))\n\t\treturn -EINVAL;\n\n\tif (flags & ~(O_NONBLOCK | O_RDWR | O_CLOEXEC))\n\t\treturn -EINVAL;\n\n\tfd = anon_inode_getfd(\"[pidfd]\", &pidfd_fops, get_pid(pid),\n\t\t\t      flags | O_RDWR | O_CLOEXEC);\n\tif (fd < 0)\n\t\tput_pid(pid);\n\n\treturn fd;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "pid"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"[pidfd]\"",
            "&pidfd_fops",
            "get_pid(pid)",
            "flags | O_RDWR | O_CLOEXEC"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "pid"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_has_task",
          "args": [
            "pid",
            "PIDTYPE_TGID"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nint pidfd_create(struct pid *pid, unsigned int flags)\n{\n\tint fd;\n\n\tif (!pid || !pid_has_task(pid, PIDTYPE_TGID))\n\t\treturn -EINVAL;\n\n\tif (flags & ~(O_NONBLOCK | O_RDWR | O_CLOEXEC))\n\t\treturn -EINVAL;\n\n\tfd = anon_inode_getfd(\"[pidfd]\", &pidfd_fops, get_pid(pid),\n\t\t\t      flags | O_RDWR | O_CLOEXEC);\n\tif (fd < 0)\n\t\tput_pid(pid);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "pidfd_get_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "559-576",
    "snippet": "struct task_struct *pidfd_get_task(int pidfd, unsigned int *flags)\n{\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\n\tpid = pidfd_get_pid(pidfd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn ERR_CAST(pid);\n\n\ttask = get_pid_task(pid, PIDTYPE_TGID);\n\tput_pid(pid);\n\tif (!task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\t*flags = f_flags;\n\treturn task;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESRCH"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "pid"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid_task",
          "args": [
            "pid",
            "PIDTYPE_TGID"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "pid"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pid"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pidfd_get_pid",
          "args": [
            "pidfd",
            "&f_flags"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "pidfd_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "523-540",
          "snippet": "struct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *pidfd_get_task(int pidfd, unsigned int *flags)\n{\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\n\tpid = pidfd_get_pid(pidfd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn ERR_CAST(pid);\n\n\ttask = get_pid_task(pid, PIDTYPE_TGID);\n\tput_pid(pid);\n\tif (!task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\t*flags = f_flags;\n\treturn task;\n}"
  },
  {
    "function_name": "pidfd_get_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "523-540",
    "snippet": "struct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "pid"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pid"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pidfd_pid",
          "args": [
            "f.file"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "pidfd_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1747-1753",
          "snippet": "struct pid *pidfd_pid(const struct file *file)\n{\n\tif (file->f_op == &pidfd_fops)\n\t\treturn file->private_data;\n\n\treturn ERR_PTR(-EBADF);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pidfd_fops = {\n\t.release = pidfd_release,\n\t.poll = pidfd_poll,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = pidfd_show_fdinfo,\n#endif\n};",
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nconst struct file_operations pidfd_fops = {\n\t.release = pidfd_release,\n\t.poll = pidfd_poll,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = pidfd_show_fdinfo,\n#endif\n};\nstatic __latent_entropy struct;\n\nstruct pid *pidfd_pid(const struct file *file)\n{\n\tif (file->f_op == &pidfd_fops)\n\t\treturn file->private_data;\n\n\treturn ERR_PTR(-EBADF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}"
  },
  {
    "function_name": "find_ge_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "518-521",
    "snippet": "struct pid *find_ge_pid(int nr, struct pid_namespace *ns)\n{\n\treturn idr_get_next(&ns->idr, &nr);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_get_next",
          "args": [
            "&ns->idr",
            "&nr"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_ge_pid(int nr, struct pid_namespace *ns)\n{\n\treturn idr_get_next(&ns->idr, &nr);\n}"
  },
  {
    "function_name": "task_active_pid_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "507-510",
    "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_of_pid",
          "args": [
            "task_pid(tsk)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "tsk"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "init_task_pid_links",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1710-1716",
          "snippet": "static inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
  },
  {
    "function_name": "__task_pid_nr_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "492-504",
    "snippet": "pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid_namespace *ns)\n{\n\tpid_t nr = 0;\n\n\trcu_read_lock();\n\tif (!ns)\n\t\tns = task_active_pid_ns(current);\n\tnr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);\n\trcu_read_unlock();\n\n\treturn nr;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_nr_ns",
          "args": [
            "rcu_dereference(*task_pid_ptr(task, type))",
            "ns"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "pid_nr_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "472-483",
          "snippet": "pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*task_pid_ptr(task, type)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_ptr",
          "args": [
            "task",
            "type"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "task_pid_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "321-326",
          "snippet": "static struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid_namespace *ns)\n{\n\tpid_t nr = 0;\n\n\trcu_read_lock();\n\tif (!ns)\n\t\tns = task_active_pid_ns(current);\n\tnr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);\n\trcu_read_unlock();\n\n\treturn nr;\n}"
  },
  {
    "function_name": "pid_vnr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "486-489",
    "snippet": "pid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_nr_ns",
          "args": [
            "pid",
            "task_active_pid_ns(current)"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "pid_nr_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "472-483",
          "snippet": "pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}"
  },
  {
    "function_name": "pid_nr_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "472-483",
    "snippet": "pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}"
  },
  {
    "function_name": "find_get_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "460-469",
    "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "find_vpid(nr)"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "nr"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "315-318",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
  },
  {
    "function_name": "get_pid_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "448-457",
    "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "result"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "type"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
  },
  {
    "function_name": "get_task_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "438-445",
    "snippet": "struct pid *get_task_pid(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid;\n\trcu_read_lock();\n\tpid = get_pid(rcu_dereference(*task_pid_ptr(task, type)));\n\trcu_read_unlock();\n\treturn pid;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "rcu_dereference(*task_pid_ptr(task, type))"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*task_pid_ptr(task, type)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_ptr",
          "args": [
            "task",
            "type"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "task_pid_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "321-326",
          "snippet": "static struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *get_task_pid(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid;\n\trcu_read_lock();\n\tpid = get_pid(rcu_dereference(*task_pid_ptr(task, type)));\n\trcu_read_unlock();\n\treturn pid;\n}"
  },
  {
    "function_name": "find_get_task_by_vpid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "425-436",
    "snippet": "struct task_struct *find_get_task_by_vpid(pid_t nr)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\ttask = find_task_by_vpid(nr);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\treturn task;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "nr"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "420-423",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_get_task_by_vpid(pid_t nr)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\ttask = find_task_by_vpid(nr);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\treturn task;\n}"
  },
  {
    "function_name": "find_task_by_vpid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "420-423",
    "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "vnr",
            "task_active_pid_ns(current)"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "413-418",
          "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
  },
  {
    "function_name": "find_task_by_pid_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "413-418",
    "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "find_pid_ns(nr, ns)",
            "PIDTYPE_PID"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_pid_ns",
          "args": [
            "nr",
            "ns"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "find_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "309-312",
          "snippet": "struct pid *find_pid_ns(int nr, struct pid_namespace *ns)\n{\n\treturn idr_find(&ns->idr, nr);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_pid_ns(int nr, struct pid_namespace *ns)\n{\n\treturn idr_find(&ns->idr, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!rcu_read_lock_held()",
            "\"find_task_by_pid_ns() needs rcu_read_lock() protection\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "305-312",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
  },
  {
    "function_name": "pid_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "396-407",
    "snippet": "struct task_struct *pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result = NULL;\n\tif (pid) {\n\t\tstruct hlist_node *first;\n\t\tfirst = rcu_dereference_check(hlist_first_rcu(&pid->tasks[type]),\n\t\t\t\t\t      lockdep_tasklist_lock_is_held());\n\t\tif (first)\n\t\t\tresult = hlist_entry(first, struct task_struct, pid_links[(type)]);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "first",
            "structtask_struct",
            "pid_links[(type)]"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "hlist_first_rcu(&pid->tasks[type])",
            "lockdep_tasklist_lock_is_held()"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_tasklist_lock_is_held",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_tasklist_lock_is_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "144-147",
          "snippet": "int lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);\n\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_first_rcu",
          "args": [
            "&pid->tasks[type]"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result = NULL;\n\tif (pid) {\n\t\tstruct hlist_node *first;\n\t\tfirst = rcu_dereference_check(hlist_first_rcu(&pid->tasks[type]),\n\t\t\t\t\t      lockdep_tasklist_lock_is_held());\n\t\tif (first)\n\t\t\tresult = hlist_entry(first, struct task_struct, pid_links[(type)]);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "transfer_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "388-394",
    "snippet": "void transfer_pid(struct task_struct *old, struct task_struct *new,\n\t\t\t   enum pid_type type)\n{\n\tif (type == PIDTYPE_PID)\n\t\tnew->thread_pid = old->thread_pid;\n\thlist_replace_rcu(&old->pid_links[type], &new->pid_links[type]);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_replace_rcu",
          "args": [
            "&old->pid_links[type]",
            "&new->pid_links[type]"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid transfer_pid(struct task_struct *old, struct task_struct *new,\n\t\t\t   enum pid_type type)\n{\n\tif (type == PIDTYPE_PID)\n\t\tnew->thread_pid = old->thread_pid;\n\thlist_replace_rcu(&old->pid_links[type], &new->pid_links[type]);\n}"
  },
  {
    "function_name": "exchange_tids",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "368-385",
    "snippet": "void exchange_tids(struct task_struct *left, struct task_struct *right)\n{\n\tstruct pid *pid1 = left->thread_pid;\n\tstruct pid *pid2 = right->thread_pid;\n\tstruct hlist_head *head1 = &pid1->tasks[PIDTYPE_PID];\n\tstruct hlist_head *head2 = &pid2->tasks[PIDTYPE_PID];\n\n\t/* Swap the single entry tid lists */\n\thlists_swap_heads_rcu(head1, head2);\n\n\t/* Swap the per task_struct pid */\n\trcu_assign_pointer(left->thread_pid, pid2);\n\trcu_assign_pointer(right->thread_pid, pid1);\n\n\t/* Swap the cached value */\n\tWRITE_ONCE(left->pid, pid_nr(pid2));\n\tWRITE_ONCE(right->pid, pid_nr(pid1));\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "right->pid",
            "pid_nr(pid1)"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_nr",
          "args": [
            "pid1"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "left->pid",
            "pid_nr(pid2)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_nr",
          "args": [
            "pid2"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "right->thread_pid",
            "pid1"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "left->thread_pid",
            "pid2"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlists_swap_heads_rcu",
          "args": [
            "head1",
            "head2"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid exchange_tids(struct task_struct *left, struct task_struct *right)\n{\n\tstruct pid *pid1 = left->thread_pid;\n\tstruct pid *pid2 = right->thread_pid;\n\tstruct hlist_head *head1 = &pid1->tasks[PIDTYPE_PID];\n\tstruct hlist_head *head2 = &pid2->tasks[PIDTYPE_PID];\n\n\t/* Swap the single entry tid lists */\n\thlists_swap_heads_rcu(head1, head2);\n\n\t/* Swap the per task_struct pid */\n\trcu_assign_pointer(left->thread_pid, pid2);\n\trcu_assign_pointer(right->thread_pid, pid1);\n\n\t/* Swap the cached value */\n\tWRITE_ONCE(left->pid, pid_nr(pid2));\n\tWRITE_ONCE(right->pid, pid_nr(pid1));\n}"
  },
  {
    "function_name": "change_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "361-366",
    "snippet": "void change_pid(struct task_struct *task, enum pid_type type,\n\t\tstruct pid *pid)\n{\n\t__change_pid(task, type, pid);\n\tattach_pid(task, type);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach_pid",
          "args": [
            "task",
            "type"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "attach_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "331-335",
          "snippet": "void attach_pid(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid = *task_pid_ptr(task, type);\n\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid attach_pid(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid = *task_pid_ptr(task, type);\n\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__change_pid",
          "args": [
            "task",
            "type",
            "pid"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "__change_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "337-354",
          "snippet": "static void __change_pid(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid *new)\n{\n\tstruct pid **pid_ptr = task_pid_ptr(task, type);\n\tstruct pid *pid;\n\tint tmp;\n\n\tpid = *pid_ptr;\n\n\thlist_del_rcu(&task->pid_links[type]);\n\t*pid_ptr = new;\n\n\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )\n\t\tif (pid_has_task(pid, tmp))\n\t\t\treturn;\n\n\tfree_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void __change_pid(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid *new)\n{\n\tstruct pid **pid_ptr = task_pid_ptr(task, type);\n\tstruct pid *pid;\n\tint tmp;\n\n\tpid = *pid_ptr;\n\n\thlist_del_rcu(&task->pid_links[type]);\n\t*pid_ptr = new;\n\n\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )\n\t\tif (pid_has_task(pid, tmp))\n\t\t\treturn;\n\n\tfree_pid(pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid change_pid(struct task_struct *task, enum pid_type type,\n\t\tstruct pid *pid)\n{\n\t__change_pid(task, type, pid);\n\tattach_pid(task, type);\n}"
  },
  {
    "function_name": "detach_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "356-359",
    "snippet": "void detach_pid(struct task_struct *task, enum pid_type type)\n{\n\t__change_pid(task, type, NULL);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__change_pid",
          "args": [
            "task",
            "type",
            "NULL"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__change_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "337-354",
          "snippet": "static void __change_pid(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid *new)\n{\n\tstruct pid **pid_ptr = task_pid_ptr(task, type);\n\tstruct pid *pid;\n\tint tmp;\n\n\tpid = *pid_ptr;\n\n\thlist_del_rcu(&task->pid_links[type]);\n\t*pid_ptr = new;\n\n\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )\n\t\tif (pid_has_task(pid, tmp))\n\t\t\treturn;\n\n\tfree_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void __change_pid(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid *new)\n{\n\tstruct pid **pid_ptr = task_pid_ptr(task, type);\n\tstruct pid *pid;\n\tint tmp;\n\n\tpid = *pid_ptr;\n\n\thlist_del_rcu(&task->pid_links[type]);\n\t*pid_ptr = new;\n\n\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )\n\t\tif (pid_has_task(pid, tmp))\n\t\t\treturn;\n\n\tfree_pid(pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid detach_pid(struct task_struct *task, enum pid_type type)\n{\n\t__change_pid(task, type, NULL);\n}"
  },
  {
    "function_name": "__change_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "337-354",
    "snippet": "static void __change_pid(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid *new)\n{\n\tstruct pid **pid_ptr = task_pid_ptr(task, type);\n\tstruct pid *pid;\n\tint tmp;\n\n\tpid = *pid_ptr;\n\n\thlist_del_rcu(&task->pid_links[type]);\n\t*pid_ptr = new;\n\n\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )\n\t\tif (pid_has_task(pid, tmp))\n\t\t\treturn;\n\n\tfree_pid(pid);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pid",
          "args": [
            "pid"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "free_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "126-157",
          "snippet": "void free_pid(struct pid *pid)\n{\n\t/* We can be called with write_lock_irq(&tasklist_lock) held */\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pidmap_lock, flags);\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tstruct upid *upid = pid->numbers + i;\n\t\tstruct pid_namespace *ns = upid->ns;\n\t\tswitch (--ns->pid_allocated) {\n\t\tcase 2:\n\t\tcase 1:\n\t\t\t/* When all that is left in the pid namespace\n\t\t\t * is the reaper wake up the reaper.  The reaper\n\t\t\t * may be sleeping in zap_pid_ns_processes().\n\t\t\t */\n\t\t\twake_up_process(ns->child_reaper);\n\t\t\tbreak;\n\t\tcase PIDNS_ADDING:\n\t\t\t/* Handle a fork failure of the first process */\n\t\t\tWARN_ON(ns->child_reaper);\n\t\t\tns->pid_allocated = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tidr_remove(&ns->idr, upid->nr);\n\t}\n\tspin_unlock_irqrestore(&pidmap_lock, flags);\n\n\tcall_rcu(&pid->rcu, delayed_put_pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);\n\nvoid free_pid(struct pid *pid)\n{\n\t/* We can be called with write_lock_irq(&tasklist_lock) held */\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pidmap_lock, flags);\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tstruct upid *upid = pid->numbers + i;\n\t\tstruct pid_namespace *ns = upid->ns;\n\t\tswitch (--ns->pid_allocated) {\n\t\tcase 2:\n\t\tcase 1:\n\t\t\t/* When all that is left in the pid namespace\n\t\t\t * is the reaper wake up the reaper.  The reaper\n\t\t\t * may be sleeping in zap_pid_ns_processes().\n\t\t\t */\n\t\t\twake_up_process(ns->child_reaper);\n\t\t\tbreak;\n\t\tcase PIDNS_ADDING:\n\t\t\t/* Handle a fork failure of the first process */\n\t\t\tWARN_ON(ns->child_reaper);\n\t\t\tns->pid_allocated = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tidr_remove(&ns->idr, upid->nr);\n\t}\n\tspin_unlock_irqrestore(&pidmap_lock, flags);\n\n\tcall_rcu(&pid->rcu, delayed_put_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_has_task",
          "args": [
            "pid",
            "tmp"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&task->pid_links[type]"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_ptr",
          "args": [
            "task",
            "type"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "task_pid_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "321-326",
          "snippet": "static struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void __change_pid(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid *new)\n{\n\tstruct pid **pid_ptr = task_pid_ptr(task, type);\n\tstruct pid *pid;\n\tint tmp;\n\n\tpid = *pid_ptr;\n\n\thlist_del_rcu(&task->pid_links[type]);\n\t*pid_ptr = new;\n\n\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )\n\t\tif (pid_has_task(pid, tmp))\n\t\t\treturn;\n\n\tfree_pid(pid);\n}"
  },
  {
    "function_name": "attach_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "331-335",
    "snippet": "void attach_pid(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid = *task_pid_ptr(task, type);\n\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&task->pid_links[type]",
            "&pid->tasks[type]"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_ptr",
          "args": [
            "task",
            "type"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "task_pid_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "321-326",
          "snippet": "static struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid attach_pid(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid = *task_pid_ptr(task, type);\n\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);\n}"
  },
  {
    "function_name": "task_pid_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "321-326",
    "snippet": "static struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}"
  },
  {
    "function_name": "find_vpid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "315-318",
    "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_pid_ns",
          "args": [
            "nr",
            "task_active_pid_ns(current)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "find_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "309-312",
          "snippet": "struct pid *find_pid_ns(int nr, struct pid_namespace *ns)\n{\n\treturn idr_find(&ns->idr, nr);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_pid_ns(int nr, struct pid_namespace *ns)\n{\n\treturn idr_find(&ns->idr, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
  },
  {
    "function_name": "find_pid_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "309-312",
    "snippet": "struct pid *find_pid_ns(int nr, struct pid_namespace *ns)\n{\n\treturn idr_find(&ns->idr, nr);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&ns->idr",
            "nr"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_pid_ns(int nr, struct pid_namespace *ns)\n{\n\treturn idr_find(&ns->idr, nr);\n}"
  },
  {
    "function_name": "disable_pid_allocation",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "302-307",
    "snippet": "void disable_pid_allocation(struct pid_namespace *ns)\n{\n\tspin_lock_irq(&pidmap_lock);\n\tns->pid_allocated &= ~PIDNS_ADDING;\n\tspin_unlock_irq(&pidmap_lock);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pidmap_lock"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pidmap_lock"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);\n\nvoid disable_pid_allocation(struct pid_namespace *ns)\n{\n\tspin_lock_irq(&pidmap_lock);\n\tns->pid_allocated &= ~PIDNS_ADDING;\n\tspin_unlock_irq(&pidmap_lock);\n}"
  },
  {
    "function_name": "alloc_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "159-300",
    "snippet": "struct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid,\n\t\t      size_t set_tid_size)\n{\n\tstruct pid *pid;\n\tenum pid_type type;\n\tint i, nr;\n\tstruct pid_namespace *tmp;\n\tstruct upid *upid;\n\tint retval = -ENOMEM;\n\n\t/*\n\t * set_tid_size contains the size of the set_tid array. Starting at\n\t * the most nested currently active PID namespace it tells alloc_pid()\n\t * which PID to set for a process in that most nested PID namespace\n\t * up to set_tid_size PID namespaces. It does not have to set the PID\n\t * for a process in all nested PID namespaces but set_tid_size must\n\t * never be greater than the current ns->level + 1.\n\t */\n\tif (set_tid_size > ns->level + 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpid = kmem_cache_alloc(ns->pid_cachep, GFP_KERNEL);\n\tif (!pid)\n\t\treturn ERR_PTR(retval);\n\n\ttmp = ns;\n\tpid->level = ns->level;\n\n\tfor (i = ns->level; i >= 0; i--) {\n\t\tint tid = 0;\n\n\t\tif (set_tid_size) {\n\t\t\ttid = set_tid[ns->level - i];\n\n\t\t\tretval = -EINVAL;\n\t\t\tif (tid < 1 || tid >= pid_max)\n\t\t\t\tgoto out_free;\n\t\t\t/*\n\t\t\t * Also fail if a PID != 1 is requested and\n\t\t\t * no PID 1 exists.\n\t\t\t */\n\t\t\tif (tid != 1 && !tmp->child_reaper)\n\t\t\t\tgoto out_free;\n\t\t\tretval = -EPERM;\n\t\t\tif (!checkpoint_restore_ns_capable(tmp->user_ns))\n\t\t\t\tgoto out_free;\n\t\t\tset_tid_size--;\n\t\t}\n\n\t\tidr_preload(GFP_KERNEL);\n\t\tspin_lock_irq(&pidmap_lock);\n\n\t\tif (tid) {\n\t\t\tnr = idr_alloc(&tmp->idr, NULL, tid,\n\t\t\t\t       tid + 1, GFP_ATOMIC);\n\t\t\t/*\n\t\t\t * If ENOSPC is returned it means that the PID is\n\t\t\t * alreay in use. Return EEXIST in that case.\n\t\t\t */\n\t\t\tif (nr == -ENOSPC)\n\t\t\t\tnr = -EEXIST;\n\t\t} else {\n\t\t\tint pid_min = 1;\n\t\t\t/*\n\t\t\t * init really needs pid 1, but after reaching the\n\t\t\t * maximum wrap back to RESERVED_PIDS\n\t\t\t */\n\t\t\tif (idr_get_cursor(&tmp->idr) > RESERVED_PIDS)\n\t\t\t\tpid_min = RESERVED_PIDS;\n\n\t\t\t/*\n\t\t\t * Store a null pointer so find_pid_ns does not find\n\t\t\t * a partially initialized PID (see below).\n\t\t\t */\n\t\t\tnr = idr_alloc_cyclic(&tmp->idr, NULL, pid_min,\n\t\t\t\t\t      pid_max, GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock_irq(&pidmap_lock);\n\t\tidr_preload_end();\n\n\t\tif (nr < 0) {\n\t\t\tretval = (nr == -ENOSPC) ? -EAGAIN : nr;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tpid->numbers[i].nr = nr;\n\t\tpid->numbers[i].ns = tmp;\n\t\ttmp = tmp->parent;\n\t}\n\n\t/*\n\t * ENOMEM is not the most obvious choice especially for the case\n\t * where the child subreaper has already exited and the pid\n\t * namespace denies the creation of any new processes. But ENOMEM\n\t * is what we have exposed to userspace for a long time and it is\n\t * documented behavior for pid namespaces. So we can't easily\n\t * change it even if there were an error code better suited.\n\t */\n\tretval = -ENOMEM;\n\n\tget_pid_ns(ns);\n\trefcount_set(&pid->count, 1);\n\tspin_lock_init(&pid->lock);\n\tfor (type = 0; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_HEAD(&pid->tasks[type]);\n\n\tinit_waitqueue_head(&pid->wait_pidfd);\n\tINIT_HLIST_HEAD(&pid->inodes);\n\n\tupid = pid->numbers + ns->level;\n\tspin_lock_irq(&pidmap_lock);\n\tif (!(ns->pid_allocated & PIDNS_ADDING))\n\t\tgoto out_unlock;\n\tfor ( ; upid >= pid->numbers; --upid) {\n\t\t/* Make the PID visible to find_pid_ns. */\n\t\tidr_replace(&upid->ns->idr, pid, upid->nr);\n\t\tupid->ns->pid_allocated++;\n\t}\n\tspin_unlock_irq(&pidmap_lock);\n\n\treturn pid;\n\nout_unlock:\n\tspin_unlock_irq(&pidmap_lock);\n\tput_pid_ns(ns);\n\nout_free:\n\tspin_lock_irq(&pidmap_lock);\n\twhile (++i <= ns->level) {\n\t\tupid = pid->numbers + i;\n\t\tidr_remove(&upid->ns->idr, upid->nr);\n\t}\n\n\t/* On failure to allocate the first pid, reset the state */\n\tif (ns->pid_allocated == PIDNS_ADDING)\n\t\tidr_set_cursor(&ns->idr, 0);\n\n\tspin_unlock_irq(&pidmap_lock);\n\n\tkmem_cache_free(ns->pid_cachep, pid);\n\treturn ERR_PTR(retval);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define RESERVED_PIDS\t\t300"
    ],
    "globals_used": [
      "int pid_max = PID_MAX_DEFAULT;",
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ns->pid_cachep",
            "pid"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pidmap_lock"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_set_cursor",
          "args": [
            "&ns->idr",
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&upid->ns->idr",
            "upid->nr"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pidmap_lock"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "ns"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid_namespace.c",
          "lines": "152-163",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_replace",
          "args": [
            "&upid->ns->idr",
            "pid",
            "upid->nr"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "332-340",
          "snippet": "static void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&pid->inodes"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&pid->wait_pidfd"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&pid->tasks[type]"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pid->lock"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&pid->count",
            "1"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "ns"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&tmp->idr",
            "NULL",
            "pid_min",
            "pid_max",
            "GFP_ATOMIC"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_get_cursor",
          "args": [
            "&tmp->idr"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&tmp->idr",
            "NULL",
            "tid",
            "tid + 1",
            "GFP_ATOMIC"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "319-330",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkpoint_restore_ns_capable",
          "args": [
            "tmp->user_ns"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ns->pid_cachep",
            "GFP_KERNEL"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define RESERVED_PIDS\t\t300\n\nint pid_max = PID_MAX_DEFAULT;\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);\n\nstruct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid,\n\t\t      size_t set_tid_size)\n{\n\tstruct pid *pid;\n\tenum pid_type type;\n\tint i, nr;\n\tstruct pid_namespace *tmp;\n\tstruct upid *upid;\n\tint retval = -ENOMEM;\n\n\t/*\n\t * set_tid_size contains the size of the set_tid array. Starting at\n\t * the most nested currently active PID namespace it tells alloc_pid()\n\t * which PID to set for a process in that most nested PID namespace\n\t * up to set_tid_size PID namespaces. It does not have to set the PID\n\t * for a process in all nested PID namespaces but set_tid_size must\n\t * never be greater than the current ns->level + 1.\n\t */\n\tif (set_tid_size > ns->level + 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpid = kmem_cache_alloc(ns->pid_cachep, GFP_KERNEL);\n\tif (!pid)\n\t\treturn ERR_PTR(retval);\n\n\ttmp = ns;\n\tpid->level = ns->level;\n\n\tfor (i = ns->level; i >= 0; i--) {\n\t\tint tid = 0;\n\n\t\tif (set_tid_size) {\n\t\t\ttid = set_tid[ns->level - i];\n\n\t\t\tretval = -EINVAL;\n\t\t\tif (tid < 1 || tid >= pid_max)\n\t\t\t\tgoto out_free;\n\t\t\t/*\n\t\t\t * Also fail if a PID != 1 is requested and\n\t\t\t * no PID 1 exists.\n\t\t\t */\n\t\t\tif (tid != 1 && !tmp->child_reaper)\n\t\t\t\tgoto out_free;\n\t\t\tretval = -EPERM;\n\t\t\tif (!checkpoint_restore_ns_capable(tmp->user_ns))\n\t\t\t\tgoto out_free;\n\t\t\tset_tid_size--;\n\t\t}\n\n\t\tidr_preload(GFP_KERNEL);\n\t\tspin_lock_irq(&pidmap_lock);\n\n\t\tif (tid) {\n\t\t\tnr = idr_alloc(&tmp->idr, NULL, tid,\n\t\t\t\t       tid + 1, GFP_ATOMIC);\n\t\t\t/*\n\t\t\t * If ENOSPC is returned it means that the PID is\n\t\t\t * alreay in use. Return EEXIST in that case.\n\t\t\t */\n\t\t\tif (nr == -ENOSPC)\n\t\t\t\tnr = -EEXIST;\n\t\t} else {\n\t\t\tint pid_min = 1;\n\t\t\t/*\n\t\t\t * init really needs pid 1, but after reaching the\n\t\t\t * maximum wrap back to RESERVED_PIDS\n\t\t\t */\n\t\t\tif (idr_get_cursor(&tmp->idr) > RESERVED_PIDS)\n\t\t\t\tpid_min = RESERVED_PIDS;\n\n\t\t\t/*\n\t\t\t * Store a null pointer so find_pid_ns does not find\n\t\t\t * a partially initialized PID (see below).\n\t\t\t */\n\t\t\tnr = idr_alloc_cyclic(&tmp->idr, NULL, pid_min,\n\t\t\t\t\t      pid_max, GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock_irq(&pidmap_lock);\n\t\tidr_preload_end();\n\n\t\tif (nr < 0) {\n\t\t\tretval = (nr == -ENOSPC) ? -EAGAIN : nr;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tpid->numbers[i].nr = nr;\n\t\tpid->numbers[i].ns = tmp;\n\t\ttmp = tmp->parent;\n\t}\n\n\t/*\n\t * ENOMEM is not the most obvious choice especially for the case\n\t * where the child subreaper has already exited and the pid\n\t * namespace denies the creation of any new processes. But ENOMEM\n\t * is what we have exposed to userspace for a long time and it is\n\t * documented behavior for pid namespaces. So we can't easily\n\t * change it even if there were an error code better suited.\n\t */\n\tretval = -ENOMEM;\n\n\tget_pid_ns(ns);\n\trefcount_set(&pid->count, 1);\n\tspin_lock_init(&pid->lock);\n\tfor (type = 0; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_HEAD(&pid->tasks[type]);\n\n\tinit_waitqueue_head(&pid->wait_pidfd);\n\tINIT_HLIST_HEAD(&pid->inodes);\n\n\tupid = pid->numbers + ns->level;\n\tspin_lock_irq(&pidmap_lock);\n\tif (!(ns->pid_allocated & PIDNS_ADDING))\n\t\tgoto out_unlock;\n\tfor ( ; upid >= pid->numbers; --upid) {\n\t\t/* Make the PID visible to find_pid_ns. */\n\t\tidr_replace(&upid->ns->idr, pid, upid->nr);\n\t\tupid->ns->pid_allocated++;\n\t}\n\tspin_unlock_irq(&pidmap_lock);\n\n\treturn pid;\n\nout_unlock:\n\tspin_unlock_irq(&pidmap_lock);\n\tput_pid_ns(ns);\n\nout_free:\n\tspin_lock_irq(&pidmap_lock);\n\twhile (++i <= ns->level) {\n\t\tupid = pid->numbers + i;\n\t\tidr_remove(&upid->ns->idr, upid->nr);\n\t}\n\n\t/* On failure to allocate the first pid, reset the state */\n\tif (ns->pid_allocated == PIDNS_ADDING)\n\t\tidr_set_cursor(&ns->idr, 0);\n\n\tspin_unlock_irq(&pidmap_lock);\n\n\tkmem_cache_free(ns->pid_cachep, pid);\n\treturn ERR_PTR(retval);\n}"
  },
  {
    "function_name": "free_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "126-157",
    "snippet": "void free_pid(struct pid *pid)\n{\n\t/* We can be called with write_lock_irq(&tasklist_lock) held */\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pidmap_lock, flags);\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tstruct upid *upid = pid->numbers + i;\n\t\tstruct pid_namespace *ns = upid->ns;\n\t\tswitch (--ns->pid_allocated) {\n\t\tcase 2:\n\t\tcase 1:\n\t\t\t/* When all that is left in the pid namespace\n\t\t\t * is the reaper wake up the reaper.  The reaper\n\t\t\t * may be sleeping in zap_pid_ns_processes().\n\t\t\t */\n\t\t\twake_up_process(ns->child_reaper);\n\t\t\tbreak;\n\t\tcase PIDNS_ADDING:\n\t\t\t/* Handle a fork failure of the first process */\n\t\t\tWARN_ON(ns->child_reaper);\n\t\t\tns->pid_allocated = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tidr_remove(&ns->idr, upid->nr);\n\t}\n\tspin_unlock_irqrestore(&pidmap_lock, flags);\n\n\tcall_rcu(&pid->rcu, delayed_put_pid);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&pid->rcu",
            "delayed_put_pid"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pidmap_lock",
            "flags"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&ns->idr",
            "upid->nr"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ns->child_reaper"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "ns->child_reaper"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pidmap_lock",
            "flags"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);\n\nvoid free_pid(struct pid *pid)\n{\n\t/* We can be called with write_lock_irq(&tasklist_lock) held */\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pidmap_lock, flags);\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tstruct upid *upid = pid->numbers + i;\n\t\tstruct pid_namespace *ns = upid->ns;\n\t\tswitch (--ns->pid_allocated) {\n\t\tcase 2:\n\t\tcase 1:\n\t\t\t/* When all that is left in the pid namespace\n\t\t\t * is the reaper wake up the reaper.  The reaper\n\t\t\t * may be sleeping in zap_pid_ns_processes().\n\t\t\t */\n\t\t\twake_up_process(ns->child_reaper);\n\t\t\tbreak;\n\t\tcase PIDNS_ADDING:\n\t\t\t/* Handle a fork failure of the first process */\n\t\t\tWARN_ON(ns->child_reaper);\n\t\t\tns->pid_allocated = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tidr_remove(&ns->idr, upid->nr);\n\t}\n\tspin_unlock_irqrestore(&pidmap_lock, flags);\n\n\tcall_rcu(&pid->rcu, delayed_put_pid);\n}"
  },
  {
    "function_name": "delayed_put_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "120-124",
    "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "pid"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structpid",
            "rcu"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
  },
  {
    "function_name": "put_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "105-117",
    "snippet": "void put_pid(struct pid *pid)\n{\n\tstruct pid_namespace *ns;\n\n\tif (!pid)\n\t\treturn;\n\n\tns = pid->numbers[pid->level].ns;\n\tif (refcount_dec_and_test(&pid->count)) {\n\t\tkmem_cache_free(ns->pid_cachep, pid);\n\t\tput_pid_ns(ns);\n\t}\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "ns"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid_namespace.c",
          "lines": "152-163",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ns->pid_cachep",
            "pid"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&pid->count"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid put_pid(struct pid *pid)\n{\n\tstruct pid_namespace *ns;\n\n\tif (!pid)\n\t\treturn;\n\n\tns = pid->numbers[pid->level].ns;\n\tif (refcount_dec_and_test(&pid->count)) {\n\t\tkmem_cache_free(ns->pid_cachep, pid);\n\t\tput_pid_ns(ns);\n\t}\n}"
  },
  {
    "function_name": "pidfd_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "628-647",
    "snippet": "SYSCALL_DEFINE2(pidfd_open, pid_t, pid, unsigned int, flags)\n{\n\tint fd;\n\tstruct pid *p;\n\n\tif (flags & ~PIDFD_NONBLOCK)\n\t\treturn -EINVAL;\n\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\tp = find_get_pid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tfd = pidfd_create(p, flags);\n\n\tput_pid(p);\n\treturn fd;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(pidfd_open, pid_t, pid, unsigned int, flags)\n{\n\tint fd;\n\tstruct pid *p;\n\n\tif (flags & ~PIDFD_NONBLOCK)\n\t\treturn -EINVAL;\n\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\tp = find_get_pid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tfd = pidfd_create(p, flags);\n\n\tput_pid(p);\n\treturn fd;\n}"
  },
  {
    "function_name": "pidfd_getfd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
    "lines": "723-746",
    "snippet": "SYSCALL_DEFINE3(pidfd_getfd, int, pidfd, int, fd,\n\t\tunsigned int, flags)\n{\n\tstruct pid *pid;\n\tstruct fd f;\n\tint ret;\n\n\t/* flags is currently unused - make sure it's unset */\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tf = fdget(pidfd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tpid = pidfd_pid(f.file);\n\tif (IS_ERR(pid))\n\t\tret = PTR_ERR(pid);\n\telse\n\t\tret = pidfd_getfd(pid, fd);\n\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include <uapi/linux/pidfd.h>",
      "#include <net/sock.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/refcount.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/init_task.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/rculist.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(pidfd_getfd, int, pidfd, int, fd,\n\t\tunsigned int, flags)\n{\n\tstruct pid *pid;\n\tstruct fd f;\n\tint ret;\n\n\t/* flags is currently unused - make sure it's unset */\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tf = fdget(pidfd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tpid = pidfd_pid(f.file);\n\tif (IS_ERR(pid))\n\t\tret = PTR_ERR(pid);\n\telse\n\t\tret = pidfd_getfd(pid, fd);\n\n\tfdput(f);\n\treturn ret;\n}"
  }
]