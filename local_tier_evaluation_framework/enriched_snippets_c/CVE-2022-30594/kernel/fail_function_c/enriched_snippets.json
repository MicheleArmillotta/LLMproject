[
  {
    "function_name": "fei_debugfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "324-341",
    "snippet": "static int __init fei_debugfs_init(void)\n{\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_function\", NULL,\n\t\t\t\t\t&fei_fault_attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\t/* injectable attribute is just a symlink of error_inject/list */\n\tdebugfs_create_symlink(\"injectable\", dir, \"../error_injection/list\");\n\n\tdebugfs_create_file(\"inject\", 0600, dir, NULL, &fei_ops);\n\n\tfei_debugfs_dir = dir;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_FAULT_ATTR(fei_fault_attr);",
      "static struct dentry *fei_debugfs_dir;",
      "static const struct file_operations fei_ops = {\n\t.open =\t\tfei_open,\n\t.read =\t\tseq_read,\n\t.write =\tfei_write,\n\t.llseek =\tseq_lseek,\n\t.release =\tseq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"inject\"",
            "0600",
            "dir",
            "NULL",
            "&fei_ops"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_symlink",
          "args": [
            "\"injectable\"",
            "dir",
            "\"../error_injection/list\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_create_debugfs_attr",
          "args": [
            "\"fail_function\"",
            "NULL",
            "&fei_fault_attr"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DECLARE_FAULT_ATTR(fei_fault_attr);\nstatic struct dentry *fei_debugfs_dir;\nstatic const struct file_operations fei_ops = {\n\t.open =\t\tfei_open,\n\t.read =\t\tseq_read,\n\t.write =\tfei_write,\n\t.llseek =\tseq_lseek,\n\t.release =\tseq_release,\n};\n\nstatic int __init fei_debugfs_init(void)\n{\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_function\", NULL,\n\t\t\t\t\t&fei_fault_attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\t/* injectable attribute is just a symlink of error_inject/list */\n\tdebugfs_create_symlink(\"injectable\", dir, \"../error_injection/list\");\n\n\tdebugfs_create_file(\"inject\", 0600, dir, NULL, &fei_ops);\n\n\tfei_debugfs_dir = dir;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fei_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "239-314",
    "snippet": "static ssize_t fei_write(struct file *file, const char __user *buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct fei_attr *attr;\n\tunsigned long addr;\n\tchar *buf, *sym;\n\tint ret;\n\n\t/* cut off if it is too long */\n\tif (count > KSYM_NAME_LEN)\n\t\tcount = KSYM_NAME_LEN;\n\tbuf = kmalloc(count + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf, buffer, count)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tbuf[count] = '\\0';\n\tsym = strstrip(buf);\n\n\tmutex_lock(&fei_lock);\n\n\t/* Writing just spaces will remove all injection points */\n\tif (sym[0] == '\\0') {\n\t\tfei_attr_remove_all();\n\t\tret = count;\n\t\tgoto out;\n\t}\n\t/* Writing !function will remove one injection point */\n\tif (sym[0] == '!') {\n\t\tattr = fei_attr_lookup(sym + 1);\n\t\tif (!attr) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tfei_attr_remove(attr);\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\taddr = kallsyms_lookup_name(sym);\n\tif (!addr) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!within_error_injection_list(addr)) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tif (fei_attr_lookup(sym)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tattr = fei_attr_new(sym, addr);\n\tif (!attr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = register_kprobe(&attr->kp);\n\tif (!ret)\n\t\tfei_debugfs_add_attr(attr);\n\tif (ret < 0)\n\t\tfei_attr_remove(attr);\n\telse {\n\t\tlist_add_tail(&attr->list, &fei_attr_list);\n\t\tret = count;\n\t}\nout:\n\tmutex_unlock(&fei_lock);\nout_free:\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);",
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fei_lock"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&attr->list",
            "&fei_attr_list"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fei_attr_remove",
          "args": [
            "attr"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "222-228",
          "snippet": "static void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_debugfs_add_attr",
          "args": [
            "attr"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_add_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "155-162",
          "snippet": "static void fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\n\tdebugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\n\tdebugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "&attr->kp"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1848-1851",
          "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_new",
          "args": [
            "sym",
            "addr"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_new",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "56-73",
          "snippet": "static struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_lookup",
          "args": [
            "sym"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "83-93",
          "snippet": "static struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fei_attr_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_error_injection_list",
          "args": [
            "addr"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "sym"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4466-4487",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_remove_all",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_remove_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "230-237",
          "snippet": "static void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fei_attr_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fei_lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "buffer",
            "count"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count + 1",
            "GFP_KERNEL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\nstatic LIST_HEAD(fei_attr_list);\n\nstatic ssize_t fei_write(struct file *file, const char __user *buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct fei_attr *attr;\n\tunsigned long addr;\n\tchar *buf, *sym;\n\tint ret;\n\n\t/* cut off if it is too long */\n\tif (count > KSYM_NAME_LEN)\n\t\tcount = KSYM_NAME_LEN;\n\tbuf = kmalloc(count + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf, buffer, count)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tbuf[count] = '\\0';\n\tsym = strstrip(buf);\n\n\tmutex_lock(&fei_lock);\n\n\t/* Writing just spaces will remove all injection points */\n\tif (sym[0] == '\\0') {\n\t\tfei_attr_remove_all();\n\t\tret = count;\n\t\tgoto out;\n\t}\n\t/* Writing !function will remove one injection point */\n\tif (sym[0] == '!') {\n\t\tattr = fei_attr_lookup(sym + 1);\n\t\tif (!attr) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tfei_attr_remove(attr);\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\taddr = kallsyms_lookup_name(sym);\n\tif (!addr) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!within_error_injection_list(addr)) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tif (fei_attr_lookup(sym)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tattr = fei_attr_new(sym, addr);\n\tif (!attr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = register_kprobe(&attr->kp);\n\tif (!ret)\n\t\tfei_debugfs_add_attr(attr);\n\tif (ret < 0)\n\t\tfei_attr_remove(attr);\n\telse {\n\t\tlist_add_tail(&attr->list, &fei_attr_list);\n\t\tret = count;\n\t}\nout:\n\tmutex_unlock(&fei_lock);\nout_free:\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "fei_attr_remove_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "230-237",
    "snippet": "static void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fei_attr_remove",
          "args": [
            "attr"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "222-228",
          "snippet": "static void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "attr",
            "n",
            "&fei_attr_list",
            "list"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}"
  },
  {
    "function_name": "fei_attr_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "222-228",
    "snippet": "static void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fei_attr_free",
          "args": [
            "attr"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "75-81",
          "snippet": "static void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&attr->list"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_kprobe",
          "args": [
            "&attr->kp"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1848-1851",
          "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_debugfs_remove_attr",
          "args": [
            "attr"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "164-170",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}"
  },
  {
    "function_name": "fei_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "217-220",
    "snippet": "static int fei_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fei_seq_ops);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations fei_seq_ops = {\n\t.start\t= fei_seq_start,\n\t.next\t= fei_seq_next,\n\t.stop\t= fei_seq_stop,\n\t.show\t= fei_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&fei_seq_ops"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic const struct seq_operations fei_seq_ops = {\n\t.start\t= fei_seq_start,\n\t.next\t= fei_seq_next,\n\t.stop\t= fei_seq_stop,\n\t.show\t= fei_seq_show,\n};\n\nstatic int fei_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fei_seq_ops);\n}"
  },
  {
    "function_name": "fei_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "202-208",
    "snippet": "static int fei_seq_show(struct seq_file *m, void *v)\n{\n\tstruct fei_attr *attr = list_entry(v, struct fei_attr, list);\n\n\tseq_printf(m, \"%ps\\n\", attr->kp.addr);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%ps\\n\"",
            "attr->kp.addr"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structfei_attr",
            "list"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic int fei_seq_show(struct seq_file *m, void *v)\n{\n\tstruct fei_attr *attr = list_entry(v, struct fei_attr, list);\n\n\tseq_printf(m, \"%ps\\n\", attr->kp.addr);\n\treturn 0;\n}"
  },
  {
    "function_name": "fei_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "197-200",
    "snippet": "static void *fei_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &fei_attr_list, pos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&fei_attr_list",
            "pos"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic void *fei_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &fei_attr_list, pos);\n}"
  },
  {
    "function_name": "fei_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "192-195",
    "snippet": "static void fei_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&fei_lock);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fei_lock"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\n\nstatic void fei_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&fei_lock);\n}"
  },
  {
    "function_name": "fei_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "184-190",
    "snippet": "NOKPROBE_SYMBOL(fei_kprobe_handler)\n\nstatic void *fei_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&fei_lock);\n\treturn seq_list_start(&fei_attr_list, *pos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);",
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&fei_attr_list",
            "*pos"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fei_lock"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\nstatic LIST_HEAD(fei_attr_list);\n\nNOKPROBE_SYMBOL(fei_kprobe_handler)\n\nstatic void *fei_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&fei_lock);\n\treturn seq_list_start(&fei_attr_list, *pos);\n}"
  },
  {
    "function_name": "fei_kprobe_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "172-183",
    "snippet": "static int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct fei_attr *attr = container_of(kp, struct fei_attr, kp);\n\n\tif (should_fail(&fei_fault_attr, 1)) {\n\t\tregs_set_return_value(regs, attr->retval);\n\t\toverride_function_with_return(regs);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);",
      "static DECLARE_FAULT_ATTR(fei_fault_attr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "override_function_with_return",
          "args": [
            "regs"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_set_return_value",
          "args": [
            "regs",
            "attr->retval"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail",
          "args": [
            "&fei_fault_attr",
            "1"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kp",
            "structfei_attr",
            "kp"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);\nstatic DECLARE_FAULT_ATTR(fei_fault_attr);\n\nstatic int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct fei_attr *attr = container_of(kp, struct fei_attr, kp);\n\n\tif (should_fail(&fei_fault_attr, 1)) {\n\t\tregs_set_return_value(regs, attr->retval);\n\t\toverride_function_with_return(regs);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fei_debugfs_remove_attr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "164-170",
    "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *fei_debugfs_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_lookup",
          "args": [
            "attr->kp.symbol_name",
            "fei_debugfs_dir"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
  },
  {
    "function_name": "fei_debugfs_add_attr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "155-162",
    "snippet": "static void fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\n\tdebugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *fei_debugfs_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"retval\"",
            "0600",
            "dir",
            "attr",
            "&fei_retval_ops"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "attr->kp.symbol_name",
            "fei_debugfs_dir"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\n\tdebugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops);\n}"
  },
  {
    "function_name": "fei_retval_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "137-151",
    "snippet": "static int fei_retval_get(void *data, u64 *val)\n{\n\tstruct fei_attr *attr = data;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t/* Here we also validate @attr to ensure it still exists. */\n\tif (!fei_attr_is_valid(attr))\n\t\terr = -ENOENT;\n\telse\n\t\t*val = attr->retval;\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fei_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_is_valid",
          "args": [
            "attr"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_is_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "95-105",
          "snippet": "static bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fei_attr_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fei_lock"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\n\nstatic int fei_retval_get(void *data, u64 *val)\n{\n\tstruct fei_attr *attr = data;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t/* Here we also validate @attr to ensure it still exists. */\n\tif (!fei_attr_is_valid(attr))\n\t\terr = -ENOENT;\n\telse\n\t\t*val = attr->retval;\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fei_retval_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "107-135",
    "snippet": "static int fei_retval_set(void *data, u64 val)\n{\n\tstruct fei_attr *attr = data;\n\tunsigned long retv = (unsigned long)val;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t/*\n\t * Since this operation can be done after retval file is removed,\n\t * It is safer to check the attr is still valid before accessing\n\t * its member.\n\t */\n\tif (!fei_attr_is_valid(attr)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (attr->kp.addr) {\n\t\tif (adjust_error_retval((unsigned long)attr->kp.addr,\n\t\t\t\t\tval) != retv)\n\t\t\terr = -EINVAL;\n\t}\n\tif (!err)\n\t\tattr->retval = val;\nout:\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fei_lock"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_error_retval",
          "args": [
            "(unsigned long)attr->kp.addr",
            "val"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_error_retval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "36-54",
          "snippet": "static unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\treturn 0;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_TRUE:\n\t\treturn 1;\n\t}\n\n\treturn retv;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\treturn 0;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_TRUE:\n\t\treturn 1;\n\t}\n\n\treturn retv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_is_valid",
          "args": [
            "attr"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_is_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "95-105",
          "snippet": "static bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fei_attr_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fei_lock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\n\nstatic int fei_retval_set(void *data, u64 val)\n{\n\tstruct fei_attr *attr = data;\n\tunsigned long retv = (unsigned long)val;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t/*\n\t * Since this operation can be done after retval file is removed,\n\t * It is safer to check the attr is still valid before accessing\n\t * its member.\n\t */\n\tif (!fei_attr_is_valid(attr)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (attr->kp.addr) {\n\t\tif (adjust_error_retval((unsigned long)attr->kp.addr,\n\t\t\t\t\tval) != retv)\n\t\t\terr = -EINVAL;\n\t}\n\tif (!err)\n\t\tattr->retval = val;\nout:\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fei_attr_is_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "95-105",
    "snippet": "static bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "attr",
            "&fei_attr_list",
            "list"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "fei_attr_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "83-93",
    "snippet": "static struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "attr->kp.symbol_name",
            "sym"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "attr",
            "&fei_attr_list",
            "list"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "fei_attr_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "75-81",
    "snippet": "static void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attr"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}"
  },
  {
    "function_name": "fei_attr_new",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "56-73",
    "snippet": "static struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&attr->list"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_error_retval",
          "args": [
            "addr",
            "0"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_error_retval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "36-54",
          "snippet": "static unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\treturn 0;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_TRUE:\n\t\treturn 1;\n\t}\n\n\treturn retv;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\treturn 0;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_TRUE:\n\t\treturn 1;\n\t}\n\n\treturn retv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attr"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sym",
            "GFP_KERNEL"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*attr)",
            "GFP_KERNEL"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}"
  },
  {
    "function_name": "adjust_error_retval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "36-54",
    "snippet": "static unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\treturn 0;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_TRUE:\n\t\treturn 1;\n\t}\n\n\treturn retv;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_injectable_error_type",
          "args": [
            "addr"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\treturn 0;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_TRUE:\n\t\treturn 1;\n\t}\n\n\treturn retv;\n}"
  },
  {
    "function_name": "fei_post_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
    "lines": "17-24",
    "snippet": "static void fei_post_handler(struct kprobe *kp, struct pt_regs *regs,\n\t\t\t     unsigned long flags)\n{\n\t/*\n\t * A dummy post handler is required to prohibit optimizing, because\n\t * jump optimization does not support execution path overriding.\n\t */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);\n\nstatic void fei_post_handler(struct kprobe *kp, struct pt_regs *regs,\n\t\t\t     unsigned long flags)\n{\n\t/*\n\t * A dummy post handler is required to prohibit optimizing, because\n\t * jump optimization does not support execution path overriding.\n\t */\n}"
  }
]