[
  {
    "function_name": "pm_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "941-957",
    "snippet": "static int __init pm_init(void)\n{\n\tint error = pm_start_workqueue();\n\tif (error)\n\t\treturn error;\n\thibernate_image_size_init();\n\thibernate_reserved_size_init();\n\tpm_states_init();\n\tpower_kobj = kobject_create_and_add(\"power\", NULL);\n\tif (!power_kobj)\n\t\treturn -ENOMEM;\n\terror = sysfs_create_groups(power_kobj, attr_groups);\n\tif (error)\n\t\treturn error;\n\tpm_print_times_init();\n\treturn pm_autosleep_init();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kobject *power_kobj;",
      "static const struct attribute_group *attr_groups[] = {\n\t&attr_group,\n#ifdef CONFIG_PM_SLEEP\n\t&suspend_attr_group,\n#endif\n\tNULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_init",
          "args": [],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "301-301",
          "snippet": "static inline int pm_autosleep_init(void) { return 0; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_autosleep_init(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "pm_print_times_init",
          "args": [],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "pm_print_times_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "575-575",
          "snippet": "static inline void pm_print_times_init(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic inline void pm_print_times_init(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_groups",
          "args": [
            "power_kobj",
            "attr_groups"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"power\"",
            "NULL"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_states_init",
          "args": [],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "pm_states_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend.c",
          "lines": "172-182",
          "snippet": "void __init pm_states_init(void)\n{\n\t/* \"mem\" and \"freeze\" are always present in /sys/power/state. */\n\tpm_states[PM_SUSPEND_MEM] = pm_labels[PM_SUSPEND_MEM];\n\tpm_states[PM_SUSPEND_TO_IDLE] = pm_labels[PM_SUSPEND_TO_IDLE];\n\t/*\n\t * Suspend-to-idle should be supported even without any suspend_ops,\n\t * initialize mem_sleep_states[] accordingly here.\n\t */\n\tmem_sleep_states[PM_SUSPEND_TO_IDLE] = mem_sleep_labels[PM_SUSPEND_TO_IDLE];\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/moduleparam.h>",
            "#include <linux/compiler.h>",
            "#include <trace/events/power.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/swait.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char * const pm_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"freeze\",\n\t[PM_SUSPEND_STANDBY] = \"standby\",\n\t[PM_SUSPEND_MEM] = \"mem\",\n};",
            "const char *pm_states[PM_SUSPEND_MAX];",
            "static const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};",
            "const char *mem_sleep_states[PM_SUSPEND_MAX];",
            "static const struct platform_suspend_ops *suspend_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/moduleparam.h>\n#include <linux/compiler.h>\n#include <trace/events/power.h>\n#include <linux/ftrace.h>\n#include <linux/swait.h>\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n\nconst char * const pm_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"freeze\",\n\t[PM_SUSPEND_STANDBY] = \"standby\",\n\t[PM_SUSPEND_MEM] = \"mem\",\n};\nconst char *pm_states[PM_SUSPEND_MAX];\nstatic const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};\nconst char *mem_sleep_states[PM_SUSPEND_MAX];\nstatic const struct platform_suspend_ops *suspend_ops;\n\nvoid __init pm_states_init(void)\n{\n\t/* \"mem\" and \"freeze\" are always present in /sys/power/state. */\n\tpm_states[PM_SUSPEND_MEM] = pm_labels[PM_SUSPEND_MEM];\n\tpm_states[PM_SUSPEND_TO_IDLE] = pm_labels[PM_SUSPEND_TO_IDLE];\n\t/*\n\t * Suspend-to-idle should be supported even without any suspend_ops,\n\t * initialize mem_sleep_states[] accordingly here.\n\t */\n\tmem_sleep_states[PM_SUSPEND_TO_IDLE] = mem_sleep_labels[PM_SUSPEND_TO_IDLE];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_reserved_size_init",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_reserved_size_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "76-76",
          "snippet": "static inline void hibernate_reserved_size_init(void) {}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void hibernate_reserved_size_init(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_image_size_init",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_image_size_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "77-77",
          "snippet": "static inline void hibernate_image_size_init(void) {}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void hibernate_image_size_init(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "pm_start_workqueue",
          "args": [],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "pm_start_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "934-939",
          "snippet": "static int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct workqueue_struct *pm_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstruct workqueue_struct *pm_wq;\n\nstatic int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstruct kobject *power_kobj;\nstatic const struct attribute_group *attr_groups[] = {\n\t&attr_group,\n#ifdef CONFIG_PM_SLEEP\n\t&suspend_attr_group,\n#endif\n\tNULL,\n};\n\nstatic int __init pm_init(void)\n{\n\tint error = pm_start_workqueue();\n\tif (error)\n\t\treturn error;\n\thibernate_image_size_init();\n\thibernate_reserved_size_init();\n\tpm_states_init();\n\tpower_kobj = kobject_create_and_add(\"power\", NULL);\n\tif (!power_kobj)\n\t\treturn -ENOMEM;\n\terror = sysfs_create_groups(power_kobj, attr_groups);\n\tif (error)\n\t\treturn error;\n\tpm_print_times_init();\n\treturn pm_autosleep_init();\n}"
  },
  {
    "function_name": "pm_start_workqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "934-939",
    "snippet": "static int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *pm_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"pm\"",
            "WQ_FREEZABLE",
            "0"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4298-4392",
          "snippet": "struct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);",
            "static bool wq_online;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstruct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstruct workqueue_struct *pm_wq;\n\nstatic int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "pm_freeze_timeout_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "869-880",
    "snippet": "static ssize_t pm_freeze_timeout_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tfreeze_timeout_msecs = val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_freeze_timeout_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tfreeze_timeout_msecs = val;\n\treturn n;\n}"
  },
  {
    "function_name": "pm_freeze_timeout_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "863-867",
    "snippet": "static ssize_t pm_freeze_timeout_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", freeze_timeout_msecs);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "freeze_timeout_msecs"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_freeze_timeout_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", freeze_timeout_msecs);\n}"
  },
  {
    "function_name": "pm_trace_dev_match_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "851-856",
    "snippet": "static ssize_t pm_trace_dev_match_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn show_trace_dev_match(buf, PAGE_SIZE);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_trace_dev_match",
          "args": [
            "buf",
            "PAGE_SIZE"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_trace_dev_match_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn show_trace_dev_match(buf, PAGE_SIZE);\n}"
  },
  {
    "function_name": "pm_trace_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "832-847",
    "snippet": "static ssize_t\npm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t       const char *buf, size_t n)\n{\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) == 1) {\n\t\tpm_trace_enabled = !!val;\n\t\tif (pm_trace_enabled) {\n\t\t\tpr_warn(\"PM: Enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"PM: Correct system time has to be restored manually after resume.\\n\");\n\t\t}\n\t\treturn n;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"PM: Enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"PM: Correct system time has to be restored manually after resume.\\n\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&val"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t\npm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t       const char *buf, size_t n)\n{\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) == 1) {\n\t\tpm_trace_enabled = !!val;\n\t\tif (pm_trace_enabled) {\n\t\t\tpr_warn(\"PM: Enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"PM: Correct system time has to be restored manually after resume.\\n\");\n\t\t}\n\t\treturn n;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "pm_trace_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "826-830",
    "snippet": "static ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_trace_enabled);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pm_trace_enabled"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_trace_enabled);\n}"
  },
  {
    "function_name": "wake_unlock_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "810-816",
    "snippet": "static ssize_t wake_unlock_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t n)\n{\n\tint error = pm_wake_unlock(buf);\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_wake_unlock",
          "args": [
            "buf"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "pm_wake_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "254-288",
          "snippet": "int pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wakelocks_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nint pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wake_unlock_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t n)\n{\n\tint error = pm_wake_unlock(buf);\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "wake_unlock_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "803-808",
    "snippet": "static ssize_t wake_unlock_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn pm_show_wakelocks(buf, false);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_show_wakelocks",
          "args": [
            "buf",
            "false"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "pm_show_wakelocks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "38-59",
          "snippet": "ssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws->active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wakelocks_lock);",
            "static struct rb_root wakelocks_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws->active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wake_unlock_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn pm_show_wakelocks(buf, false);\n}"
  },
  {
    "function_name": "wake_lock_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "793-799",
    "snippet": "static ssize_t wake_lock_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tint error = pm_wake_lock(buf);\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_wake_lock",
          "args": [
            "buf"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "pm_wake_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "206-252",
          "snippet": "int pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t/* Find out if there's a valid timeout string appended. */\n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wakelocks_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nint pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t/* Find out if there's a valid timeout string appended. */\n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wake_lock_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tint error = pm_wake_lock(buf);\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "wake_lock_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "786-791",
    "snippet": "static ssize_t wake_lock_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn pm_show_wakelocks(buf, true);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_show_wakelocks",
          "args": [
            "buf",
            "true"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "pm_show_wakelocks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "38-59",
          "snippet": "ssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws->active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wakelocks_lock);",
            "static struct rb_root wakelocks_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws->active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wake_lock_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn pm_show_wakelocks(buf, true);\n}"
  },
  {
    "function_name": "autosleep_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "764-780",
    "snippet": "static ssize_t autosleep_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state = decode_state(buf, n);\n\tint error;\n\n\tif (state == PM_SUSPEND_ON\n\t    && strcmp(buf, \"off\") && strcmp(buf, \"off\\n\"))\n\t\treturn -EINVAL;\n\n\tif (state == PM_SUSPEND_MEM)\n\t\tstate = mem_sleep_current;\n\n\terror = pm_autosleep_set_state(state);\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_set_state",
          "args": [
            "state"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/autosleep.c",
          "lines": "90-115",
          "snippet": "int pm_autosleep_set_state(suspend_state_t state)\n{\n\n#ifndef CONFIG_HIBERNATION\n\tif (state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n#endif\n\n\t__pm_stay_awake(autosleep_ws);\n\n\tmutex_lock(&autosleep_lock);\n\n\tautosleep_state = state;\n\n\t__pm_relax(autosleep_ws);\n\n\tif (state > PM_SUSPEND_ON) {\n\t\tpm_wakep_autosleep_enabled(true);\n\t\tqueue_up_suspend_work();\n\t} else {\n\t\tpm_wakep_autosleep_enabled(false);\n\t}\n\n\tmutex_unlock(&autosleep_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_wakeup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static suspend_state_t autosleep_state;",
            "static DEFINE_MUTEX(autosleep_lock);",
            "static struct wakeup_source *autosleep_ws;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic suspend_state_t autosleep_state;\nstatic DEFINE_MUTEX(autosleep_lock);\nstatic struct wakeup_source *autosleep_ws;\n\nint pm_autosleep_set_state(suspend_state_t state)\n{\n\n#ifndef CONFIG_HIBERNATION\n\tif (state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n#endif\n\n\t__pm_stay_awake(autosleep_ws);\n\n\tmutex_lock(&autosleep_lock);\n\n\tautosleep_state = state;\n\n\t__pm_relax(autosleep_ws);\n\n\tif (state > PM_SUSPEND_ON) {\n\t\tpm_wakep_autosleep_enabled(true);\n\t\tqueue_up_suspend_work();\n\t} else {\n\t\tpm_wakep_autosleep_enabled(false);\n\t}\n\n\tmutex_unlock(&autosleep_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"off\\n\""
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_state",
          "args": [
            "buf",
            "n"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "decode_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "611-636",
          "snippet": "static suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && str_has_prefix(buf, \"disk\"))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && str_has_prefix(buf, \"disk\"))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t autosleep_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state = decode_state(buf, n);\n\tint error;\n\n\tif (state == PM_SUSPEND_ON\n\t    && strcmp(buf, \"off\") && strcmp(buf, \"off\\n\"))\n\t\treturn -EINVAL;\n\n\tif (state == PM_SUSPEND_MEM)\n\t\tstate = mem_sleep_current;\n\n\terror = pm_autosleep_set_state(state);\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "autosleep_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "743-762",
    "snippet": "static ssize_t autosleep_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tsuspend_state_t state = pm_autosleep_state();\n\n\tif (state == PM_SUSPEND_ON)\n\t\treturn sprintf(buf, \"off\\n\");\n\n#ifdef CONFIG_SUSPEND\n\tif (state < PM_SUSPEND_MAX)\n\t\treturn sprintf(buf, \"%s\\n\", pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\");\n#endif\n#ifdef CONFIG_HIBERNATION\n\treturn sprintf(buf, \"disk\\n\");\n#else\n\treturn sprintf(buf, \"error\");\n#endif\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"error\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"disk\\n\""
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"off\\n\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_autosleep_state",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "304-304",
          "snippet": "static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t autosleep_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tsuspend_state_t state = pm_autosleep_state();\n\n\tif (state == PM_SUSPEND_ON)\n\t\treturn sprintf(buf, \"off\\n\");\n\n#ifdef CONFIG_SUSPEND\n\tif (state < PM_SUSPEND_MAX)\n\t\treturn sprintf(buf, \"%s\\n\", pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\");\n#endif\n#ifdef CONFIG_HIBERNATION\n\treturn sprintf(buf, \"disk\\n\");\n#else\n\treturn sprintf(buf, \"error\");\n#endif\n}"
  },
  {
    "function_name": "wakeup_count_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "711-738",
    "snippet": "static ssize_t wakeup_count_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned int val;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terror = -EINVAL;\n\tif (sscanf(buf, \"%u\", &val) == 1) {\n\t\tif (pm_save_wakeup_count(val))\n\t\t\terror = n;\n\t\telse\n\t\t\tpm_print_active_wakeup_sources();\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_unlock",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "303-303",
          "snippet": "static inline void pm_autosleep_unlock(void) {}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_autosleep_unlock(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "pm_print_active_wakeup_sources",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_save_wakeup_count",
          "args": [
            "val"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%u\"",
            "&val"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_autosleep_state",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "304-304",
          "snippet": "static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_lock",
          "args": [],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "302-302",
          "snippet": "static inline int pm_autosleep_lock(void) { return 0; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_autosleep_lock(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wakeup_count_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned int val;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terror = -EINVAL;\n\tif (sscanf(buf, \"%u\", &val) == 1) {\n\t\tif (pm_save_wakeup_count(val))\n\t\t\terror = n;\n\t\telse\n\t\t\tpm_print_active_wakeup_sources();\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error;\n}"
  },
  {
    "function_name": "wakeup_count_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "701-709",
    "snippet": "static ssize_t wakeup_count_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned int val;\n\n\treturn pm_get_wakeup_count(&val, true) ?\n\t\tsprintf(buf, \"%u\\n\", val) : -EINTR;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "val"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_get_wakeup_count",
          "args": [
            "&val",
            "true"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wakeup_count_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned int val;\n\n\treturn pm_get_wakeup_count(&val, true) ?\n\t\tsprintf(buf, \"%u\\n\", val) : -EINTR;\n}"
  },
  {
    "function_name": "state_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "638-668",
    "snippet": "static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_state(buf, n);\n\tif (state < PM_SUSPEND_MAX) {\n\t\tif (state == PM_SUSPEND_MEM)\n\t\t\tstate = mem_sleep_current;\n\n\t\terror = pm_suspend(state);\n\t} else if (state == PM_SUSPEND_MAX) {\n\t\terror = hibernate();\n\t} else {\n\t\terror = -EINVAL;\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_unlock",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "303-303",
          "snippet": "static inline void pm_autosleep_unlock(void) {}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_autosleep_unlock(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate",
          "args": [],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "712-800",
          "snippet": "int hibernate(void)\n{\n\tbool snapshot_test = false;\n\tint error;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto Restore;\n\n\tksys_sync_helper();\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing hibernation image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Hibernation image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n Restore:\n\tpm_restore_console();\n\thibernate_release();\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nocompress;",
            "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
            "bool freezer_test_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nocompress;\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nbool freezer_test_done;\n\nint hibernate(void)\n{\n\tbool snapshot_test = false;\n\tint error;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto Restore;\n\n\tksys_sync_helper();\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing hibernation image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Hibernation image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n Restore:\n\tpm_restore_console();\n\thibernate_release();\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_suspend",
          "args": [
            "state"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "pm_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend.c",
          "lines": "605-622",
          "snippet": "int pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/moduleparam.h>",
            "#include <linux/compiler.h>",
            "#include <trace/events/power.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/swait.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/moduleparam.h>\n#include <linux/compiler.h>\n#include <trace/events/power.h>\n#include <linux/ftrace.h>\n#include <linux/swait.h>\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n\nstatic const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};\n\nint pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_state",
          "args": [
            "buf",
            "n"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "decode_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "611-636",
          "snippet": "static suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && str_has_prefix(buf, \"disk\"))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && str_has_prefix(buf, \"disk\"))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_state",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "304-304",
          "snippet": "static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_lock",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "302-302",
          "snippet": "static inline int pm_autosleep_lock(void) { return 0; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_autosleep_lock(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_state(buf, n);\n\tif (state < PM_SUSPEND_MAX) {\n\t\tif (state == PM_SUSPEND_MEM)\n\t\t\tstate = mem_sleep_current;\n\n\t\terror = pm_suspend(state);\n\t} else if (state == PM_SUSPEND_MAX) {\n\t\terror = hibernate();\n\t} else {\n\t\terror = -EINVAL;\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "decode_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "611-636",
    "snippet": "static suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && str_has_prefix(buf, \"disk\"))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "label",
            "len"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "label"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "buf",
            "\"disk\""
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "n"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && str_has_prefix(buf, \"disk\"))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}"
  },
  {
    "function_name": "state_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "591-609",
    "snippet": "static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  char *buf)\n{\n\tchar *s = buf;\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (pm_states[i])\n\t\t\ts += sprintf(s,\"%s \", pm_states[i]);\n\n#endif\n\tif (hibernation_available())\n\t\ts += sprintf(s, \"disk \");\n\tif (s != buf)\n\t\t/* convert the last space to a newline */\n\t\t*(s-1) = '\\n';\n\treturn (s - buf);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"disk \""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "83-88",
          "snippet": "bool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%s \"",
            "pm_states[i]"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  char *buf)\n{\n\tchar *s = buf;\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (pm_states[i])\n\t\t\ts += sprintf(s,\"%s \", pm_states[i]);\n\n#endif\n\tif (hibernation_available())\n\t\ts += sprintf(s, \"disk \");\n\tif (s != buf)\n\t\t/* convert the last space to a newline */\n\t\t*(s-1) = '\\n';\n\treturn (s - buf);\n}"
  },
  {
    "function_name": "pm_print_times_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "575-575",
    "snippet": "static inline void pm_print_times_init(void) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic inline void pm_print_times_init(void) {}"
  },
  {
    "function_name": "__pm_pr_dbg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "553-572",
    "snippet": "void __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"PM: %pV\"",
            "&vaf"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_DEBUG \"PM: %pV\"",
            "&vaf"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "pm_debug_messages_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "538-542",
    "snippet": "static int __init pm_debug_messages_setup(char *str)\n{\n\tpm_debug_messages_on = true;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic int __init pm_debug_messages_setup(char *str)\n{\n\tpm_debug_messages_on = true;\n\treturn 1;\n}"
  },
  {
    "function_name": "pm_debug_messages_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "520-534",
    "snippet": "static ssize_t pm_debug_messages_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_debug_messages_on = !!val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_debug_messages_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_debug_messages_on = !!val;\n\treturn n;\n}"
  },
  {
    "function_name": "pm_debug_messages_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "514-518",
    "snippet": "static ssize_t pm_debug_messages_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_debug_messages_on);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pm_debug_messages_on"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_debug_messages_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_debug_messages_on);\n}"
  },
  {
    "function_name": "pm_wakeup_irq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "503-508",
    "snippet": "static ssize_t pm_wakeup_irq_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn pm_wakeup_irq ? sprintf(buf, \"%u\\n\", pm_wakeup_irq) : -ENODATA;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "pm_wakeup_irq"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_wakeup_irq_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn pm_wakeup_irq ? sprintf(buf, \"%u\\n\", pm_wakeup_irq) : -ENODATA;\n}"
  },
  {
    "function_name": "pm_print_times_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "498-501",
    "snippet": "static inline void pm_print_times_init(void)\n{\n\tpm_print_times_enabled = !!initcall_debug;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic inline void pm_print_times_init(void)\n{\n\tpm_print_times_enabled = !!initcall_debug;\n}"
  },
  {
    "function_name": "pm_print_times_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "480-494",
    "snippet": "static ssize_t pm_print_times_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_print_times_enabled = !!val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_print_times_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_print_times_enabled = !!val;\n\treturn n;\n}"
  },
  {
    "function_name": "pm_print_times_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "474-478",
    "snippet": "static ssize_t pm_print_times_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_print_times_enabled);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pm_print_times_enabled"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_print_times_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_print_times_enabled);\n}"
  },
  {
    "function_name": "pm_debugfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "453-458",
    "snippet": "static int __init pm_debugfs_init(void)\n{\n\tdebugfs_create_file(\"suspend_stats\", S_IFREG | S_IRUGO,\n\t\t\tNULL, NULL, &suspend_stats_fops);\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"suspend_stats\"",
            "S_IFREG | S_IRUGO",
            "NULL",
            "NULL",
            "&suspend_stats_fops"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic int __init pm_debugfs_init(void)\n{\n\tdebugfs_create_file(\"suspend_stats\", S_IFREG | S_IRUGO,\n\t\t\tNULL, NULL, &suspend_stats_fops);\n\treturn 0;\n}"
  },
  {
    "function_name": "suspend_stats_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "396-450",
    "snippet": "static int suspend_stats_show(struct seq_file *s, void *unused)\n{\n\tint i, index, last_dev, last_errno, last_step;\n\n\tlast_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;\n\tlast_dev %= REC_FAILED_NUM;\n\tlast_errno = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;\n\tlast_errno %= REC_FAILED_NUM;\n\tlast_step = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;\n\tlast_step %= REC_FAILED_NUM;\n\tseq_printf(s, \"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\"\n\t\t\t\"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\",\n\t\t\t\"success\", suspend_stats.success,\n\t\t\t\"fail\", suspend_stats.fail,\n\t\t\t\"failed_freeze\", suspend_stats.failed_freeze,\n\t\t\t\"failed_prepare\", suspend_stats.failed_prepare,\n\t\t\t\"failed_suspend\", suspend_stats.failed_suspend,\n\t\t\t\"failed_suspend_late\",\n\t\t\t\tsuspend_stats.failed_suspend_late,\n\t\t\t\"failed_suspend_noirq\",\n\t\t\t\tsuspend_stats.failed_suspend_noirq,\n\t\t\t\"failed_resume\", suspend_stats.failed_resume,\n\t\t\t\"failed_resume_early\",\n\t\t\t\tsuspend_stats.failed_resume_early,\n\t\t\t\"failed_resume_noirq\",\n\t\t\t\tsuspend_stats.failed_resume_noirq);\n\tseq_printf(s,\t\"failures:\\n  last_failed_dev:\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[last_dev]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_dev + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_errno:\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[last_errno]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_errno + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_step:\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[last_step]));\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_step + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index]));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"\\t\\t\\t%-s\\n\"",
            "suspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index])"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_step_name",
          "args": [
            "suspend_stats.failed_steps[index]"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_step_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "290-308",
          "snippet": "static char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic int suspend_stats_show(struct seq_file *s, void *unused)\n{\n\tint i, index, last_dev, last_errno, last_step;\n\n\tlast_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;\n\tlast_dev %= REC_FAILED_NUM;\n\tlast_errno = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;\n\tlast_errno %= REC_FAILED_NUM;\n\tlast_step = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;\n\tlast_step %= REC_FAILED_NUM;\n\tseq_printf(s, \"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\"\n\t\t\t\"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\",\n\t\t\t\"success\", suspend_stats.success,\n\t\t\t\"fail\", suspend_stats.fail,\n\t\t\t\"failed_freeze\", suspend_stats.failed_freeze,\n\t\t\t\"failed_prepare\", suspend_stats.failed_prepare,\n\t\t\t\"failed_suspend\", suspend_stats.failed_suspend,\n\t\t\t\"failed_suspend_late\",\n\t\t\t\tsuspend_stats.failed_suspend_late,\n\t\t\t\"failed_suspend_noirq\",\n\t\t\t\tsuspend_stats.failed_suspend_noirq,\n\t\t\t\"failed_resume\", suspend_stats.failed_resume,\n\t\t\t\"failed_resume_early\",\n\t\t\t\tsuspend_stats.failed_resume_early,\n\t\t\t\"failed_resume_noirq\",\n\t\t\t\tsuspend_stats.failed_resume_noirq);\n\tseq_printf(s,\t\"failures:\\n  last_failed_dev:\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[last_dev]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_dev + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_errno:\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[last_errno]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_errno + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_step:\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[last_step]));\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_step + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "last_failed_step_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "357-370",
    "snippet": "static ssize_t last_failed_step_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tenum suspend_stat_step step;\n\tchar *last_failed_step = NULL;\n\n\tindex = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tstep = suspend_stats.failed_steps[index];\n\tlast_failed_step = suspend_step_name(step);\n\n\treturn sprintf(buf, \"%s\\n\", last_failed_step);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "last_failed_step"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_step_name",
          "args": [
            "step"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_step_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "290-308",
          "snippet": "static char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t last_failed_step_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tenum suspend_stat_step step;\n\tchar *last_failed_step = NULL;\n\n\tindex = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tstep = suspend_stats.failed_steps[index];\n\tlast_failed_step = suspend_step_name(step);\n\n\treturn sprintf(buf, \"%s\\n\", last_failed_step);\n}"
  },
  {
    "function_name": "last_failed_errno_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "343-354",
    "snippet": "static ssize_t last_failed_errno_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tint last_failed_errno;\n\n\tindex = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tlast_failed_errno = suspend_stats.errno[index];\n\n\treturn sprintf(buf, \"%d\\n\", last_failed_errno);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "last_failed_errno"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t last_failed_errno_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tint last_failed_errno;\n\n\tindex = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tlast_failed_errno = suspend_stats.errno[index];\n\n\treturn sprintf(buf, \"%d\\n\", last_failed_errno);\n}"
  },
  {
    "function_name": "last_failed_dev_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "329-340",
    "snippet": "static ssize_t last_failed_dev_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tchar *last_failed_dev = NULL;\n\n\tindex = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tlast_failed_dev = suspend_stats.failed_devs[index];\n\n\treturn sprintf(buf, \"%s\\n\", last_failed_dev);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "last_failed_dev"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t last_failed_dev_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tchar *last_failed_dev = NULL;\n\n\tindex = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tlast_failed_dev = suspend_stats.failed_devs[index];\n\n\treturn sprintf(buf, \"%s\\n\", last_failed_dev);\n}"
  },
  {
    "function_name": "suspend_step_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "290-308",
    "snippet": "static char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}"
  },
  {
    "function_name": "pm_test_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "260-285",
    "snippet": "static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tconst char * const *s;\n\tint level;\n\tchar *p;\n\tint len;\n\tint error = -EINVAL;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\n\tlevel = TEST_FIRST;\n\tfor (s = &pm_tests[level]; level <= TEST_MAX; s++, level++)\n\t\tif (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {\n\t\t\tpm_test_level = level;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\tunlock_system_sleep();\n\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "*s",
            "len"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*s"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "n"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tconst char * const *s;\n\tint level;\n\tchar *p;\n\tint len;\n\tint error = -EINVAL;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\n\tlevel = TEST_FIRST;\n\tfor (s = &pm_tests[level]; level <= TEST_MAX; s++, level++)\n\t\tif (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {\n\t\t\tpm_test_level = level;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\tunlock_system_sleep();\n\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "pm_test_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "239-258",
    "snippet": "static ssize_t pm_test_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tchar *s = buf;\n\tint level;\n\n\tfor (level = TEST_FIRST; level <= TEST_MAX; level++)\n\t\tif (pm_tests[level]) {\n\t\t\tif (level == pm_test_level)\n\t\t\t\ts += sprintf(s, \"[%s] \", pm_tests[level]);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", pm_tests[level]);\n\t\t}\n\n\tif (s != buf)\n\t\t/* convert the last space to a newline */\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%s \"",
            "pm_tests[level]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"[%s] \"",
            "pm_tests[level]"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_test_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tchar *s = buf;\n\tint level;\n\n\tfor (level = TEST_FIRST; level <= TEST_MAX; level++)\n\t\tif (pm_tests[level]) {\n\t\t\tif (level == pm_test_level)\n\t\t\t\ts += sprintf(s, \"[%s] \", pm_tests[level]);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", pm_tests[level]);\n\t\t}\n\n\tif (s != buf)\n\t\t/* convert the last space to a newline */\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}"
  },
  {
    "function_name": "sync_on_suspend_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "208-222",
    "snippet": "static ssize_t sync_on_suspend_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tsync_on_suspend_enabled = !!val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t sync_on_suspend_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tsync_on_suspend_enabled = !!val;\n\treturn n;\n}"
  },
  {
    "function_name": "sync_on_suspend_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "202-206",
    "snippet": "static ssize_t sync_on_suspend_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", sync_on_suspend_enabled);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "sync_on_suspend_enabled"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t sync_on_suspend_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", sync_on_suspend_enabled);\n}"
  },
  {
    "function_name": "mem_sleep_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "166-190",
    "snippet": "static ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_suspend_state(buf, n);\n\tif (state < PM_SUSPEND_MAX && state > PM_SUSPEND_ON)\n\t\tmem_sleep_current = state;\n\telse\n\t\terror = -EINVAL;\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_unlock",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "303-303",
          "snippet": "static inline void pm_autosleep_unlock(void) {}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_autosleep_unlock(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "decode_suspend_state",
          "args": [
            "buf",
            "n"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "decode_suspend_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "147-164",
          "snippet": "static suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_state",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "304-304",
          "snippet": "static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_lock",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "302-302",
          "snippet": "static inline int pm_autosleep_lock(void) { return 0; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_autosleep_lock(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_suspend_state(buf, n);\n\tif (state < PM_SUSPEND_MAX && state > PM_SUSPEND_ON)\n\t\tmem_sleep_current = state;\n\telse\n\t\terror = -EINVAL;\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "decode_suspend_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "147-164",
    "snippet": "static suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "label",
            "len"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "label"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "n"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}"
  },
  {
    "function_name": "mem_sleep_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "124-145",
    "snippet": "static ssize_t mem_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tchar *s = buf;\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (mem_sleep_states[i]) {\n\t\t\tconst char *label = mem_sleep_states[i];\n\n\t\t\tif (mem_sleep_current == i)\n\t\t\t\ts += sprintf(s, \"[%s] \", label);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", label);\n\t\t}\n\n\t/* Convert the last space to a newline if needed. */\n\tif (s != buf)\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%s \"",
            "label"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"[%s] \"",
            "label"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t mem_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tchar *s = buf;\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (mem_sleep_states[i]) {\n\t\t\tconst char *label = mem_sleep_states[i];\n\n\t\t\tif (mem_sleep_current == i)\n\t\t\t\ts += sprintf(s, \"[%s] \", label);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", label);\n\t\t}\n\n\t/* Convert the last space to a newline if needed. */\n\tif (s != buf)\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}"
  },
  {
    "function_name": "pm_async_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "106-119",
    "snippet": "static ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_async_enabled = val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_async_enabled = val;\n\treturn n;\n}"
  },
  {
    "function_name": "pm_async_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "100-104",
    "snippet": "static ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_async_enabled);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pm_async_enabled"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_async_enabled);\n}"
  },
  {
    "function_name": "pm_notifier_call_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "92-95",
    "snippet": "int pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&pm_chain_head",
            "val",
            "NULL"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "307-323",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}"
  },
  {
    "function_name": "pm_notifier_call_chain_robust",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "83-90",
    "snippet": "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_to_errno",
          "args": [
            "ret"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain_robust",
          "args": [
            "&pm_chain_head",
            "val_up",
            "val_down",
            "NULL"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "272-288",
          "snippet": "int blocking_notifier_call_chain_robust(struct blocking_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain_robust(struct blocking_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}"
  },
  {
    "function_name": "unregister_pm_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "77-80",
    "snippet": "int unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&pm_chain_head",
            "nb"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "252-269",
          "snippet": "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}"
  },
  {
    "function_name": "register_pm_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "71-74",
    "snippet": "int register_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&pm_chain_head, nb);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&pm_chain_head",
            "nb"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "222-239",
          "snippet": "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint register_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&pm_chain_head, nb);\n}"
  },
  {
    "function_name": "ksys_sync_helper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "54-64",
    "snippet": "void ksys_sync_helper(void)\n{\n\tktime_t start;\n\tlong elapsed_msecs;\n\n\tstart = ktime_get();\n\tksys_sync();\n\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));\n\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",\n\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Filesystems sync: %ld.%03ld seconds\\n\"",
            "elapsed_msecs / MSEC_PER_SEC",
            "elapsed_msecs % MSEC_PER_SEC"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ms",
          "args": [
            "ktime_sub(ktime_get(), start)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "start"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksys_sync",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ksys_sync_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "54-64",
          "snippet": "void ksys_sync_helper(void)\n{\n\tktime_t start;\n\tlong elapsed_msecs;\n\n\tstart = ktime_get();\n\tksys_sync();\n\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));\n\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",\n\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid ksys_sync_helper(void)\n{\n\tktime_t start;\n\tlong elapsed_msecs;\n\n\tstart = ktime_get();\n\tksys_sync();\n\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));\n\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",\n\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);\n}"
  },
  {
    "function_name": "unlock_system_sleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "31-51",
    "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
  },
  {
    "function_name": "lock_system_sleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
    "lines": "24-28",
    "snippet": "void lock_system_sleep(void)\n{\n\tcurrent->flags |= PF_FREEZER_SKIP;\n\tmutex_lock(&system_transition_mutex);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/pm_runtime.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid lock_system_sleep(void)\n{\n\tcurrent->flags |= PF_FREEZER_SKIP;\n\tmutex_lock(&system_transition_mutex);\n}"
  }
]