[
  {
    "function_name": "do_raw_write_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "229-233",
    "snippet": "void do_raw_write_unlock(rwlock_t *lock)\n{\n\tdebug_write_unlock(lock);\n\tarch_write_unlock(&lock->raw_lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_write_unlock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_write_unlock",
          "args": [
            "lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "debug_write_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "197-205",
          "snippet": "static inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_write_unlock(rwlock_t *lock)\n{\n\tdebug_write_unlock(lock);\n\tarch_write_unlock(&lock->raw_lock);\n}"
  },
  {
    "function_name": "do_raw_write_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "214-227",
    "snippet": "int do_raw_write_trylock(rwlock_t *lock)\n{\n\tint ret = arch_write_trylock(&lock->raw_lock);\n\n\tif (ret)\n\t\tdebug_write_lock_after(lock);\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "!ret",
            "lock",
            "\"trylock failure on UP\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_write_lock_after",
          "args": [
            "lock"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "debug_write_lock_after",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "191-195",
          "snippet": "static inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_write_trylock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nint do_raw_write_trylock(rwlock_t *lock)\n{\n\tint ret = arch_write_trylock(&lock->raw_lock);\n\n\tif (ret)\n\t\tdebug_write_lock_after(lock);\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "do_raw_write_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "207-212",
    "snippet": "void do_raw_write_lock(rwlock_t *lock)\n{\n\tdebug_write_lock_before(lock);\n\tarch_write_lock(&lock->raw_lock);\n\tdebug_write_lock_after(lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_write_lock_after",
          "args": [
            "lock"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "debug_write_lock_after",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "191-195",
          "snippet": "static inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_write_lock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_write_lock_before",
          "args": [
            "lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "debug_write_lock_before",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "183-189",
          "snippet": "static inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_write_lock(rwlock_t *lock)\n{\n\tdebug_write_lock_before(lock);\n\tarch_write_lock(&lock->raw_lock);\n\tdebug_write_lock_after(lock);\n}"
  },
  {
    "function_name": "debug_write_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "197-205",
    "snippet": "static inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "lock->owner_cpu",
            "-1"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "lock->owner",
            "SPINLOCK_OWNER_INIT"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->owner_cpu != raw_smp_processor_id()",
            "lock",
            "\"wrong CPU\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->owner != current",
            "lock",
            "\"wrong owner\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->magic != RWLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}"
  },
  {
    "function_name": "debug_write_lock_after",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "191-195",
    "snippet": "static inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "lock->owner",
            "current"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "lock->owner_cpu",
            "raw_smp_processor_id()"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}"
  },
  {
    "function_name": "debug_write_lock_before",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "183-189",
    "snippet": "static inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->owner_cpu == raw_smp_processor_id()",
            "lock",
            "\"cpu recursion\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->owner == current",
            "lock",
            "\"recursion\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->magic != RWLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}"
  },
  {
    "function_name": "do_raw_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "177-181",
    "snippet": "void do_raw_read_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_unlock(&lock->raw_lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_read_unlock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->magic != RWLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_read_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_unlock(&lock->raw_lock);\n}"
  },
  {
    "function_name": "do_raw_read_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "164-175",
    "snippet": "int do_raw_read_trylock(rwlock_t *lock)\n{\n\tint ret = arch_read_trylock(&lock->raw_lock);\n\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "!ret",
            "lock",
            "\"trylock failure on UP\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_read_trylock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nint do_raw_read_trylock(rwlock_t *lock)\n{\n\tint ret = arch_read_trylock(&lock->raw_lock);\n\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "do_raw_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "158-162",
    "snippet": "void do_raw_read_lock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_lock(&lock->raw_lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_read_lock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->magic != RWLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_read_lock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_lock(&lock->raw_lock);\n}"
  },
  {
    "function_name": "rwlock_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "145-154",
    "snippet": "static void rwlock_bug(rwlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tprintk(KERN_EMERG \"BUG: rwlock %s on CPU#%d, %s/%d, %p\\n\",\n\t\tmsg, raw_smp_processor_id(), current->comm,\n\t\ttask_pid_nr(current), lock);\n\tdump_stack();\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"BUG: rwlock %s on CPU#%d, %s/%d, %p\\n\"",
            "msg",
            "raw_smp_processor_id()",
            "current->comm",
            "task_pid_nr(current)",
            "lock"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic void rwlock_bug(rwlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tprintk(KERN_EMERG \"BUG: rwlock %s on CPU#%d, %s/%d, %p\\n\",\n\t\tmsg, raw_smp_processor_id(), current->comm,\n\t\ttask_pid_nr(current), lock);\n\tdump_stack();\n}"
  },
  {
    "function_name": "do_raw_spin_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "137-142",
    "snippet": "void do_raw_spin_unlock(raw_spinlock_t *lock)\n{\n\tmmiowb_spin_unlock();\n\tdebug_spin_unlock(lock);\n\tarch_spin_unlock(&lock->raw_lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_spin_unlock",
          "args": [
            "lock"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "debug_spin_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "97-106",
          "snippet": "static inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmiowb_spin_unlock",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_spin_unlock(raw_spinlock_t *lock)\n{\n\tmmiowb_spin_unlock();\n\tdebug_spin_unlock(lock);\n\tarch_spin_unlock(&lock->raw_lock);\n}"
  },
  {
    "function_name": "do_raw_spin_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "120-135",
    "snippet": "int do_raw_spin_trylock(raw_spinlock_t *lock)\n{\n\tint ret = arch_spin_trylock(&lock->raw_lock);\n\n\tif (ret) {\n\t\tmmiowb_spin_lock();\n\t\tdebug_spin_lock_after(lock);\n\t}\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tSPIN_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "!ret",
            "lock",
            "\"trylock failure on UP\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_spin_lock_after",
          "args": [
            "lock"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "debug_spin_lock_after",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "91-95",
          "snippet": "static inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmiowb_spin_lock",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_trylock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nint do_raw_spin_trylock(raw_spinlock_t *lock)\n{\n\tint ret = arch_spin_trylock(&lock->raw_lock);\n\n\tif (ret) {\n\t\tmmiowb_spin_lock();\n\t\tdebug_spin_lock_after(lock);\n\t}\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tSPIN_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "do_raw_spin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "112-118",
    "snippet": "void do_raw_spin_lock(raw_spinlock_t *lock)\n{\n\tdebug_spin_lock_before(lock);\n\tarch_spin_lock(&lock->raw_lock);\n\tmmiowb_spin_lock();\n\tdebug_spin_lock_after(lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_spin_lock_after",
          "args": [
            "lock"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "debug_spin_lock_after",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "91-95",
          "snippet": "static inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmiowb_spin_lock",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_spin_lock_before",
          "args": [
            "lock"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "debug_spin_lock_before",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "82-89",
          "snippet": "static inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(READ_ONCE(lock->magic) != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner) == current, lock, \"recursion\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner_cpu) == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(READ_ONCE(lock->magic) != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner) == current, lock, \"recursion\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner_cpu) == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_spin_lock(raw_spinlock_t *lock)\n{\n\tdebug_spin_lock_before(lock);\n\tarch_spin_lock(&lock->raw_lock);\n\tmmiowb_spin_lock();\n\tdebug_spin_lock_after(lock);\n}"
  },
  {
    "function_name": "debug_spin_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "97-106",
    "snippet": "static inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "lock->owner_cpu",
            "-1"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "lock->owner",
            "SPINLOCK_OWNER_INIT"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->owner_cpu != raw_smp_processor_id()",
            "lock",
            "\"wrong CPU\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->owner != current",
            "lock",
            "\"wrong owner\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "!raw_spin_is_locked(lock)",
            "lock",
            "\"already unlocked\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "lock"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->magic != SPINLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}"
  },
  {
    "function_name": "debug_spin_lock_after",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "91-95",
    "snippet": "static inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "lock->owner",
            "current"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "lock->owner_cpu",
            "raw_smp_processor_id()"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}"
  },
  {
    "function_name": "debug_spin_lock_before",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "82-89",
    "snippet": "static inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(READ_ONCE(lock->magic) != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner) == current, lock, \"recursion\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner_cpu) == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "READ_ONCE(lock->owner_cpu) == raw_smp_processor_id()",
            "lock",
            "\"cpu recursion\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "lock->owner_cpu"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "READ_ONCE(lock->owner) == current",
            "lock",
            "\"recursion\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "lock->owner"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "READ_ONCE(lock->magic) != SPINLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "lock->magic"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(READ_ONCE(lock->magic) != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner) == current, lock, \"recursion\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner_cpu) == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}"
  },
  {
    "function_name": "spin_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "72-78",
    "snippet": "static void spin_bug(raw_spinlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tspin_dump(lock, msg);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_dump",
          "args": [
            "lock",
            "msg"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "spin_dump",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
          "lines": "54-70",
          "snippet": "static void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = READ_ONCE(lock->owner);\n\n\tif (owner == SPINLOCK_OWNER_INIT)\n\t\towner = NULL;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, READ_ONCE(lock->magic),\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tREAD_ONCE(lock->owner_cpu));\n\tdump_stack();\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = READ_ONCE(lock->owner);\n\n\tif (owner == SPINLOCK_OWNER_INIT)\n\t\towner = NULL;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, READ_ONCE(lock->magic),\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tREAD_ONCE(lock->owner_cpu));\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic void spin_bug(raw_spinlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tspin_dump(lock, msg);\n}"
  },
  {
    "function_name": "spin_dump",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "54-70",
    "snippet": "static void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = READ_ONCE(lock->owner);\n\n\tif (owner == SPINLOCK_OWNER_INIT)\n\t\towner = NULL;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, READ_ONCE(lock->magic),\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tREAD_ONCE(lock->owner_cpu));\n\tdump_stack();\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\"",
            "lock",
            "READ_ONCE(lock->magic)",
            "owner ? owner->comm : \"<none>\"",
            "owner ? task_pid_nr(owner) : -1",
            "READ_ONCE(lock->owner_cpu)"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "lock->owner_cpu"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "owner"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "lock->magic"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "lock->owner"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = READ_ONCE(lock->owner);\n\n\tif (owner == SPINLOCK_OWNER_INIT)\n\t\towner = NULL;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, READ_ONCE(lock->magic),\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tREAD_ONCE(lock->owner_cpu));\n\tdump_stack();\n}"
  },
  {
    "function_name": "__rwlock_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "35-49",
    "snippet": "void __rwlock_init(rwlock_t *lock, const char *name,\n\t\t   struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, LD_WAIT_CONFIG);\n#endif\n\tlock->raw_lock = (arch_rwlock_t) __ARCH_RW_LOCK_UNLOCKED;\n\tlock->magic = RWLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map_wait",
          "args": [
            "&lock->dep_map",
            "name",
            "key",
            "0",
            "LD_WAIT_CONFIG"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)lock",
            "sizeof(*lock)"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6405-6427",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid __rwlock_init(rwlock_t *lock, const char *name,\n\t\t   struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, LD_WAIT_CONFIG);\n#endif\n\tlock->raw_lock = (arch_rwlock_t) __ARCH_RW_LOCK_UNLOCKED;\n\tlock->magic = RWLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}"
  },
  {
    "function_name": "__raw_spin_lock_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock_debug.c",
    "lines": "16-30",
    "snippet": "void __raw_spin_lock_init(raw_spinlock_t *lock, const char *name,\n\t\t\t  struct lock_class_key *key, short inner)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, inner);\n#endif\n\tlock->raw_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\tlock->magic = SPINLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map_wait",
          "args": [
            "&lock->dep_map",
            "name",
            "key",
            "0",
            "inner"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)lock",
            "sizeof(*lock)"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6405-6427",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid __raw_spin_lock_init(raw_spinlock_t *lock, const char *name,\n\t\t\t  struct lock_class_key *key, short inner)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, inner);\n#endif\n\tlock->raw_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\tlock->magic = SPINLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}"
  }
]