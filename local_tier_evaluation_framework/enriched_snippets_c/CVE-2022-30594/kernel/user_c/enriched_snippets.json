[
  {
    "function_name": "snapshot_device_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "446-449",
    "snippet": "static int __init snapshot_device_init(void)\n{\n\treturn misc_register(&snapshot_device);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice snapshot_device = {\n\t.minor = SNAPSHOT_MINOR,\n\t.name = \"snapshot\",\n\t.fops = &snapshot_fops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&snapshot_device"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic struct miscdevice snapshot_device = {\n\t.minor = SNAPSHOT_MINOR,\n\t.name = \"snapshot\",\n\t.fops = &snapshot_fops,\n};\n\nstatic int __init snapshot_device_init(void)\n{\n\treturn misc_register(&snapshot_device);\n}"
  },
  {
    "function_name": "snapshot_compat_ioctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "409-425",
    "snippet": "static long\nsnapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));\n\n\tswitch (cmd) {\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\tcase SNAPSHOT_CREATE_IMAGE:\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\treturn snapshot_ioctl(file, cmd,\n\t\t\t\t      (unsigned long) compat_ptr(arg));\n\tdefault:\n\t\treturn snapshot_ioctl(file, cmd, arg);\n\t}\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snapshot_ioctl",
          "args": [
            "file",
            "cmd",
            "arg"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_ioctl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
          "lines": "239-406",
          "snippet": "static long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tksys_sync_helper();\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t/*\n\t\t * It is necessary to thaw kernel threads here, because\n\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after\n\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not\n\t\t * thawed, the preallocation of memory carried out by\n\t\t * hibernation_snapshot() might run into problems (i.e. it\n\t\t * might fail or even deadlock).\n\t\t */\n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Tasks are frozen and the notifiers have been called with\n\t\t * PM_HIBERNATION_PREPARE\n\t\t */\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\terror = snapshot_set_swap_area(data, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tksys_sync_helper();\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t/*\n\t\t * It is necessary to thaw kernel threads here, because\n\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after\n\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not\n\t\t * thawed, the preallocation of memory carried out by\n\t\t * hibernation_snapshot() might run into problems (i.e. it\n\t\t * might fail or even deadlock).\n\t\t */\n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Tasks are frozen and the notifiers have been called with\n\t\t * PM_HIBERNATION_PREPARE\n\t\t */\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\terror = snapshot_set_swap_area(data, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(loff_t) != sizeof(compat_loff_t)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic long\nsnapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));\n\n\tswitch (cmd) {\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\tcase SNAPSHOT_CREATE_IMAGE:\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\treturn snapshot_ioctl(file, cmd,\n\t\t\t\t      (unsigned long) compat_ptr(arg));\n\tdefault:\n\t\treturn snapshot_ioctl(file, cmd, arg);\n\t}\n}"
  },
  {
    "function_name": "snapshot_ioctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "239-406",
    "snippet": "static long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tksys_sync_helper();\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t/*\n\t\t * It is necessary to thaw kernel threads here, because\n\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after\n\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not\n\t\t * thawed, the preallocation of memory carried out by\n\t\t * hibernation_snapshot() might run into problems (i.e. it\n\t\t * might fail or even deadlock).\n\t\t */\n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Tasks are frozen and the notifiers have been called with\n\t\t * PM_HIBERNATION_PREPARE\n\t\t */\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\terror = snapshot_set_swap_area(data, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_set_swap_area",
          "args": [
            "data",
            "(void __user *)arg"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_set_swap_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
          "lines": "203-237",
          "snippet": "static int snapshot_set_swap_area(struct snapshot_data *data,\n\t\tvoid __user *argp)\n{\n\tsector_t offset;\n\tdev_t swdev;\n\n\tif (swsusp_swap_in_use())\n\t\treturn -EPERM;\n\n\tif (in_compat_syscall()) {\n\t\tstruct compat_resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t} else {\n\t\tstruct resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t}\n\n\t/*\n\t * User space encodes device types as two-byte values,\n\t * so we need to recode them\n\t */\n\tdata->swap = swap_type_of(swdev, offset);\n\tif (data->swap < 0)\n\t\treturn swdev ? -ENODEV : -EINVAL;\n\tdata->dev = swdev;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic int snapshot_set_swap_area(struct snapshot_data *data,\n\t\tvoid __user *argp)\n{\n\tsector_t offset;\n\tdev_t swdev;\n\n\tif (swsusp_swap_in_use())\n\t\treturn -EPERM;\n\n\tif (in_compat_syscall()) {\n\t\tstruct compat_resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t} else {\n\t\tstruct resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t}\n\n\t/*\n\t * User space encodes device types as two-byte values,\n\t * so we need to recode them\n\t */\n\tdata->swap = swap_type_of(swdev, offset);\n\tif (data->swap < 0)\n\t\treturn swdev ? -ENODEV : -EINVAL;\n\tdata->dev = swdev;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_platform_enter",
          "args": [],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_platform_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "559-630",
          "snippet": "int hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;",
            "static bool entering_platform_hibernation;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic bool entering_platform_hibernation;\n\nint hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_devices_and_enter",
          "args": [
            "PM_SUSPEND_MEM"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_devices_and_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "199-202",
          "snippet": "static inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_all_swap_pages",
          "args": [
            "data->swap"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "free_all_swap_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "199-214",
          "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "offset",
            "(loff_t __user *)arg"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_swapdev_block",
          "args": [
            "data->swap"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_swapdev_block",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "179-191",
          "snippet": "sector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "size",
            "(loff_t __user *)arg"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_swap_pages",
          "args": [
            "data->swap",
            "1"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "size",
            "(loff_t __user *)arg"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_get_image_size",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_get_image_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2084-2087",
          "snippet": "unsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nunsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_kernel_threads",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_kernel_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/process.c",
          "lines": "227-245",
          "snippet": "void thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data->handle",
            "0",
            "sizeof(struct snapshot_handle)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1506-1549",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_restore",
          "args": [
            "data->platform_support"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_restore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "532-554",
          "snippet": "int hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_image_loaded",
          "args": [
            "&data->handle"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_image_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2710-2714",
          "snippet": "int snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nint snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_write_finalize",
          "args": [
            "&data->handle"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_finalize",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2699-2708",
          "snippet": "void snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\n\nvoid snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "in_suspend",
            "(int __user *)arg"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_snapshot",
          "args": [
            "data->platform_support"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_snapshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "366-439",
          "snippet": "int hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool freezer_test_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nbool freezer_test_done;\n\nint hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_basic_memory_bitmaps",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "free_basic_memory_bitmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1162-1179",
          "snippet": "void free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nvoid free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_basic_memory_bitmaps",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "create_basic_memory_bitmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1112-1153",
          "snippet": "int create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n#define PG_ANY\t\t0\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nint create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_processes",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_freeze_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "280-283",
          "snippet": "static inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksys_sync_helper",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ksys_sync_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "54-64",
          "snippet": "void ksys_sync_helper(void)\n{\n\tktime_t start;\n\tlong elapsed_msecs;\n\n\tstart = ktime_get();\n\tksys_sync();\n\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));\n\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",\n\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid ksys_sync_helper(void)\n{\n\tktime_t start;\n\tlong elapsed_msecs;\n\n\tstart = ktime_get();\n\tksys_sync();\n\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));\n\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",\n\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1278-1284",
          "snippet": "static __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_IOC_NR",
          "args": [
            "cmd"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_TYPE",
          "args": [
            "cmd"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tksys_sync_helper();\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t/*\n\t\t * It is necessary to thaw kernel threads here, because\n\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after\n\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not\n\t\t * thawed, the preallocation of memory carried out by\n\t\t * hibernation_snapshot() might run into problems (i.e. it\n\t\t * might fail or even deadlock).\n\t\t */\n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Tasks are frozen and the notifiers have been called with\n\t\t * PM_HIBERNATION_PREPARE\n\t\t */\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\terror = snapshot_set_swap_area(data, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}"
  },
  {
    "function_name": "snapshot_set_swap_area",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "203-237",
    "snippet": "static int snapshot_set_swap_area(struct snapshot_data *data,\n\t\tvoid __user *argp)\n{\n\tsector_t offset;\n\tdev_t swdev;\n\n\tif (swsusp_swap_in_use())\n\t\treturn -EPERM;\n\n\tif (in_compat_syscall()) {\n\t\tstruct compat_resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t} else {\n\t\tstruct resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t}\n\n\t/*\n\t * User space encodes device types as two-byte values,\n\t * so we need to recode them\n\t */\n\tdata->swap = swap_type_of(swdev, offset);\n\tif (data->swap < 0)\n\t\treturn swdev ? -ENODEV : -EINVAL;\n\tdata->dev = swdev;\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_type_of",
          "args": [
            "swdev",
            "offset"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "swap_area.dev"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&swap_area",
            "argp",
            "sizeof(swap_area)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "swap_area.dev"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&swap_area",
            "argp",
            "sizeof(swap_area)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_swap_in_use",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_swap_in_use",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "216-219",
          "snippet": "int swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nint swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic int snapshot_set_swap_area(struct snapshot_data *data,\n\t\tvoid __user *argp)\n{\n\tsector_t offset;\n\tdev_t swdev;\n\n\tif (swsusp_swap_in_use())\n\t\treturn -EPERM;\n\n\tif (in_compat_syscall()) {\n\t\tstruct compat_resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t} else {\n\t\tstruct resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t}\n\n\t/*\n\t * User space encodes device types as two-byte values,\n\t * so we need to recode them\n\t */\n\tdata->swap = swap_type_of(swdev, offset);\n\tif (data->swap < 0)\n\t\treturn swdev ? -ENODEV : -EINVAL;\n\tdata->dev = swdev;\n\treturn 0;\n}"
  },
  {
    "function_name": "snapshot_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "164-196",
    "snippet": "static ssize_t snapshot_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *offp)\n{\n\tstruct snapshot_data *data;\n\tssize_t res;\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\n\tlock_system_sleep();\n\n\tdata = filp->private_data;\n\n\tif (!pg_offp) {\n\t\tres = snapshot_write_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = PAGE_SIZE;\n\t}\n\n\tif (!data_of(data->handle)) {\n\t\tres = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,\n\t\t\tbuf, count);\n\tif (res > 0)\n\t\t*offp += res;\nunlock:\n\tunlock_system_sleep();\n\n\treturn res;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_write_to_buffer",
          "args": [
            "data_of(data->handle)",
            "res",
            "&pg_offp",
            "buf",
            "count"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "data->handle"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "data->handle"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_write_next",
          "args": [
            "&data->handle"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2628-2689",
          "snippet": "int snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_SAFE\t\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "struct pbe *restore_pblist;",
            "static struct linked_page *safe_pages_list;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_SAFE\t\t1\n#define PG_ANY\t\t0\n\nstruct pbe *restore_pblist;\nstatic struct linked_page *safe_pages_list;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic ssize_t snapshot_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *offp)\n{\n\tstruct snapshot_data *data;\n\tssize_t res;\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\n\tlock_system_sleep();\n\n\tdata = filp->private_data;\n\n\tif (!pg_offp) {\n\t\tres = snapshot_write_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = PAGE_SIZE;\n\t}\n\n\tif (!data_of(data->handle)) {\n\t\tres = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,\n\t\t\tbuf, count);\n\tif (res > 0)\n\t\t*offp += res;\nunlock:\n\tunlock_system_sleep();\n\n\treturn res;\n}"
  },
  {
    "function_name": "snapshot_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "131-162",
    "snippet": "static ssize_t snapshot_read(struct file *filp, char __user *buf,\n                             size_t count, loff_t *offp)\n{\n\tstruct snapshot_data *data;\n\tssize_t res;\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\n\tlock_system_sleep();\n\n\tdata = filp->private_data;\n\tif (!data->ready) {\n\t\tres = -ENODATA;\n\t\tgoto Unlock;\n\t}\n\tif (!pg_offp) { /* on page boundary? */\n\t\tres = snapshot_read_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto Unlock;\n\t} else {\n\t\tres = PAGE_SIZE - pg_offp;\n\t}\n\n\tres = simple_read_from_buffer(buf, count, &pg_offp,\n\t\t\tdata_of(data->handle), res);\n\tif (res > 0)\n\t\t*offp += res;\n\n Unlock:\n\tunlock_system_sleep();\n\n\treturn res;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "&pg_offp",
            "data_of(data->handle)",
            "res"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "data->handle"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_read_next",
          "args": [
            "&data->handle"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_read_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "2135-2180",
          "snippet": "int snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic ssize_t snapshot_read(struct file *filp, char __user *buf,\n                             size_t count, loff_t *offp)\n{\n\tstruct snapshot_data *data;\n\tssize_t res;\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\n\tlock_system_sleep();\n\n\tdata = filp->private_data;\n\tif (!data->ready) {\n\t\tres = -ENODATA;\n\t\tgoto Unlock;\n\t}\n\tif (!pg_offp) { /* on page boundary? */\n\t\tres = snapshot_read_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto Unlock;\n\t} else {\n\t\tres = PAGE_SIZE - pg_offp;\n\t}\n\n\tres = simple_read_from_buffer(buf, count, &pg_offp,\n\t\t\tdata_of(data->handle), res);\n\tif (res > 0)\n\t\t*offp += res;\n\n Unlock:\n\tunlock_system_sleep();\n\n\treturn res;\n}"
  },
  {
    "function_name": "snapshot_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "105-129",
    "snippet": "static int snapshot_release(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\n\tlock_system_sleep();\n\n\tswsusp_free();\n\tdata = filp->private_data;\n\tdata->dev = 0;\n\tfree_all_swap_pages(data->swap);\n\tif (data->frozen) {\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tthaw_processes();\n\t} else if (data->free_bitmaps) {\n\t\tfree_basic_memory_bitmaps();\n\t}\n\tpm_notifier_call_chain(data->mode == O_RDONLY ?\n\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE);\n\thibernate_release();\n\n\tunlock_system_sleep();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_release",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "78-81",
          "snippet": "void hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nvoid hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain",
          "args": [
            "data->mode == O_RDONLY ?\n\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "92-95",
          "snippet": "int pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_basic_memory_bitmaps",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "free_basic_memory_bitmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1162-1179",
          "snippet": "void free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nvoid free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_all_swap_pages",
          "args": [
            "data->swap"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "free_all_swap_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "199-214",
          "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1506-1549",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic int snapshot_release(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\n\tlock_system_sleep();\n\n\tswsusp_free();\n\tdata = filp->private_data;\n\tdata->dev = 0;\n\tfree_all_swap_pages(data->swap);\n\tif (data->frozen) {\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tthaw_processes();\n\t} else if (data->free_bitmaps) {\n\t\tfree_basic_memory_bitmaps();\n\t}\n\tpm_notifier_call_chain(data->mode == O_RDONLY ?\n\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE);\n\thibernate_release();\n\n\tunlock_system_sleep();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "snapshot_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "46-103",
    "snippet": "static int snapshot_open(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\tint error;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tlock_system_sleep();\n\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tif ((filp->f_flags & O_ACCMODE) == O_RDWR) {\n\t\thibernate_release();\n\t\terror = -ENOSYS;\n\t\tgoto Unlock;\n\t}\n\tnonseekable_open(inode, filp);\n\tdata = &snapshot_state;\n\tfilp->private_data = data;\n\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\t/* Hibernating.  The image device should be accessible. */\n\t\tdata->swap = swap_type_of(swsusp_resume_device, 0);\n\t\tdata->mode = O_RDONLY;\n\t\tdata->free_bitmaps = false;\n\t\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\t} else {\n\t\t/*\n\t\t * Resuming.  We may need to wait for the image device to\n\t\t * appear.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tdata->swap = -1;\n\t\tdata->mode = O_WRONLY;\n\t\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);\n\t\tif (!error) {\n\t\t\terror = create_basic_memory_bitmaps();\n\t\t\tdata->free_bitmaps = !error;\n\t\t}\n\t}\n\tif (error)\n\t\thibernate_release();\n\n\tdata->frozen = false;\n\tdata->ready = false;\n\tdata->platform_support = false;\n\tdata->dev = 0;\n\n Unlock:\n\tunlock_system_sleep();\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct snapshot_data {\n\tstruct snapshot_handle handle;\n\tint swap;\n\tint mode;\n\tbool frozen;\n\tbool ready;\n\tbool platform_support;\n\tbool free_bitmaps;\n\tdev_t dev;\n} snapshot_state;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_release",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "78-81",
          "snippet": "void hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nvoid hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_basic_memory_bitmaps",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "create_basic_memory_bitmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1112-1153",
          "snippet": "int create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n#define PG_ANY\t\t0\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nint create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain_robust",
          "args": [
            "PM_RESTORE_PREPARE",
            "PM_POST_RESTORE"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "83-90",
          "snippet": "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_device_probe",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_type_of",
          "args": [
            "swsusp_resume_device",
            "0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data->handle",
            "0",
            "sizeof(struct snapshot_handle)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nonseekable_open",
          "args": [
            "inode",
            "filp"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernate_acquire",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "73-76",
          "snippet": "bool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nbool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "83-88",
          "snippet": "bool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic struct snapshot_data {\n\tstruct snapshot_handle handle;\n\tint swap;\n\tint mode;\n\tbool frozen;\n\tbool ready;\n\tbool platform_support;\n\tbool free_bitmaps;\n\tdev_t dev;\n} snapshot_state;\n\nstatic int snapshot_open(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\tint error;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tlock_system_sleep();\n\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tif ((filp->f_flags & O_ACCMODE) == O_RDWR) {\n\t\thibernate_release();\n\t\terror = -ENOSYS;\n\t\tgoto Unlock;\n\t}\n\tnonseekable_open(inode, filp);\n\tdata = &snapshot_state;\n\tfilp->private_data = data;\n\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\t/* Hibernating.  The image device should be accessible. */\n\t\tdata->swap = swap_type_of(swsusp_resume_device, 0);\n\t\tdata->mode = O_RDONLY;\n\t\tdata->free_bitmaps = false;\n\t\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\t} else {\n\t\t/*\n\t\t * Resuming.  We may need to wait for the image device to\n\t\t * appear.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tdata->swap = -1;\n\t\tdata->mode = O_WRONLY;\n\t\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);\n\t\tif (!error) {\n\t\t\terror = create_basic_memory_bitmaps();\n\t\t\tdata->free_bitmaps = !error;\n\t\t}\n\t}\n\tif (error)\n\t\thibernate_release();\n\n\tdata->frozen = false;\n\tdata->ready = false;\n\tdata->platform_support = false;\n\tdata->dev = 0;\n\n Unlock:\n\tunlock_system_sleep();\n\n\treturn error;\n}"
  },
  {
    "function_name": "is_hibernate_resume_dev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/user.c",
    "lines": "41-44",
    "snippet": "int is_hibernate_resume_dev(dev_t dev)\n{\n\treturn hibernation_available() && snapshot_state.dev == dev;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct snapshot_data {\n\tstruct snapshot_handle handle;\n\tint swap;\n\tint mode;\n\tbool frozen;\n\tbool ready;\n\tbool platform_support;\n\tbool free_bitmaps;\n\tdev_t dev;\n} snapshot_state;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "83-88",
          "snippet": "bool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\nstatic struct snapshot_data {\n\tstruct snapshot_handle handle;\n\tint swap;\n\tint mode;\n\tbool frozen;\n\tbool ready;\n\tbool platform_support;\n\tbool free_bitmaps;\n\tdev_t dev;\n} snapshot_state;\n\nint is_hibernate_resume_dev(dev_t dev)\n{\n\treturn hibernation_available() && snapshot_state.dev == dev;\n}"
  }
]