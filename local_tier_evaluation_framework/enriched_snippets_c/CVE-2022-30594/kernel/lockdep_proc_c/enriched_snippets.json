[
  {
    "function_name": "lockdep_proc_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "680-692",
    "snippet": "static int __init lockdep_proc_init(void)\n{\n\tproc_create_seq(\"lockdep\", S_IRUSR, NULL, &lockdep_ops);\n#ifdef CONFIG_PROVE_LOCKING\n\tproc_create_seq(\"lockdep_chains\", S_IRUSR, NULL, &lockdep_chains_ops);\n#endif\n\tproc_create_single(\"lockdep_stats\", S_IRUSR, NULL, lockdep_stats_show);\n#ifdef CONFIG_LOCK_STAT\n\tproc_create(\"lock_stat\", S_IRUSR | S_IWUSR, NULL, &lock_stat_proc_ops);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations lockdep_ops = {\n\t.start\t= l_start,\n\t.next\t= l_next,\n\t.stop\t= l_stop,\n\t.show\t= l_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"lock_stat\"",
            "S_IRUSR | S_IWUSR",
            "NULL",
            "&lock_stat_proc_ops"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single",
          "args": [
            "\"lockdep_stats\"",
            "S_IRUSR",
            "NULL",
            "lockdep_stats_show"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"lockdep_chains\"",
            "S_IRUSR",
            "NULL",
            "&lockdep_chains_ops"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"lockdep\"",
            "S_IRUSR",
            "NULL",
            "&lockdep_ops"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic const struct seq_operations lockdep_ops = {\n\t.start\t= l_start,\n\t.next\t= l_next,\n\t.stop\t= l_stop,\n\t.show\t= l_show,\n};\n\nstatic int __init lockdep_proc_init(void)\n{\n\tproc_create_seq(\"lockdep\", S_IRUSR, NULL, &lockdep_ops);\n#ifdef CONFIG_PROVE_LOCKING\n\tproc_create_seq(\"lockdep_chains\", S_IRUSR, NULL, &lockdep_chains_ops);\n#endif\n\tproc_create_single(\"lockdep_stats\", S_IRUSR, NULL, lockdep_stats_show);\n#ifdef CONFIG_LOCK_STAT\n\tproc_create(\"lock_stat\", S_IRUSR | S_IWUSR, NULL, &lock_stat_proc_ops);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_stat_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "663-669",
    "snippet": "static int lock_stat_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tvfree(seq->private);\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "seq->private"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic int lock_stat_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tvfree(seq->private);\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "lock_stat_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "644-661",
    "snippet": "static ssize_t lock_stat_write(struct file *file, const char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct lock_class *class;\n\tchar c;\n\n\tif (count) {\n\t\tif (get_user(c, buf))\n\t\t\treturn -EFAULT;\n\n\t\tif (c != '0')\n\t\t\treturn count;\n\n\t\tlist_for_each_entry(class, &all_lock_classes, lock_entry)\n\t\t\tclear_lock_stats(class);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_lock_stats",
          "args": [
            "class"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "clear_lock_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "294-306",
          "snippet": "void clear_lock_stats(struct lock_class *class)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *cpu_stats =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tmemset(cpu_stats, 0, sizeof(struct lock_class_stats));\n\t}\n\tmemset(class->contention_point, 0, sizeof(class->contention_point));\n\tmemset(class->contending_point, 0, sizeof(class->contending_point));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nvoid clear_lock_stats(struct lock_class *class)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct lock_class_stats *cpu_stats =\n\t\t\t&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\n\n\t\tmemset(cpu_stats, 0, sizeof(struct lock_class_stats));\n\t}\n\tmemset(class->contention_point, 0, sizeof(class->contention_point));\n\tmemset(class->contending_point, 0, sizeof(class->contending_point));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "class",
            "&all_lock_classes",
            "lock_entry"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "c",
            "buf"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic ssize_t lock_stat_write(struct file *file, const char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct lock_class *class;\n\tchar c;\n\n\tif (count) {\n\t\tif (get_user(c, buf))\n\t\t\treturn -EFAULT;\n\n\t\tif (c != '0')\n\t\t\treturn count;\n\n\t\tlist_for_each_entry(class, &all_lock_classes, lock_entry)\n\t\t\tclear_lock_stats(class);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "lock_stat_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "612-642",
    "snippet": "static int lock_stat_open(struct inode *inode, struct file *file)\n{\n\tint res;\n\tstruct lock_class *class;\n\tstruct lock_stat_seq *data = vmalloc(sizeof(struct lock_stat_seq));\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = seq_open(file, &lockstat_ops);\n\tif (!res) {\n\t\tstruct lock_stat_data *iter = data->stats;\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tlist_for_each_entry(class, &all_lock_classes, lock_entry) {\n\t\t\titer->class = class;\n\t\t\titer->stats = lock_stats(class);\n\t\t\titer++;\n\t\t}\n\t\tdata->iter_end = iter;\n\n\t\tsort(data->stats, data->iter_end - data->stats,\n\t\t\t\tsizeof(struct lock_stat_data),\n\t\t\t\tlock_stat_cmp, NULL);\n\n\t\tm->private = data;\n\t} else\n\t\tvfree(data);\n\n\treturn res;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "data->stats",
            "data->iter_end - data->stats",
            "sizeof(struct lock_stat_data)",
            "lock_stat_cmp",
            "NULL"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_stats",
          "args": [
            "class"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "308-311",
          "snippet": "static struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\n{\n\treturn &this_cpu_ptr(cpu_lock_stats)[class - lock_classes];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "class",
            "&all_lock_classes",
            "lock_entry"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&lockstat_ops"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "sizeof(struct lock_stat_seq)"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "array_map_vmalloc_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "379-382",
          "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic int lock_stat_open(struct inode *inode, struct file *file)\n{\n\tint res;\n\tstruct lock_class *class;\n\tstruct lock_stat_seq *data = vmalloc(sizeof(struct lock_stat_seq));\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = seq_open(file, &lockstat_ops);\n\tif (!res) {\n\t\tstruct lock_stat_data *iter = data->stats;\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tlist_for_each_entry(class, &all_lock_classes, lock_entry) {\n\t\t\titer->class = class;\n\t\t\titer->stats = lock_stats(class);\n\t\t\titer++;\n\t\t}\n\t\tdata->iter_end = iter;\n\n\t\tsort(data->stats, data->iter_end - data->stats,\n\t\t\t\tsizeof(struct lock_stat_data),\n\t\t\t\tlock_stat_cmp, NULL);\n\n\t\tm->private = data;\n\t} else\n\t\tvfree(data);\n\n\treturn res;\n}"
  },
  {
    "function_name": "ls_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "595-603",
    "snippet": "static int ls_show(struct seq_file *m, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_header(m);\n\telse\n\t\tseq_stats(m, v);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_stats",
          "args": [
            "m",
            "v"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "seq_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "431-541",
          "snippet": "static void seq_stats(struct seq_file *m, struct lock_stat_data *data)\n{\n\tconst struct lockdep_subclass_key *ckey;\n\tstruct lock_class_stats *stats;\n\tstruct lock_class *class;\n\tconst char *cname;\n\tint i, namelen;\n\tchar name[39];\n\n\tclass = data->class;\n\tstats = &data->stats;\n\n\tnamelen = 38;\n\tif (class->name_version > 1)\n\t\tnamelen -= 2; /* XXX truncates versions > 9 */\n\tif (class->subclass)\n\t\tnamelen -= 2;\n\n\trcu_read_lock_sched();\n\tcname = rcu_dereference_sched(class->name);\n\tckey  = rcu_dereference_sched(class->key);\n\n\tif (!cname && !ckey) {\n\t\trcu_read_unlock_sched();\n\t\treturn;\n\n\t} else if (!cname) {\n\t\tchar str[KSYM_NAME_LEN];\n\t\tconst char *key_name;\n\n\t\tkey_name = __get_key_name(ckey, str);\n\t\tsnprintf(name, namelen, \"%s\", key_name);\n\t} else {\n\t\tsnprintf(name, namelen, \"%s\", cname);\n\t}\n\trcu_read_unlock_sched();\n\n\tnamelen = strlen(name);\n\tif (class->name_version > 1) {\n\t\tsnprintf(name+namelen, 3, \"#%d\", class->name_version);\n\t\tnamelen += 2;\n\t}\n\tif (class->subclass) {\n\t\tsnprintf(name+namelen, 3, \"/%d\", class->subclass);\n\t\tnamelen += 2;\n\t}\n\n\tif (stats->write_holdtime.nr) {\n\t\tif (stats->read_holdtime.nr)\n\t\t\tseq_printf(m, \"%38s-W:\", name);\n\t\telse\n\t\t\tseq_printf(m, \"%40s:\", name);\n\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_write]);\n\t\tseq_lock_time(m, &stats->write_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_write]);\n\t\tseq_lock_time(m, &stats->write_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_holdtime.nr) {\n\t\tseq_printf(m, \"%38s-R:\", name);\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_read]);\n\t\tseq_lock_time(m, &stats->read_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_read]);\n\t\tseq_lock_time(m, &stats->read_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_waittime.nr + stats->write_waittime.nr == 0)\n\t\treturn;\n\n\tif (stats->read_holdtime.nr)\n\t\tnamelen += 2;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contention_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contention_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contention_point[i],\n\t\t\t   ip, (void *)class->contention_point[i]);\n\t}\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contending_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contending_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contending_point[i],\n\t\t\t   ip, (void *)class->contending_point[i]);\n\t}\n\tif (i) {\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_line(m, '.', 0, 40 + 1 + 12 * (14 + 1));\n\t\tseq_puts(m, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_stats(struct seq_file *m, struct lock_stat_data *data)\n{\n\tconst struct lockdep_subclass_key *ckey;\n\tstruct lock_class_stats *stats;\n\tstruct lock_class *class;\n\tconst char *cname;\n\tint i, namelen;\n\tchar name[39];\n\n\tclass = data->class;\n\tstats = &data->stats;\n\n\tnamelen = 38;\n\tif (class->name_version > 1)\n\t\tnamelen -= 2; /* XXX truncates versions > 9 */\n\tif (class->subclass)\n\t\tnamelen -= 2;\n\n\trcu_read_lock_sched();\n\tcname = rcu_dereference_sched(class->name);\n\tckey  = rcu_dereference_sched(class->key);\n\n\tif (!cname && !ckey) {\n\t\trcu_read_unlock_sched();\n\t\treturn;\n\n\t} else if (!cname) {\n\t\tchar str[KSYM_NAME_LEN];\n\t\tconst char *key_name;\n\n\t\tkey_name = __get_key_name(ckey, str);\n\t\tsnprintf(name, namelen, \"%s\", key_name);\n\t} else {\n\t\tsnprintf(name, namelen, \"%s\", cname);\n\t}\n\trcu_read_unlock_sched();\n\n\tnamelen = strlen(name);\n\tif (class->name_version > 1) {\n\t\tsnprintf(name+namelen, 3, \"#%d\", class->name_version);\n\t\tnamelen += 2;\n\t}\n\tif (class->subclass) {\n\t\tsnprintf(name+namelen, 3, \"/%d\", class->subclass);\n\t\tnamelen += 2;\n\t}\n\n\tif (stats->write_holdtime.nr) {\n\t\tif (stats->read_holdtime.nr)\n\t\t\tseq_printf(m, \"%38s-W:\", name);\n\t\telse\n\t\t\tseq_printf(m, \"%40s:\", name);\n\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_write]);\n\t\tseq_lock_time(m, &stats->write_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_write]);\n\t\tseq_lock_time(m, &stats->write_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_holdtime.nr) {\n\t\tseq_printf(m, \"%38s-R:\", name);\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_read]);\n\t\tseq_lock_time(m, &stats->read_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_read]);\n\t\tseq_lock_time(m, &stats->read_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_waittime.nr + stats->write_waittime.nr == 0)\n\t\treturn;\n\n\tif (stats->read_holdtime.nr)\n\t\tnamelen += 2;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contention_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contention_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contention_point[i],\n\t\t\t   ip, (void *)class->contention_point[i]);\n\t}\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contending_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contending_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contending_point[i],\n\t\t\t   ip, (void *)class->contending_point[i]);\n\t}\n\tif (i) {\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_line(m, '.', 0, 40 + 1 + 12 * (14 + 1));\n\t\tseq_puts(m, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_header",
          "args": [
            "m"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "seq_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "543-568",
          "snippet": "static void seq_header(struct seq_file *m)\n{\n\tseq_puts(m, \"lock_stat version 0.4\\n\");\n\n\tif (unlikely(!debug_locks))\n\t\tseq_printf(m, \"*WARNING* lock debugging disabled!! - possibly due to a lockdep warning\\n\");\n\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"%40s %14s %14s %14s %14s %14s %14s %14s %14s %14s %14s \"\n\t\t\t\"%14s %14s\\n\",\n\t\t\t\"class name\",\n\t\t\t\"con-bounces\",\n\t\t\t\"contentions\",\n\t\t\t\"waittime-min\",\n\t\t\t\"waittime-max\",\n\t\t\t\"waittime-total\",\n\t\t\t\"waittime-avg\",\n\t\t\t\"acq-bounces\",\n\t\t\t\"acquisitions\",\n\t\t\t\"holdtime-min\",\n\t\t\t\"holdtime-max\",\n\t\t\t\"holdtime-total\",\n\t\t\t\"holdtime-avg\");\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_header(struct seq_file *m)\n{\n\tseq_puts(m, \"lock_stat version 0.4\\n\");\n\n\tif (unlikely(!debug_locks))\n\t\tseq_printf(m, \"*WARNING* lock debugging disabled!! - possibly due to a lockdep warning\\n\");\n\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"%40s %14s %14s %14s %14s %14s %14s %14s %14s %14s %14s \"\n\t\t\t\"%14s %14s\\n\",\n\t\t\t\"class name\",\n\t\t\t\"con-bounces\",\n\t\t\t\"contentions\",\n\t\t\t\"waittime-min\",\n\t\t\t\"waittime-max\",\n\t\t\t\"waittime-total\",\n\t\t\t\"waittime-avg\",\n\t\t\t\"acq-bounces\",\n\t\t\t\"acquisitions\",\n\t\t\t\"holdtime-min\",\n\t\t\t\"holdtime-max\",\n\t\t\t\"holdtime-total\",\n\t\t\t\"holdtime-avg\");\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic int ls_show(struct seq_file *m, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_header(m);\n\telse\n\t\tseq_stats(m, v);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ls_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "591-593",
    "snippet": "static void ls_stop(struct seq_file *m, void *v)\n{\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void ls_stop(struct seq_file *m, void *v)\n{\n}"
  },
  {
    "function_name": "ls_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "585-589",
    "snippet": "static void *ls_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn ls_start(m, pos);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ls_start",
          "args": [
            "m",
            "pos"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ls_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "570-583",
          "snippet": "static void *ls_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct lock_stat_seq *data = m->private;\n\tstruct lock_stat_data *iter;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\titer = data->stats + (*pos - 1);\n\tif (iter >= data->iter_end)\n\t\titer = NULL;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void *ls_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct lock_stat_seq *data = m->private;\n\tstruct lock_stat_data *iter;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\titer = data->stats + (*pos - 1);\n\tif (iter >= data->iter_end)\n\t\titer = NULL;\n\n\treturn iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void *ls_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn ls_start(m, pos);\n}"
  },
  {
    "function_name": "ls_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "570-583",
    "snippet": "static void *ls_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct lock_stat_seq *data = m->private;\n\tstruct lock_stat_data *iter;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\titer = data->stats + (*pos - 1);\n\tif (iter >= data->iter_end)\n\t\titer = NULL;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void *ls_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct lock_stat_seq *data = m->private;\n\tstruct lock_stat_data *iter;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\titer = data->stats + (*pos - 1);\n\tif (iter >= data->iter_end)\n\t\titer = NULL;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "seq_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "543-568",
    "snippet": "static void seq_header(struct seq_file *m)\n{\n\tseq_puts(m, \"lock_stat version 0.4\\n\");\n\n\tif (unlikely(!debug_locks))\n\t\tseq_printf(m, \"*WARNING* lock debugging disabled!! - possibly due to a lockdep warning\\n\");\n\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"%40s %14s %14s %14s %14s %14s %14s %14s %14s %14s %14s \"\n\t\t\t\"%14s %14s\\n\",\n\t\t\t\"class name\",\n\t\t\t\"con-bounces\",\n\t\t\t\"contentions\",\n\t\t\t\"waittime-min\",\n\t\t\t\"waittime-max\",\n\t\t\t\"waittime-total\",\n\t\t\t\"waittime-avg\",\n\t\t\t\"acq-bounces\",\n\t\t\t\"acquisitions\",\n\t\t\t\"holdtime-min\",\n\t\t\t\"holdtime-max\",\n\t\t\t\"holdtime-total\",\n\t\t\t\"holdtime-avg\");\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_line",
          "args": [
            "m",
            "'-'",
            "0",
            "40 + 1 + 12 * (14 + 1)"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "seq_line",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "393-402",
          "snippet": "static void seq_line(struct seq_file *m, char c, int offset, int length)\n{\n\tint i;\n\n\tfor (i = 0; i < offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_line(struct seq_file *m, char c, int offset, int length)\n{\n\tint i;\n\n\tfor (i = 0; i < offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!debug_locks"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"lock_stat version 0.4\\n\""
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_header(struct seq_file *m)\n{\n\tseq_puts(m, \"lock_stat version 0.4\\n\");\n\n\tif (unlikely(!debug_locks))\n\t\tseq_printf(m, \"*WARNING* lock debugging disabled!! - possibly due to a lockdep warning\\n\");\n\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"%40s %14s %14s %14s %14s %14s %14s %14s %14s %14s %14s \"\n\t\t\t\"%14s %14s\\n\",\n\t\t\t\"class name\",\n\t\t\t\"con-bounces\",\n\t\t\t\"contentions\",\n\t\t\t\"waittime-min\",\n\t\t\t\"waittime-max\",\n\t\t\t\"waittime-total\",\n\t\t\t\"waittime-avg\",\n\t\t\t\"acq-bounces\",\n\t\t\t\"acquisitions\",\n\t\t\t\"holdtime-min\",\n\t\t\t\"holdtime-max\",\n\t\t\t\"holdtime-total\",\n\t\t\t\"holdtime-avg\");\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "seq_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "431-541",
    "snippet": "static void seq_stats(struct seq_file *m, struct lock_stat_data *data)\n{\n\tconst struct lockdep_subclass_key *ckey;\n\tstruct lock_class_stats *stats;\n\tstruct lock_class *class;\n\tconst char *cname;\n\tint i, namelen;\n\tchar name[39];\n\n\tclass = data->class;\n\tstats = &data->stats;\n\n\tnamelen = 38;\n\tif (class->name_version > 1)\n\t\tnamelen -= 2; /* XXX truncates versions > 9 */\n\tif (class->subclass)\n\t\tnamelen -= 2;\n\n\trcu_read_lock_sched();\n\tcname = rcu_dereference_sched(class->name);\n\tckey  = rcu_dereference_sched(class->key);\n\n\tif (!cname && !ckey) {\n\t\trcu_read_unlock_sched();\n\t\treturn;\n\n\t} else if (!cname) {\n\t\tchar str[KSYM_NAME_LEN];\n\t\tconst char *key_name;\n\n\t\tkey_name = __get_key_name(ckey, str);\n\t\tsnprintf(name, namelen, \"%s\", key_name);\n\t} else {\n\t\tsnprintf(name, namelen, \"%s\", cname);\n\t}\n\trcu_read_unlock_sched();\n\n\tnamelen = strlen(name);\n\tif (class->name_version > 1) {\n\t\tsnprintf(name+namelen, 3, \"#%d\", class->name_version);\n\t\tnamelen += 2;\n\t}\n\tif (class->subclass) {\n\t\tsnprintf(name+namelen, 3, \"/%d\", class->subclass);\n\t\tnamelen += 2;\n\t}\n\n\tif (stats->write_holdtime.nr) {\n\t\tif (stats->read_holdtime.nr)\n\t\t\tseq_printf(m, \"%38s-W:\", name);\n\t\telse\n\t\t\tseq_printf(m, \"%40s:\", name);\n\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_write]);\n\t\tseq_lock_time(m, &stats->write_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_write]);\n\t\tseq_lock_time(m, &stats->write_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_holdtime.nr) {\n\t\tseq_printf(m, \"%38s-R:\", name);\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_read]);\n\t\tseq_lock_time(m, &stats->read_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_read]);\n\t\tseq_lock_time(m, &stats->read_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_waittime.nr + stats->write_waittime.nr == 0)\n\t\treturn;\n\n\tif (stats->read_holdtime.nr)\n\t\tnamelen += 2;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contention_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contention_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contention_point[i],\n\t\t\t   ip, (void *)class->contention_point[i]);\n\t}\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contending_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contending_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contending_point[i],\n\t\t\t   ip, (void *)class->contending_point[i]);\n\t}\n\tif (i) {\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_line(m, '.', 0, 40 + 1 + 12 * (14 + 1));\n\t\tseq_puts(m, \"\\n\");\n\t}\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_line",
          "args": [
            "m",
            "'.'",
            "0",
            "40 + 1 + 12 * (14 + 1)"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "seq_line",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "393-402",
          "snippet": "static void seq_line(struct seq_file *m, char c, int offset, int length)\n{\n\tint i;\n\n\tfor (i = 0; i < offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_line(struct seq_file *m, char c, int offset, int length)\n{\n\tint i;\n\n\tfor (i = 0; i < offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%40s %14lu %29s %pS\\n\"",
            "name",
            "stats->contending_point[i]",
            "ip",
            "(void *)class->contending_point[i]"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ip",
            "sizeof(ip)",
            "\"[<%p>]\"",
            "(void *)class->contending_point[i]"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ip",
            "sizeof(ip)",
            "\"[<%p>]\"",
            "(void *)class->contention_point[i]"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_lock_time",
          "args": [
            "m",
            "&stats->read_holdtime"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "seq_lock_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "422-429",
          "snippet": "static void seq_lock_time(struct seq_file *m, struct lock_time *lt)\n{\n\tseq_printf(m, \"%14lu\", lt->nr);\n\tseq_time(m, lt->min);\n\tseq_time(m, lt->max);\n\tseq_time(m, lt->total);\n\tseq_time(m, lt->nr ? div64_u64(lt->total, lt->nr) : 0);\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_lock_time(struct seq_file *m, struct lock_time *lt)\n{\n\tseq_printf(m, \"%14lu\", lt->nr);\n\tseq_time(m, lt->min);\n\tseq_time(m, lt->max);\n\tseq_time(m, lt->total);\n\tseq_time(m, lt->nr ? div64_u64(lt->total, lt->nr) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name+namelen",
            "3",
            "\"/%d\"",
            "class->subclass"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name+namelen",
            "3",
            "\"#%d\"",
            "class->name_version"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "namelen",
            "\"%s\"",
            "cname"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "namelen",
            "\"%s\"",
            "key_name"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_key_name",
          "args": [
            "ckey",
            "str"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "__get_key_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "634-637",
          "snippet": "const char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nconst char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "class->key"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "class->name"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_stats(struct seq_file *m, struct lock_stat_data *data)\n{\n\tconst struct lockdep_subclass_key *ckey;\n\tstruct lock_class_stats *stats;\n\tstruct lock_class *class;\n\tconst char *cname;\n\tint i, namelen;\n\tchar name[39];\n\n\tclass = data->class;\n\tstats = &data->stats;\n\n\tnamelen = 38;\n\tif (class->name_version > 1)\n\t\tnamelen -= 2; /* XXX truncates versions > 9 */\n\tif (class->subclass)\n\t\tnamelen -= 2;\n\n\trcu_read_lock_sched();\n\tcname = rcu_dereference_sched(class->name);\n\tckey  = rcu_dereference_sched(class->key);\n\n\tif (!cname && !ckey) {\n\t\trcu_read_unlock_sched();\n\t\treturn;\n\n\t} else if (!cname) {\n\t\tchar str[KSYM_NAME_LEN];\n\t\tconst char *key_name;\n\n\t\tkey_name = __get_key_name(ckey, str);\n\t\tsnprintf(name, namelen, \"%s\", key_name);\n\t} else {\n\t\tsnprintf(name, namelen, \"%s\", cname);\n\t}\n\trcu_read_unlock_sched();\n\n\tnamelen = strlen(name);\n\tif (class->name_version > 1) {\n\t\tsnprintf(name+namelen, 3, \"#%d\", class->name_version);\n\t\tnamelen += 2;\n\t}\n\tif (class->subclass) {\n\t\tsnprintf(name+namelen, 3, \"/%d\", class->subclass);\n\t\tnamelen += 2;\n\t}\n\n\tif (stats->write_holdtime.nr) {\n\t\tif (stats->read_holdtime.nr)\n\t\t\tseq_printf(m, \"%38s-W:\", name);\n\t\telse\n\t\t\tseq_printf(m, \"%40s:\", name);\n\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_write]);\n\t\tseq_lock_time(m, &stats->write_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_write]);\n\t\tseq_lock_time(m, &stats->write_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_holdtime.nr) {\n\t\tseq_printf(m, \"%38s-R:\", name);\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_read]);\n\t\tseq_lock_time(m, &stats->read_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_read]);\n\t\tseq_lock_time(m, &stats->read_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_waittime.nr + stats->write_waittime.nr == 0)\n\t\treturn;\n\n\tif (stats->read_holdtime.nr)\n\t\tnamelen += 2;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contention_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contention_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contention_point[i],\n\t\t\t   ip, (void *)class->contention_point[i]);\n\t}\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contending_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contending_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contending_point[i],\n\t\t\t   ip, (void *)class->contending_point[i]);\n\t}\n\tif (i) {\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_line(m, '.', 0, 40 + 1 + 12 * (14 + 1));\n\t\tseq_puts(m, \"\\n\");\n\t}\n}"
  },
  {
    "function_name": "seq_lock_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "422-429",
    "snippet": "static void seq_lock_time(struct seq_file *m, struct lock_time *lt)\n{\n\tseq_printf(m, \"%14lu\", lt->nr);\n\tseq_time(m, lt->min);\n\tseq_time(m, lt->max);\n\tseq_time(m, lt->total);\n\tseq_time(m, lt->nr ? div64_u64(lt->total, lt->nr) : 0);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_time",
          "args": [
            "m",
            "lt->nr ? div64_u64(lt->total, lt->nr) : 0"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "seq_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "414-420",
          "snippet": "static void seq_time(struct seq_file *m, s64 time)\n{\n\tchar num[15];\n\n\tsnprint_time(num, sizeof(num), time);\n\tseq_printf(m, \" %14s\", num);\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_time(struct seq_file *m, s64 time)\n{\n\tchar num[15];\n\n\tsnprint_time(num, sizeof(num), time);\n\tseq_printf(m, \" %14s\", num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "lt->total",
            "lt->nr"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%14lu\"",
            "lt->nr"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_lock_time(struct seq_file *m, struct lock_time *lt)\n{\n\tseq_printf(m, \"%14lu\", lt->nr);\n\tseq_time(m, lt->min);\n\tseq_time(m, lt->max);\n\tseq_time(m, lt->total);\n\tseq_time(m, lt->nr ? div64_u64(lt->total, lt->nr) : 0);\n}"
  },
  {
    "function_name": "seq_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "414-420",
    "snippet": "static void seq_time(struct seq_file *m, s64 time)\n{\n\tchar num[15];\n\n\tsnprint_time(num, sizeof(num), time);\n\tseq_printf(m, \" %14s\", num);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %14s\"",
            "num"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprint_time",
          "args": [
            "num",
            "sizeof(num)",
            "time"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "snprint_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "404-412",
          "snippet": "static void snprint_time(char *buf, size_t bufsiz, s64 nr)\n{\n\ts64 div;\n\ts32 rem;\n\n\tnr += 5; /* for display rounding */\n\tdiv = div_s64_rem(nr, 1000, &rem);\n\tsnprintf(buf, bufsiz, \"%lld.%02d\", (long long)div, (int)rem/10);\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void snprint_time(char *buf, size_t bufsiz, s64 nr)\n{\n\ts64 div;\n\ts32 rem;\n\n\tnr += 5; /* for display rounding */\n\tdiv = div_s64_rem(nr, 1000, &rem);\n\tsnprintf(buf, bufsiz, \"%lld.%02d\", (long long)div, (int)rem/10);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_time(struct seq_file *m, s64 time)\n{\n\tchar num[15];\n\n\tsnprint_time(num, sizeof(num), time);\n\tseq_printf(m, \" %14s\", num);\n}"
  },
  {
    "function_name": "snprint_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "404-412",
    "snippet": "static void snprint_time(char *buf, size_t bufsiz, s64 nr)\n{\n\ts64 div;\n\ts32 rem;\n\n\tnr += 5; /* for display rounding */\n\tdiv = div_s64_rem(nr, 1000, &rem);\n\tsnprintf(buf, bufsiz, \"%lld.%02d\", (long long)div, (int)rem/10);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufsiz",
            "\"%lld.%02d\"",
            "(long long)div",
            "(int)rem/10"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_s64_rem",
          "args": [
            "nr",
            "1000",
            "&rem"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void snprint_time(char *buf, size_t bufsiz, s64 nr)\n{\n\ts64 div;\n\ts32 rem;\n\n\tnr += 5; /* for display rounding */\n\tdiv = div_s64_rem(nr, 1000, &rem);\n\tsnprintf(buf, bufsiz, \"%lld.%02d\", (long long)div, (int)rem/10);\n}"
  },
  {
    "function_name": "seq_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "393-402",
    "snippet": "static void seq_line(struct seq_file *m, char c, int offset, int length)\n{\n\tint i;\n\n\tfor (i = 0; i < offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%c\"",
            "c"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void seq_line(struct seq_file *m, char c, int offset, int length)\n{\n\tint i;\n\n\tfor (i = 0; i < offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}"
  },
  {
    "function_name": "lock_stat_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "382-391",
    "snippet": "static int lock_stat_cmp(const void *l, const void *r)\n{\n\tconst struct lock_stat_data *dl = l, *dr = r;\n\tunsigned long nl, nr;\n\n\tnl = dl->stats.read_waittime.nr + dl->stats.write_waittime.nr;\n\tnr = dr->stats.read_waittime.nr + dr->stats.write_waittime.nr;\n\n\treturn nr - nl;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic int lock_stat_cmp(const void *l, const void *r)\n{\n\tconst struct lock_stat_data *dl = l, *dr = r;\n\tunsigned long nl, nr;\n\n\tnl = dl->stats.read_waittime.nr + dl->stats.write_waittime.nr;\n\tnr = dr->stats.read_waittime.nr + dr->stats.write_waittime.nr;\n\n\treturn nr - nl;\n}"
  },
  {
    "function_name": "lockdep_stats_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "210-365",
    "snippet": "static int lockdep_stats_show(struct seq_file *m, void *v)\n{\n\tunsigned long nr_unused = 0, nr_uncategorized = 0,\n\t\t      nr_irq_safe = 0, nr_irq_unsafe = 0,\n\t\t      nr_softirq_safe = 0, nr_softirq_unsafe = 0,\n\t\t      nr_hardirq_safe = 0, nr_hardirq_unsafe = 0,\n\t\t      nr_irq_read_safe = 0, nr_irq_read_unsafe = 0,\n\t\t      nr_softirq_read_safe = 0, nr_softirq_read_unsafe = 0,\n\t\t      nr_hardirq_read_safe = 0, nr_hardirq_read_unsafe = 0,\n\t\t      sum_forward_deps = 0;\n\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct lock_class *class;\n\n\tlist_for_each_entry(class, &all_lock_classes, lock_entry) {\n\n\t\tif (class->usage_mask == 0)\n\t\t\tnr_unused++;\n\t\tif (class->usage_mask == LOCKF_USED)\n\t\t\tnr_uncategorized++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_IRQ)\n\t\t\tnr_irq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_IRQ)\n\t\t\tnr_irq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_SOFTIRQ)\n\t\t\tnr_softirq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_SOFTIRQ)\n\t\t\tnr_softirq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_HARDIRQ)\n\t\t\tnr_hardirq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_HARDIRQ)\n\t\t\tnr_hardirq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_IRQ_READ)\n\t\t\tnr_irq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_IRQ_READ)\n\t\t\tnr_irq_read_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_SOFTIRQ_READ)\n\t\t\tnr_softirq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_SOFTIRQ_READ)\n\t\t\tnr_softirq_read_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_HARDIRQ_READ)\n\t\t\tnr_hardirq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_HARDIRQ_READ)\n\t\t\tnr_hardirq_read_unsafe++;\n\n\t\tsum_forward_deps += lockdep_count_forward_deps(class);\n\t}\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tDEBUG_LOCKS_WARN_ON(debug_atomic_read(nr_unused_locks) != nr_unused);\n#endif\n\n#endif\n\tseq_printf(m, \" lock-classes:                  %11lu [max: %lu]\\n\",\n\t\t\tnr_lock_classes, MAX_LOCKDEP_KEYS);\n\tseq_printf(m, \" direct dependencies:           %11lu [max: %lu]\\n\",\n\t\t\tnr_list_entries, MAX_LOCKDEP_ENTRIES);\n\tseq_printf(m, \" indirect dependencies:         %11lu\\n\",\n\t\t\tsum_forward_deps);\n\n\t/*\n\t * Total number of dependencies:\n\t *\n\t * All irq-safe locks may nest inside irq-unsafe locks,\n\t * plus all the other known dependencies:\n\t */\n\tseq_printf(m, \" all direct dependencies:       %11lu\\n\",\n\t\t\tnr_irq_unsafe * nr_irq_safe +\n\t\t\tnr_hardirq_unsafe * nr_hardirq_safe +\n\t\t\tnr_list_entries);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" dependency chains:             %11lu [max: %lu]\\n\",\n\t\t\tlock_chain_count(), MAX_LOCKDEP_CHAINS);\n\tseq_printf(m, \" dependency chain hlocks used:  %11lu [max: %lu]\\n\",\n\t\t\tMAX_LOCKDEP_CHAIN_HLOCKS -\n\t\t\t(nr_free_chain_hlocks + nr_lost_chain_hlocks),\n\t\t\tMAX_LOCKDEP_CHAIN_HLOCKS);\n\tseq_printf(m, \" dependency chain hlocks lost:  %11u\\n\",\n\t\t\tnr_lost_chain_hlocks);\n#endif\n\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tseq_printf(m, \" in-hardirq chains:             %11u\\n\",\n\t\t\tnr_hardirq_chains);\n\tseq_printf(m, \" in-softirq chains:             %11u\\n\",\n\t\t\tnr_softirq_chains);\n#endif\n\tseq_printf(m, \" in-process chains:             %11u\\n\",\n\t\t\tnr_process_chains);\n\tseq_printf(m, \" stack-trace entries:           %11lu [max: %lu]\\n\",\n\t\t\tnr_stack_trace_entries, MAX_STACK_TRACE_ENTRIES);\n#if defined(CONFIG_TRACE_IRQFLAGS) && defined(CONFIG_PROVE_LOCKING)\n\tseq_printf(m, \" number of stack traces:        %11llu\\n\",\n\t\t   lockdep_stack_trace_count());\n\tseq_printf(m, \" number of stack hash chains:   %11llu\\n\",\n\t\t   lockdep_stack_hash_count());\n#endif\n\tseq_printf(m, \" combined max dependencies:     %11u\\n\",\n\t\t\t(nr_hardirq_chains + 1) *\n\t\t\t(nr_softirq_chains + 1) *\n\t\t\t(nr_process_chains + 1)\n\t);\n\tseq_printf(m, \" hardirq-safe locks:            %11lu\\n\",\n\t\t\tnr_hardirq_safe);\n\tseq_printf(m, \" hardirq-unsafe locks:          %11lu\\n\",\n\t\t\tnr_hardirq_unsafe);\n\tseq_printf(m, \" softirq-safe locks:            %11lu\\n\",\n\t\t\tnr_softirq_safe);\n\tseq_printf(m, \" softirq-unsafe locks:          %11lu\\n\",\n\t\t\tnr_softirq_unsafe);\n\tseq_printf(m, \" irq-safe locks:                %11lu\\n\",\n\t\t\tnr_irq_safe);\n\tseq_printf(m, \" irq-unsafe locks:              %11lu\\n\",\n\t\t\tnr_irq_unsafe);\n\n\tseq_printf(m, \" hardirq-read-safe locks:       %11lu\\n\",\n\t\t\tnr_hardirq_read_safe);\n\tseq_printf(m, \" hardirq-read-unsafe locks:     %11lu\\n\",\n\t\t\tnr_hardirq_read_unsafe);\n\tseq_printf(m, \" softirq-read-safe locks:       %11lu\\n\",\n\t\t\tnr_softirq_read_safe);\n\tseq_printf(m, \" softirq-read-unsafe locks:     %11lu\\n\",\n\t\t\tnr_softirq_read_unsafe);\n\tseq_printf(m, \" irq-read-safe locks:           %11lu\\n\",\n\t\t\tnr_irq_read_safe);\n\tseq_printf(m, \" irq-read-unsafe locks:         %11lu\\n\",\n\t\t\tnr_irq_read_unsafe);\n\n\tseq_printf(m, \" uncategorized locks:           %11lu\\n\",\n\t\t\tnr_uncategorized);\n\tseq_printf(m, \" unused locks:                  %11lu\\n\",\n\t\t\tnr_unused);\n\tseq_printf(m, \" max locking depth:             %11u\\n\",\n\t\t\tmax_lockdep_depth);\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" max bfs queue depth:           %11u\\n\",\n\t\t\tmax_bfs_queue_depth);\n#endif\n\tlockdep_stats_debug_show(m);\n\tseq_printf(m, \" debug_locks:                   %11u\\n\",\n\t\t\tdebug_locks);\n\n\t/*\n\t * Zapped classes and lockdep data buffers reuse statistics.\n\t */\n\tseq_puts(m, \"\\n\");\n\tseq_printf(m, \" zapped classes:                %11lu\\n\",\n\t\t\tnr_zapped_classes);\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" zapped lock chains:            %11lu\\n\",\n\t\t\tnr_zapped_lock_chains);\n\tseq_printf(m, \" large chain blocks:            %11u\\n\",\n\t\t\tnr_large_chain_blocks);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" large chain blocks:            %11u\\n\"",
            "nr_large_chain_blocks"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_stats_debug_show",
          "args": [
            "m"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_stats_debug_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "172-208",
          "snippet": "static void lockdep_stats_debug_show(struct seq_file *m)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tunsigned long long hi1 = debug_atomic_read(hardirqs_on_events),\n\t\t\t   hi2 = debug_atomic_read(hardirqs_off_events),\n\t\t\t   hr1 = debug_atomic_read(redundant_hardirqs_on),\n\t\t\t   hr2 = debug_atomic_read(redundant_hardirqs_off),\n\t\t\t   si1 = debug_atomic_read(softirqs_on_events),\n\t\t\t   si2 = debug_atomic_read(softirqs_off_events),\n\t\t\t   sr1 = debug_atomic_read(redundant_softirqs_on),\n\t\t\t   sr2 = debug_atomic_read(redundant_softirqs_off);\n\n\tseq_printf(m, \" chain lookup misses:           %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_misses));\n\tseq_printf(m, \" chain lookup hits:             %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_hits));\n\tseq_printf(m, \" cyclic checks:                 %11llu\\n\",\n\t\tdebug_atomic_read(nr_cyclic_checks));\n\tseq_printf(m, \" redundant checks:              %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant_checks));\n\tseq_printf(m, \" redundant links:               %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant));\n\tseq_printf(m, \" find-mask forwards checks:     %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_forwards_checks));\n\tseq_printf(m, \" find-mask backwards checks:    %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_backwards_checks));\n\n\tseq_printf(m, \" hardirq on events:             %11llu\\n\", hi1);\n\tseq_printf(m, \" hardirq off events:            %11llu\\n\", hi2);\n\tseq_printf(m, \" redundant hardirq ons:         %11llu\\n\", hr1);\n\tseq_printf(m, \" redundant hardirq offs:        %11llu\\n\", hr2);\n\tseq_printf(m, \" softirq on events:             %11llu\\n\", si1);\n\tseq_printf(m, \" softirq off events:            %11llu\\n\", si2);\n\tseq_printf(m, \" redundant softirq ons:         %11llu\\n\", sr1);\n\tseq_printf(m, \" redundant softirq offs:        %11llu\\n\", sr2);\n#endif\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void lockdep_stats_debug_show(struct seq_file *m)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tunsigned long long hi1 = debug_atomic_read(hardirqs_on_events),\n\t\t\t   hi2 = debug_atomic_read(hardirqs_off_events),\n\t\t\t   hr1 = debug_atomic_read(redundant_hardirqs_on),\n\t\t\t   hr2 = debug_atomic_read(redundant_hardirqs_off),\n\t\t\t   si1 = debug_atomic_read(softirqs_on_events),\n\t\t\t   si2 = debug_atomic_read(softirqs_off_events),\n\t\t\t   sr1 = debug_atomic_read(redundant_softirqs_on),\n\t\t\t   sr2 = debug_atomic_read(redundant_softirqs_off);\n\n\tseq_printf(m, \" chain lookup misses:           %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_misses));\n\tseq_printf(m, \" chain lookup hits:             %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_hits));\n\tseq_printf(m, \" cyclic checks:                 %11llu\\n\",\n\t\tdebug_atomic_read(nr_cyclic_checks));\n\tseq_printf(m, \" redundant checks:              %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant_checks));\n\tseq_printf(m, \" redundant links:               %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant));\n\tseq_printf(m, \" find-mask forwards checks:     %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_forwards_checks));\n\tseq_printf(m, \" find-mask backwards checks:    %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_backwards_checks));\n\n\tseq_printf(m, \" hardirq on events:             %11llu\\n\", hi1);\n\tseq_printf(m, \" hardirq off events:            %11llu\\n\", hi2);\n\tseq_printf(m, \" redundant hardirq ons:         %11llu\\n\", hr1);\n\tseq_printf(m, \" redundant hardirq offs:        %11llu\\n\", hr2);\n\tseq_printf(m, \" softirq on events:             %11llu\\n\", si1);\n\tseq_printf(m, \" softirq off events:            %11llu\\n\", si2);\n\tseq_printf(m, \" redundant softirq ons:         %11llu\\n\", sr1);\n\tseq_printf(m, \" redundant softirq offs:        %11llu\\n\", sr2);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_stack_hash_count",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_stack_hash_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "586-596",
          "snippet": "u64 lockdep_stack_hash_count(void)\n{\n\tu64 c = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++)\n\t\tif (!hlist_empty(&stack_trace_hash[i]))\n\t\t\tc++;\n\n\treturn c;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nu64 lockdep_stack_hash_count(void)\n{\n\tu64 c = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++)\n\t\tif (!hlist_empty(&stack_trace_hash[i]))\n\t\t\tc++;\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_stack_trace_count",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_stack_trace_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "570-583",
          "snippet": "u64 lockdep_stack_trace_count(void)\n{\n\tstruct lock_trace *trace;\n\tu64 c = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++) {\n\t\thlist_for_each_entry(trace, &stack_trace_hash[i], hash_entry) {\n\t\t\tc++;\n\t\t}\n\t}\n\n\treturn c;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nu64 lockdep_stack_trace_count(void)\n{\n\tstruct lock_trace *trace;\n\tu64 c = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++) {\n\t\thlist_for_each_entry(trace, &stack_trace_hash[i], hash_entry) {\n\t\t\tc++;\n\t\t}\n\t}\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_chain_count",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "lock_chain_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3603-3606",
          "snippet": "unsigned long lock_chain_count(void)\n{\n\treturn bitmap_weight(lock_chains_in_use, ARRAY_SIZE(lock_chains));\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nunsigned long lock_chain_count(void)\n{\n\treturn bitmap_weight(lock_chains_in_use, ARRAY_SIZE(lock_chains));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "debug_atomic_read(nr_unused_locks) != nr_unused"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "nr_unused_locks"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_count_forward_deps",
          "args": [
            "class"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_count_forward_deps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_internals.h",
          "lines": "163-167",
          "snippet": "static inline unsigned long\nlockdep_count_forward_deps(struct lock_class *class)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n\nstatic inline unsigned long\nlockdep_count_forward_deps(struct lock_class *class)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "class",
            "&all_lock_classes",
            "lock_entry"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic int lockdep_stats_show(struct seq_file *m, void *v)\n{\n\tunsigned long nr_unused = 0, nr_uncategorized = 0,\n\t\t      nr_irq_safe = 0, nr_irq_unsafe = 0,\n\t\t      nr_softirq_safe = 0, nr_softirq_unsafe = 0,\n\t\t      nr_hardirq_safe = 0, nr_hardirq_unsafe = 0,\n\t\t      nr_irq_read_safe = 0, nr_irq_read_unsafe = 0,\n\t\t      nr_softirq_read_safe = 0, nr_softirq_read_unsafe = 0,\n\t\t      nr_hardirq_read_safe = 0, nr_hardirq_read_unsafe = 0,\n\t\t      sum_forward_deps = 0;\n\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct lock_class *class;\n\n\tlist_for_each_entry(class, &all_lock_classes, lock_entry) {\n\n\t\tif (class->usage_mask == 0)\n\t\t\tnr_unused++;\n\t\tif (class->usage_mask == LOCKF_USED)\n\t\t\tnr_uncategorized++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_IRQ)\n\t\t\tnr_irq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_IRQ)\n\t\t\tnr_irq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_SOFTIRQ)\n\t\t\tnr_softirq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_SOFTIRQ)\n\t\t\tnr_softirq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_HARDIRQ)\n\t\t\tnr_hardirq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_HARDIRQ)\n\t\t\tnr_hardirq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_IRQ_READ)\n\t\t\tnr_irq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_IRQ_READ)\n\t\t\tnr_irq_read_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_SOFTIRQ_READ)\n\t\t\tnr_softirq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_SOFTIRQ_READ)\n\t\t\tnr_softirq_read_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_HARDIRQ_READ)\n\t\t\tnr_hardirq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_HARDIRQ_READ)\n\t\t\tnr_hardirq_read_unsafe++;\n\n\t\tsum_forward_deps += lockdep_count_forward_deps(class);\n\t}\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tDEBUG_LOCKS_WARN_ON(debug_atomic_read(nr_unused_locks) != nr_unused);\n#endif\n\n#endif\n\tseq_printf(m, \" lock-classes:                  %11lu [max: %lu]\\n\",\n\t\t\tnr_lock_classes, MAX_LOCKDEP_KEYS);\n\tseq_printf(m, \" direct dependencies:           %11lu [max: %lu]\\n\",\n\t\t\tnr_list_entries, MAX_LOCKDEP_ENTRIES);\n\tseq_printf(m, \" indirect dependencies:         %11lu\\n\",\n\t\t\tsum_forward_deps);\n\n\t/*\n\t * Total number of dependencies:\n\t *\n\t * All irq-safe locks may nest inside irq-unsafe locks,\n\t * plus all the other known dependencies:\n\t */\n\tseq_printf(m, \" all direct dependencies:       %11lu\\n\",\n\t\t\tnr_irq_unsafe * nr_irq_safe +\n\t\t\tnr_hardirq_unsafe * nr_hardirq_safe +\n\t\t\tnr_list_entries);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" dependency chains:             %11lu [max: %lu]\\n\",\n\t\t\tlock_chain_count(), MAX_LOCKDEP_CHAINS);\n\tseq_printf(m, \" dependency chain hlocks used:  %11lu [max: %lu]\\n\",\n\t\t\tMAX_LOCKDEP_CHAIN_HLOCKS -\n\t\t\t(nr_free_chain_hlocks + nr_lost_chain_hlocks),\n\t\t\tMAX_LOCKDEP_CHAIN_HLOCKS);\n\tseq_printf(m, \" dependency chain hlocks lost:  %11u\\n\",\n\t\t\tnr_lost_chain_hlocks);\n#endif\n\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tseq_printf(m, \" in-hardirq chains:             %11u\\n\",\n\t\t\tnr_hardirq_chains);\n\tseq_printf(m, \" in-softirq chains:             %11u\\n\",\n\t\t\tnr_softirq_chains);\n#endif\n\tseq_printf(m, \" in-process chains:             %11u\\n\",\n\t\t\tnr_process_chains);\n\tseq_printf(m, \" stack-trace entries:           %11lu [max: %lu]\\n\",\n\t\t\tnr_stack_trace_entries, MAX_STACK_TRACE_ENTRIES);\n#if defined(CONFIG_TRACE_IRQFLAGS) && defined(CONFIG_PROVE_LOCKING)\n\tseq_printf(m, \" number of stack traces:        %11llu\\n\",\n\t\t   lockdep_stack_trace_count());\n\tseq_printf(m, \" number of stack hash chains:   %11llu\\n\",\n\t\t   lockdep_stack_hash_count());\n#endif\n\tseq_printf(m, \" combined max dependencies:     %11u\\n\",\n\t\t\t(nr_hardirq_chains + 1) *\n\t\t\t(nr_softirq_chains + 1) *\n\t\t\t(nr_process_chains + 1)\n\t);\n\tseq_printf(m, \" hardirq-safe locks:            %11lu\\n\",\n\t\t\tnr_hardirq_safe);\n\tseq_printf(m, \" hardirq-unsafe locks:          %11lu\\n\",\n\t\t\tnr_hardirq_unsafe);\n\tseq_printf(m, \" softirq-safe locks:            %11lu\\n\",\n\t\t\tnr_softirq_safe);\n\tseq_printf(m, \" softirq-unsafe locks:          %11lu\\n\",\n\t\t\tnr_softirq_unsafe);\n\tseq_printf(m, \" irq-safe locks:                %11lu\\n\",\n\t\t\tnr_irq_safe);\n\tseq_printf(m, \" irq-unsafe locks:              %11lu\\n\",\n\t\t\tnr_irq_unsafe);\n\n\tseq_printf(m, \" hardirq-read-safe locks:       %11lu\\n\",\n\t\t\tnr_hardirq_read_safe);\n\tseq_printf(m, \" hardirq-read-unsafe locks:     %11lu\\n\",\n\t\t\tnr_hardirq_read_unsafe);\n\tseq_printf(m, \" softirq-read-safe locks:       %11lu\\n\",\n\t\t\tnr_softirq_read_safe);\n\tseq_printf(m, \" softirq-read-unsafe locks:     %11lu\\n\",\n\t\t\tnr_softirq_read_unsafe);\n\tseq_printf(m, \" irq-read-safe locks:           %11lu\\n\",\n\t\t\tnr_irq_read_safe);\n\tseq_printf(m, \" irq-read-unsafe locks:         %11lu\\n\",\n\t\t\tnr_irq_read_unsafe);\n\n\tseq_printf(m, \" uncategorized locks:           %11lu\\n\",\n\t\t\tnr_uncategorized);\n\tseq_printf(m, \" unused locks:                  %11lu\\n\",\n\t\t\tnr_unused);\n\tseq_printf(m, \" max locking depth:             %11u\\n\",\n\t\t\tmax_lockdep_depth);\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" max bfs queue depth:           %11u\\n\",\n\t\t\tmax_bfs_queue_depth);\n#endif\n\tlockdep_stats_debug_show(m);\n\tseq_printf(m, \" debug_locks:                   %11u\\n\",\n\t\t\tdebug_locks);\n\n\t/*\n\t * Zapped classes and lockdep data buffers reuse statistics.\n\t */\n\tseq_puts(m, \"\\n\");\n\tseq_printf(m, \" zapped classes:                %11lu\\n\",\n\t\t\tnr_zapped_classes);\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" zapped lock chains:            %11lu\\n\",\n\t\t\tnr_zapped_lock_chains);\n\tseq_printf(m, \" large chain blocks:            %11u\\n\",\n\t\t\tnr_large_chain_blocks);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "lockdep_stats_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "172-208",
    "snippet": "static void lockdep_stats_debug_show(struct seq_file *m)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tunsigned long long hi1 = debug_atomic_read(hardirqs_on_events),\n\t\t\t   hi2 = debug_atomic_read(hardirqs_off_events),\n\t\t\t   hr1 = debug_atomic_read(redundant_hardirqs_on),\n\t\t\t   hr2 = debug_atomic_read(redundant_hardirqs_off),\n\t\t\t   si1 = debug_atomic_read(softirqs_on_events),\n\t\t\t   si2 = debug_atomic_read(softirqs_off_events),\n\t\t\t   sr1 = debug_atomic_read(redundant_softirqs_on),\n\t\t\t   sr2 = debug_atomic_read(redundant_softirqs_off);\n\n\tseq_printf(m, \" chain lookup misses:           %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_misses));\n\tseq_printf(m, \" chain lookup hits:             %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_hits));\n\tseq_printf(m, \" cyclic checks:                 %11llu\\n\",\n\t\tdebug_atomic_read(nr_cyclic_checks));\n\tseq_printf(m, \" redundant checks:              %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant_checks));\n\tseq_printf(m, \" redundant links:               %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant));\n\tseq_printf(m, \" find-mask forwards checks:     %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_forwards_checks));\n\tseq_printf(m, \" find-mask backwards checks:    %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_backwards_checks));\n\n\tseq_printf(m, \" hardirq on events:             %11llu\\n\", hi1);\n\tseq_printf(m, \" hardirq off events:            %11llu\\n\", hi2);\n\tseq_printf(m, \" redundant hardirq ons:         %11llu\\n\", hr1);\n\tseq_printf(m, \" redundant hardirq offs:        %11llu\\n\", hr2);\n\tseq_printf(m, \" softirq on events:             %11llu\\n\", si1);\n\tseq_printf(m, \" softirq off events:            %11llu\\n\", si2);\n\tseq_printf(m, \" redundant softirq ons:         %11llu\\n\", sr1);\n\tseq_printf(m, \" redundant softirq offs:        %11llu\\n\", sr2);\n#endif\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" redundant softirq offs:        %11llu\\n\"",
            "sr2"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "nr_find_usage_backwards_checks"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "nr_find_usage_forwards_checks"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "nr_redundant"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "nr_redundant_checks"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "nr_cyclic_checks"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "chain_lookup_hits"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "chain_lookup_misses"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "redundant_softirqs_off"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "redundant_softirqs_on"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "softirqs_off_events"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "softirqs_on_events"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "redundant_hardirqs_off"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "redundant_hardirqs_on"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "hardirqs_off_events"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_atomic_read",
          "args": [
            "hardirqs_on_events"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void lockdep_stats_debug_show(struct seq_file *m)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tunsigned long long hi1 = debug_atomic_read(hardirqs_on_events),\n\t\t\t   hi2 = debug_atomic_read(hardirqs_off_events),\n\t\t\t   hr1 = debug_atomic_read(redundant_hardirqs_on),\n\t\t\t   hr2 = debug_atomic_read(redundant_hardirqs_off),\n\t\t\t   si1 = debug_atomic_read(softirqs_on_events),\n\t\t\t   si2 = debug_atomic_read(softirqs_off_events),\n\t\t\t   sr1 = debug_atomic_read(redundant_softirqs_on),\n\t\t\t   sr2 = debug_atomic_read(redundant_softirqs_off);\n\n\tseq_printf(m, \" chain lookup misses:           %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_misses));\n\tseq_printf(m, \" chain lookup hits:             %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_hits));\n\tseq_printf(m, \" cyclic checks:                 %11llu\\n\",\n\t\tdebug_atomic_read(nr_cyclic_checks));\n\tseq_printf(m, \" redundant checks:              %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant_checks));\n\tseq_printf(m, \" redundant links:               %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant));\n\tseq_printf(m, \" find-mask forwards checks:     %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_forwards_checks));\n\tseq_printf(m, \" find-mask backwards checks:    %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_backwards_checks));\n\n\tseq_printf(m, \" hardirq on events:             %11llu\\n\", hi1);\n\tseq_printf(m, \" hardirq off events:            %11llu\\n\", hi2);\n\tseq_printf(m, \" redundant hardirq ons:         %11llu\\n\", hr1);\n\tseq_printf(m, \" redundant hardirq offs:        %11llu\\n\", hr2);\n\tseq_printf(m, \" softirq on events:             %11llu\\n\", si1);\n\tseq_printf(m, \" softirq off events:            %11llu\\n\", si2);\n\tseq_printf(m, \" redundant softirq ons:         %11llu\\n\", sr1);\n\tseq_printf(m, \" redundant softirq offs:        %11llu\\n\", sr2);\n#endif\n}"
  },
  {
    "function_name": "lc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "128-162",
    "snippet": "static int lc_show(struct seq_file *m, void *v)\n{\n\tstruct lock_chain *chain = v;\n\tstruct lock_class *class;\n\tint i;\n\tstatic const char * const irq_strs[] = {\n\t\t[0]\t\t\t     = \"0\",\n\t\t[LOCK_CHAIN_HARDIRQ_CONTEXT] = \"hardirq\",\n\t\t[LOCK_CHAIN_SOFTIRQ_CONTEXT] = \"softirq\",\n\t\t[LOCK_CHAIN_SOFTIRQ_CONTEXT|\n\t\t LOCK_CHAIN_HARDIRQ_CONTEXT] = \"hardirq|softirq\",\n\t};\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tif (!nr_free_chain_hlocks)\n\t\t\tseq_printf(m, \"(buggered) \");\n\t\tseq_printf(m, \"all lock chains:\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"irq_context: %s\\n\", irq_strs[chain->irq_context]);\n\n\tfor (i = 0; i < chain->depth; i++) {\n\t\tclass = lock_chain_get_class(chain, i);\n\t\tif (!class->key)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"[%p] \", class->key);\n\t\tprint_name(m, class);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_name",
          "args": [
            "m",
            "class"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "print_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "41-56",
          "snippet": "static void print_name(struct seq_file *m, struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name = class->name;\n\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tseq_printf(m, \"%s\", name);\n\t} else{\n\t\tseq_printf(m, \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tseq_printf(m, \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tseq_printf(m, \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void print_name(struct seq_file *m, struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name = class->name;\n\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tseq_printf(m, \"%s\", name);\n\t} else{\n\t\tseq_printf(m, \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tseq_printf(m, \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tseq_printf(m, \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"[%p] \"",
            "class->key"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_chain_get_class",
          "args": [
            "chain",
            "i"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "lock_chain_get_class",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3460-3466",
          "snippet": "struct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)\n{\n\tu16 chain_hlock = chain_hlocks[chain->base + i];\n\tunsigned int class_idx = chain_hlock_class_idx(chain_hlock);\n\n\treturn lock_classes + class_idx - 1;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class lock_classes[MAX_LOCKDEP_KEYS];",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstruct lock_class lock_classes[MAX_LOCKDEP_KEYS];\nstatic noinstr struct;\n\nstruct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)\n{\n\tu16 chain_hlock = chain_hlocks[chain->base + i];\n\tunsigned int class_idx = chain_hlock_class_idx(chain_hlock);\n\n\treturn lock_classes + class_idx - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic int lc_show(struct seq_file *m, void *v)\n{\n\tstruct lock_chain *chain = v;\n\tstruct lock_class *class;\n\tint i;\n\tstatic const char * const irq_strs[] = {\n\t\t[0]\t\t\t     = \"0\",\n\t\t[LOCK_CHAIN_HARDIRQ_CONTEXT] = \"hardirq\",\n\t\t[LOCK_CHAIN_SOFTIRQ_CONTEXT] = \"softirq\",\n\t\t[LOCK_CHAIN_SOFTIRQ_CONTEXT|\n\t\t LOCK_CHAIN_HARDIRQ_CONTEXT] = \"hardirq|softirq\",\n\t};\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tif (!nr_free_chain_hlocks)\n\t\t\tseq_printf(m, \"(buggered) \");\n\t\tseq_printf(m, \"all lock chains:\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"irq_context: %s\\n\", irq_strs[chain->irq_context]);\n\n\tfor (i = 0; i < chain->depth; i++) {\n\t\tclass = lock_chain_get_class(chain, i);\n\t\tif (!class->key)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"[%p] \", class->key);\n\t\tprint_name(m, class);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lc_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "124-126",
    "snippet": "static void lc_stop(struct seq_file *m, void *v)\n{\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void lc_stop(struct seq_file *m, void *v)\n{\n}"
  },
  {
    "function_name": "lc_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "118-122",
    "snippet": "static void *lc_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t*pos = lockdep_next_lockchain(*pos - 1) + 1;\n\treturn lc_start(m, pos);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lc_start",
          "args": [
            "m",
            "pos"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "lc_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "107-116",
          "snippet": "static void *lc_start(struct seq_file *m, loff_t *pos)\n{\n\tif (*pos < 0)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn lock_chains + (*pos - 1);\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void *lc_start(struct seq_file *m, loff_t *pos)\n{\n\tif (*pos < 0)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn lock_chains + (*pos - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_next_lockchain",
          "args": [
            "*pos - 1"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_next_lockchain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "3597-3601",
          "snippet": "long lockdep_next_lockchain(long i)\n{\n\ti = find_next_bit(lock_chains_in_use, ARRAY_SIZE(lock_chains), i + 1);\n\treturn i < ARRAY_SIZE(lock_chains) ? i : -2;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nlong lockdep_next_lockchain(long i)\n{\n\ti = find_next_bit(lock_chains_in_use, ARRAY_SIZE(lock_chains), i + 1);\n\treturn i < ARRAY_SIZE(lock_chains) ? i : -2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void *lc_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t*pos = lockdep_next_lockchain(*pos - 1) + 1;\n\treturn lc_start(m, pos);\n}"
  },
  {
    "function_name": "lc_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "107-116",
    "snippet": "static void *lc_start(struct seq_file *m, loff_t *pos)\n{\n\tif (*pos < 0)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn lock_chains + (*pos - 1);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void *lc_start(struct seq_file *m, loff_t *pos)\n{\n\tif (*pos < 0)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn lock_chains + (*pos - 1);\n}"
  },
  {
    "function_name": "l_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "58-97",
    "snippet": "static int l_show(struct seq_file *m, void *v)\n{\n\tstruct lock_class *class = list_entry(v, struct lock_class, lock_entry);\n\tstruct lock_list *entry;\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tif (v == &all_lock_classes) {\n\t\tseq_printf(m, \"all lock classes:\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"%p\", class->key);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tseq_printf(m, \" OPS:%8ld\", debug_class_ops_read(class));\n#endif\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tseq_printf(m, \" FD:%5ld\", lockdep_count_forward_deps(class));\n\t\tseq_printf(m, \" BD:%5ld\", lockdep_count_backward_deps(class));\n\n\t\tget_usage_chars(class, usage);\n\t\tseq_printf(m, \" %s\", usage);\n\t}\n\n\tseq_printf(m, \": \");\n\tprint_name(m, class);\n\tseq_puts(m, \"\\n\");\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tlist_for_each_entry(entry, &class->locks_after, entry) {\n\t\t\tif (entry->distance == 1) {\n\t\t\t\tseq_printf(m, \" -> [%p] \", entry->class->key);\n\t\t\t\tprint_name(m, entry->class);\n\t\t\t\tseq_puts(m, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_name",
          "args": [
            "m",
            "entry->class"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "print_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
          "lines": "41-56",
          "snippet": "static void print_name(struct seq_file *m, struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name = class->name;\n\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tseq_printf(m, \"%s\", name);\n\t} else{\n\t\tseq_printf(m, \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tseq_printf(m, \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tseq_printf(m, \"/%d\", class->subclass);\n\t}\n}",
          "includes": [
            "#include \"lockdep_internals.h\"",
            "#include <asm/div64.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void print_name(struct seq_file *m, struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name = class->name;\n\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tseq_printf(m, \"%s\", name);\n\t} else{\n\t\tseq_printf(m, \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tseq_printf(m, \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tseq_printf(m, \"/%d\", class->subclass);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" -> [%p] \"",
            "entry->class->key"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&class->locks_after",
            "entry"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PROVE_LOCKING"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_usage_chars",
          "args": [
            "class",
            "usage"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "get_usage_chars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "670-681",
          "snippet": "void get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\n{\n\tint i = 0;\n\n#define LOCKDEP_STATE(__STATE) \t\t\t\t\t\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);\t\\\n\tusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\n#include \"lockdep_states.h\"\n#undef LOCKDEP_STATE\n\n\tusage[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_count_backward_deps",
          "args": [
            "class"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_count_backward_deps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_internals.h",
          "lines": "168-172",
          "snippet": "static inline unsigned long\nlockdep_count_backward_deps(struct lock_class *class)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n\nstatic inline unsigned long\nlockdep_count_backward_deps(struct lock_class *class)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_count_forward_deps",
          "args": [
            "class"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_count_forward_deps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_internals.h",
          "lines": "163-167",
          "snippet": "static inline unsigned long\nlockdep_count_forward_deps(struct lock_class *class)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n\nstatic inline unsigned long\nlockdep_count_forward_deps(struct lock_class *class)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PROVE_LOCKING"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_class_ops_read",
          "args": [
            "class"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "debug_class_ops_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_internals.h",
          "lines": "242-251",
          "snippet": "static inline unsigned long debug_class_ops_read(struct lock_class *class)\n{\n\tint idx, cpu;\n\tunsigned long ops = 0;\n\n\tidx = class - lock_classes;\n\tfor_each_possible_cpu(cpu)\n\t\tops += per_cpu(lockdep_stats.lock_class_ops[idx], cpu);\n\treturn ops;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n\nstatic inline unsigned long debug_class_ops_read(struct lock_class *class)\n{\n\tint idx, cpu;\n\tunsigned long ops = 0;\n\n\tidx = class - lock_classes;\n\tfor_each_possible_cpu(cpu)\n\t\tops += per_cpu(lockdep_stats.lock_class_ops[idx], cpu);\n\treturn ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structlock_class",
            "lock_entry"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic int l_show(struct seq_file *m, void *v)\n{\n\tstruct lock_class *class = list_entry(v, struct lock_class, lock_entry);\n\tstruct lock_list *entry;\n\tchar usage[LOCK_USAGE_CHARS];\n\n\tif (v == &all_lock_classes) {\n\t\tseq_printf(m, \"all lock classes:\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"%p\", class->key);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tseq_printf(m, \" OPS:%8ld\", debug_class_ops_read(class));\n#endif\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tseq_printf(m, \" FD:%5ld\", lockdep_count_forward_deps(class));\n\t\tseq_printf(m, \" BD:%5ld\", lockdep_count_backward_deps(class));\n\n\t\tget_usage_chars(class, usage);\n\t\tseq_printf(m, \" %s\", usage);\n\t}\n\n\tseq_printf(m, \": \");\n\tprint_name(m, class);\n\tseq_puts(m, \"\\n\");\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tlist_for_each_entry(entry, &class->locks_after, entry) {\n\t\t\tif (entry->distance == 1) {\n\t\t\t\tseq_printf(m, \" -> [%p] \", entry->class->key);\n\t\t\t\tprint_name(m, entry->class);\n\t\t\t\tseq_puts(m, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "41-56",
    "snippet": "static void print_name(struct seq_file *m, struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name = class->name;\n\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tseq_printf(m, \"%s\", name);\n\t} else{\n\t\tseq_printf(m, \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tseq_printf(m, \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tseq_printf(m, \"/%d\", class->subclass);\n\t}\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"/%d\"",
            "class->subclass"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_key_name",
          "args": [
            "class->key",
            "str"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "__get_key_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "634-637",
          "snippet": "const char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nconst char *__get_key_name(const struct lockdep_subclass_key *key, char *str)\n{\n\treturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void print_name(struct seq_file *m, struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name = class->name;\n\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tseq_printf(m, \"%s\", name);\n\t} else{\n\t\tseq_printf(m, \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tseq_printf(m, \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tseq_printf(m, \"/%d\", class->subclass);\n\t}\n}"
  },
  {
    "function_name": "l_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "37-39",
    "snippet": "static void l_stop(struct seq_file *m, void *v)\n{\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void l_stop(struct seq_file *m, void *v)\n{\n}"
  },
  {
    "function_name": "l_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "32-35",
    "snippet": "static void *l_start(struct seq_file *m, loff_t *pos)\n{\n\treturn seq_list_start_head(&all_lock_classes, *pos);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start_head",
          "args": [
            "&all_lock_classes",
            "*pos"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void *l_start(struct seq_file *m, loff_t *pos)\n{\n\treturn seq_list_start_head(&all_lock_classes, *pos);\n}"
  },
  {
    "function_name": "l_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep_proc.c",
    "lines": "27-30",
    "snippet": "static void *l_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &all_lock_classes, pos);\n}",
    "includes": [
      "#include \"lockdep_internals.h\"",
      "#include <asm/div64.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sort.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&all_lock_classes",
            "pos"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockdep_internals.h\"\n#include <asm/div64.h>\n#include <linux/uaccess.h>\n#include <linux/sort.h>\n#include <linux/vmalloc.h>\n#include <linux/debug_locks.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n\nstatic void *l_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &all_lock_classes, pos);\n}"
  }
]