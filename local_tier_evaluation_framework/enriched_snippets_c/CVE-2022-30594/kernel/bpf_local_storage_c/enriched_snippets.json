[
  {
    "function_name": "bpf_local_storage_map_check_btf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "616-631",
    "snippet": "int bpf_local_storage_map_check_btf(const struct bpf_map *map,\n\t\t\t\t    const struct btf *btf,\n\t\t\t\t    const struct btf_type *key_type,\n\t\t\t\t    const struct btf_type *value_type)\n{\n\tu32 int_data;\n\n\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)\n\t\treturn -EINVAL;\n\n\tint_data = *(u32 *)(key_type + 1);\n\tif (BTF_INT_BITS(int_data) != 32 || BTF_INT_OFFSET(int_data))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "key_type->info"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nint bpf_local_storage_map_check_btf(const struct bpf_map *map,\n\t\t\t\t    const struct btf *btf,\n\t\t\t\t    const struct btf_type *key_type,\n\t\t\t\t    const struct btf_type *value_type)\n{\n\tu32 int_data;\n\n\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)\n\t\treturn -EINVAL;\n\n\tint_data = *(u32 *)(key_type + 1);\n\tif (BTF_INT_BITS(int_data) != 32 || BTF_INT_OFFSET(int_data))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_local_storage_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "582-614",
    "snippet": "struct bpf_local_storage_map *bpf_local_storage_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_local_storage_map *smap;\n\tunsigned int i;\n\tu32 nbuckets;\n\n\tsmap = kzalloc(sizeof(*smap), GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!smap)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbpf_map_init_from_attr(&smap->map, attr);\n\n\tnbuckets = roundup_pow_of_two(num_possible_cpus());\n\t/* Use at least 2 buckets, select_bucket() is undefined behavior with 1 bucket */\n\tnbuckets = max_t(u32, 2, nbuckets);\n\tsmap->bucket_log = ilog2(nbuckets);\n\n\tsmap->buckets = kvcalloc(sizeof(*smap->buckets), nbuckets,\n\t\t\t\t GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!smap->buckets) {\n\t\tkfree(smap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < nbuckets; i++) {\n\t\tINIT_HLIST_HEAD(&smap->buckets[i].list);\n\t\traw_spin_lock_init(&smap->buckets[i].lock);\n\t}\n\n\tsmap->elem_size =\n\t\tsizeof(struct bpf_local_storage_elem) + attr->value_size;\n\n\treturn smap;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&smap->buckets[i].lock"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&smap->buckets[i].list"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smap"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "sizeof(*smap->buckets)",
            "nbuckets",
            "GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nbuckets"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u32",
            "2",
            "nbuckets"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1831-1865",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "num_possible_cpus()"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&smap->map",
            "attr"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*smap)",
            "GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_map *bpf_local_storage_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_local_storage_map *smap;\n\tunsigned int i;\n\tu32 nbuckets;\n\n\tsmap = kzalloc(sizeof(*smap), GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!smap)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbpf_map_init_from_attr(&smap->map, attr);\n\n\tnbuckets = roundup_pow_of_two(num_possible_cpus());\n\t/* Use at least 2 buckets, select_bucket() is undefined behavior with 1 bucket */\n\tnbuckets = max_t(u32, 2, nbuckets);\n\tsmap->bucket_log = ilog2(nbuckets);\n\n\tsmap->buckets = kvcalloc(sizeof(*smap->buckets), nbuckets,\n\t\t\t\t GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!smap->buckets) {\n\t\tkfree(smap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < nbuckets; i++) {\n\t\tINIT_HLIST_HEAD(&smap->buckets[i].list);\n\t\traw_spin_lock_init(&smap->buckets[i].lock);\n\t}\n\n\tsmap->elem_size =\n\t\tsizeof(struct bpf_local_storage_elem) + attr->value_size;\n\n\treturn smap;\n}"
  },
  {
    "function_name": "bpf_local_storage_map_alloc_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "563-580",
    "snippet": "int bpf_local_storage_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->map_flags & ~BPF_LOCAL_STORAGE_CREATE_FLAG_MASK ||\n\t    !(attr->map_flags & BPF_F_NO_PREALLOC) ||\n\t    attr->max_entries ||\n\t    attr->key_size != sizeof(int) || !attr->value_size ||\n\t    /* Enforce BTF for userspace sk dumping */\n\t    !attr->btf_key_type_id || !attr->btf_value_type_id)\n\t\treturn -EINVAL;\n\n\tif (!bpf_capable())\n\t\treturn -EPERM;\n\n\tif (attr->value_size > BPF_LOCAL_STORAGE_MAX_VALUE_SIZE)\n\t\treturn -E2BIG;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [
      "#define BPF_LOCAL_STORAGE_CREATE_FLAG_MASK (BPF_F_NO_PREALLOC | BPF_F_CLONE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\n#define BPF_LOCAL_STORAGE_CREATE_FLAG_MASK (BPF_F_NO_PREALLOC | BPF_F_CLONE)\n\nint bpf_local_storage_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->map_flags & ~BPF_LOCAL_STORAGE_CREATE_FLAG_MASK ||\n\t    !(attr->map_flags & BPF_F_NO_PREALLOC) ||\n\t    attr->max_entries ||\n\t    attr->key_size != sizeof(int) || !attr->value_size ||\n\t    /* Enforce BTF for userspace sk dumping */\n\t    !attr->btf_key_type_id || !attr->btf_value_type_id)\n\t\treturn -EINVAL;\n\n\tif (!bpf_capable())\n\t\treturn -EPERM;\n\n\tif (attr->value_size > BPF_LOCAL_STORAGE_MAX_VALUE_SIZE)\n\t\treturn -E2BIG;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_local_storage_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "501-561",
    "snippet": "void bpf_local_storage_map_free(struct bpf_local_storage_map *smap,\n\t\t\t\tint __percpu *busy_counter)\n{\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned int i;\n\n\t/* Note that this map might be concurrently cloned from\n\t * bpf_sk_storage_clone. Wait for any existing bpf_sk_storage_clone\n\t * RCU read section to finish before proceeding. New RCU\n\t * read sections should be prevented via bpf_map_inc_not_zero.\n\t */\n\tsynchronize_rcu();\n\n\t/* bpf prog and the userspace can no longer access this map\n\t * now.  No new selem (of this map) can be added\n\t * to the owner->storage or to the map bucket's list.\n\t *\n\t * The elem of this map can be cleaned up here\n\t * or when the storage is freed e.g.\n\t * by bpf_sk_storage_free() during __sk_destruct().\n\t */\n\tfor (i = 0; i < (1U << smap->bucket_log); i++) {\n\t\tb = &smap->buckets[i];\n\n\t\trcu_read_lock();\n\t\t/* No one is adding to b->list now */\n\t\twhile ((selem = hlist_entry_safe(\n\t\t\t\trcu_dereference_raw(hlist_first_rcu(&b->list)),\n\t\t\t\tstruct bpf_local_storage_elem, map_node))) {\n\t\t\tif (busy_counter) {\n\t\t\t\tmigrate_disable();\n\t\t\t\t__this_cpu_inc(*busy_counter);\n\t\t\t}\n\t\t\tbpf_selem_unlink(selem);\n\t\t\tif (busy_counter) {\n\t\t\t\t__this_cpu_dec(*busy_counter);\n\t\t\t\tmigrate_enable();\n\t\t\t}\n\t\t\tcond_resched_rcu();\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* While freeing the storage we may still need to access the map.\n\t *\n\t * e.g. when bpf_sk_storage_free() has unlinked selem from the map\n\t * which then made the above while((selem = ...)) loop\n\t * exit immediately.\n\t *\n\t * However, while freeing the storage one still needs to access the\n\t * smap->elem_size to do the uncharging in\n\t * bpf_selem_unlink_storage_nolock().\n\t *\n\t * Hence, wait another rcu grace period for the storage to be freed.\n\t */\n\tsynchronize_rcu();\n\n\tkvfree(smap->buckets);\n\tkfree(smap);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smap"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "smap->buckets"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_rcu",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_enable",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2178-2206",
          "snippet": "void migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "*busy_counter"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_selem_unlink",
          "args": [
            "selem"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "217-225",
          "snippet": "void bpf_selem_unlink(struct bpf_local_storage_elem *selem)\n{\n\t/* Always unlink from map before unlinking from local_storage\n\t * because selem will be freed after successfully unlinked from\n\t * the local_storage.\n\t */\n\tbpf_selem_unlink_map(selem);\n\t__bpf_selem_unlink_storage(selem);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_unlink(struct bpf_local_storage_elem *selem)\n{\n\t/* Always unlink from map before unlinking from local_storage\n\t * because selem will be freed after successfully unlinked from\n\t * the local_storage.\n\t */\n\tbpf_selem_unlink_map(selem);\n\t__bpf_selem_unlink_storage(selem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "*busy_counter"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_disable",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2162-2175",
          "snippet": "void migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry_safe",
          "args": [
            "rcu_dereference_raw(hlist_first_rcu(&b->list))",
            "structbpf_local_storage_elem",
            "map_node"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "hlist_first_rcu(&b->list)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_first_rcu",
          "args": [
            "&b->list"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_local_storage_map_free(struct bpf_local_storage_map *smap,\n\t\t\t\tint __percpu *busy_counter)\n{\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned int i;\n\n\t/* Note that this map might be concurrently cloned from\n\t * bpf_sk_storage_clone. Wait for any existing bpf_sk_storage_clone\n\t * RCU read section to finish before proceeding. New RCU\n\t * read sections should be prevented via bpf_map_inc_not_zero.\n\t */\n\tsynchronize_rcu();\n\n\t/* bpf prog and the userspace can no longer access this map\n\t * now.  No new selem (of this map) can be added\n\t * to the owner->storage or to the map bucket's list.\n\t *\n\t * The elem of this map can be cleaned up here\n\t * or when the storage is freed e.g.\n\t * by bpf_sk_storage_free() during __sk_destruct().\n\t */\n\tfor (i = 0; i < (1U << smap->bucket_log); i++) {\n\t\tb = &smap->buckets[i];\n\n\t\trcu_read_lock();\n\t\t/* No one is adding to b->list now */\n\t\twhile ((selem = hlist_entry_safe(\n\t\t\t\trcu_dereference_raw(hlist_first_rcu(&b->list)),\n\t\t\t\tstruct bpf_local_storage_elem, map_node))) {\n\t\t\tif (busy_counter) {\n\t\t\t\tmigrate_disable();\n\t\t\t\t__this_cpu_inc(*busy_counter);\n\t\t\t}\n\t\t\tbpf_selem_unlink(selem);\n\t\t\tif (busy_counter) {\n\t\t\t\t__this_cpu_dec(*busy_counter);\n\t\t\t\tmigrate_enable();\n\t\t\t}\n\t\t\tcond_resched_rcu();\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* While freeing the storage we may still need to access the map.\n\t *\n\t * e.g. when bpf_sk_storage_free() has unlinked selem from the map\n\t * which then made the above while((selem = ...)) loop\n\t * exit immediately.\n\t *\n\t * However, while freeing the storage one still needs to access the\n\t * smap->elem_size to do the uncharging in\n\t * bpf_selem_unlink_storage_nolock().\n\t *\n\t * Hence, wait another rcu grace period for the storage to be freed.\n\t */\n\tsynchronize_rcu();\n\n\tkvfree(smap->buckets);\n\tkfree(smap);\n}"
  },
  {
    "function_name": "bpf_local_storage_cache_idx_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "493-499",
    "snippet": "void bpf_local_storage_cache_idx_free(struct bpf_local_storage_cache *cache,\n\t\t\t\t      u16 idx)\n{\n\tspin_lock(&cache->idx_lock);\n\tcache->idx_usage_counts[idx]--;\n\tspin_unlock(&cache->idx_lock);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cache->idx_lock"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cache->idx_lock"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_local_storage_cache_idx_free(struct bpf_local_storage_cache *cache,\n\t\t\t\t      u16 idx)\n{\n\tspin_lock(&cache->idx_lock);\n\tcache->idx_usage_counts[idx]--;\n\tspin_unlock(&cache->idx_lock);\n}"
  },
  {
    "function_name": "bpf_local_storage_cache_idx_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "469-491",
    "snippet": "u16 bpf_local_storage_cache_idx_get(struct bpf_local_storage_cache *cache)\n{\n\tu64 min_usage = U64_MAX;\n\tu16 i, res = 0;\n\n\tspin_lock(&cache->idx_lock);\n\n\tfor (i = 0; i < BPF_LOCAL_STORAGE_CACHE_SIZE; i++) {\n\t\tif (cache->idx_usage_counts[i] < min_usage) {\n\t\t\tmin_usage = cache->idx_usage_counts[i];\n\t\t\tres = i;\n\n\t\t\t/* Found a free cache_idx */\n\t\t\tif (!min_usage)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcache->idx_usage_counts[res]++;\n\n\tspin_unlock(&cache->idx_lock);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cache->idx_lock"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cache->idx_lock"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nu16 bpf_local_storage_cache_idx_get(struct bpf_local_storage_cache *cache)\n{\n\tu64 min_usage = U64_MAX;\n\tu16 i, res = 0;\n\n\tspin_lock(&cache->idx_lock);\n\n\tfor (i = 0; i < BPF_LOCAL_STORAGE_CACHE_SIZE; i++) {\n\t\tif (cache->idx_usage_counts[i] < min_usage) {\n\t\t\tmin_usage = cache->idx_usage_counts[i];\n\t\t\tres = i;\n\n\t\t\t/* Found a free cache_idx */\n\t\t\tif (!min_usage)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcache->idx_usage_counts[res]++;\n\n\tspin_unlock(&cache->idx_lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "bpf_local_storage_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "351-467",
    "snippet": "struct bpf_local_storage_data *\nbpf_local_storage_update(void *owner, struct bpf_local_storage_map *smap,\n\t\t\t void *value, u64 map_flags)\n{\n\tstruct bpf_local_storage_data *old_sdata = NULL;\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage *local_storage;\n\tunsigned long flags;\n\tint err;\n\n\t/* BPF_EXIST and BPF_NOEXIST cannot be both set */\n\tif (unlikely((map_flags & ~BPF_F_LOCK) > BPF_EXIST) ||\n\t    /* BPF_F_LOCK can only be used in a value with spin_lock */\n\t    unlikely((map_flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(&smap->map)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlocal_storage = rcu_dereference_check(*owner_storage(smap, owner),\n\t\t\t\t\t      bpf_rcu_lock_held());\n\tif (!local_storage || hlist_empty(&local_storage->list)) {\n\t\t/* Very first elem for the owner */\n\t\terr = check_flags(NULL, map_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tselem = bpf_selem_alloc(smap, owner, value, true);\n\t\tif (!selem)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\terr = bpf_local_storage_alloc(owner, smap, selem);\n\t\tif (err) {\n\t\t\tkfree(selem);\n\t\t\tmem_uncharge(smap, owner, smap->elem_size);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\treturn SDATA(selem);\n\t}\n\n\tif ((map_flags & BPF_F_LOCK) && !(map_flags & BPF_NOEXIST)) {\n\t\t/* Hoping to find an old_sdata to do inline update\n\t\t * such that it can avoid taking the local_storage->lock\n\t\t * and changing the lists.\n\t\t */\n\t\told_sdata =\n\t\t\tbpf_local_storage_lookup(local_storage, smap, false);\n\t\terr = check_flags(old_sdata, map_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tif (old_sdata && selem_linked_to_storage(SELEM(old_sdata))) {\n\t\t\tcopy_map_value_locked(&smap->map, old_sdata->data,\n\t\t\t\t\t      value, false);\n\t\t\treturn old_sdata;\n\t\t}\n\t}\n\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\n\t/* Recheck local_storage->list under local_storage->lock */\n\tif (unlikely(hlist_empty(&local_storage->list))) {\n\t\t/* A parallel del is happening and local_storage is going\n\t\t * away.  It has just been checked before, so very\n\t\t * unlikely.  Return instead of retry to keep things\n\t\t * simple.\n\t\t */\n\t\terr = -EAGAIN;\n\t\tgoto unlock_err;\n\t}\n\n\told_sdata = bpf_local_storage_lookup(local_storage, smap, false);\n\terr = check_flags(old_sdata, map_flags);\n\tif (err)\n\t\tgoto unlock_err;\n\n\tif (old_sdata && (map_flags & BPF_F_LOCK)) {\n\t\tcopy_map_value_locked(&smap->map, old_sdata->data, value,\n\t\t\t\t      false);\n\t\tselem = SELEM(old_sdata);\n\t\tgoto unlock;\n\t}\n\n\t/* local_storage->lock is held.  Hence, we are sure\n\t * we can unlink and uncharge the old_sdata successfully\n\t * later.  Hence, instead of charging the new selem now\n\t * and then uncharge the old selem later (which may cause\n\t * a potential but unnecessary charge failure),  avoid taking\n\t * a charge at all here (the \"!old_sdata\" check) and the\n\t * old_sdata will not be uncharged later during\n\t * bpf_selem_unlink_storage_nolock().\n\t */\n\tselem = bpf_selem_alloc(smap, owner, value, !old_sdata);\n\tif (!selem) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock_err;\n\t}\n\n\t/* First, link the new selem to the map */\n\tbpf_selem_link_map(smap, selem);\n\n\t/* Second, link (and publish) the new selem to local_storage */\n\tbpf_selem_link_storage_nolock(local_storage, selem);\n\n\t/* Third, remove old selem, SELEM(old_sdata) */\n\tif (old_sdata) {\n\t\tbpf_selem_unlink_map(SELEM(old_sdata));\n\t\tbpf_selem_unlink_storage_nolock(local_storage, SELEM(old_sdata),\n\t\t\t\t\t\tfalse);\n\t}\n\nunlock:\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\treturn SDATA(selem);\n\nunlock_err:\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&local_storage->lock",
            "flags"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_selem_unlink_storage_nolock",
          "args": [
            "local_storage",
            "SELEM(old_sdata)",
            "false"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink_storage_nolock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "107-155",
          "snippet": "bool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t     struct bpf_local_storage_elem *selem,\n\t\t\t\t     bool uncharge_mem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tbool free_local_storage;\n\tvoid *owner;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\towner = local_storage->owner;\n\n\t/* All uncharging on the owner must be done first.\n\t * The owner may be freed once the last selem is unlinked\n\t * from local_storage.\n\t */\n\tif (uncharge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\tfree_local_storage = hlist_is_singular_node(&selem->snode,\n\t\t\t\t\t\t    &local_storage->list);\n\tif (free_local_storage) {\n\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));\n\t\tlocal_storage->owner = NULL;\n\n\t\t/* After this RCU_INIT, owner may be freed and cannot be used */\n\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);\n\n\t\t/* local_storage is not freed now.  local_storage->lock is\n\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)\n\t\t * will be done by the caller.\n\t\t *\n\t\t * Although the unlock will be done under\n\t\t * rcu_read_lock(),  it is more intutivie to\n\t\t * read if the freeing of the storage is done\n\t\t * after the raw_spin_unlock_bh(&local_storage->lock).\n\t\t *\n\t\t * Hence, a \"bool free_local_storage\" is returned\n\t\t * to the caller which then calls then frees the storage after\n\t\t * all the RCU grace periods have expired.\n\t\t */\n\t}\n\thlist_del_init_rcu(&selem->snode);\n\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==\n\t    SDATA(selem))\n\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);\n\n\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_rcu);\n\treturn free_local_storage;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nbool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t     struct bpf_local_storage_elem *selem,\n\t\t\t\t     bool uncharge_mem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tbool free_local_storage;\n\tvoid *owner;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\towner = local_storage->owner;\n\n\t/* All uncharging on the owner must be done first.\n\t * The owner may be freed once the last selem is unlinked\n\t * from local_storage.\n\t */\n\tif (uncharge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\tfree_local_storage = hlist_is_singular_node(&selem->snode,\n\t\t\t\t\t\t    &local_storage->list);\n\tif (free_local_storage) {\n\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));\n\t\tlocal_storage->owner = NULL;\n\n\t\t/* After this RCU_INIT, owner may be freed and cannot be used */\n\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);\n\n\t\t/* local_storage is not freed now.  local_storage->lock is\n\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)\n\t\t * will be done by the caller.\n\t\t *\n\t\t * Although the unlock will be done under\n\t\t * rcu_read_lock(),  it is more intutivie to\n\t\t * read if the freeing of the storage is done\n\t\t * after the raw_spin_unlock_bh(&local_storage->lock).\n\t\t *\n\t\t * Hence, a \"bool free_local_storage\" is returned\n\t\t * to the caller which then calls then frees the storage after\n\t\t * all the RCU grace periods have expired.\n\t\t */\n\t}\n\thlist_del_init_rcu(&selem->snode);\n\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==\n\t    SDATA(selem))\n\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);\n\n\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_rcu);\n\treturn free_local_storage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SELEM",
          "args": [
            "old_sdata"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_selem_unlink_map",
          "args": [
            "SELEM(old_sdata)"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "187-203",
          "snippet": "void bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SELEM",
          "args": [
            "old_sdata"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_selem_link_storage_nolock",
          "args": [
            "local_storage",
            "selem"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_link_storage_nolock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "180-185",
          "snippet": "void bpf_selem_link_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t   struct bpf_local_storage_elem *selem)\n{\n\tRCU_INIT_POINTER(selem->local_storage, local_storage);\n\thlist_add_head_rcu(&selem->snode, &local_storage->list);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_link_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t   struct bpf_local_storage_elem *selem)\n{\n\tRCU_INIT_POINTER(selem->local_storage, local_storage);\n\thlist_add_head_rcu(&selem->snode, &local_storage->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_link_map",
          "args": [
            "smap",
            "selem"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_link_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "205-215",
          "snippet": "void bpf_selem_link_map(struct bpf_local_storage_map *smap,\n\t\t\tstruct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map_bucket *b = select_bucket(smap, selem);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tRCU_INIT_POINTER(SDATA(selem)->smap, smap);\n\thlist_add_head_rcu(&selem->map_node, &b->list);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_link_map(struct bpf_local_storage_map *smap,\n\t\t\tstruct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map_bucket *b = select_bucket(smap, selem);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tRCU_INIT_POINTER(SDATA(selem)->smap, smap);\n\thlist_add_head_rcu(&selem->map_node, &b->list);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_alloc",
          "args": [
            "smap",
            "owner",
            "value",
            "!old_sdata"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "64-85",
          "snippet": "struct bpf_local_storage_elem *\nbpf_selem_alloc(struct bpf_local_storage_map *smap, void *owner,\n\t\tvoid *value, bool charge_mem)\n{\n\tstruct bpf_local_storage_elem *selem;\n\n\tif (charge_mem && mem_charge(smap, owner, smap->elem_size))\n\t\treturn NULL;\n\n\tselem = bpf_map_kzalloc(&smap->map, smap->elem_size,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\tif (selem) {\n\t\tif (value)\n\t\t\tmemcpy(SDATA(selem)->data, value, smap->map.value_size);\n\t\treturn selem;\n\t}\n\n\tif (charge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_elem *\nbpf_selem_alloc(struct bpf_local_storage_map *smap, void *owner,\n\t\tvoid *value, bool charge_mem)\n{\n\tstruct bpf_local_storage_elem *selem;\n\n\tif (charge_mem && mem_charge(smap, owner, smap->elem_size))\n\t\treturn NULL;\n\n\tselem = bpf_map_kzalloc(&smap->map, smap->elem_size,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\tif (selem) {\n\t\tif (value)\n\t\t\tmemcpy(SDATA(selem)->data, value, smap->map.value_size);\n\t\treturn selem;\n\t}\n\n\tif (charge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SELEM",
          "args": [
            "old_sdata"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_map_value_locked",
          "args": [
            "&smap->map",
            "old_sdata->data",
            "value",
            "false"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "copy_map_value_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "337-351",
          "snippet": "void copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "old_sdata",
            "map_flags"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "269-281",
          "snippet": "static int check_flags(const struct bpf_local_storage_data *old_sdata,\n\t\t       u64 map_flags)\n{\n\tif (old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic int check_flags(const struct bpf_local_storage_data *old_sdata,\n\t\t       u64 map_flags)\n{\n\tif (old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_local_storage_lookup",
          "args": [
            "local_storage",
            "smap",
            "false"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_local_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "227-267",
          "snippet": "struct bpf_local_storage_data *\nbpf_local_storage_lookup(struct bpf_local_storage *local_storage,\n\t\t\t struct bpf_local_storage_map *smap,\n\t\t\t bool cacheit_lockit)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct bpf_local_storage_elem *selem;\n\n\t/* Fast path (cache hit) */\n\tsdata = rcu_dereference_check(local_storage->cache[smap->cache_idx],\n\t\t\t\t      bpf_rcu_lock_held());\n\tif (sdata && rcu_access_pointer(sdata->smap) == smap)\n\t\treturn sdata;\n\n\t/* Slow path (cache miss) */\n\thlist_for_each_entry_rcu(selem, &local_storage->list, snode,\n\t\t\t\t  rcu_read_lock_trace_held())\n\t\tif (rcu_access_pointer(SDATA(selem)->smap) == smap)\n\t\t\tbreak;\n\n\tif (!selem)\n\t\treturn NULL;\n\n\tsdata = SDATA(selem);\n\tif (cacheit_lockit) {\n\t\tunsigned long flags;\n\n\t\t/* spinlock is needed to avoid racing with the\n\t\t * parallel delete.  Otherwise, publishing an already\n\t\t * deleted sdata to the cache will become a use-after-free\n\t\t * problem in the next bpf_local_storage_lookup().\n\t\t */\n\t\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\t\tif (selem_linked_to_storage(selem))\n\t\t\trcu_assign_pointer(local_storage->cache[smap->cache_idx],\n\t\t\t\t\t   sdata);\n\t\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\t}\n\n\treturn sdata;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_data *\nbpf_local_storage_lookup(struct bpf_local_storage *local_storage,\n\t\t\t struct bpf_local_storage_map *smap,\n\t\t\t bool cacheit_lockit)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct bpf_local_storage_elem *selem;\n\n\t/* Fast path (cache hit) */\n\tsdata = rcu_dereference_check(local_storage->cache[smap->cache_idx],\n\t\t\t\t      bpf_rcu_lock_held());\n\tif (sdata && rcu_access_pointer(sdata->smap) == smap)\n\t\treturn sdata;\n\n\t/* Slow path (cache miss) */\n\thlist_for_each_entry_rcu(selem, &local_storage->list, snode,\n\t\t\t\t  rcu_read_lock_trace_held())\n\t\tif (rcu_access_pointer(SDATA(selem)->smap) == smap)\n\t\t\tbreak;\n\n\tif (!selem)\n\t\treturn NULL;\n\n\tsdata = SDATA(selem);\n\tif (cacheit_lockit) {\n\t\tunsigned long flags;\n\n\t\t/* spinlock is needed to avoid racing with the\n\t\t * parallel delete.  Otherwise, publishing an already\n\t\t * deleted sdata to the cache will become a use-after-free\n\t\t * problem in the next bpf_local_storage_lookup().\n\t\t */\n\t\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\t\tif (selem_linked_to_storage(selem))\n\t\t\trcu_assign_pointer(local_storage->cache[smap->cache_idx],\n\t\t\t\t\t   sdata);\n\t\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\t}\n\n\treturn sdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hlist_empty(&local_storage->list)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&local_storage->list"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&local_storage->lock",
            "flags"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selem_linked_to_storage",
          "args": [
            "SELEM(old_sdata)"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "selem_linked_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "54-57",
          "snippet": "static bool selem_linked_to_storage(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->snode);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic bool selem_linked_to_storage(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->snode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SELEM",
          "args": [
            "old_sdata"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_uncharge",
          "args": [
            "smap",
            "owner",
            "smap->elem_size"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "mem_uncharge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "37-44",
          "snippet": "static void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "selem"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_local_storage_alloc",
          "args": [
            "owner",
            "smap",
            "selem"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_local_storage_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "283-344",
          "snippet": "int bpf_local_storage_alloc(void *owner,\n\t\t\t    struct bpf_local_storage_map *smap,\n\t\t\t    struct bpf_local_storage_elem *first_selem)\n{\n\tstruct bpf_local_storage *prev_storage, *storage;\n\tstruct bpf_local_storage **owner_storage_ptr;\n\tint err;\n\n\terr = mem_charge(smap, owner, sizeof(*storage));\n\tif (err)\n\t\treturn err;\n\n\tstorage = bpf_map_kzalloc(&smap->map, sizeof(*storage),\n\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\tif (!storage) {\n\t\terr = -ENOMEM;\n\t\tgoto uncharge;\n\t}\n\n\tINIT_HLIST_HEAD(&storage->list);\n\traw_spin_lock_init(&storage->lock);\n\tstorage->owner = owner;\n\n\tbpf_selem_link_storage_nolock(storage, first_selem);\n\tbpf_selem_link_map(smap, first_selem);\n\n\towner_storage_ptr =\n\t\t(struct bpf_local_storage **)owner_storage(smap, owner);\n\t/* Publish storage to the owner.\n\t * Instead of using any lock of the kernel object (i.e. owner),\n\t * cmpxchg will work with any kernel object regardless what\n\t * the running context is, bh, irq...etc.\n\t *\n\t * From now on, the owner->storage pointer (e.g. sk->sk_bpf_storage)\n\t * is protected by the storage->lock.  Hence, when freeing\n\t * the owner->storage, the storage->lock must be held before\n\t * setting owner->storage ptr to NULL.\n\t */\n\tprev_storage = cmpxchg(owner_storage_ptr, NULL, storage);\n\tif (unlikely(prev_storage)) {\n\t\tbpf_selem_unlink_map(first_selem);\n\t\terr = -EAGAIN;\n\t\tgoto uncharge;\n\n\t\t/* Note that even first_selem was linked to smap's\n\t\t * bucket->list, first_selem can be freed immediately\n\t\t * (instead of kfree_rcu) because\n\t\t * bpf_local_storage_map_free() does a\n\t\t * synchronize_rcu_mult (waiting for both sleepable and\n\t\t * normal programs) before walking the bucket->list.\n\t\t * Hence, no one is accessing selem from the\n\t\t * bucket->list under rcu_read_lock().\n\t\t */\n\t}\n\n\treturn 0;\n\nuncharge:\n\tkfree(storage);\n\tmem_uncharge(smap, owner, sizeof(*storage));\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nint bpf_local_storage_alloc(void *owner,\n\t\t\t    struct bpf_local_storage_map *smap,\n\t\t\t    struct bpf_local_storage_elem *first_selem)\n{\n\tstruct bpf_local_storage *prev_storage, *storage;\n\tstruct bpf_local_storage **owner_storage_ptr;\n\tint err;\n\n\terr = mem_charge(smap, owner, sizeof(*storage));\n\tif (err)\n\t\treturn err;\n\n\tstorage = bpf_map_kzalloc(&smap->map, sizeof(*storage),\n\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\tif (!storage) {\n\t\terr = -ENOMEM;\n\t\tgoto uncharge;\n\t}\n\n\tINIT_HLIST_HEAD(&storage->list);\n\traw_spin_lock_init(&storage->lock);\n\tstorage->owner = owner;\n\n\tbpf_selem_link_storage_nolock(storage, first_selem);\n\tbpf_selem_link_map(smap, first_selem);\n\n\towner_storage_ptr =\n\t\t(struct bpf_local_storage **)owner_storage(smap, owner);\n\t/* Publish storage to the owner.\n\t * Instead of using any lock of the kernel object (i.e. owner),\n\t * cmpxchg will work with any kernel object regardless what\n\t * the running context is, bh, irq...etc.\n\t *\n\t * From now on, the owner->storage pointer (e.g. sk->sk_bpf_storage)\n\t * is protected by the storage->lock.  Hence, when freeing\n\t * the owner->storage, the storage->lock must be held before\n\t * setting owner->storage ptr to NULL.\n\t */\n\tprev_storage = cmpxchg(owner_storage_ptr, NULL, storage);\n\tif (unlikely(prev_storage)) {\n\t\tbpf_selem_unlink_map(first_selem);\n\t\terr = -EAGAIN;\n\t\tgoto uncharge;\n\n\t\t/* Note that even first_selem was linked to smap's\n\t\t * bucket->list, first_selem can be freed immediately\n\t\t * (instead of kfree_rcu) because\n\t\t * bpf_local_storage_map_free() does a\n\t\t * synchronize_rcu_mult (waiting for both sleepable and\n\t\t * normal programs) before walking the bucket->list.\n\t\t * Hence, no one is accessing selem from the\n\t\t * bucket->list under rcu_read_lock().\n\t\t */\n\t}\n\n\treturn 0;\n\nuncharge:\n\tkfree(storage);\n\tmem_uncharge(smap, owner, sizeof(*storage));\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&local_storage->list"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "*owner_storage(smap, owner)",
            "bpf_rcu_lock_held()"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_rcu_lock_held",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owner_storage",
          "args": [
            "smap",
            "owner"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "owner_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "46-52",
          "snippet": "static struct bpf_local_storage __rcu **\nowner_storage(struct bpf_local_storage_map *smap, void *owner)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\treturn map->ops->map_owner_storage_ptr(owner);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic struct bpf_local_storage __rcu **\nowner_storage(struct bpf_local_storage_map *smap, void *owner)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\treturn map->ops->map_owner_storage_ptr(owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(map_flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(&smap->map)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "&smap->map"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(map_flags & ~BPF_F_LOCK) > BPF_EXIST"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_data *\nbpf_local_storage_update(void *owner, struct bpf_local_storage_map *smap,\n\t\t\t void *value, u64 map_flags)\n{\n\tstruct bpf_local_storage_data *old_sdata = NULL;\n\tstruct bpf_local_storage_elem *selem;\n\tstruct bpf_local_storage *local_storage;\n\tunsigned long flags;\n\tint err;\n\n\t/* BPF_EXIST and BPF_NOEXIST cannot be both set */\n\tif (unlikely((map_flags & ~BPF_F_LOCK) > BPF_EXIST) ||\n\t    /* BPF_F_LOCK can only be used in a value with spin_lock */\n\t    unlikely((map_flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(&smap->map)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlocal_storage = rcu_dereference_check(*owner_storage(smap, owner),\n\t\t\t\t\t      bpf_rcu_lock_held());\n\tif (!local_storage || hlist_empty(&local_storage->list)) {\n\t\t/* Very first elem for the owner */\n\t\terr = check_flags(NULL, map_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tselem = bpf_selem_alloc(smap, owner, value, true);\n\t\tif (!selem)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\terr = bpf_local_storage_alloc(owner, smap, selem);\n\t\tif (err) {\n\t\t\tkfree(selem);\n\t\t\tmem_uncharge(smap, owner, smap->elem_size);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\treturn SDATA(selem);\n\t}\n\n\tif ((map_flags & BPF_F_LOCK) && !(map_flags & BPF_NOEXIST)) {\n\t\t/* Hoping to find an old_sdata to do inline update\n\t\t * such that it can avoid taking the local_storage->lock\n\t\t * and changing the lists.\n\t\t */\n\t\told_sdata =\n\t\t\tbpf_local_storage_lookup(local_storage, smap, false);\n\t\terr = check_flags(old_sdata, map_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tif (old_sdata && selem_linked_to_storage(SELEM(old_sdata))) {\n\t\t\tcopy_map_value_locked(&smap->map, old_sdata->data,\n\t\t\t\t\t      value, false);\n\t\t\treturn old_sdata;\n\t\t}\n\t}\n\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\n\t/* Recheck local_storage->list under local_storage->lock */\n\tif (unlikely(hlist_empty(&local_storage->list))) {\n\t\t/* A parallel del is happening and local_storage is going\n\t\t * away.  It has just been checked before, so very\n\t\t * unlikely.  Return instead of retry to keep things\n\t\t * simple.\n\t\t */\n\t\terr = -EAGAIN;\n\t\tgoto unlock_err;\n\t}\n\n\told_sdata = bpf_local_storage_lookup(local_storage, smap, false);\n\terr = check_flags(old_sdata, map_flags);\n\tif (err)\n\t\tgoto unlock_err;\n\n\tif (old_sdata && (map_flags & BPF_F_LOCK)) {\n\t\tcopy_map_value_locked(&smap->map, old_sdata->data, value,\n\t\t\t\t      false);\n\t\tselem = SELEM(old_sdata);\n\t\tgoto unlock;\n\t}\n\n\t/* local_storage->lock is held.  Hence, we are sure\n\t * we can unlink and uncharge the old_sdata successfully\n\t * later.  Hence, instead of charging the new selem now\n\t * and then uncharge the old selem later (which may cause\n\t * a potential but unnecessary charge failure),  avoid taking\n\t * a charge at all here (the \"!old_sdata\" check) and the\n\t * old_sdata will not be uncharged later during\n\t * bpf_selem_unlink_storage_nolock().\n\t */\n\tselem = bpf_selem_alloc(smap, owner, value, !old_sdata);\n\tif (!selem) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock_err;\n\t}\n\n\t/* First, link the new selem to the map */\n\tbpf_selem_link_map(smap, selem);\n\n\t/* Second, link (and publish) the new selem to local_storage */\n\tbpf_selem_link_storage_nolock(local_storage, selem);\n\n\t/* Third, remove old selem, SELEM(old_sdata) */\n\tif (old_sdata) {\n\t\tbpf_selem_unlink_map(SELEM(old_sdata));\n\t\tbpf_selem_unlink_storage_nolock(local_storage, SELEM(old_sdata),\n\t\t\t\t\t\tfalse);\n\t}\n\nunlock:\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\treturn SDATA(selem);\n\nunlock_err:\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "bpf_local_storage_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "283-344",
    "snippet": "int bpf_local_storage_alloc(void *owner,\n\t\t\t    struct bpf_local_storage_map *smap,\n\t\t\t    struct bpf_local_storage_elem *first_selem)\n{\n\tstruct bpf_local_storage *prev_storage, *storage;\n\tstruct bpf_local_storage **owner_storage_ptr;\n\tint err;\n\n\terr = mem_charge(smap, owner, sizeof(*storage));\n\tif (err)\n\t\treturn err;\n\n\tstorage = bpf_map_kzalloc(&smap->map, sizeof(*storage),\n\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\tif (!storage) {\n\t\terr = -ENOMEM;\n\t\tgoto uncharge;\n\t}\n\n\tINIT_HLIST_HEAD(&storage->list);\n\traw_spin_lock_init(&storage->lock);\n\tstorage->owner = owner;\n\n\tbpf_selem_link_storage_nolock(storage, first_selem);\n\tbpf_selem_link_map(smap, first_selem);\n\n\towner_storage_ptr =\n\t\t(struct bpf_local_storage **)owner_storage(smap, owner);\n\t/* Publish storage to the owner.\n\t * Instead of using any lock of the kernel object (i.e. owner),\n\t * cmpxchg will work with any kernel object regardless what\n\t * the running context is, bh, irq...etc.\n\t *\n\t * From now on, the owner->storage pointer (e.g. sk->sk_bpf_storage)\n\t * is protected by the storage->lock.  Hence, when freeing\n\t * the owner->storage, the storage->lock must be held before\n\t * setting owner->storage ptr to NULL.\n\t */\n\tprev_storage = cmpxchg(owner_storage_ptr, NULL, storage);\n\tif (unlikely(prev_storage)) {\n\t\tbpf_selem_unlink_map(first_selem);\n\t\terr = -EAGAIN;\n\t\tgoto uncharge;\n\n\t\t/* Note that even first_selem was linked to smap's\n\t\t * bucket->list, first_selem can be freed immediately\n\t\t * (instead of kfree_rcu) because\n\t\t * bpf_local_storage_map_free() does a\n\t\t * synchronize_rcu_mult (waiting for both sleepable and\n\t\t * normal programs) before walking the bucket->list.\n\t\t * Hence, no one is accessing selem from the\n\t\t * bucket->list under rcu_read_lock().\n\t\t */\n\t}\n\n\treturn 0;\n\nuncharge:\n\tkfree(storage);\n\tmem_uncharge(smap, owner, sizeof(*storage));\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_uncharge",
          "args": [
            "smap",
            "owner",
            "sizeof(*storage)"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "mem_uncharge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "37-44",
          "snippet": "static void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "storage"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_unlink_map",
          "args": [
            "first_selem"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "187-203",
          "snippet": "void bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "prev_storage"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "owner_storage_ptr",
            "NULL",
            "storage"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "owner_storage",
          "args": [
            "smap",
            "owner"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "owner_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "46-52",
          "snippet": "static struct bpf_local_storage __rcu **\nowner_storage(struct bpf_local_storage_map *smap, void *owner)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\treturn map->ops->map_owner_storage_ptr(owner);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic struct bpf_local_storage __rcu **\nowner_storage(struct bpf_local_storage_map *smap, void *owner)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\treturn map->ops->map_owner_storage_ptr(owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_link_map",
          "args": [
            "smap",
            "first_selem"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_link_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "205-215",
          "snippet": "void bpf_selem_link_map(struct bpf_local_storage_map *smap,\n\t\t\tstruct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map_bucket *b = select_bucket(smap, selem);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tRCU_INIT_POINTER(SDATA(selem)->smap, smap);\n\thlist_add_head_rcu(&selem->map_node, &b->list);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_link_map(struct bpf_local_storage_map *smap,\n\t\t\tstruct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map_bucket *b = select_bucket(smap, selem);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tRCU_INIT_POINTER(SDATA(selem)->smap, smap);\n\thlist_add_head_rcu(&selem->map_node, &b->list);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_link_storage_nolock",
          "args": [
            "storage",
            "first_selem"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_link_storage_nolock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "180-185",
          "snippet": "void bpf_selem_link_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t   struct bpf_local_storage_elem *selem)\n{\n\tRCU_INIT_POINTER(selem->local_storage, local_storage);\n\thlist_add_head_rcu(&selem->snode, &local_storage->list);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_link_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t   struct bpf_local_storage_elem *selem)\n{\n\tRCU_INIT_POINTER(selem->local_storage, local_storage);\n\thlist_add_head_rcu(&selem->snode, &local_storage->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&storage->lock"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&storage->list"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_kzalloc",
          "args": [
            "&smap->map",
            "sizeof(*storage)",
            "GFP_ATOMIC | __GFP_NOWARN"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_kzalloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "440-450",
          "snippet": "void *bpf_map_kzalloc(const struct bpf_map *map, size_t size, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kzalloc(size, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_kzalloc(const struct bpf_map *map, size_t size, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kzalloc(size, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_charge",
          "args": [
            "smap",
            "owner",
            "sizeof(*storage)"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "mem_charge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "27-35",
          "snippet": "static int mem_charge(struct bpf_local_storage_map *smap, void *owner, u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (!map->ops->map_local_storage_charge)\n\t\treturn 0;\n\n\treturn map->ops->map_local_storage_charge(smap, owner, size);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic int mem_charge(struct bpf_local_storage_map *smap, void *owner, u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (!map->ops->map_local_storage_charge)\n\t\treturn 0;\n\n\treturn map->ops->map_local_storage_charge(smap, owner, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nint bpf_local_storage_alloc(void *owner,\n\t\t\t    struct bpf_local_storage_map *smap,\n\t\t\t    struct bpf_local_storage_elem *first_selem)\n{\n\tstruct bpf_local_storage *prev_storage, *storage;\n\tstruct bpf_local_storage **owner_storage_ptr;\n\tint err;\n\n\terr = mem_charge(smap, owner, sizeof(*storage));\n\tif (err)\n\t\treturn err;\n\n\tstorage = bpf_map_kzalloc(&smap->map, sizeof(*storage),\n\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\tif (!storage) {\n\t\terr = -ENOMEM;\n\t\tgoto uncharge;\n\t}\n\n\tINIT_HLIST_HEAD(&storage->list);\n\traw_spin_lock_init(&storage->lock);\n\tstorage->owner = owner;\n\n\tbpf_selem_link_storage_nolock(storage, first_selem);\n\tbpf_selem_link_map(smap, first_selem);\n\n\towner_storage_ptr =\n\t\t(struct bpf_local_storage **)owner_storage(smap, owner);\n\t/* Publish storage to the owner.\n\t * Instead of using any lock of the kernel object (i.e. owner),\n\t * cmpxchg will work with any kernel object regardless what\n\t * the running context is, bh, irq...etc.\n\t *\n\t * From now on, the owner->storage pointer (e.g. sk->sk_bpf_storage)\n\t * is protected by the storage->lock.  Hence, when freeing\n\t * the owner->storage, the storage->lock must be held before\n\t * setting owner->storage ptr to NULL.\n\t */\n\tprev_storage = cmpxchg(owner_storage_ptr, NULL, storage);\n\tif (unlikely(prev_storage)) {\n\t\tbpf_selem_unlink_map(first_selem);\n\t\terr = -EAGAIN;\n\t\tgoto uncharge;\n\n\t\t/* Note that even first_selem was linked to smap's\n\t\t * bucket->list, first_selem can be freed immediately\n\t\t * (instead of kfree_rcu) because\n\t\t * bpf_local_storage_map_free() does a\n\t\t * synchronize_rcu_mult (waiting for both sleepable and\n\t\t * normal programs) before walking the bucket->list.\n\t\t * Hence, no one is accessing selem from the\n\t\t * bucket->list under rcu_read_lock().\n\t\t */\n\t}\n\n\treturn 0;\n\nuncharge:\n\tkfree(storage);\n\tmem_uncharge(smap, owner, sizeof(*storage));\n\treturn err;\n}"
  },
  {
    "function_name": "check_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "269-281",
    "snippet": "static int check_flags(const struct bpf_local_storage_data *old_sdata,\n\t\t       u64 map_flags)\n{\n\tif (old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic int check_flags(const struct bpf_local_storage_data *old_sdata,\n\t\t       u64 map_flags)\n{\n\tif (old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_local_storage_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "227-267",
    "snippet": "struct bpf_local_storage_data *\nbpf_local_storage_lookup(struct bpf_local_storage *local_storage,\n\t\t\t struct bpf_local_storage_map *smap,\n\t\t\t bool cacheit_lockit)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct bpf_local_storage_elem *selem;\n\n\t/* Fast path (cache hit) */\n\tsdata = rcu_dereference_check(local_storage->cache[smap->cache_idx],\n\t\t\t\t      bpf_rcu_lock_held());\n\tif (sdata && rcu_access_pointer(sdata->smap) == smap)\n\t\treturn sdata;\n\n\t/* Slow path (cache miss) */\n\thlist_for_each_entry_rcu(selem, &local_storage->list, snode,\n\t\t\t\t  rcu_read_lock_trace_held())\n\t\tif (rcu_access_pointer(SDATA(selem)->smap) == smap)\n\t\t\tbreak;\n\n\tif (!selem)\n\t\treturn NULL;\n\n\tsdata = SDATA(selem);\n\tif (cacheit_lockit) {\n\t\tunsigned long flags;\n\n\t\t/* spinlock is needed to avoid racing with the\n\t\t * parallel delete.  Otherwise, publishing an already\n\t\t * deleted sdata to the cache will become a use-after-free\n\t\t * problem in the next bpf_local_storage_lookup().\n\t\t */\n\t\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\t\tif (selem_linked_to_storage(selem))\n\t\t\trcu_assign_pointer(local_storage->cache[smap->cache_idx],\n\t\t\t\t\t   sdata);\n\t\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\t}\n\n\treturn sdata;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&local_storage->lock",
            "flags"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "local_storage->cache[smap->cache_idx]",
            "sdata"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selem_linked_to_storage",
          "args": [
            "selem"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "selem_linked_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "54-57",
          "snippet": "static bool selem_linked_to_storage(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->snode);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic bool selem_linked_to_storage(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->snode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&local_storage->lock",
            "flags"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "SDATA(selem)->smap"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "selem",
            "&local_storage->list",
            "snode",
            "rcu_read_lock_trace_held()"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_trace_held",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "sdata->smap"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "local_storage->cache[smap->cache_idx]",
            "bpf_rcu_lock_held()"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_rcu_lock_held",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_data *\nbpf_local_storage_lookup(struct bpf_local_storage *local_storage,\n\t\t\t struct bpf_local_storage_map *smap,\n\t\t\t bool cacheit_lockit)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct bpf_local_storage_elem *selem;\n\n\t/* Fast path (cache hit) */\n\tsdata = rcu_dereference_check(local_storage->cache[smap->cache_idx],\n\t\t\t\t      bpf_rcu_lock_held());\n\tif (sdata && rcu_access_pointer(sdata->smap) == smap)\n\t\treturn sdata;\n\n\t/* Slow path (cache miss) */\n\thlist_for_each_entry_rcu(selem, &local_storage->list, snode,\n\t\t\t\t  rcu_read_lock_trace_held())\n\t\tif (rcu_access_pointer(SDATA(selem)->smap) == smap)\n\t\t\tbreak;\n\n\tif (!selem)\n\t\treturn NULL;\n\n\tsdata = SDATA(selem);\n\tif (cacheit_lockit) {\n\t\tunsigned long flags;\n\n\t\t/* spinlock is needed to avoid racing with the\n\t\t * parallel delete.  Otherwise, publishing an already\n\t\t * deleted sdata to the cache will become a use-after-free\n\t\t * problem in the next bpf_local_storage_lookup().\n\t\t */\n\t\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\t\tif (selem_linked_to_storage(selem))\n\t\t\trcu_assign_pointer(local_storage->cache[smap->cache_idx],\n\t\t\t\t\t   sdata);\n\t\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\t}\n\n\treturn sdata;\n}"
  },
  {
    "function_name": "bpf_selem_unlink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "217-225",
    "snippet": "void bpf_selem_unlink(struct bpf_local_storage_elem *selem)\n{\n\t/* Always unlink from map before unlinking from local_storage\n\t * because selem will be freed after successfully unlinked from\n\t * the local_storage.\n\t */\n\tbpf_selem_unlink_map(selem);\n\t__bpf_selem_unlink_storage(selem);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_selem_unlink_storage",
          "args": [
            "selem"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_selem_unlink_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "157-178",
          "snippet": "static void __bpf_selem_unlink_storage(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage *local_storage;\n\tbool free_local_storage = false;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_storage(selem)))\n\t\t/* selem has already been unlinked from sk */\n\t\treturn;\n\n\tlocal_storage = rcu_dereference_check(selem->local_storage,\n\t\t\t\t\t      bpf_rcu_lock_held());\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\tif (likely(selem_linked_to_storage(selem)))\n\t\tfree_local_storage = bpf_selem_unlink_storage_nolock(\n\t\t\tlocal_storage, selem, true);\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\n\tif (free_local_storage)\n\t\tcall_rcu_tasks_trace(&local_storage->rcu,\n\t\t\t\t     bpf_local_storage_free_rcu);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic void __bpf_selem_unlink_storage(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage *local_storage;\n\tbool free_local_storage = false;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_storage(selem)))\n\t\t/* selem has already been unlinked from sk */\n\t\treturn;\n\n\tlocal_storage = rcu_dereference_check(selem->local_storage,\n\t\t\t\t\t      bpf_rcu_lock_held());\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\tif (likely(selem_linked_to_storage(selem)))\n\t\tfree_local_storage = bpf_selem_unlink_storage_nolock(\n\t\t\tlocal_storage, selem, true);\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\n\tif (free_local_storage)\n\t\tcall_rcu_tasks_trace(&local_storage->rcu,\n\t\t\t\t     bpf_local_storage_free_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_unlink_map",
          "args": [
            "selem"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "187-203",
          "snippet": "void bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_unlink(struct bpf_local_storage_elem *selem)\n{\n\t/* Always unlink from map before unlinking from local_storage\n\t * because selem will be freed after successfully unlinked from\n\t * the local_storage.\n\t */\n\tbpf_selem_unlink_map(selem);\n\t__bpf_selem_unlink_storage(selem);\n}"
  },
  {
    "function_name": "bpf_selem_link_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "205-215",
    "snippet": "void bpf_selem_link_map(struct bpf_local_storage_map *smap,\n\t\t\tstruct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map_bucket *b = select_bucket(smap, selem);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tRCU_INIT_POINTER(SDATA(selem)->smap, smap);\n\thlist_add_head_rcu(&selem->map_node, &b->list);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&selem->map_node",
            "&b->list"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "SDATA(selem)->smap",
            "smap"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_bucket",
          "args": [
            "smap",
            "selem"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "select_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "20-25",
          "snippet": "static struct bpf_local_storage_map_bucket *\nselect_bucket(struct bpf_local_storage_map *smap,\n\t      struct bpf_local_storage_elem *selem)\n{\n\treturn &smap->buckets[hash_ptr(selem, smap->bucket_log)];\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic struct bpf_local_storage_map_bucket *\nselect_bucket(struct bpf_local_storage_map *smap,\n\t      struct bpf_local_storage_elem *selem)\n{\n\treturn &smap->buckets[hash_ptr(selem, smap->bucket_log)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_link_map(struct bpf_local_storage_map *smap,\n\t\t\tstruct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map_bucket *b = select_bucket(smap, selem);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tRCU_INIT_POINTER(SDATA(selem)->smap, smap);\n\thlist_add_head_rcu(&selem->map_node, &b->list);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}"
  },
  {
    "function_name": "bpf_selem_unlink_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "187-203",
    "snippet": "void bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&selem->map_node"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "selem_linked_to_map(selem)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selem_linked_to_map",
          "args": [
            "selem"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "selem_linked_to_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "59-62",
          "snippet": "static bool selem_linked_to_map(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->map_node);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic bool selem_linked_to_map(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->map_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_bucket",
          "args": [
            "smap",
            "selem"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "select_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "20-25",
          "snippet": "static struct bpf_local_storage_map_bucket *\nselect_bucket(struct bpf_local_storage_map *smap,\n\t      struct bpf_local_storage_elem *selem)\n{\n\treturn &smap->buckets[hash_ptr(selem, smap->bucket_log)];\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic struct bpf_local_storage_map_bucket *\nselect_bucket(struct bpf_local_storage_map *smap,\n\t      struct bpf_local_storage_elem *selem)\n{\n\treturn &smap->buckets[hash_ptr(selem, smap->bucket_log)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "SDATA(selem)->smap",
            "bpf_rcu_lock_held()"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_rcu_lock_held",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!selem_linked_to_map(selem)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_local_storage_map_bucket *b;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_map(selem)))\n\t\t/* selem has already be unlinked from smap */\n\t\treturn;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\tb = select_bucket(smap, selem);\n\traw_spin_lock_irqsave(&b->lock, flags);\n\tif (likely(selem_linked_to_map(selem)))\n\t\thlist_del_init_rcu(&selem->map_node);\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n}"
  },
  {
    "function_name": "bpf_selem_link_storage_nolock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "180-185",
    "snippet": "void bpf_selem_link_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t   struct bpf_local_storage_elem *selem)\n{\n\tRCU_INIT_POINTER(selem->local_storage, local_storage);\n\thlist_add_head_rcu(&selem->snode, &local_storage->list);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&selem->snode",
            "&local_storage->list"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "selem->local_storage",
            "local_storage"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_selem_link_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t   struct bpf_local_storage_elem *selem)\n{\n\tRCU_INIT_POINTER(selem->local_storage, local_storage);\n\thlist_add_head_rcu(&selem->snode, &local_storage->list);\n}"
  },
  {
    "function_name": "__bpf_selem_unlink_storage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "157-178",
    "snippet": "static void __bpf_selem_unlink_storage(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage *local_storage;\n\tbool free_local_storage = false;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_storage(selem)))\n\t\t/* selem has already been unlinked from sk */\n\t\treturn;\n\n\tlocal_storage = rcu_dereference_check(selem->local_storage,\n\t\t\t\t\t      bpf_rcu_lock_held());\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\tif (likely(selem_linked_to_storage(selem)))\n\t\tfree_local_storage = bpf_selem_unlink_storage_nolock(\n\t\t\tlocal_storage, selem, true);\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\n\tif (free_local_storage)\n\t\tcall_rcu_tasks_trace(&local_storage->rcu,\n\t\t\t\t     bpf_local_storage_free_rcu);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks_trace",
          "args": [
            "&local_storage->rcu",
            "bpf_local_storage_free_rcu"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&local_storage->lock",
            "flags"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_selem_unlink_storage_nolock",
          "args": [
            "local_storage",
            "selem",
            "true"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_selem_unlink_storage_nolock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "107-155",
          "snippet": "bool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t     struct bpf_local_storage_elem *selem,\n\t\t\t\t     bool uncharge_mem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tbool free_local_storage;\n\tvoid *owner;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\towner = local_storage->owner;\n\n\t/* All uncharging on the owner must be done first.\n\t * The owner may be freed once the last selem is unlinked\n\t * from local_storage.\n\t */\n\tif (uncharge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\tfree_local_storage = hlist_is_singular_node(&selem->snode,\n\t\t\t\t\t\t    &local_storage->list);\n\tif (free_local_storage) {\n\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));\n\t\tlocal_storage->owner = NULL;\n\n\t\t/* After this RCU_INIT, owner may be freed and cannot be used */\n\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);\n\n\t\t/* local_storage is not freed now.  local_storage->lock is\n\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)\n\t\t * will be done by the caller.\n\t\t *\n\t\t * Although the unlock will be done under\n\t\t * rcu_read_lock(),  it is more intutivie to\n\t\t * read if the freeing of the storage is done\n\t\t * after the raw_spin_unlock_bh(&local_storage->lock).\n\t\t *\n\t\t * Hence, a \"bool free_local_storage\" is returned\n\t\t * to the caller which then calls then frees the storage after\n\t\t * all the RCU grace periods have expired.\n\t\t */\n\t}\n\thlist_del_init_rcu(&selem->snode);\n\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==\n\t    SDATA(selem))\n\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);\n\n\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_rcu);\n\treturn free_local_storage;\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nbool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t     struct bpf_local_storage_elem *selem,\n\t\t\t\t     bool uncharge_mem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tbool free_local_storage;\n\tvoid *owner;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\towner = local_storage->owner;\n\n\t/* All uncharging on the owner must be done first.\n\t * The owner may be freed once the last selem is unlinked\n\t * from local_storage.\n\t */\n\tif (uncharge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\tfree_local_storage = hlist_is_singular_node(&selem->snode,\n\t\t\t\t\t\t    &local_storage->list);\n\tif (free_local_storage) {\n\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));\n\t\tlocal_storage->owner = NULL;\n\n\t\t/* After this RCU_INIT, owner may be freed and cannot be used */\n\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);\n\n\t\t/* local_storage is not freed now.  local_storage->lock is\n\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)\n\t\t * will be done by the caller.\n\t\t *\n\t\t * Although the unlock will be done under\n\t\t * rcu_read_lock(),  it is more intutivie to\n\t\t * read if the freeing of the storage is done\n\t\t * after the raw_spin_unlock_bh(&local_storage->lock).\n\t\t *\n\t\t * Hence, a \"bool free_local_storage\" is returned\n\t\t * to the caller which then calls then frees the storage after\n\t\t * all the RCU grace periods have expired.\n\t\t */\n\t}\n\thlist_del_init_rcu(&selem->snode);\n\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==\n\t    SDATA(selem))\n\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);\n\n\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_rcu);\n\treturn free_local_storage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "selem_linked_to_storage(selem)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selem_linked_to_storage",
          "args": [
            "selem"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "selem_linked_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "54-57",
          "snippet": "static bool selem_linked_to_storage(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->snode);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic bool selem_linked_to_storage(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->snode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&local_storage->lock",
            "flags"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "selem->local_storage",
            "bpf_rcu_lock_held()"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_rcu_lock_held",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!selem_linked_to_storage(selem)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic void __bpf_selem_unlink_storage(struct bpf_local_storage_elem *selem)\n{\n\tstruct bpf_local_storage *local_storage;\n\tbool free_local_storage = false;\n\tunsigned long flags;\n\n\tif (unlikely(!selem_linked_to_storage(selem)))\n\t\t/* selem has already been unlinked from sk */\n\t\treturn;\n\n\tlocal_storage = rcu_dereference_check(selem->local_storage,\n\t\t\t\t\t      bpf_rcu_lock_held());\n\traw_spin_lock_irqsave(&local_storage->lock, flags);\n\tif (likely(selem_linked_to_storage(selem)))\n\t\tfree_local_storage = bpf_selem_unlink_storage_nolock(\n\t\t\tlocal_storage, selem, true);\n\traw_spin_unlock_irqrestore(&local_storage->lock, flags);\n\n\tif (free_local_storage)\n\t\tcall_rcu_tasks_trace(&local_storage->rcu,\n\t\t\t\t     bpf_local_storage_free_rcu);\n}"
  },
  {
    "function_name": "bpf_selem_unlink_storage_nolock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "107-155",
    "snippet": "bool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t     struct bpf_local_storage_elem *selem,\n\t\t\t\t     bool uncharge_mem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tbool free_local_storage;\n\tvoid *owner;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\towner = local_storage->owner;\n\n\t/* All uncharging on the owner must be done first.\n\t * The owner may be freed once the last selem is unlinked\n\t * from local_storage.\n\t */\n\tif (uncharge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\tfree_local_storage = hlist_is_singular_node(&selem->snode,\n\t\t\t\t\t\t    &local_storage->list);\n\tif (free_local_storage) {\n\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));\n\t\tlocal_storage->owner = NULL;\n\n\t\t/* After this RCU_INIT, owner may be freed and cannot be used */\n\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);\n\n\t\t/* local_storage is not freed now.  local_storage->lock is\n\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)\n\t\t * will be done by the caller.\n\t\t *\n\t\t * Although the unlock will be done under\n\t\t * rcu_read_lock(),  it is more intutivie to\n\t\t * read if the freeing of the storage is done\n\t\t * after the raw_spin_unlock_bh(&local_storage->lock).\n\t\t *\n\t\t * Hence, a \"bool free_local_storage\" is returned\n\t\t * to the caller which then calls then frees the storage after\n\t\t * all the RCU grace periods have expired.\n\t\t */\n\t}\n\thlist_del_init_rcu(&selem->snode);\n\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==\n\t    SDATA(selem))\n\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);\n\n\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_rcu);\n\treturn free_local_storage;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks_trace",
          "args": [
            "&selem->rcu",
            "bpf_selem_free_rcu"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "local_storage->cache[smap->cache_idx]",
            "NULL"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "local_storage->cache[smap->cache_idx]"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&selem->snode"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "*owner_storage(smap, owner)",
            "NULL"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owner_storage",
          "args": [
            "smap",
            "owner"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "owner_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "46-52",
          "snippet": "static struct bpf_local_storage __rcu **\nowner_storage(struct bpf_local_storage_map *smap, void *owner)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\treturn map->ops->map_owner_storage_ptr(owner);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic struct bpf_local_storage __rcu **\nowner_storage(struct bpf_local_storage_map *smap, void *owner)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\treturn map->ops->map_owner_storage_ptr(owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_uncharge",
          "args": [
            "smap",
            "owner",
            "sizeof(struct bpf_local_storage)"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "mem_uncharge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "37-44",
          "snippet": "static void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_is_singular_node",
          "args": [
            "&selem->snode",
            "&local_storage->list"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "SDATA(selem)->smap",
            "bpf_rcu_lock_held()"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_rcu_lock_held",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nbool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,\n\t\t\t\t     struct bpf_local_storage_elem *selem,\n\t\t\t\t     bool uncharge_mem)\n{\n\tstruct bpf_local_storage_map *smap;\n\tbool free_local_storage;\n\tvoid *owner;\n\n\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());\n\towner = local_storage->owner;\n\n\t/* All uncharging on the owner must be done first.\n\t * The owner may be freed once the last selem is unlinked\n\t * from local_storage.\n\t */\n\tif (uncharge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\tfree_local_storage = hlist_is_singular_node(&selem->snode,\n\t\t\t\t\t\t    &local_storage->list);\n\tif (free_local_storage) {\n\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));\n\t\tlocal_storage->owner = NULL;\n\n\t\t/* After this RCU_INIT, owner may be freed and cannot be used */\n\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);\n\n\t\t/* local_storage is not freed now.  local_storage->lock is\n\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)\n\t\t * will be done by the caller.\n\t\t *\n\t\t * Although the unlock will be done under\n\t\t * rcu_read_lock(),  it is more intutivie to\n\t\t * read if the freeing of the storage is done\n\t\t * after the raw_spin_unlock_bh(&local_storage->lock).\n\t\t *\n\t\t * Hence, a \"bool free_local_storage\" is returned\n\t\t * to the caller which then calls then frees the storage after\n\t\t * all the RCU grace periods have expired.\n\t\t */\n\t}\n\thlist_del_init_rcu(&selem->snode);\n\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==\n\t    SDATA(selem))\n\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);\n\n\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_rcu);\n\treturn free_local_storage;\n}"
  },
  {
    "function_name": "bpf_selem_free_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "95-101",
    "snippet": "static void bpf_selem_free_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_local_storage_elem *selem;\n\n\tselem = container_of(rcu, struct bpf_local_storage_elem, rcu);\n\tkfree_rcu(selem, rcu);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "selem",
            "rcu"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_local_storage_elem",
            "rcu"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic void bpf_selem_free_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_local_storage_elem *selem;\n\n\tselem = container_of(rcu, struct bpf_local_storage_elem, rcu);\n\tkfree_rcu(selem, rcu);\n}"
  },
  {
    "function_name": "bpf_local_storage_free_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "87-93",
    "snippet": "void bpf_local_storage_free_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_local_storage *local_storage;\n\n\tlocal_storage = container_of(rcu, struct bpf_local_storage, rcu);\n\tkfree_rcu(local_storage, rcu);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "local_storage",
            "rcu"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_local_storage",
            "rcu"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nvoid bpf_local_storage_free_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_local_storage *local_storage;\n\n\tlocal_storage = container_of(rcu, struct bpf_local_storage, rcu);\n\tkfree_rcu(local_storage, rcu);\n}"
  },
  {
    "function_name": "bpf_selem_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "64-85",
    "snippet": "struct bpf_local_storage_elem *\nbpf_selem_alloc(struct bpf_local_storage_map *smap, void *owner,\n\t\tvoid *value, bool charge_mem)\n{\n\tstruct bpf_local_storage_elem *selem;\n\n\tif (charge_mem && mem_charge(smap, owner, smap->elem_size))\n\t\treturn NULL;\n\n\tselem = bpf_map_kzalloc(&smap->map, smap->elem_size,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\tif (selem) {\n\t\tif (value)\n\t\t\tmemcpy(SDATA(selem)->data, value, smap->map.value_size);\n\t\treturn selem;\n\t}\n\n\tif (charge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_uncharge",
          "args": [
            "smap",
            "owner",
            "smap->elem_size"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "mem_uncharge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "37-44",
          "snippet": "static void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "SDATA(selem)->data",
            "value",
            "smap->map.value_size"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDATA",
          "args": [
            "selem"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_kzalloc",
          "args": [
            "&smap->map",
            "smap->elem_size",
            "GFP_ATOMIC | __GFP_NOWARN"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_kzalloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "440-450",
          "snippet": "void *bpf_map_kzalloc(const struct bpf_map *map, size_t size, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kzalloc(size, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_kzalloc(const struct bpf_map *map, size_t size, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kzalloc(size, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_charge",
          "args": [
            "smap",
            "owner",
            "smap->elem_size"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "mem_charge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
          "lines": "27-35",
          "snippet": "static int mem_charge(struct bpf_local_storage_map *smap, void *owner, u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (!map->ops->map_local_storage_charge)\n\t\treturn 0;\n\n\treturn map->ops->map_local_storage_charge(smap, owner, size);\n}",
          "includes": [
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic int mem_charge(struct bpf_local_storage_map *smap, void *owner, u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (!map->ops->map_local_storage_charge)\n\t\treturn 0;\n\n\treturn map->ops->map_local_storage_charge(smap, owner, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstruct bpf_local_storage_elem *\nbpf_selem_alloc(struct bpf_local_storage_map *smap, void *owner,\n\t\tvoid *value, bool charge_mem)\n{\n\tstruct bpf_local_storage_elem *selem;\n\n\tif (charge_mem && mem_charge(smap, owner, smap->elem_size))\n\t\treturn NULL;\n\n\tselem = bpf_map_kzalloc(&smap->map, smap->elem_size,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\tif (selem) {\n\t\tif (value)\n\t\t\tmemcpy(SDATA(selem)->data, value, smap->map.value_size);\n\t\treturn selem;\n\t}\n\n\tif (charge_mem)\n\t\tmem_uncharge(smap, owner, smap->elem_size);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "selem_linked_to_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "59-62",
    "snippet": "static bool selem_linked_to_map(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->map_node);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&selem->map_node"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic bool selem_linked_to_map(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->map_node);\n}"
  },
  {
    "function_name": "selem_linked_to_storage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "54-57",
    "snippet": "static bool selem_linked_to_storage(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->snode);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&selem->snode"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic bool selem_linked_to_storage(const struct bpf_local_storage_elem *selem)\n{\n\treturn !hlist_unhashed(&selem->snode);\n}"
  },
  {
    "function_name": "owner_storage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "46-52",
    "snippet": "static struct bpf_local_storage __rcu **\nowner_storage(struct bpf_local_storage_map *smap, void *owner)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\treturn map->ops->map_owner_storage_ptr(owner);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_owner_storage_ptr",
          "args": [
            "owner"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic struct bpf_local_storage __rcu **\nowner_storage(struct bpf_local_storage_map *smap, void *owner)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\treturn map->ops->map_owner_storage_ptr(owner);\n}"
  },
  {
    "function_name": "mem_uncharge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "37-44",
    "snippet": "static void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_local_storage_uncharge",
          "args": [
            "smap",
            "owner",
            "size"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic void mem_uncharge(struct bpf_local_storage_map *smap, void *owner,\n\t\t\t u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (map->ops->map_local_storage_uncharge)\n\t\tmap->ops->map_local_storage_uncharge(smap, owner, size);\n}"
  },
  {
    "function_name": "mem_charge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "27-35",
    "snippet": "static int mem_charge(struct bpf_local_storage_map *smap, void *owner, u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (!map->ops->map_local_storage_charge)\n\t\treturn 0;\n\n\treturn map->ops->map_local_storage_charge(smap, owner, size);\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_local_storage_charge",
          "args": [
            "smap",
            "owner",
            "size"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic int mem_charge(struct bpf_local_storage_map *smap, void *owner, u32 size)\n{\n\tstruct bpf_map *map = &smap->map;\n\n\tif (!map->ops->map_local_storage_charge)\n\t\treturn 0;\n\n\treturn map->ops->map_local_storage_charge(smap, owner, size);\n}"
  },
  {
    "function_name": "select_bucket",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_local_storage.c",
    "lines": "20-25",
    "snippet": "static struct bpf_local_storage_map_bucket *\nselect_bucket(struct bpf_local_storage_map *smap,\n\t      struct bpf_local_storage_elem *selem)\n{\n\treturn &smap->buckets[hash_ptr(selem, smap->bucket_log)];\n}",
    "includes": [
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <uapi/linux/btf.h>",
      "#include <uapi/linux/sock_diag.h>",
      "#include <net/sock.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/bpf.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "selem",
            "smap->bucket_log"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/sock_diag.h>\n#include <net/sock.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/bpf.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n\nstatic struct bpf_local_storage_map_bucket *\nselect_bucket(struct bpf_local_storage_map *smap,\n\t      struct bpf_local_storage_elem *selem)\n{\n\treturn &smap->buckets[hash_ptr(selem, smap->bucket_log)];\n}"
  }
]