[
  {
    "function_name": "percpu_up_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "242-269",
    "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_sync_exit",
          "args": [
            "&sem->rss"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
          "lines": "168-183",
          "snippet": "void rcu_sync_exit(struct rcu_sync *rsp)\n{\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count) == 0);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (!--rsp->gp_count) {\n\t\tif (rsp->gp_state == GP_PASSED) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\t\trcu_sync_call(rsp);\n\t\t} else if (rsp->gp_state == GP_EXIT) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_REPLAY);\n\t\t}\n\t}\n\tspin_unlock_irq(&rsp->rss_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [
            "#define\trss_lock\tgp_wait.lock"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nvoid rcu_sync_exit(struct rcu_sync *rsp)\n{\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count) == 0);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (!--rsp->gp_count) {\n\t\tif (rsp->gp_state == GP_PASSED) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\t\trcu_sync_call(rsp);\n\t\t} else if (rsp->gp_state == GP_EXIT) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_REPLAY);\n\t\t}\n\t}\n\tspin_unlock_irq(&rsp->rss_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "&sem->waiters",
            "TASK_NORMAL",
            "1",
            "sem"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_locked_key_bookmark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "176-180",
          "snippet": "void __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&sem->block",
            "0"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&sem->dep_map",
            "_RET_IP_"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
  },
  {
    "function_name": "percpu_down_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "214-239",
    "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcuwait_wait_event",
          "args": [
            "&sem->writer",
            "readers_active_check(sem)",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readers_active_check",
          "args": [
            "sem"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "readers_active_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "199-212",
          "snippet": "static bool readers_active_check(struct percpu_rw_semaphore *sem)\n{\n\tif (per_cpu_sum(*sem->read_count) != 0)\n\t\treturn false;\n\n\t/*\n\t * If we observed the decrement; ensure we see the entire critical\n\t * section.\n\t */\n\n\tsmp_mb(); /* C matches B */\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool readers_active_check(struct percpu_rw_semaphore *sem)\n{\n\tif (per_cpu_sum(*sem->read_count) != 0)\n\t\treturn false;\n\n\t/*\n\t * If we observed the decrement; ensure we see the entire critical\n\t * section.\n\t */\n\n\tsmp_mb(); /* C matches B */\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_rwsem_wait",
          "args": [
            "sem",
            "/* .reader = */false"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_rwsem_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "139-163",
          "snippet": "static void percpu_rwsem_wait(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tDEFINE_WAIT_FUNC(wq_entry, percpu_rwsem_wake_function);\n\tbool wait;\n\n\tspin_lock_irq(&sem->waiters.lock);\n\t/*\n\t * Serialize against the wakeup in percpu_up_write(), if we fail\n\t * the trylock, the wakeup must see us on the list.\n\t */\n\twait = !__percpu_rwsem_trylock(sem, reader);\n\tif (wait) {\n\t\twq_entry.flags |= WQ_FLAG_EXCLUSIVE | reader * WQ_FLAG_CUSTOM;\n\t\t__add_wait_queue_entry_tail(&sem->waiters, &wq_entry);\n\t}\n\tspin_unlock_irq(&sem->waiters.lock);\n\n\twhile (wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!smp_load_acquire(&wq_entry.private))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic void percpu_rwsem_wait(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tDEFINE_WAIT_FUNC(wq_entry, percpu_rwsem_wake_function);\n\tbool wait;\n\n\tspin_lock_irq(&sem->waiters.lock);\n\t/*\n\t * Serialize against the wakeup in percpu_up_write(), if we fail\n\t * the trylock, the wakeup must see us on the list.\n\t */\n\twait = !__percpu_rwsem_trylock(sem, reader);\n\tif (wait) {\n\t\twq_entry.flags |= WQ_FLAG_EXCLUSIVE | reader * WQ_FLAG_CUSTOM;\n\t\t__add_wait_queue_entry_tail(&sem->waiters, &wq_entry);\n\t}\n\tspin_unlock_irq(&sem->waiters.lock);\n\n\twhile (wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!smp_load_acquire(&wq_entry.private))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__percpu_down_write_trylock",
          "args": [
            "sem"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_write_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "82-88",
          "snippet": "static inline bool __percpu_down_write_trylock(struct percpu_rw_semaphore *sem)\n{\n\tif (atomic_read(&sem->block))\n\t\treturn false;\n\n\treturn atomic_xchg(&sem->block, 1) == 0;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic inline bool __percpu_down_write_trylock(struct percpu_rw_semaphore *sem)\n{\n\tif (atomic_read(&sem->block))\n\t\treturn false;\n\n\treturn atomic_xchg(&sem->block, 1) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_sync_enter",
          "args": [
            "&sem->rss"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
          "lines": "121-156",
          "snippet": "void rcu_sync_enter(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tgp_state = rsp->gp_state;\n\tif (gp_state == GP_IDLE) {\n\t\tWRITE_ONCE(rsp->gp_state, GP_ENTER);\n\t\tWARN_ON_ONCE(rsp->gp_count);\n\t\t/*\n\t\t * Note that we could simply do rcu_sync_call(rsp) here and\n\t\t * avoid the \"if (gp_state == GP_IDLE)\" block below.\n\t\t *\n\t\t * However, synchronize_rcu() can be faster if rcu_expedited\n\t\t * or rcu_blocking_is_gp() is true.\n\t\t *\n\t\t * Another reason is that we can't wait for rcu callback if\n\t\t * we are called at early boot time but this shouldn't happen.\n\t\t */\n\t}\n\trsp->gp_count++;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state == GP_IDLE) {\n\t\t/*\n\t\t * See the comment above, this simply does the \"synchronous\"\n\t\t * call_rcu(rcu_sync_func) which does GP_ENTER -> GP_PASSED.\n\t\t */\n\t\tsynchronize_rcu();\n\t\trcu_sync_func(&rsp->cb_head);\n\t\t/* Not really needed, wait_event() would see GP_PASSED. */\n\t\treturn;\n\t}\n\n\twait_event(rsp->gp_wait, READ_ONCE(rsp->gp_state) >= GP_PASSED);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [
            "#define\trss_lock\tgp_wait.lock"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nvoid rcu_sync_enter(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tgp_state = rsp->gp_state;\n\tif (gp_state == GP_IDLE) {\n\t\tWRITE_ONCE(rsp->gp_state, GP_ENTER);\n\t\tWARN_ON_ONCE(rsp->gp_count);\n\t\t/*\n\t\t * Note that we could simply do rcu_sync_call(rsp) here and\n\t\t * avoid the \"if (gp_state == GP_IDLE)\" block below.\n\t\t *\n\t\t * However, synchronize_rcu() can be faster if rcu_expedited\n\t\t * or rcu_blocking_is_gp() is true.\n\t\t *\n\t\t * Another reason is that we can't wait for rcu callback if\n\t\t * we are called at early boot time but this shouldn't happen.\n\t\t */\n\t}\n\trsp->gp_count++;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state == GP_IDLE) {\n\t\t/*\n\t\t * See the comment above, this simply does the \"synchronous\"\n\t\t * call_rcu(rcu_sync_func) which does GP_ENTER -> GP_PASSED.\n\t\t */\n\t\tsynchronize_rcu();\n\t\trcu_sync_func(&rsp->cb_head);\n\t\t/* Not really needed, wait_event() would see GP_PASSED. */\n\t\treturn;\n\t}\n\n\twait_event(rsp->gp_wait, READ_ONCE(rsp->gp_state) >= GP_PASSED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rwsem_acquire",
          "args": [
            "&sem->dep_map",
            "0",
            "0",
            "_RET_IP_"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "readers_active_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "199-212",
    "snippet": "static bool readers_active_check(struct percpu_rw_semaphore *sem)\n{\n\tif (per_cpu_sum(*sem->read_count) != 0)\n\t\treturn false;\n\n\t/*\n\t * If we observed the decrement; ensure we see the entire critical\n\t * section.\n\t */\n\n\tsmp_mb(); /* C matches B */\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_sum",
          "args": [
            "*sem->read_count"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool readers_active_check(struct percpu_rw_semaphore *sem)\n{\n\tif (per_cpu_sum(*sem->read_count) != 0)\n\t\treturn false;\n\n\t/*\n\t * If we observed the decrement; ensure we see the entire critical\n\t * section.\n\t */\n\n\tsmp_mb(); /* C matches B */\n\n\treturn true;\n}"
  },
  {
    "function_name": "__percpu_down_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "165-178",
    "snippet": "bool __percpu_down_read(struct percpu_rw_semaphore *sem, bool try)\n{\n\tif (__percpu_down_read_trylock(sem))\n\t\treturn true;\n\n\tif (try)\n\t\treturn false;\n\n\tpreempt_enable();\n\tpercpu_rwsem_wait(sem, /* .reader = */ true);\n\tpreempt_disable();\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_rwsem_wait",
          "args": [
            "sem",
            "/* .reader = */true"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_rwsem_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "139-163",
          "snippet": "static void percpu_rwsem_wait(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tDEFINE_WAIT_FUNC(wq_entry, percpu_rwsem_wake_function);\n\tbool wait;\n\n\tspin_lock_irq(&sem->waiters.lock);\n\t/*\n\t * Serialize against the wakeup in percpu_up_write(), if we fail\n\t * the trylock, the wakeup must see us on the list.\n\t */\n\twait = !__percpu_rwsem_trylock(sem, reader);\n\tif (wait) {\n\t\twq_entry.flags |= WQ_FLAG_EXCLUSIVE | reader * WQ_FLAG_CUSTOM;\n\t\t__add_wait_queue_entry_tail(&sem->waiters, &wq_entry);\n\t}\n\tspin_unlock_irq(&sem->waiters.lock);\n\n\twhile (wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!smp_load_acquire(&wq_entry.private))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic void percpu_rwsem_wait(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tDEFINE_WAIT_FUNC(wq_entry, percpu_rwsem_wake_function);\n\tbool wait;\n\n\tspin_lock_irq(&sem->waiters.lock);\n\t/*\n\t * Serialize against the wakeup in percpu_up_write(), if we fail\n\t * the trylock, the wakeup must see us on the list.\n\t */\n\twait = !__percpu_rwsem_trylock(sem, reader);\n\tif (wait) {\n\t\twq_entry.flags |= WQ_FLAG_EXCLUSIVE | reader * WQ_FLAG_CUSTOM;\n\t\t__add_wait_queue_entry_tail(&sem->waiters, &wq_entry);\n\t}\n\tspin_unlock_irq(&sem->waiters.lock);\n\n\twhile (wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!smp_load_acquire(&wq_entry.private))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__percpu_down_read_trylock",
          "args": [
            "sem"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nbool __percpu_down_read(struct percpu_rw_semaphore *sem, bool try)\n{\n\tif (__percpu_down_read_trylock(sem))\n\t\treturn true;\n\n\tif (try)\n\t\treturn false;\n\n\tpreempt_enable();\n\tpercpu_rwsem_wait(sem, /* .reader = */ true);\n\tpreempt_disable();\n\n\treturn true;\n}"
  },
  {
    "function_name": "percpu_rwsem_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "139-163",
    "snippet": "static void percpu_rwsem_wait(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tDEFINE_WAIT_FUNC(wq_entry, percpu_rwsem_wake_function);\n\tbool wait;\n\n\tspin_lock_irq(&sem->waiters.lock);\n\t/*\n\t * Serialize against the wakeup in percpu_up_write(), if we fail\n\t * the trylock, the wakeup must see us on the list.\n\t */\n\twait = !__percpu_rwsem_trylock(sem, reader);\n\tif (wait) {\n\t\twq_entry.flags |= WQ_FLAG_EXCLUSIVE | reader * WQ_FLAG_CUSTOM;\n\t\t__add_wait_queue_entry_tail(&sem->waiters, &wq_entry);\n\t}\n\tspin_unlock_irq(&sem->waiters.lock);\n\n\twhile (wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!smp_load_acquire(&wq_entry.private))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&wq_entry.private"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&sem->waiters.lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "&sem->waiters",
            "&wq_entry"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__percpu_rwsem_trylock",
          "args": [
            "sem",
            "reader"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_rwsem_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "90-102",
          "snippet": "static bool __percpu_rwsem_trylock(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tif (reader) {\n\t\tbool ret;\n\n\t\tpreempt_disable();\n\t\tret = __percpu_down_read_trylock(sem);\n\t\tpreempt_enable();\n\n\t\treturn ret;\n\t}\n\treturn __percpu_down_write_trylock(sem);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_rwsem_trylock(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tif (reader) {\n\t\tbool ret;\n\n\t\tpreempt_disable();\n\t\tret = __percpu_down_read_trylock(sem);\n\t\tpreempt_enable();\n\n\t\treturn ret;\n\t}\n\treturn __percpu_down_write_trylock(sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&sem->waiters.lock"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_FUNC",
          "args": [
            "wq_entry",
            "percpu_rwsem_wake_function"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic void percpu_rwsem_wait(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tDEFINE_WAIT_FUNC(wq_entry, percpu_rwsem_wake_function);\n\tbool wait;\n\n\tspin_lock_irq(&sem->waiters.lock);\n\t/*\n\t * Serialize against the wakeup in percpu_up_write(), if we fail\n\t * the trylock, the wakeup must see us on the list.\n\t */\n\twait = !__percpu_rwsem_trylock(sem, reader);\n\tif (wait) {\n\t\twq_entry.flags |= WQ_FLAG_EXCLUSIVE | reader * WQ_FLAG_CUSTOM;\n\t\t__add_wait_queue_entry_tail(&sem->waiters, &wq_entry);\n\t}\n\tspin_unlock_irq(&sem->waiters.lock);\n\n\twhile (wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!smp_load_acquire(&wq_entry.private))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
  },
  {
    "function_name": "percpu_rwsem_wake_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "117-137",
    "snippet": "static int percpu_rwsem_wake_function(struct wait_queue_entry *wq_entry,\n\t\t\t\t      unsigned int mode, int wake_flags,\n\t\t\t\t      void *key)\n{\n\tbool reader = wq_entry->flags & WQ_FLAG_CUSTOM;\n\tstruct percpu_rw_semaphore *sem = key;\n\tstruct task_struct *p;\n\n\t/* concurrent against percpu_down_write(), can get stolen */\n\tif (!__percpu_rwsem_trylock(sem, reader))\n\t\treturn 1;\n\n\tp = get_task_struct(wq_entry->private);\n\tlist_del_init(&wq_entry->entry);\n\tsmp_store_release(&wq_entry->private, NULL);\n\n\twake_up_process(p);\n\tput_task_struct(p);\n\n\treturn !reader; /* wake (readers until) 1 writer */\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "p"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&wq_entry->private",
            "NULL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "wq_entry->private"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__percpu_rwsem_trylock",
          "args": [
            "sem",
            "reader"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_rwsem_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "90-102",
          "snippet": "static bool __percpu_rwsem_trylock(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tif (reader) {\n\t\tbool ret;\n\n\t\tpreempt_disable();\n\t\tret = __percpu_down_read_trylock(sem);\n\t\tpreempt_enable();\n\n\t\treturn ret;\n\t}\n\treturn __percpu_down_write_trylock(sem);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_rwsem_trylock(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tif (reader) {\n\t\tbool ret;\n\n\t\tpreempt_disable();\n\t\tret = __percpu_down_read_trylock(sem);\n\t\tpreempt_enable();\n\n\t\treturn ret;\n\t}\n\treturn __percpu_down_write_trylock(sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic int percpu_rwsem_wake_function(struct wait_queue_entry *wq_entry,\n\t\t\t\t      unsigned int mode, int wake_flags,\n\t\t\t\t      void *key)\n{\n\tbool reader = wq_entry->flags & WQ_FLAG_CUSTOM;\n\tstruct percpu_rw_semaphore *sem = key;\n\tstruct task_struct *p;\n\n\t/* concurrent against percpu_down_write(), can get stolen */\n\tif (!__percpu_rwsem_trylock(sem, reader))\n\t\treturn 1;\n\n\tp = get_task_struct(wq_entry->private);\n\tlist_del_init(&wq_entry->entry);\n\tsmp_store_release(&wq_entry->private, NULL);\n\n\twake_up_process(p);\n\tput_task_struct(p);\n\n\treturn !reader; /* wake (readers until) 1 writer */\n}"
  },
  {
    "function_name": "__percpu_rwsem_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "90-102",
    "snippet": "static bool __percpu_rwsem_trylock(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tif (reader) {\n\t\tbool ret;\n\n\t\tpreempt_disable();\n\t\tret = __percpu_down_read_trylock(sem);\n\t\tpreempt_enable();\n\n\t\treturn ret;\n\t}\n\treturn __percpu_down_write_trylock(sem);\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__percpu_down_write_trylock",
          "args": [
            "sem"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_write_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "82-88",
          "snippet": "static inline bool __percpu_down_write_trylock(struct percpu_rw_semaphore *sem)\n{\n\tif (atomic_read(&sem->block))\n\t\treturn false;\n\n\treturn atomic_xchg(&sem->block, 1) == 0;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic inline bool __percpu_down_write_trylock(struct percpu_rw_semaphore *sem)\n{\n\tif (atomic_read(&sem->block))\n\t\treturn false;\n\n\treturn atomic_xchg(&sem->block, 1) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__percpu_down_read_trylock",
          "args": [
            "sem"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_rwsem_trylock(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tif (reader) {\n\t\tbool ret;\n\n\t\tpreempt_disable();\n\t\tret = __percpu_down_read_trylock(sem);\n\t\tpreempt_enable();\n\n\t\treturn ret;\n\t}\n\treturn __percpu_down_write_trylock(sem);\n}"
  },
  {
    "function_name": "__percpu_down_write_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "82-88",
    "snippet": "static inline bool __percpu_down_write_trylock(struct percpu_rw_semaphore *sem)\n{\n\tif (atomic_read(&sem->block))\n\t\treturn false;\n\n\treturn atomic_xchg(&sem->block, 1) == 0;\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&sem->block",
            "1"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sem->block"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic inline bool __percpu_down_write_trylock(struct percpu_rw_semaphore *sem)\n{\n\tif (atomic_read(&sem->block))\n\t\treturn false;\n\n\treturn atomic_xchg(&sem->block, 1) == 0;\n}"
  },
  {
    "function_name": "__percpu_down_read_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "46-80",
    "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcuwait_wake_up",
          "args": [
            "&sem->writer"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "rcuwait_wake_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "234-260",
          "snippet": "int rcuwait_wake_up(struct rcuwait *w)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_wake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_mb(); /* (B) */\n\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\tret = wake_up_process(task);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint rcuwait_wake_up(struct rcuwait *w)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_wake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_mb(); /* (B) */\n\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\tret = wake_up_process(task);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "*sem->read_count"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!atomic_read_acquire(&sem->block)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&sem->block"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "*sem->read_count"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
  },
  {
    "function_name": "percpu_free_rwsem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "31-43",
    "snippet": "void percpu_free_rwsem(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * XXX: temporary kludge. The error path in alloc_super()\n\t * assumes that percpu_free_rwsem() is safe after kzalloc().\n\t */\n\tif (!sem->read_count)\n\t\treturn;\n\n\trcu_sync_dtor(&sem->rss);\n\tfree_percpu(sem->read_count);\n\tsem->read_count = NULL; /* catch use after free bugs */\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sem->read_count"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_sync_dtor",
          "args": [
            "&sem->rss"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_dtor",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
          "lines": "189-206",
          "snippet": "void rcu_sync_dtor(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count));\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (rsp->gp_state == GP_REPLAY)\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\tgp_state = rsp->gp_state;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state != GP_IDLE) {\n\t\trcu_barrier();\n\t\tWARN_ON_ONCE(rsp->gp_state != GP_IDLE);\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [
            "#define\trss_lock\tgp_wait.lock"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nvoid rcu_sync_dtor(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count));\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (rsp->gp_state == GP_REPLAY)\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\tgp_state = rsp->gp_state;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state != GP_IDLE) {\n\t\trcu_barrier();\n\t\tWARN_ON_ONCE(rsp->gp_state != GP_IDLE);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_free_rwsem(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * XXX: temporary kludge. The error path in alloc_super()\n\t * assumes that percpu_free_rwsem() is safe after kzalloc().\n\t */\n\tif (!sem->read_count)\n\t\treturn;\n\n\trcu_sync_dtor(&sem->rss);\n\tfree_percpu(sem->read_count);\n\tsem->read_count = NULL; /* catch use after free bugs */\n}"
  },
  {
    "function_name": "__percpu_init_rwsem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
    "lines": "12-28",
    "snippet": "int __percpu_init_rwsem(struct percpu_rw_semaphore *sem,\n\t\t\tconst char *name, struct lock_class_key *key)\n{\n\tsem->read_count = alloc_percpu(int);\n\tif (unlikely(!sem->read_count))\n\t\treturn -ENOMEM;\n\n\trcu_sync_init(&sem->rss);\n\trcuwait_init(&sem->writer);\n\tinit_waitqueue_head(&sem->waiters);\n\tatomic_set(&sem->block, 0);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tdebug_check_no_locks_freed((void *)sem, sizeof(*sem));\n\tlockdep_init_map(&sem->dep_map, name, key, 0);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/errno.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/wait.h>",
      "#include <linux/percpu.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&sem->dep_map",
            "name",
            "key",
            "0"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)sem",
            "sizeof(*sem)"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6405-6427",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sem->block",
            "0"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sem->waiters"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcuwait_init",
          "args": [
            "&sem->writer"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_sync_init",
          "args": [
            "&sem->rss"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
          "lines": "21-25",
          "snippet": "void rcu_sync_init(struct rcu_sync *rsp)\n{\n\tmemset(rsp, 0, sizeof(*rsp));\n\tinit_waitqueue_head(&rsp->gp_wait);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nvoid rcu_sync_init(struct rcu_sync *rsp)\n{\n\tmemset(rsp, 0, sizeof(*rsp));\n\tinit_waitqueue_head(&rsp->gp_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!sem->read_count"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "int"
          ],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nint __percpu_init_rwsem(struct percpu_rw_semaphore *sem,\n\t\t\tconst char *name, struct lock_class_key *key)\n{\n\tsem->read_count = alloc_percpu(int);\n\tif (unlikely(!sem->read_count))\n\t\treturn -ENOMEM;\n\n\trcu_sync_init(&sem->rss);\n\trcuwait_init(&sem->writer);\n\tinit_waitqueue_head(&sem->waiters);\n\tatomic_set(&sem->block, 0);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tdebug_check_no_locks_freed((void *)sem, sizeof(*sem));\n\tlockdep_init_map(&sem->dep_map, name, key, 0);\n#endif\n\treturn 0;\n}"
  }
]