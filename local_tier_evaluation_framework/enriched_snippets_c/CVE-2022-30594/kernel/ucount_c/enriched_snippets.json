[
  {
    "function_name": "user_namespace_sysctl_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "358-376",
    "snippet": "static __init int user_namespace_sysctl_init(void)\n{\n#ifdef CONFIG_SYSCTL\n\tstatic struct ctl_table_header *user_header;\n\tstatic struct ctl_table empty[1];\n\t/*\n\t * It is necessary to register the user directory in the\n\t * default set so that registrations in the child sets work\n\t * properly.\n\t */\n\tuser_header = register_sysctl(\"user\", empty);\n\tkmemleak_ignore(user_header);\n\tBUG_ON(!user_header);\n\tBUG_ON(!setup_userns_sysctls(&init_user_ns));\n#endif\n\thlist_add_ucounts(&init_ucounts);\n\tinc_rlimit_ucounts(&init_ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ucounts init_ucounts = {\n\t.ns    = &init_user_ns,\n\t.uid   = GLOBAL_ROOT_UID,\n\t.count = ATOMIC_INIT(1),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_rlimit_ucounts",
          "args": [
            "&init_ucounts",
            "UCOUNT_RLIMIT_NPROC",
            "1"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rlimit_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "264-279",
          "snippet": "long inc_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(v, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tret = LONG_MAX;\n\t\telse if (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nlong inc_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(v, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tret = LONG_MAX;\n\t\telse if (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_ucounts",
          "args": [
            "&init_ucounts"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "hlist_add_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "145-151",
          "snippet": "static void hlist_add_ucounts(struct ucounts *ucounts)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ucounts->ns, ucounts->uid);\n\tspin_lock_irq(&ucounts_lock);\n\thlist_add_head(&ucounts->node, hashent);\n\tspin_unlock_irq(&ucounts_lock);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstatic void hlist_add_ucounts(struct ucounts *ucounts)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ucounts->ns, ucounts->uid);\n\tspin_lock_irq(&ucounts_lock);\n\thlist_add_head(&ucounts->node, hashent);\n\tspin_unlock_irq(&ucounts_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!setup_userns_sysctls(&init_user_ns)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_userns_sysctls",
          "args": [
            "&init_user_ns"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "setup_userns_sysctls",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "98-120",
          "snippet": "bool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(user_table) != UCOUNT_COUNTS + 1);\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(user_table) != UCOUNT_COUNTS + 1);\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!user_header"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_ignore",
          "args": [
            "user_header"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_sysctl",
          "args": [
            "\"user\"",
            "empty"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts init_ucounts = {\n\t.ns    = &init_user_ns,\n\t.uid   = GLOBAL_ROOT_UID,\n\t.count = ATOMIC_INIT(1),\n};\n\nstatic __init int user_namespace_sysctl_init(void)\n{\n#ifdef CONFIG_SYSCTL\n\tstatic struct ctl_table_header *user_header;\n\tstatic struct ctl_table empty[1];\n\t/*\n\t * It is necessary to register the user directory in the\n\t * default set so that registrations in the child sets work\n\t * properly.\n\t */\n\tuser_header = register_sysctl(\"user\", empty);\n\tkmemleak_ignore(user_header);\n\tBUG_ON(!user_header);\n\tBUG_ON(!setup_userns_sysctls(&init_user_ns));\n#endif\n\thlist_add_ucounts(&init_ucounts);\n\tinc_rlimit_ucounts(&init_ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "is_ucounts_overlimit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "344-356",
    "snippet": "bool is_ucounts_overlimit(struct ucounts *ucounts, enum ucount_type type, unsigned long rlimit)\n{\n\tstruct ucounts *iter;\n\tlong max = rlimit;\n\tif (rlimit > LONG_MAX)\n\t\tmax = LONG_MAX;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tif (get_ucounts_value(iter, type) > max)\n\t\t\treturn true;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "iter->ns->ucount_max[type]"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ucounts_value",
          "args": [
            "iter",
            "type"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool is_ucounts_overlimit(struct ucounts *ucounts, enum ucount_type type, unsigned long rlimit)\n{\n\tstruct ucounts *iter;\n\tlong max = rlimit;\n\tif (rlimit > LONG_MAX)\n\t\tmax = LONG_MAX;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tif (get_ucounts_value(iter, type) > max)\n\t\t\treturn true;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "inc_rlimit_get_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "312-342",
    "snippet": "long inc_rlimit_get_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\t/* Caller must hold a reference to ucounts */\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong dec, ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(1, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tgoto unwind;\n\t\tif (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t\t/*\n\t\t * Grab an extra ucount reference for the caller when\n\t\t * the rlimit count was previously 0.\n\t\t */\n\t\tif (new != 1)\n\t\t\tcontinue;\n\t\tif (!get_ucounts(iter))\n\t\t\tgoto dec_unwind;\n\t}\n\treturn ret;\ndec_unwind:\n\tdec = atomic_long_sub_return(1, &iter->ucount[type]);\n\tWARN_ON_ONCE(dec < 0);\nunwind:\n\tdo_dec_rlimit_put_ucounts(ucounts, iter, type);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_dec_rlimit_put_ucounts",
          "args": [
            "ucounts",
            "iter",
            "type"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "do_dec_rlimit_put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "294-305",
          "snippet": "static void do_dec_rlimit_put_ucounts(struct ucounts *ucounts,\n\t\t\t\tstruct ucounts *last, enum ucount_type type)\n{\n\tstruct ucounts *iter, *next;\n\tfor (iter = ucounts; iter != last; iter = next) {\n\t\tlong dec = atomic_long_sub_return(1, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tnext = iter->ns->ucounts;\n\t\tif (dec == 0)\n\t\t\tput_ucounts(iter);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic void do_dec_rlimit_put_ucounts(struct ucounts *ucounts,\n\t\t\t\tstruct ucounts *last, enum ucount_type type)\n{\n\tstruct ucounts *iter, *next;\n\tfor (iter = ucounts; iter != last; iter = next) {\n\t\tlong dec = atomic_long_sub_return(1, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tnext = iter->ns->ucounts;\n\t\tif (dec == 0)\n\t\t\tput_ucounts(iter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dec < 0"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_sub_return",
          "args": [
            "1",
            "&iter->ucount[type]"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ucounts",
          "args": [
            "iter"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "get_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "159-166",
          "snippet": "struct ucounts *get_ucounts(struct ucounts *ucounts)\n{\n\tif (!get_ucounts_or_wrap(ucounts)) {\n\t\tput_ucounts(ucounts);\n\t\tucounts = NULL;\n\t}\n\treturn ucounts;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *get_ucounts(struct ucounts *ucounts)\n{\n\tif (!get_ucounts_or_wrap(ucounts)) {\n\t\tput_ucounts(ucounts);\n\t\tucounts = NULL;\n\t}\n\treturn ucounts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "iter->ns->ucount_max[type]"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "1",
            "&iter->ucount[type]"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nlong inc_rlimit_get_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\t/* Caller must hold a reference to ucounts */\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong dec, ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(1, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tgoto unwind;\n\t\tif (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t\t/*\n\t\t * Grab an extra ucount reference for the caller when\n\t\t * the rlimit count was previously 0.\n\t\t */\n\t\tif (new != 1)\n\t\t\tcontinue;\n\t\tif (!get_ucounts(iter))\n\t\t\tgoto dec_unwind;\n\t}\n\treturn ret;\ndec_unwind:\n\tdec = atomic_long_sub_return(1, &iter->ucount[type]);\n\tWARN_ON_ONCE(dec < 0);\nunwind:\n\tdo_dec_rlimit_put_ucounts(ucounts, iter, type);\n\treturn 0;\n}"
  },
  {
    "function_name": "dec_rlimit_put_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "307-310",
    "snippet": "void dec_rlimit_put_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\tdo_dec_rlimit_put_ucounts(ucounts, NULL, type);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_dec_rlimit_put_ucounts",
          "args": [
            "ucounts",
            "NULL",
            "type"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "do_dec_rlimit_put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "294-305",
          "snippet": "static void do_dec_rlimit_put_ucounts(struct ucounts *ucounts,\n\t\t\t\tstruct ucounts *last, enum ucount_type type)\n{\n\tstruct ucounts *iter, *next;\n\tfor (iter = ucounts; iter != last; iter = next) {\n\t\tlong dec = atomic_long_sub_return(1, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tnext = iter->ns->ucounts;\n\t\tif (dec == 0)\n\t\t\tput_ucounts(iter);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic void do_dec_rlimit_put_ucounts(struct ucounts *ucounts,\n\t\t\t\tstruct ucounts *last, enum ucount_type type)\n{\n\tstruct ucounts *iter, *next;\n\tfor (iter = ucounts; iter != last; iter = next) {\n\t\tlong dec = atomic_long_sub_return(1, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tnext = iter->ns->ucounts;\n\t\tif (dec == 0)\n\t\t\tput_ucounts(iter);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_rlimit_put_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\tdo_dec_rlimit_put_ucounts(ucounts, NULL, type);\n}"
  },
  {
    "function_name": "do_dec_rlimit_put_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "294-305",
    "snippet": "static void do_dec_rlimit_put_ucounts(struct ucounts *ucounts,\n\t\t\t\tstruct ucounts *last, enum ucount_type type)\n{\n\tstruct ucounts *iter, *next;\n\tfor (iter = ucounts; iter != last; iter = next) {\n\t\tlong dec = atomic_long_sub_return(1, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tnext = iter->ns->ucounts;\n\t\tif (dec == 0)\n\t\t\tput_ucounts(iter);\n\t}\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "iter"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "206-215",
          "snippet": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nvoid put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dec < 0"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_sub_return",
          "args": [
            "1",
            "&iter->ucount[type]"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic void do_dec_rlimit_put_ucounts(struct ucounts *ucounts,\n\t\t\t\tstruct ucounts *last, enum ucount_type type)\n{\n\tstruct ucounts *iter, *next;\n\tfor (iter = ucounts; iter != last; iter = next) {\n\t\tlong dec = atomic_long_sub_return(1, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tnext = iter->ns->ucounts;\n\t\tif (dec == 0)\n\t\t\tput_ucounts(iter);\n\t}\n}"
  },
  {
    "function_name": "dec_rlimit_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "281-292",
    "snippet": "bool dec_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong new = -1; /* Silence compiler warning */\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_sub_return(v, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tif (iter == ucounts)\n\t\t\tnew = dec;\n\t}\n\treturn (new == 0);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dec < 0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_sub_return",
          "args": [
            "v",
            "&iter->ucount[type]"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool dec_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong new = -1; /* Silence compiler warning */\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_sub_return(v, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tif (iter == ucounts)\n\t\t\tnew = dec;\n\t}\n\treturn (new == 0);\n}"
  },
  {
    "function_name": "inc_rlimit_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "264-279",
    "snippet": "long inc_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(v, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tret = LONG_MAX;\n\t\telse if (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "iter->ns->ucount_max[type]"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "v",
            "&iter->ucount[type]"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nlong inc_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(v, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tret = LONG_MAX;\n\t\telse if (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dec_ucount",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "254-262",
    "snippet": "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "ucounts"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "206-215",
          "snippet": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nvoid put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dec < 0"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec_if_positive",
          "args": [
            "&iter->ucount[type]"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}"
  },
  {
    "function_name": "inc_ucount",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "231-252",
    "snippet": "struct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = alloc_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tlong max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_long_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_long_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "ucounts"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "206-215",
          "snippet": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nvoid put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&iter->ucount[type]"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_below",
          "args": [
            "&iter->ucount[type]",
            "max"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_long_inc_below",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "217-229",
          "snippet": "static inline bool atomic_long_inc_below(atomic_long_t *v, int u)\n{\n\tlong c, old;\n\tc = atomic_long_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_long_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic inline bool atomic_long_inc_below(atomic_long_t *v, int u)\n{\n\tlong c, old;\n\tc = atomic_long_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_long_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tns->ucount_max[type]"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_ucounts",
          "args": [
            "ns",
            "uid"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "168-204",
          "snippet": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstruct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = alloc_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tlong max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_long_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_long_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}"
  },
  {
    "function_name": "atomic_long_inc_below",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "217-229",
    "snippet": "static inline bool atomic_long_inc_below(atomic_long_t *v, int u)\n{\n\tlong c, old;\n\tc = atomic_long_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_long_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "old == c"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_cmpxchg",
          "args": [
            "v",
            "c",
            "c+1"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "c >= u"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "v"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic inline bool atomic_long_inc_below(atomic_long_t *v, int u)\n{\n\tlong c, old;\n\tc = atomic_long_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_long_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}"
  },
  {
    "function_name": "put_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "206-215",
    "snippet": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(ucounts_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ucounts"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ucounts_lock",
            "flags"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&ucounts->node"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock_irqsave",
          "args": [
            "&ucounts->count",
            "&ucounts_lock",
            "flags"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nvoid put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}"
  },
  {
    "function_name": "alloc_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "168-204",
    "snippet": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(ucounts_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "ucounts"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "206-215",
          "snippet": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nvoid put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ucounts_lock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ucounts_or_wrap",
          "args": [
            "ucounts"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "get_ucounts_or_wrap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "153-157",
          "snippet": "static inline bool get_ucounts_or_wrap(struct ucounts *ucounts)\n{\n\t/* Returns true on a successful get, false if the count wraps. */\n\treturn !atomic_add_negative(1, &ucounts->count);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic inline bool get_ucounts_or_wrap(struct ucounts *ucounts)\n{\n\t/* Returns true on a successful get, false if the count wraps. */\n\treturn !atomic_add_negative(1, &ucounts->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&new->node",
            "hashent"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_ucounts",
          "args": [
            "ns",
            "uid",
            "hashent"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "find_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "134-143",
          "snippet": "static struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ucounts_lock"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->count",
            "1"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_KERNEL"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucounts_hashentry",
          "args": [
            "ns",
            "uid"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstruct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}"
  },
  {
    "function_name": "get_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "159-166",
    "snippet": "struct ucounts *get_ucounts(struct ucounts *ucounts)\n{\n\tif (!get_ucounts_or_wrap(ucounts)) {\n\t\tput_ucounts(ucounts);\n\t\tucounts = NULL;\n\t}\n\treturn ucounts;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "ucounts"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "206-215",
          "snippet": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nvoid put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ucounts_or_wrap",
          "args": [
            "ucounts"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "get_ucounts_or_wrap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "153-157",
          "snippet": "static inline bool get_ucounts_or_wrap(struct ucounts *ucounts)\n{\n\t/* Returns true on a successful get, false if the count wraps. */\n\treturn !atomic_add_negative(1, &ucounts->count);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic inline bool get_ucounts_or_wrap(struct ucounts *ucounts)\n{\n\t/* Returns true on a successful get, false if the count wraps. */\n\treturn !atomic_add_negative(1, &ucounts->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *get_ucounts(struct ucounts *ucounts)\n{\n\tif (!get_ucounts_or_wrap(ucounts)) {\n\t\tput_ucounts(ucounts);\n\t\tucounts = NULL;\n\t}\n\treturn ucounts;\n}"
  },
  {
    "function_name": "get_ucounts_or_wrap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "153-157",
    "snippet": "static inline bool get_ucounts_or_wrap(struct ucounts *ucounts)\n{\n\t/* Returns true on a successful get, false if the count wraps. */\n\treturn !atomic_add_negative(1, &ucounts->count);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add_negative",
          "args": [
            "1",
            "&ucounts->count"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic inline bool get_ucounts_or_wrap(struct ucounts *ucounts)\n{\n\t/* Returns true on a successful get, false if the count wraps. */\n\treturn !atomic_add_negative(1, &ucounts->count);\n}"
  },
  {
    "function_name": "hlist_add_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "145-151",
    "snippet": "static void hlist_add_ucounts(struct ucounts *ucounts)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ucounts->ns, ucounts->uid);\n\tspin_lock_irq(&ucounts_lock);\n\thlist_add_head(&ucounts->node, hashent);\n\tspin_unlock_irq(&ucounts_lock);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(ucounts_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ucounts_lock"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&ucounts->node",
            "hashent"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ucounts_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ucounts_hashentry",
          "args": [
            "ucounts->ns",
            "ucounts->uid"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstatic void hlist_add_ucounts(struct ucounts *ucounts)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ucounts->ns, ucounts->uid);\n\tspin_lock_irq(&ucounts_lock);\n\thlist_add_head(&ucounts->node, hashent);\n\tspin_unlock_irq(&ucounts_lock);\n}"
  },
  {
    "function_name": "find_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "134-143",
    "snippet": "static struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "ucounts->uid",
            "uid"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "ucounts",
            "hashent",
            "node"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "retire_userns_sysctls",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "122-132",
    "snippet": "void retire_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->sysctls);\n\tretire_sysctl_set(&ns->set);\n\tkfree(tbl);\n#endif\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbl"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retire_sysctl_set",
          "args": [
            "&ns->set"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_sysctl_table",
          "args": [
            "ns->sysctls"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid retire_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->sysctls);\n\tretire_sysctl_set(&ns->set);\n\tkfree(tbl);\n#endif\n}"
  },
  {
    "function_name": "setup_userns_sysctls",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "98-120",
    "snippet": "bool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(user_table) != UCOUNT_COUNTS + 1);\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retire_sysctl_set",
          "args": [
            "&ns->set"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbl"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_sysctl_table",
          "args": [
            "&ns->set",
            "\"user\"",
            "tbl"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "user_table",
            "sizeof(user_table)",
            "GFP_KERNEL"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_sysctl_set",
          "args": [
            "&ns->set",
            "&set_root",
            "set_is_seen"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ARRAY_SIZE(user_table) != UCOUNT_COUNTS + 1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "user_table"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(user_table) != UCOUNT_COUNTS + 1);\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}"
  },
  {
    "function_name": "set_permissions",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "40-54",
    "snippet": "static int set_permissions(struct ctl_table_header *head,\n\t\t\t\t  struct ctl_table *table)\n{\n\tstruct user_namespace *user_ns =\n\t\tcontainer_of(head->set, struct user_namespace, set);\n\tint mode;\n\n\t/* Allow users with CAP_SYS_RESOURCE unrestrained access */\n\tif (ns_capable(user_ns, CAP_SYS_RESOURCE))\n\t\tmode = (table->mode & S_IRWXU) >> 6;\n\telse\n\t/* Allow all others at most read-only access */\n\t\tmode = table->mode & S_IROTH;\n\treturn (mode << 6) | (mode << 3) | mode;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_RESOURCE"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head->set",
            "structuser_namespace",
            "set"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic int set_permissions(struct ctl_table_header *head,\n\t\t\t\t  struct ctl_table *table)\n{\n\tstruct user_namespace *user_ns =\n\t\tcontainer_of(head->set, struct user_namespace, set);\n\tint mode;\n\n\t/* Allow users with CAP_SYS_RESOURCE unrestrained access */\n\tif (ns_capable(user_ns, CAP_SYS_RESOURCE))\n\t\tmode = (table->mode & S_IRWXU) >> 6;\n\telse\n\t/* Allow all others at most read-only access */\n\t\tmode = table->mode & S_IROTH;\n\treturn (mode << 6) | (mode << 3) | mode;\n}"
  },
  {
    "function_name": "set_is_seen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "35-38",
    "snippet": "static int set_is_seen(struct ctl_table_set *set)\n{\n\treturn &current_user_ns()->set == set;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic int set_is_seen(struct ctl_table_set *set)\n{\n\treturn &current_user_ns()->set == set;\n}"
  },
  {
    "function_name": "set_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
    "lines": "29-33",
    "snippet": "static struct ctl_table_set *\nset_lookup(struct ctl_table_root *root)\n{\n\treturn &current_user_ns()->set;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic struct ctl_table_set *\nset_lookup(struct ctl_table_root *root)\n{\n\treturn &current_user_ns()->set;\n}"
  }
]