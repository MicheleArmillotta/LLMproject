[
  {
    "function_name": "kcov_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "1036-1056",
    "snippet": "static int __init kcov_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid *area = vmalloc_node(CONFIG_KCOV_IRQ_AREA_SIZE *\n\t\t\t\tsizeof(unsigned long), cpu_to_node(cpu));\n\t\tif (!area)\n\t\t\treturn -ENOMEM;\n\t\tper_cpu_ptr(&kcov_percpu_data, cpu)->irq_area = area;\n\t}\n\n\t/*\n\t * The kcov debugfs file won't ever get removed and thus,\n\t * there is no need to protect it against removal races. The\n\t * use of debugfs_create_file_unsafe() is actually safe here.\n\t */\n\tdebugfs_create_file_unsafe(\"kcov\", 0600, NULL, NULL, &kcov_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};",
      "static const struct file_operations kcov_fops = {\n\t.open\t\t= kcov_open,\n\t.unlocked_ioctl\t= kcov_ioctl,\n\t.compat_ioctl\t= kcov_ioctl,\n\t.mmap\t\t= kcov_mmap,\n\t.release        = kcov_close,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"kcov\"",
            "0600",
            "NULL",
            "NULL",
            "&kcov_fops"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&kcov_percpu_data",
            "cpu"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_node",
          "args": [
            "CONFIG_KCOV_IRQ_AREA_SIZE *\n\t\t\t\tsizeof(unsigned long)",
            "cpu_to_node(cpu)"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\nstatic const struct file_operations kcov_fops = {\n\t.open\t\t= kcov_open,\n\t.unlocked_ioctl\t= kcov_ioctl,\n\t.compat_ioctl\t= kcov_ioctl,\n\t.mmap\t\t= kcov_mmap,\n\t.release        = kcov_close,\n};\n\nstatic int __init kcov_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid *area = vmalloc_node(CONFIG_KCOV_IRQ_AREA_SIZE *\n\t\t\t\tsizeof(unsigned long), cpu_to_node(cpu));\n\t\tif (!area)\n\t\t\treturn -ENOMEM;\n\t\tper_cpu_ptr(&kcov_percpu_data, cpu)->irq_area = area;\n\t}\n\n\t/*\n\t * The kcov debugfs file won't ever get removed and thus,\n\t * there is no need to protect it against removal races. The\n\t * use of debugfs_create_file_unsafe() is actually safe here.\n\t */\n\tdebugfs_create_file_unsafe(\"kcov\", 0600, NULL, NULL, &kcov_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kcov_common_handle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "1028-1033",
    "snippet": "u64 kcov_common_handle(void)\n{\n\tif (!in_task())\n\t\treturn 0;\n\treturn current->kcov_handle;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nu64 kcov_common_handle(void)\n{\n\tif (!in_task())\n\t\treturn 0;\n\treturn current->kcov_handle;\n}"
  },
  {
    "function_name": "kcov_remote_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "959-1024",
    "snippet": "void kcov_remote_stop(void)\n{\n\tstruct task_struct *t = current;\n\tstruct kcov *kcov;\n\tunsigned int mode;\n\tvoid *area;\n\tunsigned int size;\n\tint sequence;\n\tunsigned long flags;\n\n\tif (!in_task() && !in_serving_softirq())\n\t\treturn;\n\n\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\n\tmode = READ_ONCE(t->kcov_mode);\n\tbarrier();\n\tif (!kcov_mode_enabled(mode)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t/*\n\t * When in softirq, check if the corresponding kcov_remote_start()\n\t * actually found the remote handle and started collecting coverage.\n\t */\n\tif (in_serving_softirq() && !t->kcov_softirq) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t/* Make sure that kcov_softirq is only set when in softirq. */\n\tif (WARN_ON(!in_serving_softirq() && t->kcov_softirq)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\n\tkcov = t->kcov;\n\tarea = t->kcov_area;\n\tsize = t->kcov_size;\n\tsequence = t->kcov_sequence;\n\n\tkcov_stop(t);\n\tif (in_serving_softirq()) {\n\t\tt->kcov_softirq = 0;\n\t\tkcov_remote_softirq_stop(t);\n\t}\n\n\tspin_lock(&kcov->lock);\n\t/*\n\t * KCOV_DISABLE could have been called between kcov_remote_start()\n\t * and kcov_remote_stop(), hence the sequence check.\n\t */\n\tif (sequence == kcov->sequence && kcov->remote)\n\t\tkcov_move_area(kcov->mode, kcov->area, kcov->size, area);\n\tspin_unlock(&kcov->lock);\n\n\tif (in_task()) {\n\t\tspin_lock(&kcov_remote_lock);\n\t\tkcov_remote_area_put(area, size);\n\t\tspin_unlock(&kcov_remote_lock);\n\t}\n\n\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\n\t/* Get in kcov_remote_start(). */\n\tkcov_put(kcov);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kcov_remote_lock);",
      "static DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_put",
          "args": [
            "kcov"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "407-414",
          "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kcov_remote_lock"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_remote_area_put",
          "args": [
            "area",
            "size"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_area_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "149-155",
          "snippet": "static void kcov_remote_area_put(struct kcov_remote_area *area,\n\t\t\t\t\tunsigned int size)\n{\n\tINIT_LIST_HEAD(&area->list);\n\tarea->size = size;\n\tlist_add(&area->list, &kcov_remote_areas);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);\n\nstatic void kcov_remote_area_put(struct kcov_remote_area *area,\n\t\t\t\t\tunsigned int size)\n{\n\tINIT_LIST_HEAD(&area->list);\n\tarea->size = size;\n\tlist_add(&area->list, &kcov_remote_areas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kcov_remote_lock"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_move_area",
          "args": [
            "kcov->mode",
            "kcov->area",
            "kcov->size",
            "area"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_move_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "903-956",
          "snippet": "static void kcov_move_area(enum kcov_mode mode, void *dst_area,\n\t\t\t\tunsigned int dst_area_size, void *src_area)\n{\n\tu64 word_size = sizeof(unsigned long);\n\tu64 count_size, entry_size_log;\n\tu64 dst_len, src_len;\n\tvoid *dst_entries, *src_entries;\n\tu64 dst_occupied, dst_free, bytes_to_move, entries_moved;\n\n\tkcov_debug(\"%px %u <= %px %lu\\n\",\n\t\tdst_area, dst_area_size, src_area, *(unsigned long *)src_area);\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tdst_len = READ_ONCE(*(unsigned long *)dst_area);\n\t\tsrc_len = *(unsigned long *)src_area;\n\t\tcount_size = sizeof(unsigned long);\n\t\tentry_size_log = __ilog2_u64(sizeof(unsigned long));\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tdst_len = READ_ONCE(*(u64 *)dst_area);\n\t\tsrc_len = *(u64 *)src_area;\n\t\tcount_size = sizeof(u64);\n\t\tBUILD_BUG_ON(!is_power_of_2(KCOV_WORDS_PER_CMP));\n\t\tentry_size_log = __ilog2_u64(sizeof(u64) * KCOV_WORDS_PER_CMP);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* As arm can't divide u64 integers use log of entry size. */\n\tif (dst_len > ((dst_area_size * word_size - count_size) >>\n\t\t\t\tentry_size_log))\n\t\treturn;\n\tdst_occupied = count_size + (dst_len << entry_size_log);\n\tdst_free = dst_area_size * word_size - dst_occupied;\n\tbytes_to_move = min(dst_free, src_len << entry_size_log);\n\tdst_entries = dst_area + dst_occupied;\n\tsrc_entries = src_area + count_size;\n\tmemcpy(dst_entries, src_entries, bytes_to_move);\n\tentries_moved = bytes_to_move >> entry_size_log;\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tWRITE_ONCE(*(unsigned long *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tWRITE_ONCE(*(u64 *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void kcov_move_area(enum kcov_mode mode, void *dst_area,\n\t\t\t\tunsigned int dst_area_size, void *src_area)\n{\n\tu64 word_size = sizeof(unsigned long);\n\tu64 count_size, entry_size_log;\n\tu64 dst_len, src_len;\n\tvoid *dst_entries, *src_entries;\n\tu64 dst_occupied, dst_free, bytes_to_move, entries_moved;\n\n\tkcov_debug(\"%px %u <= %px %lu\\n\",\n\t\tdst_area, dst_area_size, src_area, *(unsigned long *)src_area);\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tdst_len = READ_ONCE(*(unsigned long *)dst_area);\n\t\tsrc_len = *(unsigned long *)src_area;\n\t\tcount_size = sizeof(unsigned long);\n\t\tentry_size_log = __ilog2_u64(sizeof(unsigned long));\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tdst_len = READ_ONCE(*(u64 *)dst_area);\n\t\tsrc_len = *(u64 *)src_area;\n\t\tcount_size = sizeof(u64);\n\t\tBUILD_BUG_ON(!is_power_of_2(KCOV_WORDS_PER_CMP));\n\t\tentry_size_log = __ilog2_u64(sizeof(u64) * KCOV_WORDS_PER_CMP);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* As arm can't divide u64 integers use log of entry size. */\n\tif (dst_len > ((dst_area_size * word_size - count_size) >>\n\t\t\t\tentry_size_log))\n\t\treturn;\n\tdst_occupied = count_size + (dst_len << entry_size_log);\n\tdst_free = dst_area_size * word_size - dst_occupied;\n\tbytes_to_move = min(dst_free, src_len << entry_size_log);\n\tdst_entries = dst_area + dst_occupied;\n\tsrc_entries = src_area + count_size;\n\tmemcpy(dst_entries, src_entries, bytes_to_move);\n\tentries_moved = bytes_to_move >> entry_size_log;\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tWRITE_ONCE(*(unsigned long *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tWRITE_ONCE(*(u64 *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_remote_softirq_stop",
          "args": [
            "t"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_softirq_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "798-812",
          "snippet": "static void kcov_remote_softirq_stop(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\n\tif (data->saved_kcov) {\n\t\tkcov_start(t, data->saved_kcov, data->saved_size,\n\t\t\t\tdata->saved_area, data->saved_mode,\n\t\t\t\tdata->saved_sequence);\n\t\tdata->saved_mode = 0;\n\t\tdata->saved_size = 0;\n\t\tdata->saved_area = NULL;\n\t\tdata->saved_sequence = 0;\n\t\tdata->saved_kcov = NULL;\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\nstatic void kcov_remote_softirq_stop(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\n\tif (data->saved_kcov) {\n\t\tkcov_start(t, data->saved_kcov, data->saved_size,\n\t\t\t\tdata->saved_area, data->saved_mode,\n\t\t\t\tdata->saved_sequence);\n\t\tdata->saved_mode = 0;\n\t\tdata->saved_size = 0;\n\t\tdata->saved_area = NULL;\n\t\tdata->saved_sequence = 0;\n\t\tdata->saved_kcov = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_stop",
          "args": [
            "t"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "343-350",
          "snippet": "static void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!in_serving_softirq() && t->kcov_softirq"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_mode_enabled",
          "args": [
            "mode"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_mode_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "776-779",
          "snippet": "static inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->kcov_mode"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_lock_irqsave",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(kcov_remote_lock);\nstatic DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\nvoid kcov_remote_stop(void)\n{\n\tstruct task_struct *t = current;\n\tstruct kcov *kcov;\n\tunsigned int mode;\n\tvoid *area;\n\tunsigned int size;\n\tint sequence;\n\tunsigned long flags;\n\n\tif (!in_task() && !in_serving_softirq())\n\t\treturn;\n\n\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\n\tmode = READ_ONCE(t->kcov_mode);\n\tbarrier();\n\tif (!kcov_mode_enabled(mode)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t/*\n\t * When in softirq, check if the corresponding kcov_remote_start()\n\t * actually found the remote handle and started collecting coverage.\n\t */\n\tif (in_serving_softirq() && !t->kcov_softirq) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t/* Make sure that kcov_softirq is only set when in softirq. */\n\tif (WARN_ON(!in_serving_softirq() && t->kcov_softirq)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\n\tkcov = t->kcov;\n\tarea = t->kcov_area;\n\tsize = t->kcov_size;\n\tsequence = t->kcov_sequence;\n\n\tkcov_stop(t);\n\tif (in_serving_softirq()) {\n\t\tt->kcov_softirq = 0;\n\t\tkcov_remote_softirq_stop(t);\n\t}\n\n\tspin_lock(&kcov->lock);\n\t/*\n\t * KCOV_DISABLE could have been called between kcov_remote_start()\n\t * and kcov_remote_stop(), hence the sequence check.\n\t */\n\tif (sequence == kcov->sequence && kcov->remote)\n\t\tkcov_move_area(kcov->mode, kcov->area, kcov->size, area);\n\tspin_unlock(&kcov->lock);\n\n\tif (in_task()) {\n\t\tspin_lock(&kcov_remote_lock);\n\t\tkcov_remote_area_put(area, size);\n\t\tspin_unlock(&kcov_remote_lock);\n\t}\n\n\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\n\t/* Get in kcov_remote_start(). */\n\tkcov_put(kcov);\n}"
  },
  {
    "function_name": "kcov_move_area",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "903-956",
    "snippet": "static void kcov_move_area(enum kcov_mode mode, void *dst_area,\n\t\t\t\tunsigned int dst_area_size, void *src_area)\n{\n\tu64 word_size = sizeof(unsigned long);\n\tu64 count_size, entry_size_log;\n\tu64 dst_len, src_len;\n\tvoid *dst_entries, *src_entries;\n\tu64 dst_occupied, dst_free, bytes_to_move, entries_moved;\n\n\tkcov_debug(\"%px %u <= %px %lu\\n\",\n\t\tdst_area, dst_area_size, src_area, *(unsigned long *)src_area);\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tdst_len = READ_ONCE(*(unsigned long *)dst_area);\n\t\tsrc_len = *(unsigned long *)src_area;\n\t\tcount_size = sizeof(unsigned long);\n\t\tentry_size_log = __ilog2_u64(sizeof(unsigned long));\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tdst_len = READ_ONCE(*(u64 *)dst_area);\n\t\tsrc_len = *(u64 *)src_area;\n\t\tcount_size = sizeof(u64);\n\t\tBUILD_BUG_ON(!is_power_of_2(KCOV_WORDS_PER_CMP));\n\t\tentry_size_log = __ilog2_u64(sizeof(u64) * KCOV_WORDS_PER_CMP);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* As arm can't divide u64 integers use log of entry size. */\n\tif (dst_len > ((dst_area_size * word_size - count_size) >>\n\t\t\t\tentry_size_log))\n\t\treturn;\n\tdst_occupied = count_size + (dst_len << entry_size_log);\n\tdst_free = dst_area_size * word_size - dst_occupied;\n\tbytes_to_move = min(dst_free, src_len << entry_size_log);\n\tdst_entries = dst_area + dst_occupied;\n\tsrc_entries = src_area + count_size;\n\tmemcpy(dst_entries, src_entries, bytes_to_move);\n\tentries_moved = bytes_to_move >> entry_size_log;\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tWRITE_ONCE(*(unsigned long *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tWRITE_ONCE(*(u64 *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define KCOV_WORDS_PER_CMP 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(u64 *)dst_area",
            "dst_len + entries_moved"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(unsigned long *)dst_area",
            "dst_len + entries_moved"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_entries",
            "src_entries",
            "bytes_to_move"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "dst_free",
            "src_len << entry_size_log"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ilog2_u64",
          "args": [
            "sizeof(u64) * KCOV_WORDS_PER_CMP"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "!is_power_of_2(KCOV_WORDS_PER_CMP)"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "KCOV_WORDS_PER_CMP"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*(u64 *)dst_area"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ilog2_u64",
          "args": [
            "sizeof(unsigned long)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*(unsigned long *)dst_area"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_debug",
          "args": [
            "\"%px %u <= %px %lu\\n\"",
            "dst_area",
            "dst_area_size",
            "src_area",
            "*(unsigned long *)src_area"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void kcov_move_area(enum kcov_mode mode, void *dst_area,\n\t\t\t\tunsigned int dst_area_size, void *src_area)\n{\n\tu64 word_size = sizeof(unsigned long);\n\tu64 count_size, entry_size_log;\n\tu64 dst_len, src_len;\n\tvoid *dst_entries, *src_entries;\n\tu64 dst_occupied, dst_free, bytes_to_move, entries_moved;\n\n\tkcov_debug(\"%px %u <= %px %lu\\n\",\n\t\tdst_area, dst_area_size, src_area, *(unsigned long *)src_area);\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tdst_len = READ_ONCE(*(unsigned long *)dst_area);\n\t\tsrc_len = *(unsigned long *)src_area;\n\t\tcount_size = sizeof(unsigned long);\n\t\tentry_size_log = __ilog2_u64(sizeof(unsigned long));\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tdst_len = READ_ONCE(*(u64 *)dst_area);\n\t\tsrc_len = *(u64 *)src_area;\n\t\tcount_size = sizeof(u64);\n\t\tBUILD_BUG_ON(!is_power_of_2(KCOV_WORDS_PER_CMP));\n\t\tentry_size_log = __ilog2_u64(sizeof(u64) * KCOV_WORDS_PER_CMP);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* As arm can't divide u64 integers use log of entry size. */\n\tif (dst_len > ((dst_area_size * word_size - count_size) >>\n\t\t\t\tentry_size_log))\n\t\treturn;\n\tdst_occupied = count_size + (dst_len << entry_size_log);\n\tdst_free = dst_area_size * word_size - dst_occupied;\n\tbytes_to_move = min(dst_free, src_len << entry_size_log);\n\tdst_entries = dst_area + dst_occupied;\n\tsrc_entries = src_area + count_size;\n\tmemcpy(dst_entries, src_entries, bytes_to_move);\n\tentries_moved = bytes_to_move >> entry_size_log;\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tWRITE_ONCE(*(unsigned long *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tWRITE_ONCE(*(u64 *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "kcov_remote_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "814-900",
    "snippet": "void kcov_remote_start(u64 handle)\n{\n\tstruct task_struct *t = current;\n\tstruct kcov_remote *remote;\n\tstruct kcov *kcov;\n\tunsigned int mode;\n\tvoid *area;\n\tunsigned int size;\n\tint sequence;\n\tunsigned long flags;\n\n\tif (WARN_ON(!kcov_check_handle(handle, true, true, true)))\n\t\treturn;\n\tif (!in_task() && !in_serving_softirq())\n\t\treturn;\n\n\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\n\t/*\n\t * Check that kcov_remote_start() is not called twice in background\n\t * threads nor called by user tasks (with enabled kcov).\n\t */\n\tmode = READ_ONCE(t->kcov_mode);\n\tif (WARN_ON(in_task() && kcov_mode_enabled(mode))) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t/*\n\t * Check that kcov_remote_start() is not called twice in softirqs.\n\t * Note, that kcov_remote_start() can be called from a softirq that\n\t * happened while collecting coverage from a background thread.\n\t */\n\tif (WARN_ON(in_serving_softirq() && t->kcov_softirq)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\n\tspin_lock(&kcov_remote_lock);\n\tremote = kcov_remote_find(handle);\n\tif (!remote) {\n\t\tspin_unlock(&kcov_remote_lock);\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\tkcov_debug(\"handle = %llx, context: %s\\n\", handle,\n\t\t\tin_task() ? \"task\" : \"softirq\");\n\tkcov = remote->kcov;\n\t/* Put in kcov_remote_stop(). */\n\tkcov_get(kcov);\n\t/*\n\t * Read kcov fields before unlock to prevent races with\n\t * KCOV_DISABLE / kcov_remote_reset().\n\t */\n\tmode = kcov->mode;\n\tsequence = kcov->sequence;\n\tif (in_task()) {\n\t\tsize = kcov->remote_size;\n\t\tarea = kcov_remote_area_get(size);\n\t} else {\n\t\tsize = CONFIG_KCOV_IRQ_AREA_SIZE;\n\t\tarea = this_cpu_ptr(&kcov_percpu_data)->irq_area;\n\t}\n\tspin_unlock(&kcov_remote_lock);\n\n\t/* Can only happen when in_task(). */\n\tif (!area) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\tarea = vmalloc(size * sizeof(unsigned long));\n\t\tif (!area) {\n\t\t\tkcov_put(kcov);\n\t\t\treturn;\n\t\t}\n\t\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\t}\n\n\t/* Reset coverage size. */\n\t*(u64 *)area = 0;\n\n\tif (in_serving_softirq()) {\n\t\tkcov_remote_softirq_start(t);\n\t\tt->kcov_softirq = 1;\n\t}\n\tkcov_start(t, kcov, size, area, mode, sequence);\n\n\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kcov_remote_lock);",
      "static DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_start",
          "args": [
            "t",
            "kcov",
            "size",
            "area",
            "mode",
            "sequence"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "328-341",
          "snippet": "static void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t/* Cache in task struct for performance. */\n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t/* See comment in check_kcov_mode(). */\n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t/* Cache in task struct for performance. */\n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t/* See comment in check_kcov_mode(). */\n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_remote_softirq_start",
          "args": [
            "t"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_softirq_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "781-796",
          "snippet": "static void kcov_remote_softirq_start(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\tunsigned int mode;\n\n\tmode = READ_ONCE(t->kcov_mode);\n\tbarrier();\n\tif (kcov_mode_enabled(mode)) {\n\t\tdata->saved_mode = mode;\n\t\tdata->saved_size = t->kcov_size;\n\t\tdata->saved_area = t->kcov_area;\n\t\tdata->saved_sequence = t->kcov_sequence;\n\t\tdata->saved_kcov = t->kcov;\n\t\tkcov_stop(t);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\nstatic void kcov_remote_softirq_start(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\tunsigned int mode;\n\n\tmode = READ_ONCE(t->kcov_mode);\n\tbarrier();\n\tif (kcov_mode_enabled(mode)) {\n\t\tdata->saved_mode = mode;\n\t\tdata->saved_size = t->kcov_size;\n\t\tdata->saved_area = t->kcov_area;\n\t\tdata->saved_sequence = t->kcov_sequence;\n\t\tdata->saved_kcov = t->kcov;\n\t\tkcov_stop(t);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_lock_irqsave",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_put",
          "args": [
            "kcov"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "407-414",
          "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size * sizeof(unsigned long)"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "array_map_vmalloc_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "379-382",
          "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kcov_remote_lock"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&kcov_percpu_data"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_remote_area_get",
          "args": [
            "size"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_area_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "133-146",
          "snippet": "static struct kcov_remote_area *kcov_remote_area_get(unsigned int size)\n{\n\tstruct kcov_remote_area *area;\n\tstruct list_head *pos;\n\n\tlist_for_each(pos, &kcov_remote_areas) {\n\t\tarea = list_entry(pos, struct kcov_remote_area, list);\n\t\tif (area->size == size) {\n\t\t\tlist_del(&area->list);\n\t\t\treturn area;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);\n\nstatic struct kcov_remote_area *kcov_remote_area_get(unsigned int size)\n{\n\tstruct kcov_remote_area *area;\n\tstruct list_head *pos;\n\n\tlist_for_each(pos, &kcov_remote_areas) {\n\t\tarea = list_entry(pos, struct kcov_remote_area, list);\n\t\tif (area->size == size) {\n\t\t\tlist_del(&area->list);\n\t\t\treturn area;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_get",
          "args": [
            "kcov"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_get_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "517-529",
          "snippet": "static int kcov_get_mode(unsigned long arg)\n{\n\tif (arg == KCOV_TRACE_PC)\n\t\treturn KCOV_MODE_TRACE_PC;\n\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\treturn KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_get_mode(unsigned long arg)\n{\n\tif (arg == KCOV_TRACE_PC)\n\t\treturn KCOV_MODE_TRACE_PC;\n\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\treturn KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_debug",
          "args": [
            "\"handle = %llx, context: %s\\n\"",
            "handle",
            "in_task() ? \"task\" : \"softirq\""
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_remote_find",
          "args": [
            "handle"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_find",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "105-114",
          "snippet": "static struct kcov_remote *kcov_remote_find(u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\thash_for_each_possible(kcov_remote_map, remote, hnode, handle) {\n\t\tif (remote->handle == handle)\n\t\t\treturn remote;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(kcov_remote_map, 4);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\n\nstatic struct kcov_remote *kcov_remote_find(u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\thash_for_each_possible(kcov_remote_map, remote, hnode, handle) {\n\t\tif (remote->handle == handle)\n\t\t\treturn remote;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kcov_remote_lock"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "in_serving_softirq() && t->kcov_softirq"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_unlock_irqrestore",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "in_task() && kcov_mode_enabled(mode)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_mode_enabled",
          "args": [
            "mode"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_mode_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "776-779",
          "snippet": "static inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->kcov_mode"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_lock_irqsave",
          "args": [
            "&kcov_percpu_data.lock",
            "flags"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!kcov_check_handle(handle, true, true, true)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_check_handle",
          "args": [
            "handle",
            "true",
            "true",
            "true"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_check_handle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "546-561",
          "snippet": "static inline bool kcov_check_handle(u64 handle, bool common_valid,\n\t\t\t\tbool uncommon_valid, bool zero_valid)\n{\n\tif (handle & ~(KCOV_SUBSYSTEM_MASK | KCOV_INSTANCE_MASK))\n\t\treturn false;\n\tswitch (handle & KCOV_SUBSYSTEM_MASK) {\n\tcase KCOV_SUBSYSTEM_COMMON:\n\t\treturn (handle & KCOV_INSTANCE_MASK) ?\n\t\t\tcommon_valid : zero_valid;\n\tcase KCOV_SUBSYSTEM_USB:\n\t\treturn uncommon_valid;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic inline bool kcov_check_handle(u64 handle, bool common_valid,\n\t\t\t\tbool uncommon_valid, bool zero_valid)\n{\n\tif (handle & ~(KCOV_SUBSYSTEM_MASK | KCOV_INSTANCE_MASK))\n\t\treturn false;\n\tswitch (handle & KCOV_SUBSYSTEM_MASK) {\n\tcase KCOV_SUBSYSTEM_COMMON:\n\t\treturn (handle & KCOV_INSTANCE_MASK) ?\n\t\t\tcommon_valid : zero_valid;\n\tcase KCOV_SUBSYSTEM_USB:\n\t\treturn uncommon_valid;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(kcov_remote_lock);\nstatic DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\nvoid kcov_remote_start(u64 handle)\n{\n\tstruct task_struct *t = current;\n\tstruct kcov_remote *remote;\n\tstruct kcov *kcov;\n\tunsigned int mode;\n\tvoid *area;\n\tunsigned int size;\n\tint sequence;\n\tunsigned long flags;\n\n\tif (WARN_ON(!kcov_check_handle(handle, true, true, true)))\n\t\treturn;\n\tif (!in_task() && !in_serving_softirq())\n\t\treturn;\n\n\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\n\t/*\n\t * Check that kcov_remote_start() is not called twice in background\n\t * threads nor called by user tasks (with enabled kcov).\n\t */\n\tmode = READ_ONCE(t->kcov_mode);\n\tif (WARN_ON(in_task() && kcov_mode_enabled(mode))) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t/*\n\t * Check that kcov_remote_start() is not called twice in softirqs.\n\t * Note, that kcov_remote_start() can be called from a softirq that\n\t * happened while collecting coverage from a background thread.\n\t */\n\tif (WARN_ON(in_serving_softirq() && t->kcov_softirq)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\n\tspin_lock(&kcov_remote_lock);\n\tremote = kcov_remote_find(handle);\n\tif (!remote) {\n\t\tspin_unlock(&kcov_remote_lock);\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\tkcov_debug(\"handle = %llx, context: %s\\n\", handle,\n\t\t\tin_task() ? \"task\" : \"softirq\");\n\tkcov = remote->kcov;\n\t/* Put in kcov_remote_stop(). */\n\tkcov_get(kcov);\n\t/*\n\t * Read kcov fields before unlock to prevent races with\n\t * KCOV_DISABLE / kcov_remote_reset().\n\t */\n\tmode = kcov->mode;\n\tsequence = kcov->sequence;\n\tif (in_task()) {\n\t\tsize = kcov->remote_size;\n\t\tarea = kcov_remote_area_get(size);\n\t} else {\n\t\tsize = CONFIG_KCOV_IRQ_AREA_SIZE;\n\t\tarea = this_cpu_ptr(&kcov_percpu_data)->irq_area;\n\t}\n\tspin_unlock(&kcov_remote_lock);\n\n\t/* Can only happen when in_task(). */\n\tif (!area) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\tarea = vmalloc(size * sizeof(unsigned long));\n\t\tif (!area) {\n\t\t\tkcov_put(kcov);\n\t\t\treturn;\n\t\t}\n\t\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\t}\n\n\t/* Reset coverage size. */\n\t*(u64 *)area = 0;\n\n\tif (in_serving_softirq()) {\n\t\tkcov_remote_softirq_start(t);\n\t\tt->kcov_softirq = 1;\n\t}\n\tkcov_start(t, kcov, size, area, mode, sequence);\n\n\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\n}"
  },
  {
    "function_name": "kcov_remote_softirq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "798-812",
    "snippet": "static void kcov_remote_softirq_stop(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\n\tif (data->saved_kcov) {\n\t\tkcov_start(t, data->saved_kcov, data->saved_size,\n\t\t\t\tdata->saved_area, data->saved_mode,\n\t\t\t\tdata->saved_sequence);\n\t\tdata->saved_mode = 0;\n\t\tdata->saved_size = 0;\n\t\tdata->saved_area = NULL;\n\t\tdata->saved_sequence = 0;\n\t\tdata->saved_kcov = NULL;\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_start",
          "args": [
            "t",
            "data->saved_kcov",
            "data->saved_size",
            "data->saved_area",
            "data->saved_mode",
            "data->saved_sequence"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "328-341",
          "snippet": "static void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t/* Cache in task struct for performance. */\n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t/* See comment in check_kcov_mode(). */\n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t/* Cache in task struct for performance. */\n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t/* See comment in check_kcov_mode(). */\n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&kcov_percpu_data"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\nstatic void kcov_remote_softirq_stop(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\n\tif (data->saved_kcov) {\n\t\tkcov_start(t, data->saved_kcov, data->saved_size,\n\t\t\t\tdata->saved_area, data->saved_mode,\n\t\t\t\tdata->saved_sequence);\n\t\tdata->saved_mode = 0;\n\t\tdata->saved_size = 0;\n\t\tdata->saved_area = NULL;\n\t\tdata->saved_sequence = 0;\n\t\tdata->saved_kcov = NULL;\n\t}\n}"
  },
  {
    "function_name": "kcov_remote_softirq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "781-796",
    "snippet": "static void kcov_remote_softirq_start(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\tunsigned int mode;\n\n\tmode = READ_ONCE(t->kcov_mode);\n\tbarrier();\n\tif (kcov_mode_enabled(mode)) {\n\t\tdata->saved_mode = mode;\n\t\tdata->saved_size = t->kcov_size;\n\t\tdata->saved_area = t->kcov_area;\n\t\tdata->saved_sequence = t->kcov_sequence;\n\t\tdata->saved_kcov = t->kcov;\n\t\tkcov_stop(t);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_stop",
          "args": [
            "t"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "343-350",
          "snippet": "static void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_mode_enabled",
          "args": [
            "mode"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_mode_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "776-779",
          "snippet": "static inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->kcov_mode"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&kcov_percpu_data"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\nstatic void kcov_remote_softirq_start(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\tunsigned int mode;\n\n\tmode = READ_ONCE(t->kcov_mode);\n\tbarrier();\n\tif (kcov_mode_enabled(mode)) {\n\t\tdata->saved_mode = mode;\n\t\tdata->saved_size = t->kcov_size;\n\t\tdata->saved_area = t->kcov_area;\n\t\tdata->saved_sequence = t->kcov_sequence;\n\t\tdata->saved_kcov = t->kcov;\n\t\tkcov_stop(t);\n\t}\n}"
  },
  {
    "function_name": "kcov_mode_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "776-779",
    "snippet": "static inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}"
  },
  {
    "function_name": "kcov_ioctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "688-723",
    "snippet": "static long kcov_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct kcov *kcov;\n\tint res;\n\tstruct kcov_remote_arg *remote_arg = NULL;\n\tunsigned int remote_num_handles;\n\tunsigned long remote_arg_size;\n\tunsigned long flags;\n\n\tif (cmd == KCOV_REMOTE_ENABLE) {\n\t\tif (get_user(remote_num_handles, (unsigned __user *)(arg +\n\t\t\t\toffsetof(struct kcov_remote_arg, num_handles))))\n\t\t\treturn -EFAULT;\n\t\tif (remote_num_handles > KCOV_REMOTE_MAX_HANDLES)\n\t\t\treturn -EINVAL;\n\t\tremote_arg_size = struct_size(remote_arg, handles,\n\t\t\t\t\tremote_num_handles);\n\t\tremote_arg = memdup_user((void __user *)arg, remote_arg_size);\n\t\tif (IS_ERR(remote_arg))\n\t\t\treturn PTR_ERR(remote_arg);\n\t\tif (remote_arg->num_handles != remote_num_handles) {\n\t\t\tkfree(remote_arg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\targ = (unsigned long)remote_arg;\n\t}\n\n\tkcov = filep->private_data;\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tres = kcov_ioctl_locked(kcov, cmd, arg);\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\n\tkfree(remote_arg);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "remote_arg"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kcov->lock",
            "flags"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_ioctl_locked",
          "args": [
            "kcov",
            "cmd",
            "arg"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_ioctl_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "563-686",
          "snippet": "static int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long size, unused;\n\tint mode, i;\n\tstruct kcov_remote_arg *remote_arg;\n\tstruct kcov_remote *remote;\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t/*\n\t\t * Enable kcov in trace mode and setup buffer size.\n\t\t * Must happen before anything else.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_DISABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * Size must be at least 2 to hold current position and one PC.\n\t\t * Later we allocate size * sizeof(unsigned long) memory,\n\t\t * that must not overflow.\n\t\t */\n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\treturn 0;\n\tcase KCOV_ENABLE:\n\t\t/*\n\t\t * Enable coverage for the current task.\n\t\t * At this point user must have been enabled trace mode,\n\t\t * and mmapped the file. Coverage collection is disabled only\n\t\t * at task exit or voluntary by KCOV_DISABLE. After that it can\n\t\t * be enabled for another task.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tmode = kcov_get_mode(arg);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tkcov_fault_in_area(kcov);\n\t\tkcov->mode = mode;\n\t\tkcov_start(t, kcov, kcov->size, kcov->area, kcov->mode,\n\t\t\t\tkcov->sequence);\n\t\tkcov->t = t;\n\t\t/* Put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t/* Disable coverage for the current task. */\n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_disable(t, kcov);\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tcase KCOV_REMOTE_ENABLE:\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tremote_arg = (struct kcov_remote_arg *)arg;\n\t\tmode = kcov_get_mode(remote_arg->trace_mode);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tif (remote_arg->area_size > LONG_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->mode = mode;\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\tkcov->remote = true;\n\t\tkcov->remote_size = remote_arg->area_size;\n\t\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\t\tfor (i = 0; i < remote_arg->num_handles; i++) {\n\t\t\tif (!kcov_check_handle(remote_arg->handles[i],\n\t\t\t\t\t\tfalse, true, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov, remote_arg->handles[i]);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t}\n\t\tif (remote_arg->common_handle) {\n\t\t\tif (!kcov_check_handle(remote_arg->common_handle,\n\t\t\t\t\t\ttrue, false, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov,\n\t\t\t\t\tremote_arg->common_handle);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t\tt->kcov_handle = remote_arg->common_handle;\n\t\t}\n\t\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n\t\t/* Put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kcov_remote_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(kcov_remote_lock);\n\nstatic int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long size, unused;\n\tint mode, i;\n\tstruct kcov_remote_arg *remote_arg;\n\tstruct kcov_remote *remote;\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t/*\n\t\t * Enable kcov in trace mode and setup buffer size.\n\t\t * Must happen before anything else.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_DISABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * Size must be at least 2 to hold current position and one PC.\n\t\t * Later we allocate size * sizeof(unsigned long) memory,\n\t\t * that must not overflow.\n\t\t */\n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\treturn 0;\n\tcase KCOV_ENABLE:\n\t\t/*\n\t\t * Enable coverage for the current task.\n\t\t * At this point user must have been enabled trace mode,\n\t\t * and mmapped the file. Coverage collection is disabled only\n\t\t * at task exit or voluntary by KCOV_DISABLE. After that it can\n\t\t * be enabled for another task.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tmode = kcov_get_mode(arg);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tkcov_fault_in_area(kcov);\n\t\tkcov->mode = mode;\n\t\tkcov_start(t, kcov, kcov->size, kcov->area, kcov->mode,\n\t\t\t\tkcov->sequence);\n\t\tkcov->t = t;\n\t\t/* Put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t/* Disable coverage for the current task. */\n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_disable(t, kcov);\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tcase KCOV_REMOTE_ENABLE:\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tremote_arg = (struct kcov_remote_arg *)arg;\n\t\tmode = kcov_get_mode(remote_arg->trace_mode);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tif (remote_arg->area_size > LONG_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->mode = mode;\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\tkcov->remote = true;\n\t\tkcov->remote_size = remote_arg->area_size;\n\t\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\t\tfor (i = 0; i < remote_arg->num_handles; i++) {\n\t\t\tif (!kcov_check_handle(remote_arg->handles[i],\n\t\t\t\t\t\tfalse, true, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov, remote_arg->handles[i]);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t}\n\t\tif (remote_arg->common_handle) {\n\t\t\tif (!kcov_check_handle(remote_arg->common_handle,\n\t\t\t\t\t\ttrue, false, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov,\n\t\t\t\t\tremote_arg->common_handle);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t\tt->kcov_handle = remote_arg->common_handle;\n\t\t}\n\t\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n\t\t/* Put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kcov->lock",
            "flags"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "remote_arg"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "remote_arg"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "(void __user *)arg",
            "remote_arg_size"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "remote_arg",
            "handles",
            "remote_num_handles"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "remote_num_handles",
            "(unsigned __user *)(arg +\n\t\t\t\toffsetof(struct kcov_remote_arg, num_handles))"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic long kcov_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct kcov *kcov;\n\tint res;\n\tstruct kcov_remote_arg *remote_arg = NULL;\n\tunsigned int remote_num_handles;\n\tunsigned long remote_arg_size;\n\tunsigned long flags;\n\n\tif (cmd == KCOV_REMOTE_ENABLE) {\n\t\tif (get_user(remote_num_handles, (unsigned __user *)(arg +\n\t\t\t\toffsetof(struct kcov_remote_arg, num_handles))))\n\t\t\treturn -EFAULT;\n\t\tif (remote_num_handles > KCOV_REMOTE_MAX_HANDLES)\n\t\t\treturn -EINVAL;\n\t\tremote_arg_size = struct_size(remote_arg, handles,\n\t\t\t\t\tremote_num_handles);\n\t\tremote_arg = memdup_user((void __user *)arg, remote_arg_size);\n\t\tif (IS_ERR(remote_arg))\n\t\t\treturn PTR_ERR(remote_arg);\n\t\tif (remote_arg->num_handles != remote_num_handles) {\n\t\t\tkfree(remote_arg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\targ = (unsigned long)remote_arg;\n\t}\n\n\tkcov = filep->private_data;\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tres = kcov_ioctl_locked(kcov, cmd, arg);\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\n\tkfree(remote_arg);\n\n\treturn res;\n}"
  },
  {
    "function_name": "kcov_ioctl_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "563-686",
    "snippet": "static int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long size, unused;\n\tint mode, i;\n\tstruct kcov_remote_arg *remote_arg;\n\tstruct kcov_remote *remote;\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t/*\n\t\t * Enable kcov in trace mode and setup buffer size.\n\t\t * Must happen before anything else.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_DISABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * Size must be at least 2 to hold current position and one PC.\n\t\t * Later we allocate size * sizeof(unsigned long) memory,\n\t\t * that must not overflow.\n\t\t */\n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\treturn 0;\n\tcase KCOV_ENABLE:\n\t\t/*\n\t\t * Enable coverage for the current task.\n\t\t * At this point user must have been enabled trace mode,\n\t\t * and mmapped the file. Coverage collection is disabled only\n\t\t * at task exit or voluntary by KCOV_DISABLE. After that it can\n\t\t * be enabled for another task.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tmode = kcov_get_mode(arg);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tkcov_fault_in_area(kcov);\n\t\tkcov->mode = mode;\n\t\tkcov_start(t, kcov, kcov->size, kcov->area, kcov->mode,\n\t\t\t\tkcov->sequence);\n\t\tkcov->t = t;\n\t\t/* Put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t/* Disable coverage for the current task. */\n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_disable(t, kcov);\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tcase KCOV_REMOTE_ENABLE:\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tremote_arg = (struct kcov_remote_arg *)arg;\n\t\tmode = kcov_get_mode(remote_arg->trace_mode);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tif (remote_arg->area_size > LONG_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->mode = mode;\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\tkcov->remote = true;\n\t\tkcov->remote_size = remote_arg->area_size;\n\t\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\t\tfor (i = 0; i < remote_arg->num_handles; i++) {\n\t\t\tif (!kcov_check_handle(remote_arg->handles[i],\n\t\t\t\t\t\tfalse, true, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov, remote_arg->handles[i]);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t}\n\t\tif (remote_arg->common_handle) {\n\t\t\tif (!kcov_check_handle(remote_arg->common_handle,\n\t\t\t\t\t\ttrue, false, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov,\n\t\t\t\t\tremote_arg->common_handle);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t\tt->kcov_handle = remote_arg->common_handle;\n\t\t}\n\t\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n\t\t/* Put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kcov_remote_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_get",
          "args": [
            "kcov"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_get_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "517-529",
          "snippet": "static int kcov_get_mode(unsigned long arg)\n{\n\tif (arg == KCOV_TRACE_PC)\n\t\treturn KCOV_MODE_TRACE_PC;\n\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\treturn KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_get_mode(unsigned long arg)\n{\n\tif (arg == KCOV_TRACE_PC)\n\t\treturn KCOV_MODE_TRACE_PC;\n\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\treturn KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kcov_remote_lock",
            "flags"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "remote"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_disable",
          "args": [
            "t",
            "kcov"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "393-400",
          "snippet": "static void kcov_disable(struct task_struct *t, struct kcov *kcov)\n{\n\tkcov_task_reset(t);\n\tif (kcov->remote)\n\t\tkcov_remote_reset(kcov);\n\telse\n\t\tkcov_reset(kcov);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_disable(struct task_struct *t, struct kcov *kcov)\n{\n\tkcov_task_reset(t);\n\tif (kcov->remote)\n\t\tkcov_remote_reset(kcov);\n\telse\n\t\tkcov_reset(kcov);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "remote"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_remote_add",
          "args": [
            "kcov",
            "remote_arg->common_handle"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "117-130",
          "snippet": "static struct kcov_remote *kcov_remote_add(struct kcov *kcov, u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\tif (kcov_remote_find(handle))\n\t\treturn ERR_PTR(-EEXIST);\n\tremote = kmalloc(sizeof(*remote), GFP_ATOMIC);\n\tif (!remote)\n\t\treturn ERR_PTR(-ENOMEM);\n\tremote->handle = handle;\n\tremote->kcov = kcov;\n\thash_add(kcov_remote_map, &remote->hnode, handle);\n\treturn remote;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(kcov_remote_map, 4);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\n\nstatic struct kcov_remote *kcov_remote_add(struct kcov *kcov, u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\tif (kcov_remote_find(handle))\n\t\treturn ERR_PTR(-EEXIST);\n\tremote = kmalloc(sizeof(*remote), GFP_ATOMIC);\n\tif (!remote)\n\t\treturn ERR_PTR(-ENOMEM);\n\tremote->handle = handle;\n\tremote->kcov = kcov;\n\thash_add(kcov_remote_map, &remote->hnode, handle);\n\treturn remote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_check_handle",
          "args": [
            "remote_arg->common_handle",
            "true",
            "false",
            "false"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_check_handle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "546-561",
          "snippet": "static inline bool kcov_check_handle(u64 handle, bool common_valid,\n\t\t\t\tbool uncommon_valid, bool zero_valid)\n{\n\tif (handle & ~(KCOV_SUBSYSTEM_MASK | KCOV_INSTANCE_MASK))\n\t\treturn false;\n\tswitch (handle & KCOV_SUBSYSTEM_MASK) {\n\tcase KCOV_SUBSYSTEM_COMMON:\n\t\treturn (handle & KCOV_INSTANCE_MASK) ?\n\t\t\tcommon_valid : zero_valid;\n\tcase KCOV_SUBSYSTEM_USB:\n\t\treturn uncommon_valid;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic inline bool kcov_check_handle(u64 handle, bool common_valid,\n\t\t\t\tbool uncommon_valid, bool zero_valid)\n{\n\tif (handle & ~(KCOV_SUBSYSTEM_MASK | KCOV_INSTANCE_MASK))\n\t\treturn false;\n\tswitch (handle & KCOV_SUBSYSTEM_MASK) {\n\tcase KCOV_SUBSYSTEM_COMMON:\n\t\treturn (handle & KCOV_INSTANCE_MASK) ?\n\t\t\tcommon_valid : zero_valid;\n\tcase KCOV_SUBSYSTEM_USB:\n\t\treturn uncommon_valid;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "remote"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "remote"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kcov_remote_lock",
            "flags"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_put",
          "args": [
            "kcov"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "407-414",
          "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kcov->t != t"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_start",
          "args": [
            "t",
            "kcov",
            "kcov->size",
            "kcov->area",
            "kcov->mode",
            "kcov->sequence"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "328-341",
          "snippet": "static void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t/* Cache in task struct for performance. */\n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t/* See comment in check_kcov_mode(). */\n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t/* Cache in task struct for performance. */\n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t/* See comment in check_kcov_mode(). */\n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_fault_in_area",
          "args": [
            "kcov"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_fault_in_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "536-544",
          "snippet": "static void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(kcov_remote_lock);\n\nstatic int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long size, unused;\n\tint mode, i;\n\tstruct kcov_remote_arg *remote_arg;\n\tstruct kcov_remote *remote;\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t/*\n\t\t * Enable kcov in trace mode and setup buffer size.\n\t\t * Must happen before anything else.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_DISABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * Size must be at least 2 to hold current position and one PC.\n\t\t * Later we allocate size * sizeof(unsigned long) memory,\n\t\t * that must not overflow.\n\t\t */\n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\treturn 0;\n\tcase KCOV_ENABLE:\n\t\t/*\n\t\t * Enable coverage for the current task.\n\t\t * At this point user must have been enabled trace mode,\n\t\t * and mmapped the file. Coverage collection is disabled only\n\t\t * at task exit or voluntary by KCOV_DISABLE. After that it can\n\t\t * be enabled for another task.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tmode = kcov_get_mode(arg);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tkcov_fault_in_area(kcov);\n\t\tkcov->mode = mode;\n\t\tkcov_start(t, kcov, kcov->size, kcov->area, kcov->mode,\n\t\t\t\tkcov->sequence);\n\t\tkcov->t = t;\n\t\t/* Put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t/* Disable coverage for the current task. */\n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_disable(t, kcov);\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tcase KCOV_REMOTE_ENABLE:\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tremote_arg = (struct kcov_remote_arg *)arg;\n\t\tmode = kcov_get_mode(remote_arg->trace_mode);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tif (remote_arg->area_size > LONG_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->mode = mode;\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\tkcov->remote = true;\n\t\tkcov->remote_size = remote_arg->area_size;\n\t\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\t\tfor (i = 0; i < remote_arg->num_handles; i++) {\n\t\t\tif (!kcov_check_handle(remote_arg->handles[i],\n\t\t\t\t\t\tfalse, true, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov, remote_arg->handles[i]);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t}\n\t\tif (remote_arg->common_handle) {\n\t\t\tif (!kcov_check_handle(remote_arg->common_handle,\n\t\t\t\t\t\ttrue, false, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov,\n\t\t\t\t\tremote_arg->common_handle);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t\tt->kcov_handle = remote_arg->common_handle;\n\t\t}\n\t\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n\t\t/* Put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "kcov_check_handle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "546-561",
    "snippet": "static inline bool kcov_check_handle(u64 handle, bool common_valid,\n\t\t\t\tbool uncommon_valid, bool zero_valid)\n{\n\tif (handle & ~(KCOV_SUBSYSTEM_MASK | KCOV_INSTANCE_MASK))\n\t\treturn false;\n\tswitch (handle & KCOV_SUBSYSTEM_MASK) {\n\tcase KCOV_SUBSYSTEM_COMMON:\n\t\treturn (handle & KCOV_INSTANCE_MASK) ?\n\t\t\tcommon_valid : zero_valid;\n\tcase KCOV_SUBSYSTEM_USB:\n\t\treturn uncommon_valid;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic inline bool kcov_check_handle(u64 handle, bool common_valid,\n\t\t\t\tbool uncommon_valid, bool zero_valid)\n{\n\tif (handle & ~(KCOV_SUBSYSTEM_MASK | KCOV_INSTANCE_MASK))\n\t\treturn false;\n\tswitch (handle & KCOV_SUBSYSTEM_MASK) {\n\tcase KCOV_SUBSYSTEM_COMMON:\n\t\treturn (handle & KCOV_INSTANCE_MASK) ?\n\t\t\tcommon_valid : zero_valid;\n\tcase KCOV_SUBSYSTEM_USB:\n\t\treturn uncommon_valid;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "kcov_fault_in_area",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "536-544",
    "snippet": "static void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "area[offset]"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}"
  },
  {
    "function_name": "kcov_get_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "517-529",
    "snippet": "static int kcov_get_mode(unsigned long arg)\n{\n\tif (arg == KCOV_TRACE_PC)\n\t\treturn KCOV_MODE_TRACE_PC;\n\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\treturn KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\telse\n\t\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_get_mode(unsigned long arg)\n{\n\tif (arg == KCOV_TRACE_PC)\n\t\treturn KCOV_MODE_TRACE_PC;\n\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\treturn KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\telse\n\t\treturn -EINVAL;\n}"
  },
  {
    "function_name": "kcov_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "511-515",
    "snippet": "static int kcov_close(struct inode *inode, struct file *filep)\n{\n\tkcov_put(filep->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_put",
          "args": [
            "filep->private_data"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "407-414",
          "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_close(struct inode *inode, struct file *filep)\n{\n\tkcov_put(filep->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "kcov_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "496-509",
    "snippet": "static int kcov_open(struct inode *inode, struct file *filep)\n{\n\tstruct kcov *kcov;\n\n\tkcov = kzalloc(sizeof(*kcov), GFP_KERNEL);\n\tif (!kcov)\n\t\treturn -ENOMEM;\n\tkcov->mode = KCOV_MODE_DISABLED;\n\tkcov->sequence = 1;\n\trefcount_set(&kcov->refcount, 1);\n\tspin_lock_init(&kcov->lock);\n\tfilep->private_data = kcov;\n\treturn nonseekable_open(inode, filep);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nonseekable_open",
          "args": [
            "inode",
            "filep"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&kcov->lock"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&kcov->refcount",
            "1"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*kcov)",
            "GFP_KERNEL"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_open(struct inode *inode, struct file *filep)\n{\n\tstruct kcov *kcov;\n\n\tkcov = kzalloc(sizeof(*kcov), GFP_KERNEL);\n\tif (!kcov)\n\t\treturn -ENOMEM;\n\tkcov->mode = KCOV_MODE_DISABLED;\n\tkcov->sequence = 1;\n\trefcount_set(&kcov->refcount, 1);\n\tspin_lock_init(&kcov->lock);\n\tfilep->private_data = kcov;\n\treturn nonseekable_open(inode, filep);\n}"
  },
  {
    "function_name": "kcov_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "459-494",
    "snippet": "static int kcov_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tint res = 0;\n\tvoid *area;\n\tstruct kcov *kcov = vma->vm_file->private_data;\n\tunsigned long size, off;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tarea = vmalloc_user(vma->vm_end - vma->vm_start);\n\tif (!area)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tsize = kcov->size * sizeof(unsigned long);\n\tif (kcov->mode != KCOV_MODE_INIT || vma->vm_pgoff != 0 ||\n\t    vma->vm_end - vma->vm_start != size) {\n\t\tres = -EINVAL;\n\t\tgoto exit;\n\t}\n\tif (!kcov->area) {\n\t\tkcov->area = area;\n\t\tvma->vm_flags |= VM_DONTEXPAND;\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\tfor (off = 0; off < size; off += PAGE_SIZE) {\n\t\t\tpage = vmalloc_to_page(kcov->area + off);\n\t\t\tif (vm_insert_page(vma, vma->vm_start + off, page))\n\t\t\t\tWARN_ONCE(1, \"vm_insert_page() failed\");\n\t\t}\n\t\treturn 0;\n\t}\nexit:\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\tvfree(area);\n\treturn res;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "area"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kcov->lock",
            "flags"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"vm_insert_page() failed\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_insert_page",
          "args": [
            "vma",
            "vma->vm_start + off",
            "page"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "kcov->area + off"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kcov->lock",
            "flags"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc_user",
          "args": [
            "vma->vm_end - vma->vm_start"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tint res = 0;\n\tvoid *area;\n\tstruct kcov *kcov = vma->vm_file->private_data;\n\tunsigned long size, off;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tarea = vmalloc_user(vma->vm_end - vma->vm_start);\n\tif (!area)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tsize = kcov->size * sizeof(unsigned long);\n\tif (kcov->mode != KCOV_MODE_INIT || vma->vm_pgoff != 0 ||\n\t    vma->vm_end - vma->vm_start != size) {\n\t\tres = -EINVAL;\n\t\tgoto exit;\n\t}\n\tif (!kcov->area) {\n\t\tkcov->area = area;\n\t\tvma->vm_flags |= VM_DONTEXPAND;\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\tfor (off = 0; off < size; off += PAGE_SIZE) {\n\t\t\tpage = vmalloc_to_page(kcov->area + off);\n\t\t\tif (vm_insert_page(vma, vma->vm_start + off, page))\n\t\t\t\tWARN_ONCE(1, \"vm_insert_page() failed\");\n\t\t}\n\t\treturn 0;\n\t}\nexit:\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\tvfree(area);\n\treturn res;\n}"
  },
  {
    "function_name": "kcov_task_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "416-457",
    "snippet": "void kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\tunsigned long flags;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tkcov_debug(\"t = %px, kcov->t = %px\\n\", t, kcov->t);\n\t/*\n\t * For KCOV_ENABLE devices we want to make sure that t->kcov->t == t,\n\t * which comes down to:\n\t *        WARN_ON(!kcov->remote && kcov->t != t);\n\t *\n\t * For KCOV_REMOTE_ENABLE devices, the exiting task is either:\n\t *\n\t * 1. A remote task between kcov_remote_start() and kcov_remote_stop().\n\t *    In this case we should print a warning right away, since a task\n\t *    shouldn't be exiting when it's in a kcov coverage collection\n\t *    section. Here t points to the task that is collecting remote\n\t *    coverage, and t->kcov->t points to the thread that created the\n\t *    kcov device. Which means that to detect this case we need to\n\t *    check that t != t->kcov->t, and this gives us the following:\n\t *        WARN_ON(kcov->remote && kcov->t != t);\n\t *\n\t * 2. The task that created kcov exiting without calling KCOV_DISABLE,\n\t *    and then again we make sure that t->kcov->t == t:\n\t *        WARN_ON(kcov->remote && kcov->t != t);\n\t *\n\t * By combining all three checks into one we get:\n\t */\n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\treturn;\n\t}\n\t/* Just to not leave dangling references behind. */\n\tkcov_disable(t, kcov);\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\tkcov_put(kcov);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_put",
          "args": [
            "kcov"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "407-414",
          "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kcov->lock",
            "flags"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_disable",
          "args": [
            "t",
            "kcov"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "393-400",
          "snippet": "static void kcov_disable(struct task_struct *t, struct kcov *kcov)\n{\n\tkcov_task_reset(t);\n\tif (kcov->remote)\n\t\tkcov_remote_reset(kcov);\n\telse\n\t\tkcov_reset(kcov);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_disable(struct task_struct *t, struct kcov *kcov)\n{\n\tkcov_task_reset(t);\n\tif (kcov->remote)\n\t\tkcov_remote_reset(kcov);\n\telse\n\t\tkcov_reset(kcov);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kcov->t != t"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_debug",
          "args": [
            "\"t = %px, kcov->t = %px\\n\"",
            "t",
            "kcov->t"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kcov->lock",
            "flags"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\tunsigned long flags;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tkcov_debug(\"t = %px, kcov->t = %px\\n\", t, kcov->t);\n\t/*\n\t * For KCOV_ENABLE devices we want to make sure that t->kcov->t == t,\n\t * which comes down to:\n\t *        WARN_ON(!kcov->remote && kcov->t != t);\n\t *\n\t * For KCOV_REMOTE_ENABLE devices, the exiting task is either:\n\t *\n\t * 1. A remote task between kcov_remote_start() and kcov_remote_stop().\n\t *    In this case we should print a warning right away, since a task\n\t *    shouldn't be exiting when it's in a kcov coverage collection\n\t *    section. Here t points to the task that is collecting remote\n\t *    coverage, and t->kcov->t points to the thread that created the\n\t *    kcov device. Which means that to detect this case we need to\n\t *    check that t != t->kcov->t, and this gives us the following:\n\t *        WARN_ON(kcov->remote && kcov->t != t);\n\t *\n\t * 2. The task that created kcov exiting without calling KCOV_DISABLE,\n\t *    and then again we make sure that t->kcov->t == t:\n\t *        WARN_ON(kcov->remote && kcov->t != t);\n\t *\n\t * By combining all three checks into one we get:\n\t */\n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\treturn;\n\t}\n\t/* Just to not leave dangling references behind. */\n\tkcov_disable(t, kcov);\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\tkcov_put(kcov);\n}"
  },
  {
    "function_name": "kcov_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "407-414",
    "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kcov"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "kcov->area"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_remote_reset",
          "args": [
            "kcov"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "374-391",
          "snippet": "static void kcov_remote_reset(struct kcov *kcov)\n{\n\tint bkt;\n\tstruct kcov_remote *remote;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\thash_for_each_safe(kcov_remote_map, bkt, tmp, remote, hnode) {\n\t\tif (remote->kcov != kcov)\n\t\t\tcontinue;\n\t\thash_del(&remote->hnode);\n\t\tkfree(remote);\n\t}\n\t/* Do reset before unlock to prevent races with kcov_remote_start(). */\n\tkcov_reset(kcov);\n\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kcov_remote_lock);",
            "static DEFINE_HASHTABLE(kcov_remote_map, 4);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(kcov_remote_lock);\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\n\nstatic void kcov_remote_reset(struct kcov *kcov)\n{\n\tint bkt;\n\tstruct kcov_remote *remote;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\thash_for_each_safe(kcov_remote_map, bkt, tmp, remote, hnode) {\n\t\tif (remote->kcov != kcov)\n\t\t\tcontinue;\n\t\thash_del(&remote->hnode);\n\t\tkfree(remote);\n\t}\n\t/* Do reset before unlock to prevent races with kcov_remote_start(). */\n\tkcov_reset(kcov);\n\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&kcov->refcount"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
  },
  {
    "function_name": "kcov_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "402-405",
    "snippet": "static void kcov_get(struct kcov *kcov)\n{\n\trefcount_inc(&kcov->refcount);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&kcov->refcount"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_get(struct kcov *kcov)\n{\n\trefcount_inc(&kcov->refcount);\n}"
  },
  {
    "function_name": "kcov_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "393-400",
    "snippet": "static void kcov_disable(struct task_struct *t, struct kcov *kcov)\n{\n\tkcov_task_reset(t);\n\tif (kcov->remote)\n\t\tkcov_remote_reset(kcov);\n\telse\n\t\tkcov_reset(kcov);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_reset",
          "args": [
            "kcov"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "365-372",
          "snippet": "static void kcov_reset(struct kcov *kcov)\n{\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tkcov->remote = false;\n\tkcov->remote_size = 0;\n\tkcov->sequence++;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_reset(struct kcov *kcov)\n{\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tkcov->remote = false;\n\tkcov->remote_size = 0;\n\tkcov->sequence++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_remote_reset",
          "args": [
            "kcov"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "374-391",
          "snippet": "static void kcov_remote_reset(struct kcov *kcov)\n{\n\tint bkt;\n\tstruct kcov_remote *remote;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\thash_for_each_safe(kcov_remote_map, bkt, tmp, remote, hnode) {\n\t\tif (remote->kcov != kcov)\n\t\t\tcontinue;\n\t\thash_del(&remote->hnode);\n\t\tkfree(remote);\n\t}\n\t/* Do reset before unlock to prevent races with kcov_remote_start(). */\n\tkcov_reset(kcov);\n\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kcov_remote_lock);",
            "static DEFINE_HASHTABLE(kcov_remote_map, 4);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(kcov_remote_lock);\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\n\nstatic void kcov_remote_reset(struct kcov *kcov)\n{\n\tint bkt;\n\tstruct kcov_remote *remote;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\thash_for_each_safe(kcov_remote_map, bkt, tmp, remote, hnode) {\n\t\tif (remote->kcov != kcov)\n\t\t\tcontinue;\n\t\thash_del(&remote->hnode);\n\t\tkfree(remote);\n\t}\n\t/* Do reset before unlock to prevent races with kcov_remote_start(). */\n\tkcov_reset(kcov);\n\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_task_reset",
          "args": [
            "t"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_task_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "352-357",
          "snippet": "static void kcov_task_reset(struct task_struct *t)\n{\n\tkcov_stop(t);\n\tt->kcov_sequence = 0;\n\tt->kcov_handle = 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_task_reset(struct task_struct *t)\n{\n\tkcov_stop(t);\n\tt->kcov_sequence = 0;\n\tt->kcov_handle = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_disable(struct task_struct *t, struct kcov *kcov)\n{\n\tkcov_task_reset(t);\n\tif (kcov->remote)\n\t\tkcov_remote_reset(kcov);\n\telse\n\t\tkcov_reset(kcov);\n}"
  },
  {
    "function_name": "kcov_remote_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "374-391",
    "snippet": "static void kcov_remote_reset(struct kcov *kcov)\n{\n\tint bkt;\n\tstruct kcov_remote *remote;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\thash_for_each_safe(kcov_remote_map, bkt, tmp, remote, hnode) {\n\t\tif (remote->kcov != kcov)\n\t\t\tcontinue;\n\t\thash_del(&remote->hnode);\n\t\tkfree(remote);\n\t}\n\t/* Do reset before unlock to prevent races with kcov_remote_start(). */\n\tkcov_reset(kcov);\n\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kcov_remote_lock);",
      "static DEFINE_HASHTABLE(kcov_remote_map, 4);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kcov_remote_lock",
            "flags"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_reset",
          "args": [
            "kcov"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "365-372",
          "snippet": "static void kcov_reset(struct kcov *kcov)\n{\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tkcov->remote = false;\n\tkcov->remote_size = 0;\n\tkcov->sequence++;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_reset(struct kcov *kcov)\n{\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tkcov->remote = false;\n\tkcov->remote_size = 0;\n\tkcov->sequence++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "remote"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&remote->hnode"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each_safe",
          "args": [
            "kcov_remote_map",
            "bkt",
            "tmp",
            "remote",
            "hnode"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kcov_remote_lock",
            "flags"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(kcov_remote_lock);\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\n\nstatic void kcov_remote_reset(struct kcov *kcov)\n{\n\tint bkt;\n\tstruct kcov_remote *remote;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\thash_for_each_safe(kcov_remote_map, bkt, tmp, remote, hnode) {\n\t\tif (remote->kcov != kcov)\n\t\t\tcontinue;\n\t\thash_del(&remote->hnode);\n\t\tkfree(remote);\n\t}\n\t/* Do reset before unlock to prevent races with kcov_remote_start(). */\n\tkcov_reset(kcov);\n\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n}"
  },
  {
    "function_name": "kcov_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "365-372",
    "snippet": "static void kcov_reset(struct kcov *kcov)\n{\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tkcov->remote = false;\n\tkcov->remote_size = 0;\n\tkcov->sequence++;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_reset(struct kcov *kcov)\n{\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tkcov->remote = false;\n\tkcov->remote_size = 0;\n\tkcov->sequence++;\n}"
  },
  {
    "function_name": "kcov_task_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "359-363",
    "snippet": "void kcov_task_init(struct task_struct *t)\n{\n\tkcov_task_reset(t);\n\tt->kcov_handle = current->kcov_handle;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_task_reset",
          "args": [
            "t"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_task_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "352-357",
          "snippet": "static void kcov_task_reset(struct task_struct *t)\n{\n\tkcov_stop(t);\n\tt->kcov_sequence = 0;\n\tt->kcov_handle = 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_task_reset(struct task_struct *t)\n{\n\tkcov_stop(t);\n\tt->kcov_sequence = 0;\n\tt->kcov_handle = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid kcov_task_init(struct task_struct *t)\n{\n\tkcov_task_reset(t);\n\tt->kcov_handle = current->kcov_handle;\n}"
  },
  {
    "function_name": "kcov_task_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "352-357",
    "snippet": "static void kcov_task_reset(struct task_struct *t)\n{\n\tkcov_stop(t);\n\tt->kcov_sequence = 0;\n\tt->kcov_handle = 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_stop",
          "args": [
            "t"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "343-350",
          "snippet": "static void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_task_reset(struct task_struct *t)\n{\n\tkcov_stop(t);\n\tt->kcov_sequence = 0;\n\tt->kcov_handle = 0;\n}"
  },
  {
    "function_name": "kcov_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "343-350",
    "snippet": "static void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "t->kcov_mode",
            "KCOV_MODE_DISABLED"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}"
  },
  {
    "function_name": "kcov_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "328-341",
    "snippet": "static void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t/* Cache in task struct for performance. */\n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t/* See comment in check_kcov_mode(). */\n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "t->kcov_mode",
            "mode"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_debug",
          "args": [
            "\"t = %px, size = %u, area = %px\\n\"",
            "t",
            "size",
            "area"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t/* Cache in task struct for performance. */\n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t/* See comment in check_kcov_mode(). */\n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "299-324",
    "snippet": "void notrace __sanitizer_cov_trace_switch(u64 val, u64 *cases)\n{\n\tu64 i;\n\tu64 count = cases[0];\n\tu64 size = cases[1];\n\tu64 type = KCOV_CMP_CONST;\n\n\tswitch (size) {\n\tcase 8:\n\t\ttype |= KCOV_CMP_SIZE(0);\n\t\tbreak;\n\tcase 16:\n\t\ttype |= KCOV_CMP_SIZE(1);\n\t\tbreak;\n\tcase 32:\n\t\ttype |= KCOV_CMP_SIZE(2);\n\t\tbreak;\n\tcase 64:\n\t\ttype |= KCOV_CMP_SIZE(3);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tfor (i = 0; i < count; i++)\n\t\twrite_comp_data(type, cases[i + 2], val, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "type",
            "cases[i + 2]",
            "val",
            "_RET_IP_"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "3"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "2"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "1"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_switch(u64 val, u64 *cases)\n{\n\tu64 i;\n\tu64 count = cases[0];\n\tu64 size = cases[1];\n\tu64 type = KCOV_CMP_CONST;\n\n\tswitch (size) {\n\tcase 8:\n\t\ttype |= KCOV_CMP_SIZE(0);\n\t\tbreak;\n\tcase 16:\n\t\ttype |= KCOV_CMP_SIZE(1);\n\t\tbreak;\n\tcase 32:\n\t\ttype |= KCOV_CMP_SIZE(2);\n\t\tbreak;\n\tcase 64:\n\t\ttype |= KCOV_CMP_SIZE(3);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tfor (i = 0; i < count; i++)\n\t\twrite_comp_data(type, cases[i + 2], val, _RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_const_cmp8",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "292-296",
    "snippet": "void notrace __sanitizer_cov_trace_const_cmp8(u64 arg1, u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(3) | KCOV_CMP_CONST",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "3"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_const_cmp8(u64 arg1, u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_const_cmp4",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "285-289",
    "snippet": "void notrace __sanitizer_cov_trace_const_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(2) | KCOV_CMP_CONST",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "2"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_const_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_const_cmp2",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "278-282",
    "snippet": "void notrace __sanitizer_cov_trace_const_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(1) | KCOV_CMP_CONST",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "1"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_const_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_const_cmp1",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "271-275",
    "snippet": "void notrace __sanitizer_cov_trace_const_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(0) | KCOV_CMP_CONST",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_const_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_cmp8",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "265-268",
    "snippet": "void notrace __sanitizer_cov_trace_cmp8(u64 arg1, u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3), arg1, arg2, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(3)",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "3"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_cmp8(u64 arg1, u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3), arg1, arg2, _RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_cmp4",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "259-262",
    "snippet": "void notrace __sanitizer_cov_trace_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2), arg1, arg2, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(2)",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "2"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2), arg1, arg2, _RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_cmp2",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "253-256",
    "snippet": "void notrace __sanitizer_cov_trace_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1), arg1, arg2, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(1)",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "1"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1), arg1, arg2, _RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_cmp1",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "247-250",
    "snippet": "void notrace __sanitizer_cov_trace_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0), arg1, arg2, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(0)",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "214-245",
          "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "0"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0), arg1, arg2, _RET_IP_);\n}"
  },
  {
    "function_name": "write_comp_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "214-245",
    "snippet": "static void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define KCOV_WORDS_PER_CMP 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "area[0]",
            "count + 1"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "end_pos <= max_pos"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "area[0]"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalize_ip",
          "args": [
            "ip"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "canonicalize_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "180-186",
          "snippet": "static notrace unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic notrace unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kcov_mode",
          "args": [
            "KCOV_MODE_TRACE_CMP",
            "t"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "check_kcov_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "157-178",
          "snippet": "static notrace bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts, unless we are in a remote\n\t * coverage collection section in a softirq.\n\t */\n\tif (!in_task() && !(in_serving_softirq() && t->kcov_softirq))\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_start().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic notrace bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts, unless we are in a remote\n\t * coverage collection section in a softirq.\n\t */\n\tif (!in_task() && !(in_serving_softirq() && t->kcov_softirq))\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_start().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_pc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "192-210",
    "snippet": "void notrace __sanitizer_cov_trace_pc(void)\n{\n\tstruct task_struct *t;\n\tunsigned long *area;\n\tunsigned long ip = canonicalize_ip(_RET_IP_);\n\tunsigned long pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_PC, t))\n\t\treturn;\n\n\tarea = t->kcov_area;\n\t/* The first 64-bit word is the number of subsequent PCs. */\n\tpos = READ_ONCE(area[0]) + 1;\n\tif (likely(pos < t->kcov_size)) {\n\t\tarea[pos] = ip;\n\t\tWRITE_ONCE(area[0], pos);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "area[0]",
            "pos"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pos < t->kcov_size"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "area[0]"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_kcov_mode",
          "args": [
            "KCOV_MODE_TRACE_PC",
            "t"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "check_kcov_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "157-178",
          "snippet": "static notrace bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts, unless we are in a remote\n\t * coverage collection section in a softirq.\n\t */\n\tif (!in_task() && !(in_serving_softirq() && t->kcov_softirq))\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_start().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic notrace bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts, unless we are in a remote\n\t * coverage collection section in a softirq.\n\t */\n\tif (!in_task() && !(in_serving_softirq() && t->kcov_softirq))\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_start().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalize_ip",
          "args": [
            "_RET_IP_"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "canonicalize_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "180-186",
          "snippet": "static notrace unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic notrace unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_pc(void)\n{\n\tstruct task_struct *t;\n\tunsigned long *area;\n\tunsigned long ip = canonicalize_ip(_RET_IP_);\n\tunsigned long pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_PC, t))\n\t\treturn;\n\n\tarea = t->kcov_area;\n\t/* The first 64-bit word is the number of subsequent PCs. */\n\tpos = READ_ONCE(area[0]) + 1;\n\tif (likely(pos < t->kcov_size)) {\n\t\tarea[pos] = ip;\n\t\tWRITE_ONCE(area[0], pos);\n\t}\n}"
  },
  {
    "function_name": "canonicalize_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "180-186",
    "snippet": "static notrace unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kaslr_offset",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic notrace unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}"
  },
  {
    "function_name": "check_kcov_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "157-178",
    "snippet": "static notrace bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts, unless we are in a remote\n\t * coverage collection section in a softirq.\n\t */\n\tif (!in_task() && !(in_serving_softirq() && t->kcov_softirq))\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_start().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->kcov_mode"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic notrace bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts, unless we are in a remote\n\t * coverage collection section in a softirq.\n\t */\n\tif (!in_task() && !(in_serving_softirq() && t->kcov_softirq))\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_start().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}"
  },
  {
    "function_name": "kcov_remote_area_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "149-155",
    "snippet": "static void kcov_remote_area_put(struct kcov_remote_area *area,\n\t\t\t\t\tunsigned int size)\n{\n\tINIT_LIST_HEAD(&area->list);\n\tarea->size = size;\n\tlist_add(&area->list, &kcov_remote_areas);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&area->list",
            "&kcov_remote_areas"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&area->list"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);\n\nstatic void kcov_remote_area_put(struct kcov_remote_area *area,\n\t\t\t\t\tunsigned int size)\n{\n\tINIT_LIST_HEAD(&area->list);\n\tarea->size = size;\n\tlist_add(&area->list, &kcov_remote_areas);\n}"
  },
  {
    "function_name": "kcov_remote_area_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "133-146",
    "snippet": "static struct kcov_remote_area *kcov_remote_area_get(unsigned int size)\n{\n\tstruct kcov_remote_area *area;\n\tstruct list_head *pos;\n\n\tlist_for_each(pos, &kcov_remote_areas) {\n\t\tarea = list_entry(pos, struct kcov_remote_area, list);\n\t\tif (area->size == size) {\n\t\t\tlist_del(&area->list);\n\t\t\treturn area;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&area->list"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structkcov_remote_area",
            "list"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos",
            "&kcov_remote_areas"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);\n\nstatic struct kcov_remote_area *kcov_remote_area_get(unsigned int size)\n{\n\tstruct kcov_remote_area *area;\n\tstruct list_head *pos;\n\n\tlist_for_each(pos, &kcov_remote_areas) {\n\t\tarea = list_entry(pos, struct kcov_remote_area, list);\n\t\tif (area->size == size) {\n\t\t\tlist_del(&area->list);\n\t\t\treturn area;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "kcov_remote_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "117-130",
    "snippet": "static struct kcov_remote *kcov_remote_add(struct kcov *kcov, u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\tif (kcov_remote_find(handle))\n\t\treturn ERR_PTR(-EEXIST);\n\tremote = kmalloc(sizeof(*remote), GFP_ATOMIC);\n\tif (!remote)\n\t\treturn ERR_PTR(-ENOMEM);\n\tremote->handle = handle;\n\tremote->kcov = kcov;\n\thash_add(kcov_remote_map, &remote->hnode, handle);\n\treturn remote;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(kcov_remote_map, 4);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "kcov_remote_map",
            "&remote->hnode",
            "handle"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*remote)",
            "GFP_ATOMIC"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EEXIST"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_remote_find",
          "args": [
            "handle"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_remote_find",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "105-114",
          "snippet": "static struct kcov_remote *kcov_remote_find(u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\thash_for_each_possible(kcov_remote_map, remote, hnode, handle) {\n\t\tif (remote->handle == handle)\n\t\t\treturn remote;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(kcov_remote_map, 4);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\n\nstatic struct kcov_remote *kcov_remote_find(u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\thash_for_each_possible(kcov_remote_map, remote, hnode, handle) {\n\t\tif (remote->handle == handle)\n\t\t\treturn remote;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\n\nstatic struct kcov_remote *kcov_remote_add(struct kcov *kcov, u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\tif (kcov_remote_find(handle))\n\t\treturn ERR_PTR(-EEXIST);\n\tremote = kmalloc(sizeof(*remote), GFP_ATOMIC);\n\tif (!remote)\n\t\treturn ERR_PTR(-ENOMEM);\n\tremote->handle = handle;\n\tremote->kcov = kcov;\n\thash_add(kcov_remote_map, &remote->hnode, handle);\n\treturn remote;\n}"
  },
  {
    "function_name": "kcov_remote_find",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
    "lines": "105-114",
    "snippet": "static struct kcov_remote *kcov_remote_find(u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\thash_for_each_possible(kcov_remote_map, remote, hnode, handle) {\n\t\tif (remote->handle == handle)\n\t\t\treturn remote;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/log2.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(kcov_remote_map, 4);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "kcov_remote_map",
            "remote",
            "hnode",
            "handle"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\n\nstatic struct kcov_remote *kcov_remote_find(u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\thash_for_each_possible(kcov_remote_map, remote, hnode, handle) {\n\t\tif (remote->handle == handle)\n\t\t\treturn remote;\n\t}\n\treturn NULL;\n}"
  }
]