[
  {
    "function_name": "pcpu_freelist_pop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "200-209",
    "snippet": "struct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_node *ret;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tret = __pcpu_freelist_pop(s);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pcpu_freelist_pop",
          "args": [
            "s"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__pcpu_freelist_pop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "193-198",
          "snippet": "struct pcpu_freelist_node *__pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tif (in_nmi())\n\t\treturn ___pcpu_freelist_pop_nmi(s);\n\treturn ___pcpu_freelist_pop(s);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstruct pcpu_freelist_node *__pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tif (in_nmi())\n\t\treturn ___pcpu_freelist_pop_nmi(s);\n\treturn ___pcpu_freelist_pop(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstruct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_node *ret;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tret = __pcpu_freelist_pop(s);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__pcpu_freelist_pop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "193-198",
    "snippet": "struct pcpu_freelist_node *__pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tif (in_nmi())\n\t\treturn ___pcpu_freelist_pop_nmi(s);\n\treturn ___pcpu_freelist_pop(s);\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___pcpu_freelist_pop",
          "args": [
            "s"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "___pcpu_freelist_pop_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "157-191",
          "snippet": "static struct pcpu_freelist_node *\n___pcpu_freelist_pop_nmi(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tint orig_cpu, cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tnode = head->first;\n\t\t\tif (node) {\n\t\t\t\thead->first = node->next;\n\t\t\t\traw_spin_unlock(&head->lock);\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\traw_spin_unlock(&head->lock);\n\t\t}\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu)\n\t\t\tbreak;\n\t}\n\n\t/* cannot pop from per cpu lists, try extralist */\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn NULL;\n\tnode = s->extralist.first;\n\tif (node)\n\t\ts->extralist.first = node->next;\n\traw_spin_unlock(&s->extralist.lock);\n\treturn node;\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic struct pcpu_freelist_node *\n___pcpu_freelist_pop_nmi(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tint orig_cpu, cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tnode = head->first;\n\t\t\tif (node) {\n\t\t\t\thead->first = node->next;\n\t\t\t\traw_spin_unlock(&head->lock);\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\traw_spin_unlock(&head->lock);\n\t\t}\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu)\n\t\t\tbreak;\n\t}\n\n\t/* cannot pop from per cpu lists, try extralist */\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn NULL;\n\tnode = s->extralist.first;\n\tif (node)\n\t\ts->extralist.first = node->next;\n\traw_spin_unlock(&s->extralist.lock);\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstruct pcpu_freelist_node *__pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tif (in_nmi())\n\t\treturn ___pcpu_freelist_pop_nmi(s);\n\treturn ___pcpu_freelist_pop(s);\n}"
  },
  {
    "function_name": "___pcpu_freelist_pop_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "157-191",
    "snippet": "static struct pcpu_freelist_node *\n___pcpu_freelist_pop_nmi(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tint orig_cpu, cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tnode = head->first;\n\t\t\tif (node) {\n\t\t\t\thead->first = node->next;\n\t\t\t\traw_spin_unlock(&head->lock);\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\traw_spin_unlock(&head->lock);\n\t\t}\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu)\n\t\t\tbreak;\n\t}\n\n\t/* cannot pop from per cpu lists, try extralist */\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn NULL;\n\tnode = s->extralist.first;\n\tif (node)\n\t\ts->extralist.first = node->next;\n\traw_spin_unlock(&s->extralist.lock);\n\treturn node;\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&s->extralist.lock"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&s->extralist.lock"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "cpu",
            "cpu_possible_mask"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->freelist",
            "cpu"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic struct pcpu_freelist_node *\n___pcpu_freelist_pop_nmi(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tint orig_cpu, cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tnode = head->first;\n\t\t\tif (node) {\n\t\t\t\thead->first = node->next;\n\t\t\t\traw_spin_unlock(&head->lock);\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\traw_spin_unlock(&head->lock);\n\t\t}\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu)\n\t\t\tbreak;\n\t}\n\n\t/* cannot pop from per cpu lists, try extralist */\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn NULL;\n\tnode = s->extralist.first;\n\tif (node)\n\t\ts->extralist.first = node->next;\n\traw_spin_unlock(&s->extralist.lock);\n\treturn node;\n}"
  },
  {
    "function_name": "___pcpu_freelist_pop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "124-155",
    "snippet": "static struct pcpu_freelist_node *___pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tint orig_cpu, cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\traw_spin_lock(&head->lock);\n\t\tnode = head->first;\n\t\tif (node) {\n\t\t\thead->first = node->next;\n\t\t\traw_spin_unlock(&head->lock);\n\t\t\treturn node;\n\t\t}\n\t\traw_spin_unlock(&head->lock);\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu)\n\t\t\tbreak;\n\t}\n\n\t/* per cpu lists are all empty, try extralist */\n\traw_spin_lock(&s->extralist.lock);\n\tnode = s->extralist.first;\n\tif (node)\n\t\ts->extralist.first = node->next;\n\traw_spin_unlock(&s->extralist.lock);\n\treturn node;\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&s->extralist.lock"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&s->extralist.lock"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "cpu",
            "cpu_possible_mask"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->freelist",
            "cpu"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic struct pcpu_freelist_node *___pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tint orig_cpu, cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\traw_spin_lock(&head->lock);\n\t\tnode = head->first;\n\t\tif (node) {\n\t\t\thead->first = node->next;\n\t\t\traw_spin_unlock(&head->lock);\n\t\t\treturn node;\n\t\t}\n\t\traw_spin_unlock(&head->lock);\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu)\n\t\t\tbreak;\n\t}\n\n\t/* per cpu lists are all empty, try extralist */\n\traw_spin_lock(&s->extralist.lock);\n\tnode = s->extralist.first;\n\tif (node)\n\t\ts->extralist.first = node->next;\n\traw_spin_unlock(&s->extralist.lock);\n\treturn node;\n}"
  },
  {
    "function_name": "pcpu_freelist_populate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "101-122",
    "snippet": "void pcpu_freelist_populate(struct pcpu_freelist *s, void *buf, u32 elem_size,\n\t\t\t    u32 nr_elems)\n{\n\tstruct pcpu_freelist_head *head;\n\tint i, cpu, pcpu_entries;\n\n\tpcpu_entries = nr_elems / num_possible_cpus() + 1;\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\nagain:\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\t/* No locking required as this is not visible yet. */\n\t\tpcpu_freelist_push_node(head, buf);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_freelist_push_node",
          "args": [
            "head",
            "buf"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_push_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "30-35",
          "snippet": "static inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->freelist",
            "cpu"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_populate(struct pcpu_freelist *s, void *buf, u32 elem_size,\n\t\t\t    u32 nr_elems)\n{\n\tstruct pcpu_freelist_head *head;\n\tint i, cpu, pcpu_entries;\n\n\tpcpu_entries = nr_elems / num_possible_cpus() + 1;\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\nagain:\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\t/* No locking required as this is not visible yet. */\n\t\tpcpu_freelist_push_node(head, buf);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}"
  },
  {
    "function_name": "pcpu_freelist_push",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "91-99",
    "snippet": "void pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__pcpu_freelist_push(s, node);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pcpu_freelist_push",
          "args": [
            "s",
            "node"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__pcpu_freelist_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "82-89",
          "snippet": "void __pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (in_nmi())\n\t\t___pcpu_freelist_push_nmi(s, node);\n\telse\n\t\t___pcpu_freelist_push(this_cpu_ptr(s->freelist), node);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid __pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (in_nmi())\n\t\t___pcpu_freelist_push_nmi(s, node);\n\telse\n\t\t___pcpu_freelist_push(this_cpu_ptr(s->freelist), node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__pcpu_freelist_push(s, node);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__pcpu_freelist_push",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "82-89",
    "snippet": "void __pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (in_nmi())\n\t\t___pcpu_freelist_push_nmi(s, node);\n\telse\n\t\t___pcpu_freelist_push(this_cpu_ptr(s->freelist), node);\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___pcpu_freelist_push",
          "args": [
            "this_cpu_ptr(s->freelist)",
            "node"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "___pcpu_freelist_push_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "56-80",
          "snippet": "static inline void ___pcpu_freelist_push_nmi(struct pcpu_freelist *s,\n\t\t\t\t\t     struct pcpu_freelist_node *node)\n{\n\tint cpu, orig_cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\tstruct pcpu_freelist_head *head;\n\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tpcpu_freelist_push_node(head, node);\n\t\t\traw_spin_unlock(&head->lock);\n\t\t\treturn;\n\t\t}\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\n\t\t/* cannot lock any per cpu lock, try extralist */\n\t\tif (cpu == orig_cpu &&\n\t\t    pcpu_freelist_try_push_extra(s, node))\n\t\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline void ___pcpu_freelist_push_nmi(struct pcpu_freelist *s,\n\t\t\t\t\t     struct pcpu_freelist_node *node)\n{\n\tint cpu, orig_cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\tstruct pcpu_freelist_head *head;\n\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tpcpu_freelist_push_node(head, node);\n\t\t\traw_spin_unlock(&head->lock);\n\t\t\treturn;\n\t\t}\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\n\t\t/* cannot lock any per cpu lock, try extralist */\n\t\tif (cpu == orig_cpu &&\n\t\t    pcpu_freelist_try_push_extra(s, node))\n\t\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s->freelist"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid __pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (in_nmi())\n\t\t___pcpu_freelist_push_nmi(s, node);\n\telse\n\t\t___pcpu_freelist_push(this_cpu_ptr(s->freelist), node);\n}"
  },
  {
    "function_name": "___pcpu_freelist_push_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "56-80",
    "snippet": "static inline void ___pcpu_freelist_push_nmi(struct pcpu_freelist *s,\n\t\t\t\t\t     struct pcpu_freelist_node *node)\n{\n\tint cpu, orig_cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\tstruct pcpu_freelist_head *head;\n\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tpcpu_freelist_push_node(head, node);\n\t\t\traw_spin_unlock(&head->lock);\n\t\t\treturn;\n\t\t}\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\n\t\t/* cannot lock any per cpu lock, try extralist */\n\t\tif (cpu == orig_cpu &&\n\t\t    pcpu_freelist_try_push_extra(s, node))\n\t\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_freelist_try_push_extra",
          "args": [
            "s",
            "node"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_try_push_extra",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "45-54",
          "snippet": "static inline bool pcpu_freelist_try_push_extra(struct pcpu_freelist *s,\n\t\t\t\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn false;\n\n\tpcpu_freelist_push_node(&s->extralist, node);\n\traw_spin_unlock(&s->extralist.lock);\n\treturn true;\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline bool pcpu_freelist_try_push_extra(struct pcpu_freelist *s,\n\t\t\t\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn false;\n\n\tpcpu_freelist_push_node(&s->extralist, node);\n\traw_spin_unlock(&s->extralist.lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "cpu",
            "cpu_possible_mask"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&head->lock"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_push_node",
          "args": [
            "head",
            "node"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_push_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "30-35",
          "snippet": "static inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&head->lock"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->freelist",
            "cpu"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline void ___pcpu_freelist_push_nmi(struct pcpu_freelist *s,\n\t\t\t\t\t     struct pcpu_freelist_node *node)\n{\n\tint cpu, orig_cpu;\n\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\tstruct pcpu_freelist_head *head;\n\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tpcpu_freelist_push_node(head, node);\n\t\t\traw_spin_unlock(&head->lock);\n\t\t\treturn;\n\t\t}\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\n\t\t/* cannot lock any per cpu lock, try extralist */\n\t\tif (cpu == orig_cpu &&\n\t\t    pcpu_freelist_try_push_extra(s, node))\n\t\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "pcpu_freelist_try_push_extra",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "45-54",
    "snippet": "static inline bool pcpu_freelist_try_push_extra(struct pcpu_freelist *s,\n\t\t\t\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn false;\n\n\tpcpu_freelist_push_node(&s->extralist, node);\n\traw_spin_unlock(&s->extralist.lock);\n\treturn true;\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&s->extralist.lock"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_push_node",
          "args": [
            "&s->extralist",
            "node"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_push_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "30-35",
          "snippet": "static inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&s->extralist.lock"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline bool pcpu_freelist_try_push_extra(struct pcpu_freelist *s,\n\t\t\t\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn false;\n\n\tpcpu_freelist_push_node(&s->extralist, node);\n\traw_spin_unlock(&s->extralist.lock);\n\treturn true;\n}"
  },
  {
    "function_name": "___pcpu_freelist_push",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "37-43",
    "snippet": "static inline void ___pcpu_freelist_push(struct pcpu_freelist_head *head,\n\t\t\t\t\t struct pcpu_freelist_node *node)\n{\n\traw_spin_lock(&head->lock);\n\tpcpu_freelist_push_node(head, node);\n\traw_spin_unlock(&head->lock);\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&head->lock"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_push_node",
          "args": [
            "head",
            "node"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_push_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
          "lines": "30-35",
          "snippet": "static inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&head->lock"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline void ___pcpu_freelist_push(struct pcpu_freelist_head *head,\n\t\t\t\t\t struct pcpu_freelist_node *node)\n{\n\traw_spin_lock(&head->lock);\n\tpcpu_freelist_push_node(head, node);\n\traw_spin_unlock(&head->lock);\n}"
  },
  {
    "function_name": "pcpu_freelist_push_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "30-35",
    "snippet": "static inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstatic inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}"
  },
  {
    "function_name": "pcpu_freelist_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "25-28",
    "snippet": "void pcpu_freelist_destroy(struct pcpu_freelist *s)\n{\n\tfree_percpu(s->freelist);\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "s->freelist"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_destroy(struct pcpu_freelist *s)\n{\n\tfree_percpu(s->freelist);\n}"
  },
  {
    "function_name": "pcpu_freelist_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/percpu_freelist.c",
    "lines": "6-23",
    "snippet": "int pcpu_freelist_init(struct pcpu_freelist *s)\n{\n\tint cpu;\n\n\ts->freelist = alloc_percpu(struct pcpu_freelist_head);\n\tif (!s->freelist)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct pcpu_freelist_head *head = per_cpu_ptr(s->freelist, cpu);\n\n\t\traw_spin_lock_init(&head->lock);\n\t\thead->first = NULL;\n\t}\n\traw_spin_lock_init(&s->extralist.lock);\n\ts->extralist.first = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu_freelist.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&s->extralist.lock"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&head->lock"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->freelist",
            "cpu"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structpcpu_freelist_head"
          ],
          "line": 10
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n\nint pcpu_freelist_init(struct pcpu_freelist *s)\n{\n\tint cpu;\n\n\ts->freelist = alloc_percpu(struct pcpu_freelist_head);\n\tif (!s->freelist)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct pcpu_freelist_head *head = per_cpu_ptr(s->freelist, cpu);\n\n\t\traw_spin_lock_init(&head->lock);\n\t\thead->first = NULL;\n\t}\n\traw_spin_lock_init(&s->extralist.lock);\n\ts->extralist.first = NULL;\n\treturn 0;\n}"
  }
]