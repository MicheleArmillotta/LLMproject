[
  {
    "function_name": "init_function_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "970-974",
    "snippet": "__init int init_function_trace(void)\n{\n\tinit_func_cmd_traceon();\n\treturn register_tracer(&function_trace);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&function_trace"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_func_cmd_traceon",
          "args": [],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "init_func_cmd_traceon",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "964-967",
          "snippet": "static inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n__init int init_function_trace(void)\n{\n\tinit_func_cmd_traceon();\n\treturn register_tracer(&function_trace);\n}"
  },
  {
    "function_name": "init_func_cmd_traceon",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "964-967",
    "snippet": "static inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "init_func_cmd_traceon",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "926-962",
    "snippet": "static int __init init_func_cmd_traceon(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&ftrace_traceoff_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_ftrace_command(&ftrace_traceon_cmd);\n\tif (ret)\n\t\tgoto out_free_traceoff;\n\n\tret = register_ftrace_command(&ftrace_stacktrace_cmd);\n\tif (ret)\n\t\tgoto out_free_traceon;\n\n\tret = register_ftrace_command(&ftrace_dump_cmd);\n\tif (ret)\n\t\tgoto out_free_stacktrace;\n\n\tret = register_ftrace_command(&ftrace_cpudump_cmd);\n\tif (ret)\n\t\tgoto out_free_dump;\n\n\treturn 0;\n\n out_free_dump:\n\tunregister_ftrace_command(&ftrace_dump_cmd);\n out_free_stacktrace:\n\tunregister_ftrace_command(&ftrace_stacktrace_cmd);\n out_free_traceon:\n\tunregister_ftrace_command(&ftrace_traceon_cmd);\n out_free_traceoff:\n\tunregister_ftrace_command(&ftrace_traceoff_cmd);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_command",
          "args": [
            "&ftrace_traceoff_cmd"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4851-4868",
          "snippet": "__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int __init init_func_cmd_traceon(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&ftrace_traceoff_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_ftrace_command(&ftrace_traceon_cmd);\n\tif (ret)\n\t\tgoto out_free_traceoff;\n\n\tret = register_ftrace_command(&ftrace_stacktrace_cmd);\n\tif (ret)\n\t\tgoto out_free_traceon;\n\n\tret = register_ftrace_command(&ftrace_dump_cmd);\n\tif (ret)\n\t\tgoto out_free_stacktrace;\n\n\tret = register_ftrace_command(&ftrace_cpudump_cmd);\n\tif (ret)\n\t\tgoto out_free_dump;\n\n\treturn 0;\n\n out_free_dump:\n\tunregister_ftrace_command(&ftrace_dump_cmd);\n out_free_stacktrace:\n\tunregister_ftrace_command(&ftrace_stacktrace_cmd);\n out_free_traceon:\n\tunregister_ftrace_command(&ftrace_traceon_cmd);\n out_free_traceoff:\n\tunregister_ftrace_command(&ftrace_traceoff_cmd);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_cpudump_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "885-899",
    "snippet": "static int\nftrace_cpudump_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = &cpudump_probe_ops;\n\n\t/* Only dump once. */\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trace_probe_callback",
          "args": [
            "tr",
            "ops",
            "hash",
            "glob",
            "cmd",
            "\"1\"",
            "enable"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_probe_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "796-833",
          "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_cpudump_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = &cpudump_probe_ops;\n\n\t/* Only dump once. */\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}"
  },
  {
    "function_name": "ftrace_dump_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "869-883",
    "snippet": "static int\nftrace_dump_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = &dump_probe_ops;\n\n\t/* Only dump once. */\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trace_probe_callback",
          "args": [
            "tr",
            "ops",
            "hash",
            "glob",
            "cmd",
            "\"1\"",
            "enable"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_probe_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "796-833",
          "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_dump_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = &dump_probe_ops;\n\n\t/* Only dump once. */\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}"
  },
  {
    "function_name": "ftrace_stacktrace_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "854-867",
    "snippet": "static int\nftrace_stacktrace_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = param ? &stacktrace_count_probe_ops : &stacktrace_probe_ops;\n\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trace_probe_callback",
          "args": [
            "tr",
            "ops",
            "hash",
            "glob",
            "cmd",
            "param",
            "enable"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_probe_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "796-833",
          "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_stacktrace_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = param ? &stacktrace_count_probe_ops : &stacktrace_probe_ops;\n\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}"
  },
  {
    "function_name": "ftrace_trace_onoff_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "835-852",
    "snippet": "static int\nftrace_trace_onoff_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t    char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* we register both traceon and traceoff to this callback */\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_probe_ops : &traceon_probe_ops;\n\telse\n\t\tops = param ? &traceoff_count_probe_ops : &traceoff_probe_ops;\n\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trace_probe_callback",
          "args": [
            "tr",
            "ops",
            "hash",
            "glob",
            "cmd",
            "param",
            "enable"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_probe_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "796-833",
          "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"traceon\""
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_onoff_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t    char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* we register both traceon and traceoff to this callback */\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_probe_ops : &traceon_probe_ops;\n\telse\n\t\tops = param ? &traceoff_count_probe_ops : &traceoff_probe_ops;\n\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}"
  },
  {
    "function_name": "ftrace_trace_probe_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "796-833",
    "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function_probe",
          "args": [
            "glob",
            "tr",
            "ops",
            "count"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_function_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4541-4682",
          "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "(unsigned long *)&count"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function_probe_func",
          "args": [
            "glob+1",
            "tr",
            "ops"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function_probe_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4684-4811",
          "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "ftrace_count_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "734-746",
    "snippet": "static void\nftrace_count_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\n\tif (!ip) {\n\t\tfree_ftrace_func_mapper(mapper, NULL);\n\t\treturn;\n\t}\n\n\tftrace_func_mapper_remove_ip(mapper, ip);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_func_mapper_remove_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_remove_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4455-4473",
          "snippet": "void *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_func_mapper",
          "args": [
            "mapper",
            "NULL"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_func_mapper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4483-4505",
          "snippet": "void free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size, i;\n\n\tif (!mapper)\n\t\treturn;\n\n\tif (free_func && mapper->hash.count) {\n\t\tsize = 1 << mapper->hash.size_bits;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size, i;\n\n\tif (!mapper)\n\t\treturn;\n\n\tif (free_func && mapper->hash.count) {\n\t\tsize = 1 << mapper->hash.size_bits;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_count_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\n\tif (!ip) {\n\t\tfree_ftrace_func_mapper(mapper, NULL);\n\t\treturn;\n\t}\n\n\tftrace_func_mapper_remove_ip(mapper, ip);\n}"
  },
  {
    "function_name": "ftrace_count_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "718-732",
    "snippet": "static int\nftrace_count_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENOMEM;\n\t\t*data = mapper;\n\t}\n\n\treturn ftrace_func_mapper_add_ip(mapper, ip, init_data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_func_mapper_add_ip",
          "args": [
            "mapper",
            "ip",
            "init_data"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_add_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4423-4443",
          "snippet": "int ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_ftrace_func_mapper",
          "args": [],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_ftrace_func_mapper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4377-4388",
          "snippet": "struct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstruct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_count_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENOMEM;\n\t\t*data = mapper;\n\t}\n\n\treturn ftrace_func_mapper_add_ip(mapper, ip, init_data);\n}"
  },
  {
    "function_name": "ftrace_cpudump_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "710-715",
    "snippet": "static int\nftrace_cpudump_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"cpudump\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"cpudump\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "660-679",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_cpudump_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"cpudump\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_dump_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "703-708",
    "snippet": "static int\nftrace_dump_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"dump\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"dump\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "660-679",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_dump_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"dump\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_stacktrace_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "696-701",
    "snippet": "static int\nftrace_stacktrace_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"stacktrace\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"stacktrace\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "660-679",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_stacktrace_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"stacktrace\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_traceoff_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "689-694",
    "snippet": "static int\nftrace_traceoff_print(struct seq_file *m, unsigned long ip,\n\t\t\t struct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"traceoff\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"traceoff\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "660-679",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_traceoff_print(struct seq_file *m, unsigned long ip,\n\t\t\t struct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"traceoff\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_traceon_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "681-687",
    "snippet": "static int\nftrace_traceon_print(struct seq_file *m, unsigned long ip,\n\t\t     struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\treturn ftrace_probe_print(\"traceon\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"traceon\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "660-679",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_traceon_print(struct seq_file *m, unsigned long ip,\n\t\t     struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\treturn ftrace_probe_print(\"traceon\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_probe_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "660-679",
    "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\":unlimited\\n\""
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\":count=%ld\\n\"",
            "*count"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4401-4413",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_cpudump_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "651-658",
    "snippet": "static void\nftrace_cpudump_probe(unsigned long ip, unsigned long parent_ip,\n\t\t     struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\tif (update_count(ops, ip, data))\n\t\tftrace_dump(DUMP_ORIG);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_dump",
          "args": [
            "DUMP_ORIG"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dump",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9808-9917",
          "snippet": "void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp and iter.fmt */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\titer.fmt = static_fmt_buf;\n\titer.fmt_size = STATIC_FMT_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define STATIC_TEMP_BUF_SIZE\t128",
            "#define STATIC_FMT_BUF_SIZE\t128"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static char static_fmt_buf[STATIC_FMT_BUF_SIZE];",
            "static char static_temp_buf[STATIC_TEMP_BUF_SIZE]",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define STATIC_TEMP_BUF_SIZE\t128\n#define STATIC_FMT_BUF_SIZE\t128\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic char static_fmt_buf[STATIC_FMT_BUF_SIZE];\nstatic char static_temp_buf[STATIC_TEMP_BUF_SIZE];\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp and iter.fmt */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\titer.fmt = static_fmt_buf;\n\titer.fmt_size = STATIC_FMT_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_count",
          "args": [
            "ops",
            "ip",
            "data"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "update_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "623-639",
          "snippet": "static int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_cpudump_probe(unsigned long ip, unsigned long parent_ip,\n\t\t     struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\tif (update_count(ops, ip, data))\n\t\tftrace_dump(DUMP_ORIG);\n}"
  },
  {
    "function_name": "ftrace_dump_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "641-648",
    "snippet": "static void\nftrace_dump_probe(unsigned long ip, unsigned long parent_ip,\n\t\t  struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t  void *data)\n{\n\tif (update_count(ops, ip, data))\n\t\tftrace_dump(DUMP_ALL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dump",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9808-9917",
          "snippet": "void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp and iter.fmt */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\titer.fmt = static_fmt_buf;\n\titer.fmt_size = STATIC_FMT_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define STATIC_TEMP_BUF_SIZE\t128",
            "#define STATIC_FMT_BUF_SIZE\t128"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static char static_fmt_buf[STATIC_FMT_BUF_SIZE];",
            "static char static_temp_buf[STATIC_TEMP_BUF_SIZE]",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define STATIC_TEMP_BUF_SIZE\t128\n#define STATIC_FMT_BUF_SIZE\t128\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic char static_fmt_buf[STATIC_FMT_BUF_SIZE];\nstatic char static_temp_buf[STATIC_TEMP_BUF_SIZE];\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp and iter.fmt */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\titer.fmt = static_fmt_buf;\n\titer.fmt_size = STATIC_FMT_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_count",
          "args": [
            "ops",
            "ip",
            "data"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "update_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "623-639",
          "snippet": "static int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_dump_probe(unsigned long ip, unsigned long parent_ip,\n\t\t  struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t  void *data)\n{\n\tif (update_count(ops, ip, data))\n\t\tftrace_dump(DUMP_ALL);\n}"
  },
  {
    "function_name": "update_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "623-639",
    "snippet": "static int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4401-4413",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_stacktrace_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "581-621",
    "snippet": "static void\nftrace_stacktrace_count(unsigned long ip, unsigned long parent_ip,\n\t\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\tlong new_count;\n\n\tif (!tracing_is_on())\n\t\treturn;\n\n\t/* unlimited? */\n\tif (!mapper) {\n\t\ttrace_stack(tr);\n\t\treturn;\n\t}\n\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\t/*\n\t * Stack traces should only execute the number of times the\n\t * user specified in the counter.\n\t */\n\tdo {\n\t\told_count = *count;\n\n\t\tif (!old_count)\n\t\t\treturn;\n\n\t\tnew_count = old_count - 1;\n\t\tnew_count = cmpxchg(count, old_count, new_count);\n\t\tif (new_count == old_count)\n\t\t\ttrace_stack(tr);\n\n\t\tif (!tracing_is_on())\n\t\t\treturn;\n\n\t} while (new_count != old_count);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1460-1463",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_stack",
          "args": [
            "tr"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "trace_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "564-571",
          "snippet": "static __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\t__trace_stack(tr, trace_ctx, FTRACE_STACK_SKIP);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define FTRACE_STACK_SKIP 5",
            "#define FTRACE_STACK_SKIP 3"
          ],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define FTRACE_STACK_SKIP 5\n#define FTRACE_STACK_SKIP 3\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\t__trace_stack(tr, trace_ctx, FTRACE_STACK_SKIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "count",
            "old_count",
            "new_count"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4401-4413",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_stacktrace_count(unsigned long ip, unsigned long parent_ip,\n\t\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\tlong new_count;\n\n\tif (!tracing_is_on())\n\t\treturn;\n\n\t/* unlimited? */\n\tif (!mapper) {\n\t\ttrace_stack(tr);\n\t\treturn;\n\t}\n\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\t/*\n\t * Stack traces should only execute the number of times the\n\t * user specified in the counter.\n\t */\n\tdo {\n\t\told_count = *count;\n\n\t\tif (!old_count)\n\t\t\treturn;\n\n\t\tnew_count = old_count - 1;\n\t\tnew_count = cmpxchg(count, old_count, new_count);\n\t\tif (new_count == old_count)\n\t\t\ttrace_stack(tr);\n\n\t\tif (!tracing_is_on())\n\t\t\treturn;\n\n\t} while (new_count != old_count);\n}"
  },
  {
    "function_name": "ftrace_stacktrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "573-579",
    "snippet": "static void\nftrace_stacktrace(unsigned long ip, unsigned long parent_ip,\n\t\t  struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t  void *data)\n{\n\ttrace_stack(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_stack",
          "args": [
            "tr"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "trace_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "564-571",
          "snippet": "static __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\t__trace_stack(tr, trace_ctx, FTRACE_STACK_SKIP);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define FTRACE_STACK_SKIP 5",
            "#define FTRACE_STACK_SKIP 3"
          ],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define FTRACE_STACK_SKIP 5\n#define FTRACE_STACK_SKIP 3\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\t__trace_stack(tr, trace_ctx, FTRACE_STACK_SKIP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_stacktrace(unsigned long ip, unsigned long parent_ip,\n\t\t  struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t  void *data)\n{\n\ttrace_stack(tr);\n}"
  },
  {
    "function_name": "trace_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "564-571",
    "snippet": "static __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\t__trace_stack(tr, trace_ctx, FTRACE_STACK_SKIP);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [
      "#define FTRACE_STACK_SKIP 5",
      "#define FTRACE_STACK_SKIP 3"
    ],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_stack",
          "args": [
            "tr",
            "trace_ctx",
            "FTRACE_STACK_SKIP"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3078-3100",
          "snippet": "void __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nvoid __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define FTRACE_STACK_SKIP 5\n#define FTRACE_STACK_SKIP 3\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\t__trace_stack(tr, trace_ctx, FTRACE_STACK_SKIP);\n}"
  },
  {
    "function_name": "ftrace_traceoff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "531-540",
    "snippet": "static void\nftrace_traceoff(unsigned long ip, unsigned long parent_ip,\n\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\tvoid *data)\n{\n\tif (!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\ttracer_tracing_off(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracer_tracing_off",
          "args": [
            "tr"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1404-1419",
          "snippet": "void tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_is_on",
          "args": [
            "tr"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1450-1455",
          "snippet": "bool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_traceoff(unsigned long ip, unsigned long parent_ip,\n\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\tvoid *data)\n{\n\tif (!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\ttracer_tracing_off(tr);\n}"
  },
  {
    "function_name": "ftrace_traceon",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "520-529",
    "snippet": "static void\nftrace_traceon(unsigned long ip, unsigned long parent_ip,\n\t       struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t       void *data)\n{\n\tif (tracer_tracing_is_on(tr))\n\t\treturn;\n\n\ttracer_tracing_on(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracer_tracing_on",
          "args": [
            "tr"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "942-957",
          "snippet": "void tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_on(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_on(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_is_on",
          "args": [
            "tr"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1450-1455",
          "snippet": "bool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_traceon(unsigned long ip, unsigned long parent_ip,\n\t       struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t       void *data)\n{\n\tif (tracer_tracing_is_on(tr))\n\t\treturn;\n\n\ttracer_tracing_on(tr);\n}"
  },
  {
    "function_name": "ftrace_traceoff_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "512-518",
    "snippet": "static void\nftrace_traceoff_count(unsigned long ip, unsigned long parent_ip,\n\t\t      struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t      void *data)\n{\n\tupdate_traceon_count(ops, ip, tr, 0, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_traceon_count",
          "args": [
            "ops",
            "ip",
            "tr",
            "0",
            "data"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "update_traceon_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "443-502",
          "snippet": "static void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_traceoff_count(unsigned long ip, unsigned long parent_ip,\n\t\t      struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t      void *data)\n{\n\tupdate_traceon_count(ops, ip, tr, 0, data);\n}"
  },
  {
    "function_name": "ftrace_traceon_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "504-510",
    "snippet": "static void\nftrace_traceon_count(unsigned long ip, unsigned long parent_ip,\n\t\t     struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\tupdate_traceon_count(ops, ip, tr, 1, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_traceon_count",
          "args": [
            "ops",
            "ip",
            "tr",
            "1",
            "data"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "update_traceon_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "443-502",
          "snippet": "static void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_traceon_count(unsigned long ip, unsigned long parent_ip,\n\t\t     struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\tupdate_traceon_count(ops, ip, tr, 1, data);\n}"
  },
  {
    "function_name": "update_traceon_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "443-502",
    "snippet": "static void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_tracing_off",
          "args": [
            "tr"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1404-1419",
          "snippet": "void tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_on",
          "args": [
            "tr"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "942-957",
          "snippet": "void tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_on(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_on(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_is_on",
          "args": [
            "tr"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1450-1455",
          "snippet": "bool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4401-4413",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}"
  },
  {
    "function_name": "func_set_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "395-426",
    "snippet": "static int\nfunc_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\tftrace_func_t func;\n\tu32 new_flags;\n\n\t/* Do nothing if already set. */\n\tif (!!set == !!(func_flags.val & bit))\n\t\treturn 0;\n\n\t/* We can change this flag only when not running. */\n\tif (tr->current_trace != &function_trace)\n\t\treturn 0;\n\n\tnew_flags = (func_flags.val & ~bit) | (set ? bit : 0);\n\tfunc = select_trace_function(new_flags);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\t/* Check if there's anything to change. */\n\tif (tr->ops->func == func)\n\t\treturn 0;\n\n\tif (!handle_func_repeats(tr, new_flags))\n\t\treturn -ENOMEM;\n\n\tunregister_ftrace_function(tr->ops);\n\ttr->ops->func = func;\n\tregister_ftrace_function(tr->ops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static struct tracer_flags func_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_func_repeats",
          "args": [
            "tr",
            "new_flags"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "handle_func_repeats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "120-130",
          "snippet": "static bool handle_func_repeats(struct trace_array *tr, u32 flags_val)\n{\n\tif (!tr->last_func_repeats &&\n\t    (flags_val & TRACE_FUNC_OPT_NO_REPEATS)) {\n\t\ttr->last_func_repeats = alloc_percpu(struct trace_func_repeats);\n\t\tif (!tr->last_func_repeats)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic bool handle_func_repeats(struct trace_array *tr, u32 flags_val)\n{\n\tif (!tr->last_func_repeats &&\n\t    (flags_val & TRACE_FUNC_OPT_NO_REPEATS)) {\n\t\ttr->last_func_repeats = alloc_percpu(struct trace_func_repeats);\n\t\tif (!tr->last_func_repeats)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_trace_function",
          "args": [
            "new_flags"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "select_trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "104-118",
          "snippet": "static ftrace_func_t select_trace_function(u32 flags_val)\n{\n\tswitch (flags_val & TRACE_FUNC_OPT_MASK) {\n\tcase TRACE_FUNC_NO_OPTS:\n\t\treturn function_trace_call;\n\tcase TRACE_FUNC_OPT_STACK:\n\t\treturn function_stack_trace_call;\n\tcase TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_no_repeats_trace_call;\n\tcase TRACE_FUNC_OPT_STACK | TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_stack_no_repeats_trace_call;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define TRACE_FUNC_OPT_MASK\t(TRACE_FUNC_OPT_HIGHEST_BIT - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define TRACE_FUNC_OPT_MASK\t(TRACE_FUNC_OPT_HIGHEST_BIT - 1)\n\nstatic ftrace_func_t select_trace_function(u32 flags_val)\n{\n\tswitch (flags_val & TRACE_FUNC_OPT_MASK) {\n\tcase TRACE_FUNC_NO_OPTS:\n\t\treturn function_trace_call;\n\tcase TRACE_FUNC_OPT_STACK:\n\t\treturn function_stack_trace_call;\n\tcase TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_no_repeats_trace_call;\n\tcase TRACE_FUNC_OPT_STACK | TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_stack_no_repeats_trace_call;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic struct tracer_flags func_flags;\n\nstatic int\nfunc_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\tftrace_func_t func;\n\tu32 new_flags;\n\n\t/* Do nothing if already set. */\n\tif (!!set == !!(func_flags.val & bit))\n\t\treturn 0;\n\n\t/* We can change this flag only when not running. */\n\tif (tr->current_trace != &function_trace)\n\t\treturn 0;\n\n\tnew_flags = (func_flags.val & ~bit) | (set ? bit : 0);\n\tfunc = select_trace_function(new_flags);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\t/* Check if there's anything to change. */\n\tif (tr->ops->func == func)\n\t\treturn 0;\n\n\tif (!handle_func_repeats(tr, new_flags))\n\t\treturn -ENOMEM;\n\n\tunregister_ftrace_function(tr->ops);\n\ttr->ops->func = func;\n\tregister_ftrace_function(tr->ops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tracing_stop_function_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "387-391",
    "snippet": "static void tracing_stop_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tunregister_ftrace_function(tr->ops);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void tracing_stop_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tunregister_ftrace_function(tr->ops);\n}"
  },
  {
    "function_name": "tracing_start_function_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "380-385",
    "snippet": "static void tracing_start_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tregister_ftrace_function(tr->ops);\n\ttr->function_enabled = 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void tracing_start_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tregister_ftrace_function(tr->ops);\n\ttr->function_enabled = 1;\n}"
  },
  {
    "function_name": "function_stack_no_repeats_trace_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "325-365",
    "snippet": "static void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs)\n{\n\tstruct trace_func_repeats *last_info;\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tunsigned int trace_ctx;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\t/*\n\t * Need to use raw, since this must be called before the\n\t * recursive protection is performed.\n\t */\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\n\tif (likely(disabled == 1)) {\n\t\tlast_info = per_cpu_ptr(tr->last_func_repeats, cpu);\n\t\tif (is_repeat_check(tr, last_info, ip, parent_ip))\n\t\t\tgoto out;\n\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\tprocess_repeats(tr, ip, parent_ip, last_info, trace_ctx);\n\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\t\t__trace_stack(tr, trace_ctx, STACK_SKIP);\n\t}\n\n out:\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [
      "#define STACK_SKIP 3",
      "#define STACK_SKIP 2"
    ],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_stack",
          "args": [
            "tr",
            "trace_ctx",
            "STACK_SKIP"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3078-3100",
          "snippet": "void __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nvoid __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_function_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4541-4682",
          "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_repeats",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "last_info",
            "trace_ctx"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "process_repeats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "265-277",
          "snippet": "static inline void process_repeats(struct trace_array *tr,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned int trace_ctx)\n{\n\tif (last_info->count) {\n\t\ttrace_last_func_repeats(tr, last_info, trace_ctx);\n\t\tlast_info->count = 0;\n\t}\n\n\tlast_info->ip = ip;\n\tlast_info->parent_ip = parent_ip;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic inline void process_repeats(struct trace_array *tr,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned int trace_ctx)\n{\n\tif (last_info->count) {\n\t\ttrace_last_func_repeats(tr, last_info, trace_ctx);\n\t\tlast_info->count = 0;\n\t}\n\n\tlast_info->ip = ip;\n\tlast_info->parent_ip = parent_ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_repeat_check",
          "args": [
            "tr",
            "last_info",
            "ip",
            "parent_ip"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "is_repeat_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "249-263",
          "snippet": "static inline bool is_repeat_check(struct trace_array *tr,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip)\n{\n\tif (last_info->ip == ip &&\n\t    last_info->parent_ip == parent_ip &&\n\t    last_info->count < U16_MAX) {\n\t\tlast_info->ts_last_call =\n\t\t\tring_buffer_time_stamp(tr->array_buffer.buffer);\n\t\tlast_info->count++;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic inline bool is_repeat_check(struct trace_array *tr,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip)\n{\n\tif (last_info->ip == ip &&\n\t    last_info->parent_ip == parent_ip &&\n\t    last_info->count < U16_MAX) {\n\t\tlast_info->ts_last_call =\n\t\t\tring_buffer_time_stamp(tr->array_buffer.buffer);\n\t\tlast_info->count++;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->last_func_repeats",
            "cpu"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled == 1"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&data->disabled"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tr->function_enabled"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define STACK_SKIP 3\n#define STACK_SKIP 2\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs);\n\nstatic void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs)\n{\n\tstruct trace_func_repeats *last_info;\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tunsigned int trace_ctx;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\t/*\n\t * Need to use raw, since this must be called before the\n\t * recursive protection is performed.\n\t */\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\n\tif (likely(disabled == 1)) {\n\t\tlast_info = per_cpu_ptr(tr->last_func_repeats, cpu);\n\t\tif (is_repeat_check(tr, last_info, ip, parent_ip))\n\t\t\tgoto out;\n\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\tprocess_repeats(tr, ip, parent_ip, last_info, trace_ctx);\n\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\t\t__trace_stack(tr, trace_ctx, STACK_SKIP);\n\t}\n\n out:\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "function_no_repeats_trace_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "279-323",
    "snippet": "static void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op,\n\t\t\t       struct ftrace_regs *fregs)\n{\n\tstruct trace_func_repeats *last_info;\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\tunsigned long flags;\n\tint bit;\n\tint cpu;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tif (atomic_read(&data->disabled))\n\t\tgoto out;\n\n\t/*\n\t * An interrupt may happen at any place here. But as far as I can see,\n\t * the only damage that this can cause is to mess up the repetition\n\t * counter without valuable data being lost.\n\t * TODO: think about a solution that is better than just hoping to be\n\t * lucky.\n\t */\n\tlast_info = per_cpu_ptr(tr->last_func_repeats, cpu);\n\tif (is_repeat_check(tr, last_info, ip, parent_ip))\n\t\tgoto out;\n\n\tlocal_save_flags(flags);\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tprocess_repeats(tr, ip, parent_ip, last_info, trace_ctx);\n\n\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\nout:\n\tftrace_test_recursion_unlock(bit);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_test_recursion_unlock",
          "args": [
            "bit"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_function_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4541-4682",
          "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_repeats",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "last_info",
            "trace_ctx"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "process_repeats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "265-277",
          "snippet": "static inline void process_repeats(struct trace_array *tr,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned int trace_ctx)\n{\n\tif (last_info->count) {\n\t\ttrace_last_func_repeats(tr, last_info, trace_ctx);\n\t\tlast_info->count = 0;\n\t}\n\n\tlast_info->ip = ip;\n\tlast_info->parent_ip = parent_ip;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic inline void process_repeats(struct trace_array *tr,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned int trace_ctx)\n{\n\tif (last_info->count) {\n\t\ttrace_last_func_repeats(tr, last_info, trace_ctx);\n\t\tlast_info->count = 0;\n\t}\n\n\tlast_info->ip = ip;\n\tlast_info->parent_ip = parent_ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_repeat_check",
          "args": [
            "tr",
            "last_info",
            "ip",
            "parent_ip"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "is_repeat_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "249-263",
          "snippet": "static inline bool is_repeat_check(struct trace_array *tr,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip)\n{\n\tif (last_info->ip == ip &&\n\t    last_info->parent_ip == parent_ip &&\n\t    last_info->count < U16_MAX) {\n\t\tlast_info->ts_last_call =\n\t\t\tring_buffer_time_stamp(tr->array_buffer.buffer);\n\t\tlast_info->count++;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic inline bool is_repeat_check(struct trace_array *tr,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip)\n{\n\tif (last_info->ip == ip &&\n\t    last_info->parent_ip == parent_ip &&\n\t    last_info->count < U16_MAX) {\n\t\tlast_info->ts_last_call =\n\t\t\tring_buffer_time_stamp(tr->array_buffer.buffer);\n\t\tlast_info->count++;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->last_func_repeats",
            "cpu"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->disabled"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_test_recursion_trylock",
          "args": [
            "ip",
            "parent_ip"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tr->function_enabled"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs);\n\nstatic void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op,\n\t\t\t       struct ftrace_regs *fregs)\n{\n\tstruct trace_func_repeats *last_info;\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\tunsigned long flags;\n\tint bit;\n\tint cpu;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tif (atomic_read(&data->disabled))\n\t\tgoto out;\n\n\t/*\n\t * An interrupt may happen at any place here. But as far as I can see,\n\t * the only damage that this can cause is to mess up the repetition\n\t * counter without valuable data being lost.\n\t * TODO: think about a solution that is better than just hoping to be\n\t * lucky.\n\t */\n\tlast_info = per_cpu_ptr(tr->last_func_repeats, cpu);\n\tif (is_repeat_check(tr, last_info, ip, parent_ip))\n\t\tgoto out;\n\n\tlocal_save_flags(flags);\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tprocess_repeats(tr, ip, parent_ip, last_info, trace_ctx);\n\n\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\nout:\n\tftrace_test_recursion_unlock(bit);\n}"
  },
  {
    "function_name": "process_repeats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "265-277",
    "snippet": "static inline void process_repeats(struct trace_array *tr,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned int trace_ctx)\n{\n\tif (last_info->count) {\n\t\ttrace_last_func_repeats(tr, last_info, trace_ctx);\n\t\tlast_info->count = 0;\n\t}\n\n\tlast_info->ip = ip;\n\tlast_info->parent_ip = parent_ip;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_last_func_repeats",
          "args": [
            "tr",
            "last_info",
            "trace_ctx"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "trace_last_func_repeats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3187-3211",
          "snippet": "void trace_last_func_repeats(struct trace_array *tr,\n\t\t\t     struct trace_func_repeats *last_info,\n\t\t\t     unsigned int trace_ctx)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct func_repeats_entry *entry;\n\tstruct ring_buffer_event *event;\n\tu64 delta;\n\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_FUNC_REPEATS,\n\t\t\t\t\t    sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\n\tdelta = ring_buffer_event_time_stamp(buffer, event) -\n\t\tlast_info->ts_last_call;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = last_info->ip;\n\tentry->parent_ip = last_info->parent_ip;\n\tentry->count = last_info->count;\n\tfunc_repeats_set_delta_ts(entry, delta);\n\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nvoid trace_last_func_repeats(struct trace_array *tr,\n\t\t\t     struct trace_func_repeats *last_info,\n\t\t\t     unsigned int trace_ctx)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct func_repeats_entry *entry;\n\tstruct ring_buffer_event *event;\n\tu64 delta;\n\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_FUNC_REPEATS,\n\t\t\t\t\t    sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\n\tdelta = ring_buffer_event_time_stamp(buffer, event) -\n\t\tlast_info->ts_last_call;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = last_info->ip;\n\tentry->parent_ip = last_info->parent_ip;\n\tentry->count = last_info->count;\n\tfunc_repeats_set_delta_ts(entry, delta);\n\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic inline void process_repeats(struct trace_array *tr,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned int trace_ctx)\n{\n\tif (last_info->count) {\n\t\ttrace_last_func_repeats(tr, last_info, trace_ctx);\n\t\tlast_info->count = 0;\n\t}\n\n\tlast_info->ip = ip;\n\tlast_info->parent_ip = parent_ip;\n}"
  },
  {
    "function_name": "is_repeat_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "249-263",
    "snippet": "static inline bool is_repeat_check(struct trace_array *tr,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip)\n{\n\tif (last_info->ip == ip &&\n\t    last_info->parent_ip == parent_ip &&\n\t    last_info->count < U16_MAX) {\n\t\tlast_info->ts_last_call =\n\t\t\tring_buffer_time_stamp(tr->array_buffer.buffer);\n\t\tlast_info->count++;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_time_stamp",
          "args": [
            "tr->array_buffer.buffer"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_time_stamp_abs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "1810-1813",
          "snippet": "bool ring_buffer_time_stamp_abs(struct trace_buffer *buffer)\n{\n\treturn buffer->time_stamp_abs;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nbool ring_buffer_time_stamp_abs(struct trace_buffer *buffer)\n{\n\treturn buffer->time_stamp_abs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic inline bool is_repeat_check(struct trace_array *tr,\n\t\t\t\t   struct trace_func_repeats *last_info,\n\t\t\t\t   unsigned long ip, unsigned long parent_ip)\n{\n\tif (last_info->ip == ip &&\n\t    last_info->parent_ip == parent_ip &&\n\t    last_info->count < U16_MAX) {\n\t\tlast_info->ts_last_call =\n\t\t\tring_buffer_time_stamp(tr->array_buffer.buffer);\n\t\tlast_info->count++;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "function_stack_trace_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "216-247",
    "snippet": "static void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tunsigned int trace_ctx;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\t/*\n\t * Need to use raw, since this must be called before the\n\t * recursive protection is performed.\n\t */\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\n\tif (likely(disabled == 1)) {\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\t\t__trace_stack(tr, trace_ctx, STACK_SKIP);\n\t}\n\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [
      "#define STACK_SKIP 3",
      "#define STACK_SKIP 2"
    ],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_stack",
          "args": [
            "tr",
            "trace_ctx",
            "STACK_SKIP"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3078-3100",
          "snippet": "void __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nvoid __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_function_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4541-4682",
          "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled == 1"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&data->disabled"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tr->function_enabled"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define STACK_SKIP 3\n#define STACK_SKIP 2\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs);\n\nstatic void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tunsigned int trace_ctx;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\t/*\n\t * Need to use raw, since this must be called before the\n\t * recursive protection is performed.\n\t */\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\n\tif (likely(disabled == 1)) {\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\t\t__trace_stack(tr, trace_ctx, STACK_SKIP);\n\t}\n\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "function_trace_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "171-196",
    "snippet": "static void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\tint bit;\n\tint cpu;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0)\n\t\treturn;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tcpu = smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tif (!atomic_read(&data->disabled))\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\n\tftrace_test_recursion_unlock(bit);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_test_recursion_unlock",
          "args": [
            "bit"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_function_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4541-4682",
          "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->disabled"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_test_recursion_trylock",
          "args": [
            "ip",
            "parent_ip"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tr->function_enabled"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void\nfunction_stack_no_repeats_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t     struct ftrace_ops *op,\n\t\t\t\t     struct ftrace_regs *fregs);\n\nstatic void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\tint bit;\n\tint cpu;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0)\n\t\treturn;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tcpu = smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tif (!atomic_read(&data->disabled))\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\n\tftrace_test_recursion_unlock(bit);\n}"
  },
  {
    "function_name": "function_trace_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "166-169",
    "snippet": "static void function_trace_start(struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&tr->array_buffer"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2138-2155",
          "snippet": "void tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void function_trace_start(struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}"
  },
  {
    "function_name": "function_trace_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "159-164",
    "snippet": "static void function_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_function_trace(tr);\n\ttracing_stop_cmdline_record();\n\tftrace_reset_array_ops(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_reset_array_ops",
          "args": [
            "tr"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_reset_array_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7225-7228",
          "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "136-139",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_function_trace",
          "args": [
            "tr"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_function_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "387-391",
          "snippet": "static void tracing_stop_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tunregister_ftrace_function(tr->ops);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void tracing_stop_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tunregister_ftrace_function(tr->ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void function_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_function_trace(tr);\n\ttracing_stop_cmdline_record();\n\tftrace_reset_array_ops(tr);\n}"
  },
  {
    "function_name": "function_trace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "132-157",
    "snippet": "static int function_trace_init(struct trace_array *tr)\n{\n\tftrace_func_t func;\n\t/*\n\t * Instance trace_arrays get their ops allocated\n\t * at instance creation. Unless it failed\n\t * the allocation.\n\t */\n\tif (!tr->ops)\n\t\treturn -ENOMEM;\n\n\tfunc = select_trace_function(func_flags.val);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tif (!handle_func_repeats(tr, func_flags.val))\n\t\treturn -ENOMEM;\n\n\tftrace_init_array_ops(tr, func);\n\n\ttr->array_buffer.cpu = raw_smp_processor_id();\n\n\ttracing_start_cmdline_record();\n\ttracing_start_function_trace(tr);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static struct tracer_flags func_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_start_function_trace",
          "args": [
            "tr"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_function_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "380-385",
          "snippet": "static void tracing_start_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tregister_ftrace_function(tr->ops);\n\ttr->function_enabled = 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void tracing_start_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tregister_ftrace_function(tr->ops);\n\ttr->function_enabled = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "131-134",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_init_array_ops",
          "args": [
            "tr",
            "func"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_array_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7213-7223",
          "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_func_repeats",
          "args": [
            "tr",
            "func_flags.val"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "handle_func_repeats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "120-130",
          "snippet": "static bool handle_func_repeats(struct trace_array *tr, u32 flags_val)\n{\n\tif (!tr->last_func_repeats &&\n\t    (flags_val & TRACE_FUNC_OPT_NO_REPEATS)) {\n\t\ttr->last_func_repeats = alloc_percpu(struct trace_func_repeats);\n\t\tif (!tr->last_func_repeats)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic bool handle_func_repeats(struct trace_array *tr, u32 flags_val)\n{\n\tif (!tr->last_func_repeats &&\n\t    (flags_val & TRACE_FUNC_OPT_NO_REPEATS)) {\n\t\ttr->last_func_repeats = alloc_percpu(struct trace_func_repeats);\n\t\tif (!tr->last_func_repeats)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_trace_function",
          "args": [
            "func_flags.val"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "select_trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "104-118",
          "snippet": "static ftrace_func_t select_trace_function(u32 flags_val)\n{\n\tswitch (flags_val & TRACE_FUNC_OPT_MASK) {\n\tcase TRACE_FUNC_NO_OPTS:\n\t\treturn function_trace_call;\n\tcase TRACE_FUNC_OPT_STACK:\n\t\treturn function_stack_trace_call;\n\tcase TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_no_repeats_trace_call;\n\tcase TRACE_FUNC_OPT_STACK | TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_stack_no_repeats_trace_call;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define TRACE_FUNC_OPT_MASK\t(TRACE_FUNC_OPT_HIGHEST_BIT - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define TRACE_FUNC_OPT_MASK\t(TRACE_FUNC_OPT_HIGHEST_BIT - 1)\n\nstatic ftrace_func_t select_trace_function(u32 flags_val)\n{\n\tswitch (flags_val & TRACE_FUNC_OPT_MASK) {\n\tcase TRACE_FUNC_NO_OPTS:\n\t\treturn function_trace_call;\n\tcase TRACE_FUNC_OPT_STACK:\n\t\treturn function_stack_trace_call;\n\tcase TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_no_repeats_trace_call;\n\tcase TRACE_FUNC_OPT_STACK | TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_stack_no_repeats_trace_call;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic struct tracer_flags func_flags;\n\nstatic int function_trace_init(struct trace_array *tr)\n{\n\tftrace_func_t func;\n\t/*\n\t * Instance trace_arrays get their ops allocated\n\t * at instance creation. Unless it failed\n\t * the allocation.\n\t */\n\tif (!tr->ops)\n\t\treturn -ENOMEM;\n\n\tfunc = select_trace_function(func_flags.val);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tif (!handle_func_repeats(tr, func_flags.val))\n\t\treturn -ENOMEM;\n\n\tftrace_init_array_ops(tr, func);\n\n\ttr->array_buffer.cpu = raw_smp_processor_id();\n\n\ttracing_start_cmdline_record();\n\ttracing_start_function_trace(tr);\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_func_repeats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "120-130",
    "snippet": "static bool handle_func_repeats(struct trace_array *tr, u32 flags_val)\n{\n\tif (!tr->last_func_repeats &&\n\t    (flags_val & TRACE_FUNC_OPT_NO_REPEATS)) {\n\t\ttr->last_func_repeats = alloc_percpu(struct trace_func_repeats);\n\t\tif (!tr->last_func_repeats)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structtrace_func_repeats"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic bool handle_func_repeats(struct trace_array *tr, u32 flags_val)\n{\n\tif (!tr->last_func_repeats &&\n\t    (flags_val & TRACE_FUNC_OPT_NO_REPEATS)) {\n\t\ttr->last_func_repeats = alloc_percpu(struct trace_func_repeats);\n\t\tif (!tr->last_func_repeats)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "select_trace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "104-118",
    "snippet": "static ftrace_func_t select_trace_function(u32 flags_val)\n{\n\tswitch (flags_val & TRACE_FUNC_OPT_MASK) {\n\tcase TRACE_FUNC_NO_OPTS:\n\t\treturn function_trace_call;\n\tcase TRACE_FUNC_OPT_STACK:\n\t\treturn function_stack_trace_call;\n\tcase TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_no_repeats_trace_call;\n\tcase TRACE_FUNC_OPT_STACK | TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_stack_no_repeats_trace_call;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [
      "#define TRACE_FUNC_OPT_MASK\t(TRACE_FUNC_OPT_HIGHEST_BIT - 1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define TRACE_FUNC_OPT_MASK\t(TRACE_FUNC_OPT_HIGHEST_BIT - 1)\n\nstatic ftrace_func_t select_trace_function(u32 flags_val)\n{\n\tswitch (flags_val & TRACE_FUNC_OPT_MASK) {\n\tcase TRACE_FUNC_NO_OPTS:\n\t\treturn function_trace_call;\n\tcase TRACE_FUNC_OPT_STACK:\n\t\treturn function_stack_trace_call;\n\tcase TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_no_repeats_trace_call;\n\tcase TRACE_FUNC_OPT_STACK | TRACE_FUNC_OPT_NO_REPEATS:\n\t\treturn function_stack_no_repeats_trace_call;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "ftrace_destroy_function_files",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "98-102",
    "snippet": "void ftrace_destroy_function_files(struct trace_array *tr)\n{\n\tftrace_destroy_filter_files(tr->ops);\n\tftrace_free_ftrace_ops(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_free_ftrace_ops",
          "args": [
            "tr"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_free_ftrace_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
          "lines": "74-78",
          "snippet": "void ftrace_free_ftrace_ops(struct trace_array *tr)\n{\n\tkfree(tr->ops);\n\ttr->ops = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nvoid ftrace_free_ftrace_ops(struct trace_array *tr)\n{\n\tkfree(tr->ops);\n\ttr->ops = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_destroy_filter_files",
          "args": [
            "tr->ops"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_destroy_filter_files",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6352-6360",
          "snippet": "void ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= FTRACE_OPS_FL_DELETED;\n\tftrace_free_filter(ops);\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= FTRACE_OPS_FL_DELETED;\n\tftrace_free_filter(ops);\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nvoid ftrace_destroy_function_files(struct trace_array *tr)\n{\n\tftrace_destroy_filter_files(tr->ops);\n\tftrace_free_ftrace_ops(tr);\n}"
  },
  {
    "function_name": "ftrace_create_function_files",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "80-96",
    "snippet": "int ftrace_create_function_files(struct trace_array *tr,\n\t\t\t\t struct dentry *parent)\n{\n\t/*\n\t * The top level array uses the \"global_ops\", and the files are\n\t * created on boot up.\n\t */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn 0;\n\n\tif (!tr->ops)\n\t\treturn -EINVAL;\n\n\tftrace_create_filter_files(tr->ops, parent);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_create_filter_files",
          "args": [
            "tr->ops",
            "parent"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_create_filter_files",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6331-6340",
          "snippet": "void ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nint ftrace_create_function_files(struct trace_array *tr,\n\t\t\t\t struct dentry *parent)\n{\n\t/*\n\t * The top level array uses the \"global_ops\", and the files are\n\t * created on boot up.\n\t */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn 0;\n\n\tif (!tr->ops)\n\t\treturn -EINVAL;\n\n\tftrace_create_filter_files(tr->ops, parent);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_free_ftrace_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "74-78",
    "snippet": "void ftrace_free_ftrace_ops(struct trace_array *tr)\n{\n\tkfree(tr->ops);\n\ttr->ops = NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tr->ops"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nvoid ftrace_free_ftrace_ops(struct trace_array *tr)\n{\n\tkfree(tr->ops);\n\ttr->ops = NULL;\n}"
  },
  {
    "function_name": "ftrace_allocate_ftrace_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions.c",
    "lines": "52-72",
    "snippet": "int ftrace_allocate_ftrace_ops(struct trace_array *tr)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* The top level array uses the \"global_ops\" */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn 0;\n\n\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\t/* Currently only the non stack version is supported */\n\tops->func = function_trace_call;\n\tops->flags = FTRACE_OPS_FL_PID;\n\n\ttr->ops = ops;\n\tops->private = tr;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ops)",
            "GFP_KERNEL"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nint ftrace_allocate_ftrace_ops(struct trace_array *tr)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* The top level array uses the \"global_ops\" */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn 0;\n\n\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\t/* Currently only the non stack version is supported */\n\tops->func = function_trace_call;\n\tops->flags = FTRACE_OPS_FL_PID;\n\n\ttr->ops = ops;\n\tops->private = tr;\n\n\treturn 0;\n}"
  }
]