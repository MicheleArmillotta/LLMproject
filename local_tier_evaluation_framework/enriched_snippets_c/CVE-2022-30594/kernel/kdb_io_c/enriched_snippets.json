[
  {
    "function_name": "kdb_printf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "859-869",
    "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vkdb_printf",
          "args": [
            "KDB_MSGSRC_INTERNAL",
            "fmt",
            "ap"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "vkdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "583-857",
          "snippet": "int vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tunsigned long flags;\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH) {\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Replace the \\0 with\n\t\t\t * its original value to ensure multi-line strings\n\t\t\t * are handled properly, and return to normal mode.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tkdb_grepping_flag = 0;\n\t\t}\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected)\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\telse\n\t\tkdb_msg_write(cp, retlen - (cp - kdb_buffer));\n\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar ch;\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tkdb_msg_write(moreprompt, strlen(moreprompt));\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tch = kdb_getchar();\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((ch == 'q') || (ch == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (ch == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '\\n' || ch == '\\r') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch) {\n\t\t\t/* user hit something unexpected */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (ch != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];",
            "int kdb_printf_cpu = -1;",
            "static char kdb_buffer[256];",
            "static char *next_avail = kdb_buffer;",
            "static int  size_avail;",
            "static int  suspend_grep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nchar kdb_prompt_str[CMD_BUFLEN];\nint kdb_printf_cpu = -1;\nstatic char kdb_buffer[256];\nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tunsigned long flags;\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH) {\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Replace the \\0 with\n\t\t\t * its original value to ensure multi-line strings\n\t\t\t * are handled properly, and return to normal mode.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tkdb_grepping_flag = 0;\n\t\t}\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected)\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\telse\n\t\tkdb_msg_write(cp, retlen - (cp - kdb_buffer));\n\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar ch;\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tkdb_msg_write(moreprompt, strlen(moreprompt));\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tch = kdb_getchar();\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((ch == 'q') || (ch == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (ch == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '\\n' || ch == '\\r') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch) {\n\t\t\t/* user hit something unexpected */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (ch != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
  },
  {
    "function_name": "vkdb_printf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "583-857",
    "snippet": "int vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tunsigned long flags;\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH) {\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Replace the \\0 with\n\t\t\t * its original value to ensure multi-line strings\n\t\t\t * are handled properly, and return to normal mode.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tkdb_grepping_flag = 0;\n\t\t}\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected)\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\telse\n\t\tkdb_msg_write(cp, retlen - (cp - kdb_buffer));\n\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar ch;\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tkdb_msg_write(moreprompt, strlen(moreprompt));\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tch = kdb_getchar();\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((ch == 'q') || (ch == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (ch == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '\\n' || ch == '\\r') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch) {\n\t\t\t/* user hit something unexpected */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (ch != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char kdb_prompt_str[CMD_BUFLEN];",
      "int kdb_printf_cpu = -1;",
      "static char kdb_buffer[256];",
      "static char *next_avail = kdb_buffer;",
      "static int  size_avail;",
      "static int  suspend_grep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&kdb_printf_cpu",
            "old_cpu"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kdb_buffer"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "kdb_buffer",
            "cphold"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_input_flush",
          "args": [],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_input_flush",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "462-481",
          "snippet": "static void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchrnul",
          "args": [
            "kdb_grep_string",
            "'\\n'"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getstr",
          "args": [
            "kdb_grep_string",
            "KDB_GREP_STRLEN",
            "kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \""
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getstr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "436-443",
          "snippet": "char *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrscpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN 256"
          ],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrscpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "\"SEARCHPROMPT\""
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "197-217",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "PAGER"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG_SET",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getchar",
          "args": [],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getchar",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "126-173",
          "snippet": "char kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar buf[4];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * When the first character is received (or we get a change\n\t\t * input source) we set ourselves up to handle an escape\n\t\t * sequences (just in case).\n\t\t */\n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0) /* no escape sequence; return best character */\n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */",
            "#define ESCAPE_UDELAY 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n#define ESCAPE_UDELAY 1000\n\nchar kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar buf[4];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * When the first character is received (or we get a change\n\t\t * input source) we set ourselves up to handle an escape\n\t\t * sequences (just in case).\n\t\t */\n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0) /* no escape sequence; return best character */\n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s\"",
            "moreprompt"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_msg_write",
          "args": [
            "moreprompt",
            "strlen(moreprompt)"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_msg_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "545-581",
          "snippet": "static void kdb_msg_write(const char *msg, int msg_len)\n{\n\tstruct console *c;\n\tconst char *cp;\n\tint len;\n\n\tif (msg_len == 0)\n\t\treturn;\n\n\tcp = msg;\n\tlen = msg_len;\n\n\twhile (len--) {\n\t\tdbg_io_ops->write_char(*cp);\n\t\tcp++;\n\t}\n\n\tfor_each_console(c) {\n\t\tif (!(c->flags & CON_ENABLED))\n\t\t\tcontinue;\n\t\tif (c == dbg_io_ops->cons)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Set oops_in_progress to encourage the console drivers to\n\t\t * disregard their internal spin locks: in the current calling\n\t\t * context the risk of deadlock is a bigger problem than risks\n\t\t * due to re-entering the console driver. We operate directly on\n\t\t * oops_in_progress rather than using bust_spinlocks() because\n\t\t * the calls bust_spinlocks() makes on exit are not appropriate\n\t\t * for this calling context.\n\t\t */\n\t\t++oops_in_progress;\n\t\tc->write(c, msg, msg_len);\n\t\t--oops_in_progress;\n\t\ttouch_nmi_watchdog();\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void kdb_msg_write(const char *msg, int msg_len)\n{\n\tstruct console *c;\n\tconst char *cp;\n\tint len;\n\n\tif (msg_len == 0)\n\t\treturn;\n\n\tcp = msg;\n\tlen = msg_len;\n\n\twhile (len--) {\n\t\tdbg_io_ops->write_char(*cp);\n\t\tcp++;\n\t}\n\n\tfor_each_console(c) {\n\t\tif (!(c->flags & CON_ENABLED))\n\t\t\tcontinue;\n\t\tif (c == dbg_io_ops->cons)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Set oops_in_progress to encourage the console drivers to\n\t\t * disregard their internal spin locks: in the current calling\n\t\t * context the risk of deadlock is a bigger problem than risks\n\t\t * due to re-entering the console driver. We operate directly on\n\t\t * oops_in_progress rather than using bust_spinlocks() because\n\t\t * the calls bust_spinlocks() makes on exit are not appropriate\n\t\t * for this calling context.\n\t\t */\n\t\t++oops_in_progress;\n\t\tc->write(c, msg, msg_len);\n\t\t--oops_in_progress;\n\t\ttouch_nmi_watchdog();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "PAGER"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s\"",
            "kdb_buffer"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_get_level",
          "args": [
            "kdb_buffer"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdbstub_msg_write",
          "args": [
            "cp",
            "retlen - (cp - kdb_buffer)"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_msg_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "195-229",
          "snippet": "void gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char gdbmsgbuf[BUFMAX + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char gdbmsgbuf[BUFMAX + 1];\n\nvoid gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_skip_headers",
          "args": [
            "kdb_buffer"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "kdb_buffer",
            "cphold"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_search_string",
          "args": [
            "kdb_buffer",
            "kdb_grep_string"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_search_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "515-543",
          "snippet": "static int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t/* not counting the newline at the end of \"searched\" */\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t/* not counting the newline at the end of \"searched\" */\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp2",
            "kdb_prompt_str",
            "len"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "kdb_buffer",
            "'\\n'"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "next_avail",
            "size_avail",
            "fmt",
            "ap"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"LOGGING\"",
            "&logging"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "284-293",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&kdb_printf_cpu",
            "-1",
            "this_cpu"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nchar kdb_prompt_str[CMD_BUFLEN];\nint kdb_printf_cpu = -1;\nstatic char kdb_buffer[256];\nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tunsigned long flags;\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH) {\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Replace the \\0 with\n\t\t\t * its original value to ensure multi-line strings\n\t\t\t * are handled properly, and return to normal mode.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tkdb_grepping_flag = 0;\n\t\t}\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected)\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\telse\n\t\tkdb_msg_write(cp, retlen - (cp - kdb_buffer));\n\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar ch;\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tkdb_msg_write(moreprompt, strlen(moreprompt));\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tch = kdb_getchar();\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((ch == 'q') || (ch == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (ch == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '\\n' || ch == '\\r') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (ch) {\n\t\t\t/* user hit something unexpected */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (ch != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}"
  },
  {
    "function_name": "kdb_msg_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "545-581",
    "snippet": "static void kdb_msg_write(const char *msg, int msg_len)\n{\n\tstruct console *c;\n\tconst char *cp;\n\tint len;\n\n\tif (msg_len == 0)\n\t\treturn;\n\n\tcp = msg;\n\tlen = msg_len;\n\n\twhile (len--) {\n\t\tdbg_io_ops->write_char(*cp);\n\t\tcp++;\n\t}\n\n\tfor_each_console(c) {\n\t\tif (!(c->flags & CON_ENABLED))\n\t\t\tcontinue;\n\t\tif (c == dbg_io_ops->cons)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Set oops_in_progress to encourage the console drivers to\n\t\t * disregard their internal spin locks: in the current calling\n\t\t * context the risk of deadlock is a bigger problem than risks\n\t\t * due to re-entering the console driver. We operate directly on\n\t\t * oops_in_progress rather than using bust_spinlocks() because\n\t\t * the calls bust_spinlocks() makes on exit are not appropriate\n\t\t * for this calling context.\n\t\t */\n\t\t++oops_in_progress;\n\t\tc->write(c, msg, msg_len);\n\t\t--oops_in_progress;\n\t\ttouch_nmi_watchdog();\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->write",
          "args": [
            "c",
            "msg",
            "msg_len"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "*cp"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void kdb_msg_write(const char *msg, int msg_len)\n{\n\tstruct console *c;\n\tconst char *cp;\n\tint len;\n\n\tif (msg_len == 0)\n\t\treturn;\n\n\tcp = msg;\n\tlen = msg_len;\n\n\twhile (len--) {\n\t\tdbg_io_ops->write_char(*cp);\n\t\tcp++;\n\t}\n\n\tfor_each_console(c) {\n\t\tif (!(c->flags & CON_ENABLED))\n\t\t\tcontinue;\n\t\tif (c == dbg_io_ops->cons)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Set oops_in_progress to encourage the console drivers to\n\t\t * disregard their internal spin locks: in the current calling\n\t\t * context the risk of deadlock is a bigger problem than risks\n\t\t * due to re-entering the console driver. We operate directly on\n\t\t * oops_in_progress rather than using bust_spinlocks() because\n\t\t * the calls bust_spinlocks() makes on exit are not appropriate\n\t\t * for this calling context.\n\t\t */\n\t\t++oops_in_progress;\n\t\tc->write(c, msg, msg_len);\n\t\t--oops_in_progress;\n\t\ttouch_nmi_watchdog();\n\t}\n}"
  },
  {
    "function_name": "kdb_search_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "515-543",
    "snippet": "static int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t/* not counting the newline at the end of \"searched\" */\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp",
            "searchfor",
            "len2"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "firstchar"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "searched+len1-len2",
            "searchfor",
            "len2"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "searched",
            "searchfor",
            "len2"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "searchfor"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t/* not counting the newline at the end of \"searched\" */\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_input_flush",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "462-481",
    "snippet": "static void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}"
  },
  {
    "function_name": "kdb_getstr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "436-443",
    "snippet": "char *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrscpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define CMD_BUFLEN 256"
    ],
    "globals_used": [
      "char kdb_prompt_str[CMD_BUFLEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_read",
          "args": [
            "buffer",
            "bufsize"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "196-415",
          "snippet": "static char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key, buf_size, ret;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_getchar();\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tbuf_size = sizeof(tmpbuffer) - (p_tmp - tmpbuffer);\n\t\tcount = kallsyms_symbol_complete(p_tmp, buf_size);\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tret = kallsyms_symbol_next(p_tmp, i, buf_size);\n\t\t\t\tif (WARN_ON(!ret))\n\t\t\t\t\tbreak;\n\t\t\t\tif (ret != -E2BIG)\n\t\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\telse\n\t\t\t\t\tkdb_printf(\"%s... \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN 256"
          ],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nstatic char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key, buf_size, ret;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_getchar();\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tbuf_size = sizeof(tmpbuffer) - (p_tmp - tmpbuffer);\n\t\tcount = kallsyms_symbol_complete(p_tmp, buf_size);\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tret = kallsyms_symbol_next(p_tmp, i, buf_size);\n\t\t\t\tif (WARN_ON(!ret))\n\t\t\t\t\tbreak;\n\t\t\t\tif (ret != -E2BIG)\n\t\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\telse\n\t\t\t\t\tkdb_printf(\"%s... \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "kdb_prompt_str"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "kdb_prompt_str",
            "prompt",
            "CMD_BUFLEN"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrscpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}"
  },
  {
    "function_name": "kdb_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "196-415",
    "snippet": "static char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key, buf_size, ret;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_getchar();\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tbuf_size = sizeof(tmpbuffer) - (p_tmp - tmpbuffer);\n\t\tcount = kallsyms_symbol_complete(p_tmp, buf_size);\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tret = kallsyms_symbol_next(p_tmp, i, buf_size);\n\t\t\t\tif (WARN_ON(!ret))\n\t\t\t\t\tbreak;\n\t\t\t\tif (ret != -E2BIG)\n\t\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\telse\n\t\t\t\t\tkdb_printf(\"%s... \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define CMD_BUFLEN 256"
    ],
    "globals_used": [
      "char kdb_prompt_str[CMD_BUFLEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_KGDB"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"kgdb\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_gdb_state_pass",
          "args": [
            "lastchar - 11"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_gdb_state_pass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
          "lines": "173-176",
          "snippet": "void kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}",
          "includes": [
            "#include \"../debug_core.h\"",
            "#include \"kdb_private.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_state *kdb_ks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nstatic struct kgdb_state *kdb_ks;\n\nvoid kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lastchar - 11",
            "\"$qSupported\""
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_KGDB"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"kgdb\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%c\"",
            "key"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_transition_check",
          "args": [
            "buffer"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_transition_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "35-50",
          "snippet": "static int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cp+1",
            "tmpbuffer",
            "lastchar - cp"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cp",
            "p_tmp+len",
            "len_tmp-len + 1"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p_tmp"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "p_tmp+len_tmp",
            "cp",
            "lastchar-cp+1"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ret"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_symbol_next",
          "args": [
            "p_tmp",
            "i",
            "buf_size"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_symbol_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "171-185",
          "snippet": "int kallsyms_symbol_next(char *prefix_name, int flag, int buf_size)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (!strncmp(name, prefix_name, prefix_len))\n\t\t\treturn strscpy(prefix_name, name, buf_size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kallsyms_symbol_next(char *prefix_name, int flag, int buf_size)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (!strncmp(name, prefix_name, prefix_len))\n\t\t\treturn strscpy(prefix_name, name, buf_size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_symbol_complete",
          "args": [
            "p_tmp",
            "buf_size"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_symbol_complete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "127-157",
          "snippet": "int kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrscpy(ks_namebuf, name, sizeof(ks_namebuf));\n\t\t\t/* Work out the longest name that matches the prefix */\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];\n\nint kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrscpy(ks_namebuf, name, sizeof(ks_namebuf));\n\t\t\t/* Work out the longest name that matches the prefix */\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "tmpbuffer",
            "' '"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmpbuffer",
            "' '",
            "strlen(kdb_prompt_str) + (lastchar-buffer)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmpbuffer",
            "' '",
            "strlen(kdb_prompt_str) + (lastchar-buffer)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getchar",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getchar",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "126-173",
          "snippet": "char kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar buf[4];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * When the first character is received (or we get a change\n\t\t * input source) we set ourselves up to handle an escape\n\t\t * sequences (just in case).\n\t\t */\n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0) /* no escape sequence; return best character */\n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */",
            "#define ESCAPE_UDELAY 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n#define ESCAPE_UDELAY 1000\n\nchar kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar buf[4];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * When the first character is received (or we get a change\n\t\t * input source) we set ourselves up to handle an escape\n\t\t * sequences (just in case).\n\t\t */\n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0) /* no escape sequence; return best character */\n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"DTABCOUNT\"",
            "&dtab_count"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "284-293",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nstatic char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key, buf_size, ret;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_getchar();\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tbuf_size = sizeof(tmpbuffer) - (p_tmp - tmpbuffer);\n\t\tcount = kallsyms_symbol_complete(p_tmp, buf_size);\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tret = kallsyms_symbol_next(p_tmp, i, buf_size);\n\t\t\t\tif (WARN_ON(!ret))\n\t\t\t\t\tbreak;\n\t\t\t\tif (ret != -E2BIG)\n\t\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\telse\n\t\t\t\t\tkdb_printf(\"%s... \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}"
  },
  {
    "function_name": "kdb_getchar",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "126-173",
    "snippet": "char kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar buf[4];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * When the first character is received (or we get a change\n\t\t * input source) we set ourselves up to handle an escape\n\t\t * sequences (just in case).\n\t\t */\n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0) /* no escape sequence; return best character */\n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */",
      "#define ESCAPE_UDELAY 1000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unreachable",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_handle_escape",
          "args": [
            "buf",
            "pbuf - buf"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_handle_escape",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "62-109",
          "snippet": "static int kdb_handle_escape(char *buf, size_t sz)\n{\n\tchar *lastkey = buf + sz - 1;\n\n\tswitch (sz) {\n\tcase 1:\n\t\tif (*lastkey == '\\e')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 2: /* \\e<something> */\n\t\tif (*lastkey == '[')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 3:\n\t\tswitch (*lastkey) {\n\t\tcase 'A': /* \\e[A, up arrow */\n\t\t\treturn 16;\n\t\tcase 'B': /* \\e[B, down arrow */\n\t\t\treturn 14;\n\t\tcase 'C': /* \\e[C, right arrow */\n\t\t\treturn 6;\n\t\tcase 'D': /* \\e[D, left arrow */\n\t\t\treturn 2;\n\t\tcase '1': /* \\e[<1,3,4>], may be home, del, end */\n\t\tcase '3':\n\t\tcase '4':\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tif (*lastkey == '~') {\n\t\t\tswitch (buf[2]) {\n\t\t\tcase '1': /* \\e[1~, home */\n\t\t\t\treturn 1;\n\t\t\tcase '3': /* \\e[3~, del */\n\t\t\t\treturn 4;\n\t\t\tcase '4': /* \\e[4~, end */\n\t\t\t\treturn 5;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kdb_handle_escape(char *buf, size_t sz)\n{\n\tchar *lastkey = buf + sz - 1;\n\n\tswitch (sz) {\n\tcase 1:\n\t\tif (*lastkey == '\\e')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 2: /* \\e<something> */\n\t\tif (*lastkey == '[')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 3:\n\t\tswitch (*lastkey) {\n\t\tcase 'A': /* \\e[A, up arrow */\n\t\t\treturn 16;\n\t\tcase 'B': /* \\e[B, down arrow */\n\t\t\treturn 14;\n\t\tcase 'C': /* \\e[C, right arrow */\n\t\t\treturn 6;\n\t\tcase 'D': /* \\e[D, left arrow */\n\t\t\treturn 2;\n\t\tcase '1': /* \\e[<1,3,4>], may be home, del, end */\n\t\tcase '3':\n\t\tcase '4':\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tif (*lastkey == '~') {\n\t\t\tswitch (buf[2]) {\n\t\t\tcase '1': /* \\e[1~, home */\n\t\t\t\treturn 1;\n\t\t\tcase '3': /* \\e[3~, del */\n\t\t\t\treturn 4;\n\t\t\tcase '4': /* \\e[4~, end */\n\t\t\t\treturn 5;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "ESCAPE_UDELAY"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n#define ESCAPE_UDELAY 1000\n\nchar kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar buf[4];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * When the first character is received (or we get a change\n\t\t * input source) we set ourselves up to handle an escape\n\t\t * sequences (just in case).\n\t\t */\n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0) /* no escape sequence; return best character */\n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}"
  },
  {
    "function_name": "kdb_handle_escape",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "62-109",
    "snippet": "static int kdb_handle_escape(char *buf, size_t sz)\n{\n\tchar *lastkey = buf + sz - 1;\n\n\tswitch (sz) {\n\tcase 1:\n\t\tif (*lastkey == '\\e')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 2: /* \\e<something> */\n\t\tif (*lastkey == '[')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 3:\n\t\tswitch (*lastkey) {\n\t\tcase 'A': /* \\e[A, up arrow */\n\t\t\treturn 16;\n\t\tcase 'B': /* \\e[B, down arrow */\n\t\t\treturn 14;\n\t\tcase 'C': /* \\e[C, right arrow */\n\t\t\treturn 6;\n\t\tcase 'D': /* \\e[D, left arrow */\n\t\t\treturn 2;\n\t\tcase '1': /* \\e[<1,3,4>], may be home, del, end */\n\t\tcase '3':\n\t\tcase '4':\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tif (*lastkey == '~') {\n\t\t\tswitch (buf[2]) {\n\t\t\tcase '1': /* \\e[1~, home */\n\t\t\t\treturn 1;\n\t\t\tcase '3': /* \\e[3~, del */\n\t\t\t\treturn 4;\n\t\t\tcase '4': /* \\e[4~, end */\n\t\t\t\treturn 5;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kdb_handle_escape(char *buf, size_t sz)\n{\n\tchar *lastkey = buf + sz - 1;\n\n\tswitch (sz) {\n\tcase 1:\n\t\tif (*lastkey == '\\e')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 2: /* \\e<something> */\n\t\tif (*lastkey == '[')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 3:\n\t\tswitch (*lastkey) {\n\t\tcase 'A': /* \\e[A, up arrow */\n\t\t\treturn 16;\n\t\tcase 'B': /* \\e[B, down arrow */\n\t\t\treturn 14;\n\t\tcase 'C': /* \\e[C, right arrow */\n\t\t\treturn 6;\n\t\tcase 'D': /* \\e[D, left arrow */\n\t\t\treturn 2;\n\t\tcase '1': /* \\e[<1,3,4>], may be home, del, end */\n\t\tcase '3':\n\t\tcase '4':\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tif (*lastkey == '~') {\n\t\t\tswitch (buf[2]) {\n\t\t\tcase '1': /* \\e[1~, home */\n\t\t\t\treturn 1;\n\t\t\tcase '3': /* \\e[3~, del */\n\t\t\t\treturn 4;\n\t\t\tcase '4': /* \\e[4~, end */\n\t\t\t\treturn 5;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "kgdb_transition_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "35-50",
    "snippet": "static int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_KGDB"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"kgdb\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_gdb_state_pass",
          "args": [
            "buffer"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_gdb_state_pass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
          "lines": "173-176",
          "snippet": "void kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}",
          "includes": [
            "#include \"../debug_core.h\"",
            "#include \"kdb_private.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_state *kdb_ks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nstatic struct kgdb_state *kdb_ks;\n\nvoid kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%s\"",
            "buffer"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  }
]