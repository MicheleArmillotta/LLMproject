[
  {
    "function_name": "lockevent_pv_hop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock_stat.h",
    "lines": "140-140",
    "snippet": "static inline void lockevent_pv_hop(int hopcnt)\t{ }",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include \"lock_events.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include \"lock_events.h\"\n\nstatic inline void lockevent_pv_hop(int hopcnt)\t{ }"
  },
  {
    "function_name": "__pv_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock_stat.h",
    "lines": "120-131",
    "snippet": "static inline void __pv_wait(u8 *ptr, u8 val)\n{\n\tu64 *pkick_time = this_cpu_ptr(&pv_kick_time);\n\n\t*pkick_time = 0;\n\tpv_wait(ptr, val);\n\tif (*pkick_time) {\n\t\tthis_cpu_add(EVENT_COUNT(pv_latency_wake),\n\t\t\t     sched_clock() - *pkick_time);\n\t\tlockevent_inc(pv_kick_wake);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include \"lock_events.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockevent_inc",
          "args": [
            "pv_kick_wake"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "EVENT_COUNT(pv_latency_wake)",
            "sched_clock() - *pkick_time"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVENT_COUNT",
          "args": [
            "pv_latency_wake"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_wait",
          "args": [
            "ptr",
            "val"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock_stat.h",
          "lines": "120-131",
          "snippet": "static inline void __pv_wait(u8 *ptr, u8 val)\n{\n\tu64 *pkick_time = this_cpu_ptr(&pv_kick_time);\n\n\t*pkick_time = 0;\n\tpv_wait(ptr, val);\n\tif (*pkick_time) {\n\t\tthis_cpu_add(EVENT_COUNT(pv_latency_wake),\n\t\t\t     sched_clock() - *pkick_time);\n\t\tlockevent_inc(pv_kick_wake);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&pv_kick_time"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include \"lock_events.h\"\n\nstatic inline void __pv_wait(u8 *ptr, u8 val)\n{\n\tu64 *pkick_time = this_cpu_ptr(&pv_kick_time);\n\n\t*pkick_time = 0;\n\tpv_wait(ptr, val);\n\tif (*pkick_time) {\n\t\tthis_cpu_add(EVENT_COUNT(pv_latency_wake),\n\t\t\t     sched_clock() - *pkick_time);\n\t\tlockevent_inc(pv_kick_wake);\n\t}\n}"
  },
  {
    "function_name": "__pv_kick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock_stat.h",
    "lines": "108-115",
    "snippet": "static inline void __pv_kick(int cpu)\n{\n\tu64 start = sched_clock();\n\n\tper_cpu(pv_kick_time, cpu) = start;\n\tpv_kick(cpu);\n\tthis_cpu_add(EVENT_COUNT(pv_latency_kick), sched_clock() - start);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include \"lock_events.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "EVENT_COUNT(pv_latency_kick)",
            "sched_clock() - start"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVENT_COUNT",
          "args": [
            "pv_latency_kick"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_kick",
          "args": [
            "cpu"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_kick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock_stat.h",
          "lines": "108-115",
          "snippet": "static inline void __pv_kick(int cpu)\n{\n\tu64 start = sched_clock();\n\n\tper_cpu(pv_kick_time, cpu) = start;\n\tpv_kick(cpu);\n\tthis_cpu_add(EVENT_COUNT(pv_latency_kick), sched_clock() - start);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "pv_kick_time",
            "cpu"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include \"lock_events.h\"\n\nstatic inline void __pv_kick(int cpu)\n{\n\tu64 start = sched_clock();\n\n\tper_cpu(pv_kick_time, cpu) = start;\n\tpv_kick(cpu);\n\tthis_cpu_add(EVENT_COUNT(pv_latency_kick), sched_clock() - start);\n}"
  },
  {
    "function_name": "lockevent_pv_hop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock_stat.h",
    "lines": "100-103",
    "snippet": "static inline void lockevent_pv_hop(int hopcnt)\n{\n\tthis_cpu_add(EVENT_COUNT(pv_hash_hops), hopcnt);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include \"lock_events.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "EVENT_COUNT(pv_hash_hops)",
            "hopcnt"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVENT_COUNT",
          "args": [
            "pv_hash_hops"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include \"lock_events.h\"\n\nstatic inline void lockevent_pv_hop(int hopcnt)\n{\n\tthis_cpu_add(EVENT_COUNT(pv_hash_hops), hopcnt);\n}"
  },
  {
    "function_name": "lockevent_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock_stat.h",
    "lines": "36-95",
    "snippet": "ssize_t lockevent_read(struct file *file, char __user *user_buf,\n\t\t       size_t count, loff_t *ppos)\n{\n\tchar buf[64];\n\tint cpu, id, len;\n\tu64 sum = 0, kicks = 0;\n\n\t/*\n\t * Get the counter ID stored in file->f_inode->i_private\n\t */\n\tid = (long)file_inode(file)->i_private;\n\n\tif (id >= lockevent_num)\n\t\treturn -EBADF;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsum += per_cpu(lockevents[id], cpu);\n\t\t/*\n\t\t * Need to sum additional counters for some of them\n\t\t */\n\t\tswitch (id) {\n\n\t\tcase LOCKEVENT_pv_latency_kick:\n\t\tcase LOCKEVENT_pv_hash_hops:\n\t\t\tkicks += per_cpu(EVENT_COUNT(pv_kick_unlock), cpu);\n\t\t\tbreak;\n\n\t\tcase LOCKEVENT_pv_latency_wake:\n\t\t\tkicks += per_cpu(EVENT_COUNT(pv_kick_wake), cpu);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (id == LOCKEVENT_pv_hash_hops) {\n\t\tu64 frac = 0;\n\n\t\tif (kicks) {\n\t\t\tfrac = 100ULL * do_div(sum, kicks);\n\t\t\tfrac = DIV_ROUND_CLOSEST_ULL(frac, kicks);\n\t\t}\n\n\t\t/*\n\t\t * Return a X.XX decimal number\n\t\t */\n\t\tlen = snprintf(buf, sizeof(buf) - 1, \"%llu.%02llu\\n\",\n\t\t\t       sum, frac);\n\t} else {\n\t\t/*\n\t\t * Round to the nearest ns\n\t\t */\n\t\tif ((id == LOCKEVENT_pv_latency_kick) ||\n\t\t    (id == LOCKEVENT_pv_latency_wake)) {\n\t\t\tif (kicks)\n\t\t\t\tsum = DIV_ROUND_CLOSEST_ULL(sum, kicks);\n\t\t}\n\t\tlen = snprintf(buf, sizeof(buf) - 1, \"%llu\\n\", sum);\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include \"lock_events.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "user_buf",
            "count",
            "ppos",
            "buf",
            "len"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf) - 1",
            "\"%llu\\n\"",
            "sum"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_CLOSEST_ULL",
          "args": [
            "sum",
            "kicks"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf) - 1",
            "\"%llu.%02llu\\n\"",
            "sum",
            "frac"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_CLOSEST_ULL",
          "args": [
            "frac",
            "kicks"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "sum",
            "kicks"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "EVENT_COUNT(pv_kick_wake)",
            "cpu"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVENT_COUNT",
          "args": [
            "pv_kick_wake"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVENT_COUNT",
          "args": [
            "pv_kick_unlock"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include \"lock_events.h\"\n\nssize_t lockevent_read(struct file *file, char __user *user_buf,\n\t\t       size_t count, loff_t *ppos)\n{\n\tchar buf[64];\n\tint cpu, id, len;\n\tu64 sum = 0, kicks = 0;\n\n\t/*\n\t * Get the counter ID stored in file->f_inode->i_private\n\t */\n\tid = (long)file_inode(file)->i_private;\n\n\tif (id >= lockevent_num)\n\t\treturn -EBADF;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsum += per_cpu(lockevents[id], cpu);\n\t\t/*\n\t\t * Need to sum additional counters for some of them\n\t\t */\n\t\tswitch (id) {\n\n\t\tcase LOCKEVENT_pv_latency_kick:\n\t\tcase LOCKEVENT_pv_hash_hops:\n\t\t\tkicks += per_cpu(EVENT_COUNT(pv_kick_unlock), cpu);\n\t\t\tbreak;\n\n\t\tcase LOCKEVENT_pv_latency_wake:\n\t\t\tkicks += per_cpu(EVENT_COUNT(pv_kick_wake), cpu);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (id == LOCKEVENT_pv_hash_hops) {\n\t\tu64 frac = 0;\n\n\t\tif (kicks) {\n\t\t\tfrac = 100ULL * do_div(sum, kicks);\n\t\t\tfrac = DIV_ROUND_CLOSEST_ULL(frac, kicks);\n\t\t}\n\n\t\t/*\n\t\t * Return a X.XX decimal number\n\t\t */\n\t\tlen = snprintf(buf, sizeof(buf) - 1, \"%llu.%02llu\\n\",\n\t\t\t       sum, frac);\n\t} else {\n\t\t/*\n\t\t * Round to the nearest ns\n\t\t */\n\t\tif ((id == LOCKEVENT_pv_latency_kick) ||\n\t\t    (id == LOCKEVENT_pv_latency_wake)) {\n\t\t\tif (kicks)\n\t\t\t\tsum = DIV_ROUND_CLOSEST_ULL(sum, kicks);\n\t\t}\n\t\tlen = snprintf(buf, sizeof(buf) - 1, \"%llu\\n\", sum);\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}"
  }
]