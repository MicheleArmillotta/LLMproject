[
  {
    "function_name": "kthread_blkcg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1519-1529",
    "snippet": "struct cgroup_subsys_state *kthread_blkcg(void)\n{\n\tstruct kthread *kthread;\n\n\tif (current->flags & PF_KTHREAD) {\n\t\tkthread = to_kthread(current);\n\t\tif (kthread)\n\t\t\treturn kthread->blkcg_css;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "current"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct cgroup_subsys_state *kthread_blkcg(void)\n{\n\tstruct kthread *kthread;\n\n\tif (current->flags & PF_KTHREAD) {\n\t\tkthread = to_kthread(current);\n\t\tif (kthread)\n\t\t\treturn kthread->blkcg_css;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "kthread_associate_blkcg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1493-1511",
    "snippet": "void kthread_associate_blkcg(struct cgroup_subsys_state *css)\n{\n\tstruct kthread *kthread;\n\n\tif (!(current->flags & PF_KTHREAD))\n\t\treturn;\n\tkthread = to_kthread(current);\n\tif (!kthread)\n\t\treturn;\n\n\tif (kthread->blkcg_css) {\n\t\tcss_put(kthread->blkcg_css);\n\t\tkthread->blkcg_css = NULL;\n\t}\n\tif (css) {\n\t\tcss_get(css);\n\t\tkthread->blkcg_css = css;\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "kthread->blkcg_css"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "current"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_associate_blkcg(struct cgroup_subsys_state *css)\n{\n\tstruct kthread *kthread;\n\n\tif (!(current->flags & PF_KTHREAD))\n\t\treturn;\n\tkthread = to_kthread(current);\n\tif (!kthread)\n\t\treturn;\n\n\tif (kthread->blkcg_css) {\n\t\tcss_put(kthread->blkcg_css);\n\t\tkthread->blkcg_css = NULL;\n\t}\n\tif (css) {\n\t\tcss_get(css);\n\t\tkthread->blkcg_css = css;\n\t}\n}"
  },
  {
    "function_name": "kthread_unuse_mm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1453-1479",
    "snippet": "void kthread_unuse_mm(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk = current;\n\n\tWARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));\n\tWARN_ON_ONCE(!tsk->mm);\n\n\tforce_uaccess_end(to_kthread(tsk)->oldfs);\n\n\ttask_lock(tsk);\n\t/*\n\t * When a kthread stops operating on an address space, the loop\n\t * in membarrier_{private,global}_expedited() may not observe\n\t * that tsk->mm, and not issue an IPI. Membarrier requires a\n\t * memory barrier after accessing user-space memory, before\n\t * clearing tsk->mm.\n\t */\n\tsmp_mb__after_spinlock();\n\tsync_mm_rss(mm);\n\tlocal_irq_disable();\n\ttsk->mm = NULL;\n\tmembarrier_update_current_mm(NULL);\n\t/* active_mm is still 'mm' */\n\tenter_lazy_tlb(mm, tsk);\n\tlocal_irq_enable();\n\ttask_unlock(tsk);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_lazy_tlb",
          "args": [
            "mm",
            "tsk"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membarrier_update_current_mm",
          "args": [
            "NULL"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_update_current_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "232-242",
          "snippet": "void membarrier_update_current_mm(struct mm_struct *next_mm)\n{\n\tstruct rq *rq = this_rq();\n\tint membarrier_state = 0;\n\n\tif (next_mm)\n\t\tmembarrier_state = atomic_read(&next_mm->membarrier_state);\n\tif (READ_ONCE(rq->membarrier_state) == membarrier_state)\n\t\treturn;\n\tWRITE_ONCE(rq->membarrier_state, membarrier_state);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid membarrier_update_current_mm(struct mm_struct *next_mm)\n{\n\tstruct rq *rq = this_rq();\n\tint membarrier_state = 0;\n\n\tif (next_mm)\n\t\tmembarrier_state = atomic_read(&next_mm->membarrier_state);\n\tif (READ_ONCE(rq->membarrier_state) == membarrier_state)\n\t\treturn;\n\tWRITE_ONCE(rq->membarrier_state, membarrier_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "mm"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_uaccess_end",
          "args": [
            "to_kthread(tsk)->oldfs"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "tsk"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tsk->mm"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(tsk->flags & PF_KTHREAD)"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unuse_mm(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk = current;\n\n\tWARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));\n\tWARN_ON_ONCE(!tsk->mm);\n\n\tforce_uaccess_end(to_kthread(tsk)->oldfs);\n\n\ttask_lock(tsk);\n\t/*\n\t * When a kthread stops operating on an address space, the loop\n\t * in membarrier_{private,global}_expedited() may not observe\n\t * that tsk->mm, and not issue an IPI. Membarrier requires a\n\t * memory barrier after accessing user-space memory, before\n\t * clearing tsk->mm.\n\t */\n\tsmp_mb__after_spinlock();\n\tsync_mm_rss(mm);\n\tlocal_irq_disable();\n\ttsk->mm = NULL;\n\tmembarrier_update_current_mm(NULL);\n\t/* active_mm is still 'mm' */\n\tenter_lazy_tlb(mm, tsk);\n\tlocal_irq_enable();\n\ttask_unlock(tsk);\n}"
  },
  {
    "function_name": "kthread_use_mm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1406-1446",
    "snippet": "void kthread_use_mm(struct mm_struct *mm)\n{\n\tstruct mm_struct *active_mm;\n\tstruct task_struct *tsk = current;\n\n\tWARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));\n\tWARN_ON_ONCE(tsk->mm);\n\n\ttask_lock(tsk);\n\t/* Hold off tlb flush IPIs while switching mm's */\n\tlocal_irq_disable();\n\tactive_mm = tsk->active_mm;\n\tif (active_mm != mm) {\n\t\tmmgrab(mm);\n\t\ttsk->active_mm = mm;\n\t}\n\ttsk->mm = mm;\n\tmembarrier_update_current_mm(mm);\n\tswitch_mm_irqs_off(active_mm, mm, tsk);\n\tlocal_irq_enable();\n\ttask_unlock(tsk);\n#ifdef finish_arch_post_lock_switch\n\tfinish_arch_post_lock_switch();\n#endif\n\n\t/*\n\t * When a kthread starts operating on an address space, the loop\n\t * in membarrier_{private,global}_expedited() may not observe\n\t * that tsk->mm, and not issue an IPI. Membarrier requires a\n\t * memory barrier after storing to tsk->mm, before accessing\n\t * user-space memory. A full memory barrier for membarrier\n\t * {PRIVATE,GLOBAL}_EXPEDITED is implicitly provided by\n\t * mmdrop(), or explicitly with smp_mb().\n\t */\n\tif (active_mm != mm)\n\t\tmmdrop(active_mm);\n\telse\n\t\tsmp_mb();\n\n\tto_kthread(tsk)->oldfs = force_uaccess_begin();\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_uaccess_begin",
          "args": [],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "tsk"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "active_mm"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "mmdrop_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "718-724",
          "snippet": "static void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_arch_post_lock_switch",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_mm_irqs_off",
          "args": [
            "active_mm",
            "mm",
            "tsk"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membarrier_update_current_mm",
          "args": [
            "mm"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_update_current_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "232-242",
          "snippet": "void membarrier_update_current_mm(struct mm_struct *next_mm)\n{\n\tstruct rq *rq = this_rq();\n\tint membarrier_state = 0;\n\n\tif (next_mm)\n\t\tmembarrier_state = atomic_read(&next_mm->membarrier_state);\n\tif (READ_ONCE(rq->membarrier_state) == membarrier_state)\n\t\treturn;\n\tWRITE_ONCE(rq->membarrier_state, membarrier_state);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid membarrier_update_current_mm(struct mm_struct *next_mm)\n{\n\tstruct rq *rq = this_rq();\n\tint membarrier_state = 0;\n\n\tif (next_mm)\n\t\tmembarrier_state = atomic_read(&next_mm->membarrier_state);\n\tif (READ_ONCE(rq->membarrier_state) == membarrier_state)\n\t\treturn;\n\tWRITE_ONCE(rq->membarrier_state, membarrier_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "mm"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tsk->mm"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(tsk->flags & PF_KTHREAD)"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_use_mm(struct mm_struct *mm)\n{\n\tstruct mm_struct *active_mm;\n\tstruct task_struct *tsk = current;\n\n\tWARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));\n\tWARN_ON_ONCE(tsk->mm);\n\n\ttask_lock(tsk);\n\t/* Hold off tlb flush IPIs while switching mm's */\n\tlocal_irq_disable();\n\tactive_mm = tsk->active_mm;\n\tif (active_mm != mm) {\n\t\tmmgrab(mm);\n\t\ttsk->active_mm = mm;\n\t}\n\ttsk->mm = mm;\n\tmembarrier_update_current_mm(mm);\n\tswitch_mm_irqs_off(active_mm, mm, tsk);\n\tlocal_irq_enable();\n\ttask_unlock(tsk);\n#ifdef finish_arch_post_lock_switch\n\tfinish_arch_post_lock_switch();\n#endif\n\n\t/*\n\t * When a kthread starts operating on an address space, the loop\n\t * in membarrier_{private,global}_expedited() may not observe\n\t * that tsk->mm, and not issue an IPI. Membarrier requires a\n\t * memory barrier after storing to tsk->mm, before accessing\n\t * user-space memory. A full memory barrier for membarrier\n\t * {PRIVATE,GLOBAL}_EXPEDITED is implicitly provided by\n\t * mmdrop(), or explicitly with smp_mb().\n\t */\n\tif (active_mm != mm)\n\t\tmmdrop(active_mm);\n\telse\n\t\tsmp_mb();\n\n\tto_kthread(tsk)->oldfs = force_uaccess_begin();\n}"
  },
  {
    "function_name": "kthread_destroy_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1387-1399",
    "snippet": "void kthread_destroy_worker(struct kthread_worker *worker)\n{\n\tstruct task_struct *task;\n\n\ttask = worker->task;\n\tif (WARN_ON(!task))\n\t\treturn;\n\n\tkthread_flush_worker(worker);\n\tkthread_stop(task);\n\tWARN_ON(!list_empty(&worker->work_list));\n\tkfree(worker);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "worker"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&worker->work_list)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->work_list"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "task"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_flush_worker",
          "args": [
            "worker"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_flush_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1367-1376",
          "snippet": "void kthread_flush_worker(struct kthread_worker *worker)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\n\tkthread_queue_work(worker, &fwork.work);\n\twait_for_completion(&fwork.done);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_flush_worker(struct kthread_worker *worker)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\n\tkthread_queue_work(worker, &fwork.work);\n\twait_for_completion(&fwork.done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!task"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid kthread_destroy_worker(struct kthread_worker *worker)\n{\n\tstruct task_struct *task;\n\n\ttask = worker->task;\n\tif (WARN_ON(!task))\n\t\treturn;\n\n\tkthread_flush_worker(worker);\n\tkthread_stop(task);\n\tWARN_ON(!list_empty(&worker->work_list));\n\tkfree(worker);\n}"
  },
  {
    "function_name": "kthread_flush_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1367-1376",
    "snippet": "void kthread_flush_worker(struct kthread_worker *worker)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\n\tkthread_queue_work(worker, &fwork.work);\n\twait_for_completion(&fwork.done);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&fwork.done"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_queue_work",
          "args": [
            "worker",
            "&fwork.work"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "995-1008",
          "snippet": "bool kthread_queue_work(struct kthread_worker *worker,\n\t\t\tstruct kthread_work *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\tif (!queuing_blocked(worker, work)) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\tret = true;\n\t}\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_work(struct kthread_worker *worker,\n\t\t\tstruct kthread_work *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\tif (!queuing_blocked(worker, work)) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\tret = true;\n\t}\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPLETION_INITIALIZER_ONSTACK",
          "args": [
            "fwork.done"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KTHREAD_WORK_INIT",
          "args": [
            "fwork.work",
            "kthread_flush_work_fn"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_flush_worker(struct kthread_worker *worker)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\n\tkthread_queue_work(worker, &fwork.work);\n\twait_for_completion(&fwork.done);\n}"
  },
  {
    "function_name": "kthread_cancel_delayed_work_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1354-1357",
    "snippet": "bool kthread_cancel_delayed_work_sync(struct kthread_delayed_work *dwork)\n{\n\treturn __kthread_cancel_work_sync(&dwork->work, true);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kthread_cancel_work_sync",
          "args": [
            "&dwork->work",
            "true"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_cancel_work_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1286-1321",
          "snippet": "static bool __kthread_cancel_work_sync(struct kthread_work *work, bool is_dwork)\n{\n\tstruct kthread_worker *worker = work->worker;\n\tunsigned long flags;\n\tint ret = false;\n\n\tif (!worker)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\tif (is_dwork)\n\t\tkthread_cancel_delayed_work_timer(work, &flags);\n\n\tret = __kthread_cancel_work(work);\n\n\tif (worker->current_work != work)\n\t\tgoto out_fast;\n\n\t/*\n\t * The work is in progress and we need to wait with the lock released.\n\t * In the meantime, block any queuing by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\tkthread_flush_work(work);\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\twork->canceling--;\n\nout_fast:\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic bool __kthread_cancel_work_sync(struct kthread_work *work, bool is_dwork)\n{\n\tstruct kthread_worker *worker = work->worker;\n\tunsigned long flags;\n\tint ret = false;\n\n\tif (!worker)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\tif (is_dwork)\n\t\tkthread_cancel_delayed_work_timer(work, &flags);\n\n\tret = __kthread_cancel_work(work);\n\n\tif (worker->current_work != work)\n\t\tgoto out_fast;\n\n\t/*\n\t * The work is in progress and we need to wait with the lock released.\n\t * In the meantime, block any queuing by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\tkthread_flush_work(work);\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\twork->canceling--;\n\nout_fast:\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_cancel_delayed_work_sync(struct kthread_delayed_work *dwork)\n{\n\treturn __kthread_cancel_work_sync(&dwork->work, true);\n}"
  },
  {
    "function_name": "kthread_cancel_work_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1339-1342",
    "snippet": "bool kthread_cancel_work_sync(struct kthread_work *work)\n{\n\treturn __kthread_cancel_work_sync(work, false);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kthread_cancel_work_sync",
          "args": [
            "work",
            "false"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_cancel_work_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1286-1321",
          "snippet": "static bool __kthread_cancel_work_sync(struct kthread_work *work, bool is_dwork)\n{\n\tstruct kthread_worker *worker = work->worker;\n\tunsigned long flags;\n\tint ret = false;\n\n\tif (!worker)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\tif (is_dwork)\n\t\tkthread_cancel_delayed_work_timer(work, &flags);\n\n\tret = __kthread_cancel_work(work);\n\n\tif (worker->current_work != work)\n\t\tgoto out_fast;\n\n\t/*\n\t * The work is in progress and we need to wait with the lock released.\n\t * In the meantime, block any queuing by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\tkthread_flush_work(work);\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\twork->canceling--;\n\nout_fast:\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic bool __kthread_cancel_work_sync(struct kthread_work *work, bool is_dwork)\n{\n\tstruct kthread_worker *worker = work->worker;\n\tunsigned long flags;\n\tint ret = false;\n\n\tif (!worker)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\tif (is_dwork)\n\t\tkthread_cancel_delayed_work_timer(work, &flags);\n\n\tret = __kthread_cancel_work(work);\n\n\tif (worker->current_work != work)\n\t\tgoto out_fast;\n\n\t/*\n\t * The work is in progress and we need to wait with the lock released.\n\t * In the meantime, block any queuing by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\tkthread_flush_work(work);\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\twork->canceling--;\n\nout_fast:\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_cancel_work_sync(struct kthread_work *work)\n{\n\treturn __kthread_cancel_work_sync(work, false);\n}"
  },
  {
    "function_name": "__kthread_cancel_work_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1286-1321",
    "snippet": "static bool __kthread_cancel_work_sync(struct kthread_work *work, bool is_dwork)\n{\n\tstruct kthread_worker *worker = work->worker;\n\tunsigned long flags;\n\tint ret = false;\n\n\tif (!worker)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\tif (is_dwork)\n\t\tkthread_cancel_delayed_work_timer(work, &flags);\n\n\tret = __kthread_cancel_work(work);\n\n\tif (worker->current_work != work)\n\t\tgoto out_fast;\n\n\t/*\n\t * The work is in progress and we need to wait with the lock released.\n\t * In the meantime, block any queuing by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\tkthread_flush_work(work);\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\twork->canceling--;\n\nout_fast:\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_flush_work",
          "args": [
            "work"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_flush_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1367-1376",
          "snippet": "void kthread_flush_worker(struct kthread_worker *worker)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\n\tkthread_queue_work(worker, &fwork.work);\n\twait_for_completion(&fwork.done);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_flush_worker(struct kthread_worker *worker)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\n\tkthread_queue_work(worker, &fwork.work);\n\twait_for_completion(&fwork.done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kthread_cancel_work",
          "args": [
            "work"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_cancel_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1202-1214",
          "snippet": "static bool __kthread_cancel_work(struct kthread_work *work)\n{\n\t/*\n\t * Try to remove the work from a worker list. It might either\n\t * be from worker->work_list or from worker->delayed_work_list.\n\t */\n\tif (!list_empty(&work->node)) {\n\t\tlist_del_init(&work->node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic bool __kthread_cancel_work(struct kthread_work *work)\n{\n\t/*\n\t * Try to remove the work from a worker list. It might either\n\t * be from worker->work_list or from worker->delayed_work_list.\n\t */\n\tif (!list_empty(&work->node)) {\n\t\tlist_del_init(&work->node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_cancel_delayed_work_timer",
          "args": [
            "work",
            "&flags"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_cancel_delayed_work_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1169-1187",
          "snippet": "static void kthread_cancel_delayed_work_timer(struct kthread_work *work,\n\t\t\t\t\t      unsigned long *flags)\n{\n\tstruct kthread_delayed_work *dwork =\n\t\tcontainer_of(work, struct kthread_delayed_work, work);\n\tstruct kthread_worker *worker = work->worker;\n\n\t/*\n\t * del_timer_sync() must be called to make sure that the timer\n\t * callback is not running. The lock must be temporary released\n\t * to avoid a deadlock with the callback. In the meantime,\n\t * any queuing is blocked by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, *flags);\n\tdel_timer_sync(&dwork->timer);\n\traw_spin_lock_irqsave(&worker->lock, *flags);\n\twork->canceling--;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void kthread_cancel_delayed_work_timer(struct kthread_work *work,\n\t\t\t\t\t      unsigned long *flags)\n{\n\tstruct kthread_delayed_work *dwork =\n\t\tcontainer_of(work, struct kthread_delayed_work, work);\n\tstruct kthread_worker *worker = work->worker;\n\n\t/*\n\t * del_timer_sync() must be called to make sure that the timer\n\t * callback is not running. The lock must be temporary released\n\t * to avoid a deadlock with the callback. In the meantime,\n\t * any queuing is blocked by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, *flags);\n\tdel_timer_sync(&dwork->timer);\n\traw_spin_lock_irqsave(&worker->lock, *flags);\n\twork->canceling--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "work->worker != worker"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic bool __kthread_cancel_work_sync(struct kthread_work *work, bool is_dwork)\n{\n\tstruct kthread_worker *worker = work->worker;\n\tunsigned long flags;\n\tint ret = false;\n\n\tif (!worker)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\tif (is_dwork)\n\t\tkthread_cancel_delayed_work_timer(work, &flags);\n\n\tret = __kthread_cancel_work(work);\n\n\tif (worker->current_work != work)\n\t\tgoto out_fast;\n\n\t/*\n\t * The work is in progress and we need to wait with the lock released.\n\t * In the meantime, block any queuing by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\tkthread_flush_work(work);\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\twork->canceling--;\n\nout_fast:\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "kthread_mod_delayed_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1239-1283",
    "snippet": "bool kthread_mod_delayed_work(struct kthread_worker *worker,\n\t\t\t      struct kthread_delayed_work *dwork,\n\t\t\t      unsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\t/* Do not bother with canceling when never queued. */\n\tif (!work->worker) {\n\t\tret = false;\n\t\tgoto fast_queue;\n\t}\n\n\t/* Work must not be used with >1 worker, see kthread_queue_work() */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\t/*\n\t * Temporary cancel the work but do not fight with another command\n\t * that is canceling the work as well.\n\t *\n\t * It is a bit tricky because of possible races with another\n\t * mod_delayed_work() and cancel_delayed_work() callers.\n\t *\n\t * The timer must be canceled first because worker->lock is released\n\t * when doing so. But the work can be removed from the queue (list)\n\t * only when it can be queued again so that the return value can\n\t * be used for reference counting.\n\t */\n\tkthread_cancel_delayed_work_timer(work, &flags);\n\tif (work->canceling) {\n\t\t/* The number of works in the queue does not change. */\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tret = __kthread_cancel_work(work);\n\nfast_queue:\n\t__kthread_queue_delayed_work(worker, dwork, delay);\nout:\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kthread_queue_delayed_work",
          "args": [
            "worker",
            "dwork",
            "delay"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_queue_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1047-1075",
          "snippet": "static void __kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\t\t struct kthread_delayed_work *dwork,\n\t\t\t\t\t unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct kthread_work *work = &dwork->work;\n\n\tWARN_ON_FUNCTION_MISMATCH(timer->function,\n\t\t\t\t  kthread_delayed_work_timer_fn);\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\treturn;\n\t}\n\n\t/* Be paranoid and try to detect possible races already now. */\n\tkthread_insert_work_sanity_check(worker, work);\n\n\tlist_add(&work->node, &worker->delayed_work_list);\n\twork->worker = worker;\n\ttimer->expires = jiffies + delay;\n\tadd_timer(timer);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic void __kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\t\t struct kthread_delayed_work *dwork,\n\t\t\t\t\t unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct kthread_work *work = &dwork->work;\n\n\tWARN_ON_FUNCTION_MISMATCH(timer->function,\n\t\t\t\t  kthread_delayed_work_timer_fn);\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\treturn;\n\t}\n\n\t/* Be paranoid and try to detect possible races already now. */\n\tkthread_insert_work_sanity_check(worker, work);\n\n\tlist_add(&work->node, &worker->delayed_work_list);\n\twork->worker = worker;\n\ttimer->expires = jiffies + delay;\n\tadd_timer(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kthread_cancel_work",
          "args": [
            "work"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_cancel_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1202-1214",
          "snippet": "static bool __kthread_cancel_work(struct kthread_work *work)\n{\n\t/*\n\t * Try to remove the work from a worker list. It might either\n\t * be from worker->work_list or from worker->delayed_work_list.\n\t */\n\tif (!list_empty(&work->node)) {\n\t\tlist_del_init(&work->node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic bool __kthread_cancel_work(struct kthread_work *work)\n{\n\t/*\n\t * Try to remove the work from a worker list. It might either\n\t * be from worker->work_list or from worker->delayed_work_list.\n\t */\n\tif (!list_empty(&work->node)) {\n\t\tlist_del_init(&work->node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_cancel_delayed_work_timer",
          "args": [
            "work",
            "&flags"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_cancel_delayed_work_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1169-1187",
          "snippet": "static void kthread_cancel_delayed_work_timer(struct kthread_work *work,\n\t\t\t\t\t      unsigned long *flags)\n{\n\tstruct kthread_delayed_work *dwork =\n\t\tcontainer_of(work, struct kthread_delayed_work, work);\n\tstruct kthread_worker *worker = work->worker;\n\n\t/*\n\t * del_timer_sync() must be called to make sure that the timer\n\t * callback is not running. The lock must be temporary released\n\t * to avoid a deadlock with the callback. In the meantime,\n\t * any queuing is blocked by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, *flags);\n\tdel_timer_sync(&dwork->timer);\n\traw_spin_lock_irqsave(&worker->lock, *flags);\n\twork->canceling--;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void kthread_cancel_delayed_work_timer(struct kthread_work *work,\n\t\t\t\t\t      unsigned long *flags)\n{\n\tstruct kthread_delayed_work *dwork =\n\t\tcontainer_of(work, struct kthread_delayed_work, work);\n\tstruct kthread_worker *worker = work->worker;\n\n\t/*\n\t * del_timer_sync() must be called to make sure that the timer\n\t * callback is not running. The lock must be temporary released\n\t * to avoid a deadlock with the callback. In the meantime,\n\t * any queuing is blocked by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, *flags);\n\tdel_timer_sync(&dwork->timer);\n\traw_spin_lock_irqsave(&worker->lock, *flags);\n\twork->canceling--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "work->worker != worker"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_mod_delayed_work(struct kthread_worker *worker,\n\t\t\t      struct kthread_delayed_work *dwork,\n\t\t\t      unsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\t/* Do not bother with canceling when never queued. */\n\tif (!work->worker) {\n\t\tret = false;\n\t\tgoto fast_queue;\n\t}\n\n\t/* Work must not be used with >1 worker, see kthread_queue_work() */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\t/*\n\t * Temporary cancel the work but do not fight with another command\n\t * that is canceling the work as well.\n\t *\n\t * It is a bit tricky because of possible races with another\n\t * mod_delayed_work() and cancel_delayed_work() callers.\n\t *\n\t * The timer must be canceled first because worker->lock is released\n\t * when doing so. But the work can be removed from the queue (list)\n\t * only when it can be queued again so that the return value can\n\t * be used for reference counting.\n\t */\n\tkthread_cancel_delayed_work_timer(work, &flags);\n\tif (work->canceling) {\n\t\t/* The number of works in the queue does not change. */\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tret = __kthread_cancel_work(work);\n\nfast_queue:\n\t__kthread_queue_delayed_work(worker, dwork, delay);\nout:\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__kthread_cancel_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1202-1214",
    "snippet": "static bool __kthread_cancel_work(struct kthread_work *work)\n{\n\t/*\n\t * Try to remove the work from a worker list. It might either\n\t * be from worker->work_list or from worker->delayed_work_list.\n\t */\n\tif (!list_empty(&work->node)) {\n\t\tlist_del_init(&work->node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->node"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&work->node"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic bool __kthread_cancel_work(struct kthread_work *work)\n{\n\t/*\n\t * Try to remove the work from a worker list. It might either\n\t * be from worker->work_list or from worker->delayed_work_list.\n\t */\n\tif (!list_empty(&work->node)) {\n\t\tlist_del_init(&work->node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "kthread_cancel_delayed_work_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1169-1187",
    "snippet": "static void kthread_cancel_delayed_work_timer(struct kthread_work *work,\n\t\t\t\t\t      unsigned long *flags)\n{\n\tstruct kthread_delayed_work *dwork =\n\t\tcontainer_of(work, struct kthread_delayed_work, work);\n\tstruct kthread_worker *worker = work->worker;\n\n\t/*\n\t * del_timer_sync() must be called to make sure that the timer\n\t * callback is not running. The lock must be temporary released\n\t * to avoid a deadlock with the callback. In the meantime,\n\t * any queuing is blocked by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, *flags);\n\tdel_timer_sync(&dwork->timer);\n\traw_spin_lock_irqsave(&worker->lock, *flags);\n\twork->canceling--;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&worker->lock",
            "*flags"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&dwork->timer"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&worker->lock",
            "*flags"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkthread_delayed_work",
            "work"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void kthread_cancel_delayed_work_timer(struct kthread_work *work,\n\t\t\t\t\t      unsigned long *flags)\n{\n\tstruct kthread_delayed_work *dwork =\n\t\tcontainer_of(work, struct kthread_delayed_work, work);\n\tstruct kthread_worker *worker = work->worker;\n\n\t/*\n\t * del_timer_sync() must be called to make sure that the timer\n\t * callback is not running. The lock must be temporary released\n\t * to avoid a deadlock with the callback. In the meantime,\n\t * any queuing is blocked by setting the canceling counter.\n\t */\n\twork->canceling++;\n\traw_spin_unlock_irqrestore(&worker->lock, *flags);\n\tdel_timer_sync(&dwork->timer);\n\traw_spin_lock_irqsave(&worker->lock, *flags);\n\twork->canceling--;\n}"
  },
  {
    "function_name": "kthread_flush_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1130-1159",
    "snippet": "void kthread_flush_work(struct kthread_work *work)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\tstruct kthread_worker *worker;\n\tbool noop = false;\n\n\tworker = work->worker;\n\tif (!worker)\n\t\treturn;\n\n\traw_spin_lock_irq(&worker->lock);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\tif (!list_empty(&work->node))\n\t\tkthread_insert_work(worker, &fwork.work, work->node.next);\n\telse if (worker->current_work == work)\n\t\tkthread_insert_work(worker, &fwork.work,\n\t\t\t\t    worker->work_list.next);\n\telse\n\t\tnoop = true;\n\n\traw_spin_unlock_irq(&worker->lock);\n\n\tif (!noop)\n\t\twait_for_completion(&fwork.done);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&fwork.done"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&worker->lock"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_insert_work",
          "args": [
            "worker",
            "&fwork.work",
            "worker->work_list.next"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_insert_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "969-981",
          "snippet": "static void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;",
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstatic void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&work->node"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "work->worker != worker"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&worker->lock"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPLETION_INITIALIZER_ONSTACK",
          "args": [
            "fwork.done"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KTHREAD_WORK_INIT",
          "args": [
            "fwork.work",
            "kthread_flush_work_fn"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nvoid kthread_flush_work(struct kthread_work *work)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\tstruct kthread_worker *worker;\n\tbool noop = false;\n\n\tworker = work->worker;\n\tif (!worker)\n\t\treturn;\n\n\traw_spin_lock_irq(&worker->lock);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\tif (!list_empty(&work->node))\n\t\tkthread_insert_work(worker, &fwork.work, work->node.next);\n\telse if (worker->current_work == work)\n\t\tkthread_insert_work(worker, &fwork.work,\n\t\t\t\t    worker->work_list.next);\n\telse\n\t\tnoop = true;\n\n\traw_spin_unlock_irq(&worker->lock);\n\n\tif (!noop)\n\t\twait_for_completion(&fwork.done);\n}"
  },
  {
    "function_name": "kthread_flush_work_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1117-1122",
    "snippet": "static void kthread_flush_work_fn(struct kthread_work *work)\n{\n\tstruct kthread_flush_work *fwork =\n\t\tcontainer_of(work, struct kthread_flush_work, work);\n\tcomplete(&fwork->done);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&fwork->done"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkthread_flush_work",
            "work"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void kthread_flush_work_fn(struct kthread_work *work)\n{\n\tstruct kthread_flush_work *fwork =\n\t\tcontainer_of(work, struct kthread_flush_work, work);\n\tcomplete(&fwork->done);\n}"
  },
  {
    "function_name": "kthread_queue_delayed_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1092-1109",
    "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kthread_queue_delayed_work",
          "args": [
            "worker",
            "dwork",
            "delay"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_queue_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1047-1075",
          "snippet": "static void __kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\t\t struct kthread_delayed_work *dwork,\n\t\t\t\t\t unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct kthread_work *work = &dwork->work;\n\n\tWARN_ON_FUNCTION_MISMATCH(timer->function,\n\t\t\t\t  kthread_delayed_work_timer_fn);\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\treturn;\n\t}\n\n\t/* Be paranoid and try to detect possible races already now. */\n\tkthread_insert_work_sanity_check(worker, work);\n\n\tlist_add(&work->node, &worker->delayed_work_list);\n\twork->worker = worker;\n\ttimer->expires = jiffies + delay;\n\tadd_timer(timer);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic void __kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\t\t struct kthread_delayed_work *dwork,\n\t\t\t\t\t unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct kthread_work *work = &dwork->work;\n\n\tWARN_ON_FUNCTION_MISMATCH(timer->function,\n\t\t\t\t  kthread_delayed_work_timer_fn);\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\treturn;\n\t}\n\n\t/* Be paranoid and try to detect possible races already now. */\n\tkthread_insert_work_sanity_check(worker, work);\n\n\tlist_add(&work->node, &worker->delayed_work_list);\n\twork->worker = worker;\n\ttimer->expires = jiffies + delay;\n\tadd_timer(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queuing_blocked",
          "args": [
            "worker",
            "work"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "queuing_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "951-957",
          "snippet": "static inline bool queuing_blocked(struct kthread_worker *worker,\n\t\t\t\t   struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\n\treturn !list_empty(&work->node) || work->canceling;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic inline bool queuing_blocked(struct kthread_worker *worker,\n\t\t\t\t   struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\n\treturn !list_empty(&work->node) || work->canceling;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__kthread_queue_delayed_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1047-1075",
    "snippet": "static void __kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\t\t struct kthread_delayed_work *dwork,\n\t\t\t\t\t unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct kthread_work *work = &dwork->work;\n\n\tWARN_ON_FUNCTION_MISMATCH(timer->function,\n\t\t\t\t  kthread_delayed_work_timer_fn);\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\treturn;\n\t}\n\n\t/* Be paranoid and try to detect possible races already now. */\n\tkthread_insert_work_sanity_check(worker, work);\n\n\tlist_add(&work->node, &worker->delayed_work_list);\n\twork->worker = worker;\n\ttimer->expires = jiffies + delay;\n\tadd_timer(timer);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_timer",
          "args": [
            "timer"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1141-1145",
          "snippet": "void add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\t__mod_timer(timer, timer->expires, MOD_TIMER_NOTPENDING);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define MOD_TIMER_NOTPENDING\t\t0x04"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_NOTPENDING\t\t0x04\n\nvoid add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\t__mod_timer(timer, timer->expires, MOD_TIMER_NOTPENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&work->node",
            "&worker->delayed_work_list"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_insert_work_sanity_check",
          "args": [
            "worker",
            "work"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_insert_work_sanity_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "959-966",
          "snippet": "static void kthread_insert_work_sanity_check(struct kthread_worker *worker,\n\t\t\t\t\t     struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\tWARN_ON_ONCE(!list_empty(&work->node));\n\t/* Do not use a work with >1 worker, see kthread_queue_work() */\n\tWARN_ON_ONCE(work->worker && work->worker != worker);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic void kthread_insert_work_sanity_check(struct kthread_worker *worker,\n\t\t\t\t\t     struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\tWARN_ON_ONCE(!list_empty(&work->node));\n\t/* Do not use a work with >1 worker, see kthread_queue_work() */\n\tWARN_ON_ONCE(work->worker && work->worker != worker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_insert_work",
          "args": [
            "worker",
            "work",
            "&worker->work_list"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_insert_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "969-981",
          "snippet": "static void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;",
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstatic void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_FUNCTION_MISMATCH",
          "args": [
            "timer->function",
            "kthread_delayed_work_timer_fn"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic void __kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\t\t struct kthread_delayed_work *dwork,\n\t\t\t\t\t unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct kthread_work *work = &dwork->work;\n\n\tWARN_ON_FUNCTION_MISMATCH(timer->function,\n\t\t\t\t  kthread_delayed_work_timer_fn);\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\treturn;\n\t}\n\n\t/* Be paranoid and try to detect possible races already now. */\n\tkthread_insert_work_sanity_check(worker, work);\n\n\tlist_add(&work->node, &worker->delayed_work_list);\n\twork->worker = worker;\n\ttimer->expires = jiffies + delay;\n\tadd_timer(timer);\n}"
  },
  {
    "function_name": "kthread_delayed_work_timer_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "1019-1044",
    "snippet": "void kthread_delayed_work_timer_fn(struct timer_list *t)\n{\n\tstruct kthread_delayed_work *dwork = from_timer(dwork, t, timer);\n\tstruct kthread_work *work = &dwork->work;\n\tstruct kthread_worker *worker = work->worker;\n\tunsigned long flags;\n\n\t/*\n\t * This might happen when a pending work is reinitialized.\n\t * It means that it is used a wrong way.\n\t */\n\tif (WARN_ON_ONCE(!worker))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\t/* Move the work from worker->delayed_work_list. */\n\tWARN_ON_ONCE(list_empty(&work->node));\n\tlist_del_init(&work->node);\n\tif (!work->canceling)\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_insert_work",
          "args": [
            "worker",
            "work",
            "&worker->work_list"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_insert_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "969-981",
          "snippet": "static void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;",
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstatic void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->node"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "list_empty(&work->node)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&work->node"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "work->worker != worker"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!worker"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "dwork",
            "t",
            "timer"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nvoid kthread_delayed_work_timer_fn(struct timer_list *t)\n{\n\tstruct kthread_delayed_work *dwork = from_timer(dwork, t, timer);\n\tstruct kthread_work *work = &dwork->work;\n\tstruct kthread_worker *worker = work->worker;\n\tunsigned long flags;\n\n\t/*\n\t * This might happen when a pending work is reinitialized.\n\t * It means that it is used a wrong way.\n\t */\n\tif (WARN_ON_ONCE(!worker))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\t/* Work must not be used with >1 worker, see kthread_queue_work(). */\n\tWARN_ON_ONCE(work->worker != worker);\n\n\t/* Move the work from worker->delayed_work_list. */\n\tWARN_ON_ONCE(list_empty(&work->node));\n\tlist_del_init(&work->node);\n\tif (!work->canceling)\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n}"
  },
  {
    "function_name": "kthread_queue_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "995-1008",
    "snippet": "bool kthread_queue_work(struct kthread_worker *worker,\n\t\t\tstruct kthread_work *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\tif (!queuing_blocked(worker, work)) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\tret = true;\n\t}\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_insert_work",
          "args": [
            "worker",
            "work",
            "&worker->work_list"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_insert_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "969-981",
          "snippet": "static void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;",
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstatic void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queuing_blocked",
          "args": [
            "worker",
            "work"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "queuing_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "951-957",
          "snippet": "static inline bool queuing_blocked(struct kthread_worker *worker,\n\t\t\t\t   struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\n\treturn !list_empty(&work->node) || work->canceling;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic inline bool queuing_blocked(struct kthread_worker *worker,\n\t\t\t\t   struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\n\treturn !list_empty(&work->node) || work->canceling;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&worker->lock",
            "flags"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_work(struct kthread_worker *worker,\n\t\t\tstruct kthread_work *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\tif (!queuing_blocked(worker, work)) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\tret = true;\n\t}\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "kthread_insert_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "969-981",
    "snippet": "static void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;",
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "worker->task"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "worker->task"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&work->node",
            "pos"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_kthread_work_queue_work",
          "args": [
            "worker",
            "work"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_insert_work_sanity_check",
          "args": [
            "worker",
            "work"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_insert_work_sanity_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "959-966",
          "snippet": "static void kthread_insert_work_sanity_check(struct kthread_worker *worker,\n\t\t\t\t\t     struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\tWARN_ON_ONCE(!list_empty(&work->node));\n\t/* Do not use a work with >1 worker, see kthread_queue_work() */\n\tWARN_ON_ONCE(work->worker && work->worker != worker);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic void kthread_insert_work_sanity_check(struct kthread_worker *worker,\n\t\t\t\t\t     struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\tWARN_ON_ONCE(!list_empty(&work->node));\n\t/* Do not use a work with >1 worker, see kthread_queue_work() */\n\tWARN_ON_ONCE(work->worker && work->worker != worker);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstatic void kthread_insert_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_work *work,\n\t\t\t\tstruct list_head *pos)\n{\n\tkthread_insert_work_sanity_check(worker, work);\n\n\ttrace_sched_kthread_work_queue_work(worker, work);\n\n\tlist_add_tail(&work->node, pos);\n\twork->worker = worker;\n\tif (!worker->current_work && likely(worker->task))\n\t\twake_up_process(worker->task);\n}"
  },
  {
    "function_name": "kthread_insert_work_sanity_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "959-966",
    "snippet": "static void kthread_insert_work_sanity_check(struct kthread_worker *worker,\n\t\t\t\t\t     struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\tWARN_ON_ONCE(!list_empty(&work->node));\n\t/* Do not use a work with >1 worker, see kthread_queue_work() */\n\tWARN_ON_ONCE(work->worker && work->worker != worker);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "work->worker && work->worker != worker"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&work->node)"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&work->node"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&worker->lock"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic void kthread_insert_work_sanity_check(struct kthread_worker *worker,\n\t\t\t\t\t     struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\tWARN_ON_ONCE(!list_empty(&work->node));\n\t/* Do not use a work with >1 worker, see kthread_queue_work() */\n\tWARN_ON_ONCE(work->worker && work->worker != worker);\n}"
  },
  {
    "function_name": "queuing_blocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "951-957",
    "snippet": "static inline bool queuing_blocked(struct kthread_worker *worker,\n\t\t\t\t   struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\n\treturn !list_empty(&work->node) || work->canceling;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&work->node"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&worker->lock"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint node = NUMA_NO_NODE;\n\nstatic inline bool queuing_blocked(struct kthread_worker *worker,\n\t\t\t\t   struct kthread_work *work)\n{\n\tlockdep_assert_held(&worker->lock);\n\n\treturn !list_empty(&work->node) || work->canceling;\n}"
  },
  {
    "function_name": "kthread_create_worker_on_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "931-943",
    "snippet": "struct kthread_worker *\nkthread_create_worker_on_cpu(int cpu, unsigned int flags,\n\t\t\t     const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(cpu, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
      "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kthread_create_worker",
          "args": [
            "cpu",
            "flags",
            "namefmt",
            "args"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "namefmt"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker_on_cpu(int cpu, unsigned int flags,\n\t\t\t     const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(cpu, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
  },
  {
    "function_name": "kthread_create_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "882-893",
    "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
      "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kthread_create_worker",
          "args": [
            "-1",
            "flags",
            "namefmt",
            "args"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "namefmt"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
  },
  {
    "function_name": "kthread_worker_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "783-835",
    "snippet": "int kthread_worker_fn(void *worker_ptr)\n{\n\tstruct kthread_worker *worker = worker_ptr;\n\tstruct kthread_work *work;\n\n\t/*\n\t * FIXME: Update the check and remove the assignment when all kthread\n\t * worker users are created using kthread_create_worker*() functions.\n\t */\n\tWARN_ON(worker->task && worker->task != current);\n\tworker->task = current;\n\n\tif (worker->flags & KTW_FREEZABLE)\n\t\tset_freezable();\n\nrepeat:\n\tset_current_state(TASK_INTERRUPTIBLE);\t/* mb paired w/ kthread_stop */\n\n\tif (kthread_should_stop()) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\traw_spin_lock_irq(&worker->lock);\n\t\tworker->task = NULL;\n\t\traw_spin_unlock_irq(&worker->lock);\n\t\treturn 0;\n\t}\n\n\twork = NULL;\n\traw_spin_lock_irq(&worker->lock);\n\tif (!list_empty(&worker->work_list)) {\n\t\twork = list_first_entry(&worker->work_list,\n\t\t\t\t\tstruct kthread_work, node);\n\t\tlist_del_init(&work->node);\n\t}\n\tworker->current_work = work;\n\traw_spin_unlock_irq(&worker->lock);\n\n\tif (work) {\n\t\tkthread_work_func_t func = work->func;\n\t\t__set_current_state(TASK_RUNNING);\n\t\ttrace_sched_kthread_work_execute_start(work);\n\t\twork->func(work);\n\t\t/*\n\t\t * Avoid dereferencing work after this point.  The trace\n\t\t * event only cares about the address.\n\t\t */\n\t\ttrace_sched_kthread_work_execute_end(work, func);\n\t} else if (!freezing(current))\n\t\tschedule();\n\n\ttry_to_freeze();\n\tcond_resched();\n\tgoto repeat;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;",
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "37-52",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_kthread_work_execute_end",
          "args": [
            "work",
            "func"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work->func",
          "args": [
            "work"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_kthread_work_execute_start",
          "args": [
            "work"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&worker->lock"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->node"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&worker->work_list",
            "structkthread_work",
            "node"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->work_list"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&worker->lock"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "set_freezable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "161-175",
          "snippet": "bool set_freezable(void)\n{\n\tmight_sleep();\n\n\t/*\n\t * Modify flags while holding freezer_lock.  This ensures the\n\t * freezer notices that we aren't frozen yet or the freezing\n\t * condition is visible to try_to_freeze() below.\n\t */\n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool set_freezable(void)\n{\n\tmight_sleep();\n\n\t/*\n\t * Modify flags while holding freezer_lock.  This ensures the\n\t * freezer notices that we aren't frozen yet or the freezing\n\t * condition is visible to try_to_freeze() below.\n\t */\n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "worker->task && worker->task != current"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nint kthread_worker_fn(void *worker_ptr)\n{\n\tstruct kthread_worker *worker = worker_ptr;\n\tstruct kthread_work *work;\n\n\t/*\n\t * FIXME: Update the check and remove the assignment when all kthread\n\t * worker users are created using kthread_create_worker*() functions.\n\t */\n\tWARN_ON(worker->task && worker->task != current);\n\tworker->task = current;\n\n\tif (worker->flags & KTW_FREEZABLE)\n\t\tset_freezable();\n\nrepeat:\n\tset_current_state(TASK_INTERRUPTIBLE);\t/* mb paired w/ kthread_stop */\n\n\tif (kthread_should_stop()) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\traw_spin_lock_irq(&worker->lock);\n\t\tworker->task = NULL;\n\t\traw_spin_unlock_irq(&worker->lock);\n\t\treturn 0;\n\t}\n\n\twork = NULL;\n\traw_spin_lock_irq(&worker->lock);\n\tif (!list_empty(&worker->work_list)) {\n\t\twork = list_first_entry(&worker->work_list,\n\t\t\t\t\tstruct kthread_work, node);\n\t\tlist_del_init(&work->node);\n\t}\n\tworker->current_work = work;\n\traw_spin_unlock_irq(&worker->lock);\n\n\tif (work) {\n\t\tkthread_work_func_t func = work->func;\n\t\t__set_current_state(TASK_RUNNING);\n\t\ttrace_sched_kthread_work_execute_start(work);\n\t\twork->func(work);\n\t\t/*\n\t\t * Avoid dereferencing work after this point.  The trace\n\t\t * event only cares about the address.\n\t\t */\n\t\ttrace_sched_kthread_work_execute_end(work, func);\n\t} else if (!freezing(current))\n\t\tschedule();\n\n\ttry_to_freeze();\n\tcond_resched();\n\tgoto repeat;\n}"
  },
  {
    "function_name": "__kthread_init_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "756-765",
    "snippet": "void __kthread_init_worker(struct kthread_worker *worker,\n\t\t\t\tconst char *name,\n\t\t\t\tstruct lock_class_key *key)\n{\n\tmemset(worker, 0, sizeof(struct kthread_worker));\n\traw_spin_lock_init(&worker->lock);\n\tlockdep_set_class_and_name(&worker->lock, key, name);\n\tINIT_LIST_HEAD(&worker->work_list);\n\tINIT_LIST_HEAD(&worker->delayed_work_list);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&worker->delayed_work_list"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&worker->work_list"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class_and_name",
          "args": [
            "&worker->lock",
            "key",
            "name"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&worker->lock"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "worker",
            "0",
            "sizeof(struct kthread_worker)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid __kthread_init_worker(struct kthread_worker *worker,\n\t\t\t\tconst char *name,\n\t\t\t\tstruct lock_class_key *key)\n{\n\tmemset(worker, 0, sizeof(struct kthread_worker));\n\traw_spin_lock_init(&worker->lock);\n\tlockdep_set_class_and_name(&worker->lock, key, name);\n\tINIT_LIST_HEAD(&worker->work_list);\n\tINIT_LIST_HEAD(&worker->delayed_work_list);\n}"
  },
  {
    "function_name": "kthreadd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "718-754",
    "snippet": "int kthreadd(void *unused)\n{\n\tstruct task_struct *tsk = current;\n\n\t/* Setup a clean context for our children to inherit. */\n\tset_task_comm(tsk, \"kthreadd\");\n\tignore_signals(tsk);\n\tset_cpus_allowed_ptr(tsk, housekeeping_cpumask(HK_FLAG_KTHREAD));\n\tset_mems_allowed(node_states[N_MEMORY]);\n\n\tcurrent->flags |= PF_NOFREEZE;\n\tcgroup_init_kthreadd();\n\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (list_empty(&kthread_create_list))\n\t\t\tschedule();\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\tspin_lock(&kthread_create_lock);\n\t\twhile (!list_empty(&kthread_create_list)) {\n\t\t\tstruct kthread_create_info *create;\n\n\t\t\tcreate = list_entry(kthread_create_list.next,\n\t\t\t\t\t    struct kthread_create_info, list);\n\t\t\tlist_del_init(&create->list);\n\t\t\tspin_unlock(&kthread_create_lock);\n\n\t\t\tcreate_kthread(create);\n\n\t\t\tspin_lock(&kthread_create_lock);\n\t\t}\n\t\tspin_unlock(&kthread_create_lock);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kthread_create_lock);",
      "static LIST_HEAD(kthread_create_list);",
      "struct kthread_create_info *create = kmalloc(sizeof(*create),\n\t\t\t\t\t\t     GFP_KERNEL);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kthread_create_lock"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kthread_create_lock"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_kthread",
          "args": [
            "create"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "create_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "392-412",
          "snippet": "static void create_kthread(struct kthread_create_info *create)\n{\n\tint pid;\n\n#ifdef CONFIG_NUMA\n\tcurrent->pref_node_fork = create->node;\n#endif\n\t/* We want our own signal handler (we take no signals by default). */\n\tpid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);\n\tif (pid < 0) {\n\t\t/* If user was SIGKILLed, I release the structure. */\n\t\tstruct completion *done = xchg(&create->done, NULL);\n\n\t\tif (!done) {\n\t\t\tkfree(create);\n\t\t\treturn;\n\t\t}\n\t\tcreate->result = ERR_PTR(pid);\n\t\tcomplete(done);\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kthread_create_info *create = kmalloc(sizeof(*create),\n\t\t\t\t\t\t     GFP_KERNEL);",
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct kthread_create_info *create = kmalloc(sizeof(*create),\n\t\t\t\t\t\t     GFP_KERNEL);\nint node = NUMA_NO_NODE;\n\nstatic void create_kthread(struct kthread_create_info *create)\n{\n\tint pid;\n\n#ifdef CONFIG_NUMA\n\tcurrent->pref_node_fork = create->node;\n#endif\n\t/* We want our own signal handler (we take no signals by default). */\n\tpid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);\n\tif (pid < 0) {\n\t\t/* If user was SIGKILLed, I release the structure. */\n\t\tstruct completion *done = xchg(&create->done, NULL);\n\n\t\tif (!done) {\n\t\t\tkfree(create);\n\t\t\treturn;\n\t\t}\n\t\tcreate->result = ERR_PTR(pid);\n\t\tcomplete(done);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&create->list"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "kthread_create_list.next",
            "structkthread_create_info",
            "list"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&kthread_create_list"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_kthreadd",
          "args": [],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_mems_allowed",
          "args": [
            "node_states[N_MEMORY]"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_mems_allowed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3450-3462",
          "snippet": "nodemask_t cpuset_mems_allowed(struct task_struct *tsk)\n{\n\tnodemask_t mask;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&callback_lock, flags);\n\trcu_read_lock();\n\tguarantee_online_mems(task_cs(tsk), &mask);\n\trcu_read_unlock();\n\tspin_unlock_irqrestore(&callback_lock, flags);\n\n\treturn mask;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nnodemask_t cpuset_mems_allowed(struct task_struct *tsk)\n{\n\tnodemask_t mask;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&callback_lock, flags);\n\trcu_read_lock();\n\tguarantee_online_mems(task_cs(tsk), &mask);\n\trcu_read_unlock();\n\tspin_unlock_irqrestore(&callback_lock, flags);\n\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "tsk",
            "housekeeping_cpumask(HK_FLAG_KTHREAD)"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_KTHREAD"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_signals",
          "args": [
            "tsk"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_signals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "524-532",
          "snippet": "void ignore_signals(struct task_struct *t)\n{\n\tint i;\n\n\tfor (i = 0; i < _NSIG; ++i)\n\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n\tflush_signals(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid ignore_signals(struct task_struct *t)\n{\n\tint i;\n\n\tfor (i = 0; i < _NSIG; ++i)\n\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n\tflush_signals(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_comm",
          "args": [
            "tsk",
            "\"kthreadd\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic DEFINE_SPINLOCK(kthread_create_lock);\nstatic LIST_HEAD(kthread_create_list);\nstruct kthread_create_info *create = kmalloc(sizeof(*create),\n\t\t\t\t\t\t     GFP_KERNEL);\n\nint kthreadd(void *unused)\n{\n\tstruct task_struct *tsk = current;\n\n\t/* Setup a clean context for our children to inherit. */\n\tset_task_comm(tsk, \"kthreadd\");\n\tignore_signals(tsk);\n\tset_cpus_allowed_ptr(tsk, housekeeping_cpumask(HK_FLAG_KTHREAD));\n\tset_mems_allowed(node_states[N_MEMORY]);\n\n\tcurrent->flags |= PF_NOFREEZE;\n\tcgroup_init_kthreadd();\n\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (list_empty(&kthread_create_list))\n\t\t\tschedule();\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\tspin_lock(&kthread_create_lock);\n\t\twhile (!list_empty(&kthread_create_list)) {\n\t\t\tstruct kthread_create_info *create;\n\n\t\t\tcreate = list_entry(kthread_create_list.next,\n\t\t\t\t\t    struct kthread_create_info, list);\n\t\t\tlist_del_init(&create->list);\n\t\t\tspin_unlock(&kthread_create_lock);\n\n\t\t\tcreate_kthread(create);\n\n\t\t\tspin_lock(&kthread_create_lock);\n\t\t}\n\t\tspin_unlock(&kthread_create_lock);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kthread_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "697-715",
    "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_sched_kthread_stop_ret",
          "args": [
            "ret"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "k"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&kthread->exited"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "k"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "k"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_unpark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "622-638",
          "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KTHREAD_SHOULD_STOP",
            "&kthread->flags"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "k"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "k"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_kthread_stop",
          "args": [
            "k"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "kthread_park",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "653-679",
    "snippet": "int kthread_park(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\tif (WARN_ON(k->flags & PF_EXITING))\n\t\treturn -ENOSYS;\n\n\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))\n\t\treturn -EBUSY;\n\n\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\tif (k != current) {\n\t\twake_up_process(k);\n\t\t/*\n\t\t * Wait for __kthread_parkme() to complete(), this means we\n\t\t * _will_ have TASK_PARKED and are about to call schedule().\n\t\t */\n\t\twait_for_completion(&kthread->parked);\n\t\t/*\n\t\t * Now wait for that schedule() to complete and the task to\n\t\t * get scheduled out.\n\t\t */\n\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!wait_task_inactive(k, TASK_PARKED)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_task_inactive",
          "args": [
            "k",
            "TASK_PARKED"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3214-3304",
          "snippet": "unsigned long wait_task_inactive(struct task_struct *p, unsigned int match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(READ_ONCE(p->__state) != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || READ_ONCE(p->__state) == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL_HARD);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nunsigned long wait_task_inactive(struct task_struct *p, unsigned int match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(READ_ONCE(p->__state) != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || READ_ONCE(p->__state) == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL_HARD);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&kthread->parked"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "k"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KTHREAD_SHOULD_PARK",
            "&kthread->flags"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KTHREAD_SHOULD_PARK",
            "&kthread->flags"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "k->flags & PF_EXITING"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "k"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nint kthread_park(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\tif (WARN_ON(k->flags & PF_EXITING))\n\t\treturn -ENOSYS;\n\n\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))\n\t\treturn -EBUSY;\n\n\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\tif (k != current) {\n\t\twake_up_process(k);\n\t\t/*\n\t\t * Wait for __kthread_parkme() to complete(), this means we\n\t\t * _will_ have TASK_PARKED and are about to call schedule().\n\t\t */\n\t\twait_for_completion(&kthread->parked);\n\t\t/*\n\t\t * Now wait for that schedule() to complete and the task to\n\t\t * get scheduled out.\n\t\t */\n\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kthread_unpark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "622-638",
    "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "k",
            "TASK_PARKED"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KTHREAD_SHOULD_PARK",
            "&kthread->flags"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kthread_bind",
          "args": [
            "k",
            "kthread->cpu",
            "TASK_PARKED"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_bind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "536-539",
          "snippet": "static void __kthread_bind(struct task_struct *p, unsigned int cpu, unsigned int state)\n{\n\t__kthread_bind_mask(p, cpumask_of(cpu), state);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void __kthread_bind(struct task_struct *p, unsigned int cpu, unsigned int state)\n{\n\t__kthread_bind_mask(p, cpumask_of(cpu), state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KTHREAD_IS_PER_CPU",
            "&kthread->flags"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "k"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
  },
  {
    "function_name": "kthread_is_per_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "605-612",
    "snippet": "bool kthread_is_per_cpu(struct task_struct *p)\n{\n\tstruct kthread *kthread = __to_kthread(p);\n\tif (!kthread)\n\t\treturn false;\n\n\treturn test_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KTHREAD_IS_PER_CPU",
            "&kthread->flags"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__to_kthread",
          "args": [
            "p"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_is_per_cpu(struct task_struct *p)\n{\n\tstruct kthread *kthread = __to_kthread(p);\n\tif (!kthread)\n\t\treturn false;\n\n\treturn test_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
  },
  {
    "function_name": "kthread_set_per_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "588-603",
    "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KTHREAD_IS_PER_CPU",
            "&kthread->flags"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KTHREAD_IS_PER_CPU",
            "&kthread->flags"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(k->flags & PF_NO_SETAFFINITY)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "k"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
  },
  {
    "function_name": "kthread_create_on_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "571-585",
    "snippet": "struct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),\n\t\t\t\t\t  void *data, unsigned int cpu,\n\t\t\t\t\t  const char *namefmt)\n{\n\tstruct task_struct *p;\n\n\tp = kthread_create_on_node(threadfn, data, cpu_to_node(cpu), namefmt,\n\t\t\t\t   cpu);\n\tif (IS_ERR(p))\n\t\treturn p;\n\tkthread_bind(p, cpu);\n\t/* CPU hotplug need to bind once again when unparking the thread. */\n\tto_kthread(p)->cpu = cpu;\n\treturn p;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
      "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "p"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_bind",
          "args": [
            "p",
            "cpu"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_bind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "555-558",
          "snippet": "void kthread_bind(struct task_struct *p, unsigned int cpu)\n{\n\t__kthread_bind(p, cpu, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind(struct task_struct *p, unsigned int cpu)\n{\n\t__kthread_bind(p, cpu, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create_on_node",
          "args": [
            "threadfn",
            "data",
            "cpu_to_node(cpu)",
            "namefmt",
            "cpu"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_on_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "504-517",
          "snippet": "struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;",
            "struct task_struct *task;",
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),\n\t\t\t\t\t  void *data, unsigned int cpu,\n\t\t\t\t\t  const char *namefmt)\n{\n\tstruct task_struct *p;\n\n\tp = kthread_create_on_node(threadfn, data, cpu_to_node(cpu), namefmt,\n\t\t\t\t   cpu);\n\tif (IS_ERR(p))\n\t\treturn p;\n\tkthread_bind(p, cpu);\n\t/* CPU hotplug need to bind once again when unparking the thread. */\n\tto_kthread(p)->cpu = cpu;\n\treturn p;\n}"
  },
  {
    "function_name": "kthread_bind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "555-558",
    "snippet": "void kthread_bind(struct task_struct *p, unsigned int cpu)\n{\n\t__kthread_bind(p, cpu, TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kthread_bind",
          "args": [
            "p",
            "cpu",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_bind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "536-539",
          "snippet": "static void __kthread_bind(struct task_struct *p, unsigned int cpu, unsigned int state)\n{\n\t__kthread_bind_mask(p, cpumask_of(cpu), state);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void __kthread_bind(struct task_struct *p, unsigned int cpu, unsigned int state)\n{\n\t__kthread_bind_mask(p, cpumask_of(cpu), state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind(struct task_struct *p, unsigned int cpu)\n{\n\t__kthread_bind(p, cpu, TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "kthread_bind_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "541-544",
    "snippet": "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kthread_bind_mask",
          "args": [
            "p",
            "mask",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_bind_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "520-534",
          "snippet": "static void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)\n{\n\tunsigned long flags;\n\n\tif (!wait_task_inactive(p, state)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* It's safe because the task is inactive. */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdo_set_cpus_allowed(p, mask);\n\tp->flags |= PF_NO_SETAFFINITY;\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nstatic void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)\n{\n\tunsigned long flags;\n\n\tif (!wait_task_inactive(p, state)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* It's safe because the task is inactive. */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdo_set_cpus_allowed(p, mask);\n\tp->flags |= PF_NO_SETAFFINITY;\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "__kthread_bind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "536-539",
    "snippet": "static void __kthread_bind(struct task_struct *p, unsigned int cpu, unsigned int state)\n{\n\t__kthread_bind_mask(p, cpumask_of(cpu), state);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kthread_bind_mask",
          "args": [
            "p",
            "cpumask_of(cpu)",
            "state"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_bind_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "520-534",
          "snippet": "static void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)\n{\n\tunsigned long flags;\n\n\tif (!wait_task_inactive(p, state)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* It's safe because the task is inactive. */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdo_set_cpus_allowed(p, mask);\n\tp->flags |= PF_NO_SETAFFINITY;\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nstatic void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)\n{\n\tunsigned long flags;\n\n\tif (!wait_task_inactive(p, state)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* It's safe because the task is inactive. */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdo_set_cpus_allowed(p, mask);\n\tp->flags |= PF_NO_SETAFFINITY;\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void __kthread_bind(struct task_struct *p, unsigned int cpu, unsigned int state)\n{\n\t__kthread_bind_mask(p, cpumask_of(cpu), state);\n}"
  },
  {
    "function_name": "__kthread_bind_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "520-534",
    "snippet": "static void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)\n{\n\tunsigned long flags;\n\n\tif (!wait_task_inactive(p, state)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* It's safe because the task is inactive. */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdo_set_cpus_allowed(p, mask);\n\tp->flags |= PF_NO_SETAFFINITY;\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_set_cpus_allowed",
          "args": [
            "p",
            "mask"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_cpus_allowed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2532-2535",
          "snippet": "void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\t__do_set_cpus_allowed(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\t__do_set_cpus_allowed(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_task_inactive",
          "args": [
            "p",
            "state"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3214-3304",
          "snippet": "unsigned long wait_task_inactive(struct task_struct *p, unsigned int match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(READ_ONCE(p->__state) != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || READ_ONCE(p->__state) == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL_HARD);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nunsigned long wait_task_inactive(struct task_struct *p, unsigned int match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(READ_ONCE(p->__state) != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || READ_ONCE(p->__state) == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL_HARD);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nstatic void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)\n{\n\tunsigned long flags;\n\n\tif (!wait_task_inactive(p, state)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* It's safe because the task is inactive. */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdo_set_cpus_allowed(p, mask);\n\tp->flags |= PF_NO_SETAFFINITY;\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}"
  },
  {
    "function_name": "kthread_create_on_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "504-517",
    "snippet": "struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
      "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;",
      "struct task_struct *task;",
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kthread_create_on_node",
          "args": [
            "threadfn",
            "data",
            "node",
            "namefmt",
            "args"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "namefmt"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}"
  },
  {
    "function_name": "create_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "392-412",
    "snippet": "static void create_kthread(struct kthread_create_info *create)\n{\n\tint pid;\n\n#ifdef CONFIG_NUMA\n\tcurrent->pref_node_fork = create->node;\n#endif\n\t/* We want our own signal handler (we take no signals by default). */\n\tpid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);\n\tif (pid < 0) {\n\t\t/* If user was SIGKILLed, I release the structure. */\n\t\tstruct completion *done = xchg(&create->done, NULL);\n\n\t\tif (!done) {\n\t\t\tkfree(create);\n\t\t\treturn;\n\t\t}\n\t\tcreate->result = ERR_PTR(pid);\n\t\tcomplete(done);\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kthread_create_info *create = kmalloc(sizeof(*create),\n\t\t\t\t\t\t     GFP_KERNEL);",
      "int node = NUMA_NO_NODE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "done"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "pid"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "create"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&create->done",
            "NULL"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_thread",
          "args": [
            "kthread",
            "create",
            "CLONE_FS | CLONE_FILES | SIGCHLD"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "2597-2608",
          "snippet": "pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.stack\t\t= (unsigned long)fn,\n\t\t.stack_size\t= (unsigned long)arg,\n\t};\n\n\treturn kernel_clone(&args);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.stack\t\t= (unsigned long)fn,\n\t\t.stack_size\t= (unsigned long)arg,\n\t};\n\n\treturn kernel_clone(&args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct kthread_create_info *create = kmalloc(sizeof(*create),\n\t\t\t\t\t\t     GFP_KERNEL);\nint node = NUMA_NO_NODE;\n\nstatic void create_kthread(struct kthread_create_info *create)\n{\n\tint pid;\n\n#ifdef CONFIG_NUMA\n\tcurrent->pref_node_fork = create->node;\n#endif\n\t/* We want our own signal handler (we take no signals by default). */\n\tpid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);\n\tif (pid < 0) {\n\t\t/* If user was SIGKILLed, I release the structure. */\n\t\tstruct completion *done = xchg(&create->done, NULL);\n\n\t\tif (!done) {\n\t\t\tkfree(create);\n\t\t\treturn;\n\t\t}\n\t\tcreate->result = ERR_PTR(pid);\n\t\tcomplete(done);\n\t}\n}"
  },
  {
    "function_name": "tsk_fork_get_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "383-390",
    "snippet": "int tsk_fork_get_node(struct task_struct *tsk)\n{\n#ifdef CONFIG_NUMA\n\tif (tsk == kthreadd_task)\n\t\treturn tsk->pref_node_fork;\n#endif\n\treturn NUMA_NO_NODE;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *kthreadd_task;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *kthreadd_task;\n\nint tsk_fork_get_node(struct task_struct *tsk)\n{\n#ifdef CONFIG_NUMA\n\tif (tsk == kthreadd_task)\n\t\treturn tsk->pref_node_fork;\n#endif\n\treturn NUMA_NO_NODE;\n}"
  },
  {
    "function_name": "kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "331-380",
    "snippet": "static int kthread(void *_create)\n{\n\tstatic const struct sched_param param = { .sched_priority = 0 };\n\t/* Copy data: it's on kthread's stack */\n\tstruct kthread_create_info *create = _create;\n\tint (*threadfn)(void *data) = create->threadfn;\n\tvoid *data = create->data;\n\tstruct completion *done;\n\tstruct kthread *self;\n\tint ret;\n\n\tself = to_kthread(current);\n\n\t/* If user was SIGKILLed, I release the structure. */\n\tdone = xchg(&create->done, NULL);\n\tif (!done) {\n\t\tkfree(create);\n\t\tkthread_exit(-EINTR);\n\t}\n\n\tself->threadfn = threadfn;\n\tself->data = data;\n\n\t/*\n\t * The new thread inherited kthreadd's priority and CPU mask. Reset\n\t * back to default in case they have been changed.\n\t */\n\tsched_setscheduler_nocheck(current, SCHED_NORMAL, &param);\n\tset_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_KTHREAD));\n\n\t/* OK, tell user we're spawned, wait for stop or wakeup */\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tcreate->result = current;\n\t/*\n\t * Thread is going to call schedule(), do not preempt it,\n\t * or the creator may spend more time in wait_task_inactive().\n\t */\n\tpreempt_disable();\n\tcomplete(done);\n\tschedule_preempt_disabled();\n\tpreempt_enable();\n\n\tret = -EINTR;\n\tif (!test_bit(KTHREAD_SHOULD_STOP, &self->flags)) {\n\t\tcgroup_kthread_ready();\n\t\t__kthread_parkme(self);\n\t\tret = threadfn(data);\n\t}\n\tkthread_exit(ret);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kthread_create_info *create = kmalloc(sizeof(*create),\n\t\t\t\t\t\t     GFP_KERNEL);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "ret"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "303-308",
          "snippet": "void __noreturn kthread_exit(long result)\n{\n\tstruct kthread *kthread = to_kthread(current);\n\tkthread->result = result;\n\tdo_exit(0);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid __noreturn kthread_exit(long result)\n{\n\tstruct kthread *kthread = to_kthread(current);\n\tkthread->result = result;\n\tdo_exit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "threadfn",
          "args": [
            "data"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "lzo_decompress_threadfn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1133-1160",
          "snippet": "static int lzo_decompress_threadfn(void *data)\n{\n\tstruct dec_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->unc_len = LZO_UNC_SIZE;\n\t\td->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,\n\t\t                               d->unc, &d->unc_len);\n\t\tif (clean_pages_on_decompress)\n\t\t\tflush_icache_range((unsigned long)d->unc,\n\t\t\t\t\t   (unsigned long)d->unc + d->unc_len);\n\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
            "#define LZO_HEADER\tsizeof(size_t)"
          ],
          "globals_used": [
            "static bool clean_pages_on_decompress;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic bool clean_pages_on_decompress;\n\nstatic int lzo_decompress_threadfn(void *data)\n{\n\tstruct dec_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->unc_len = LZO_UNC_SIZE;\n\t\td->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,\n\t\t                               d->unc, &d->unc_len);\n\t\tif (clean_pages_on_decompress)\n\t\t\tflush_icache_range((unsigned long)d->unc,\n\t\t\t\t\t   (unsigned long)d->unc + d->unc_len);\n\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kthread_parkme",
          "args": [
            "self"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_parkme",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "258-285",
          "snippet": "static void __kthread_parkme(struct kthread *self)\n{\n\tfor (;;) {\n\t\t/*\n\t\t * TASK_PARKED is a special state; we must serialize against\n\t\t * possible pending wakeups to avoid store-store collisions on\n\t\t * task->state.\n\t\t *\n\t\t * Such a collision might possibly result in the task state\n\t\t * changin from TASK_PARKED and us failing the\n\t\t * wait_task_inactive() in kthread_park().\n\t\t */\n\t\tset_special_state(TASK_PARKED);\n\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Thread is going to call schedule(), do not preempt it,\n\t\t * or the caller of kthread_park() may spend more time in\n\t\t * wait_task_inactive().\n\t\t */\n\t\tpreempt_disable();\n\t\tcomplete(&self->parked);\n\t\tschedule_preempt_disabled();\n\t\tpreempt_enable();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nstatic void __kthread_parkme(struct kthread *self)\n{\n\tfor (;;) {\n\t\t/*\n\t\t * TASK_PARKED is a special state; we must serialize against\n\t\t * possible pending wakeups to avoid store-store collisions on\n\t\t * task->state.\n\t\t *\n\t\t * Such a collision might possibly result in the task state\n\t\t * changin from TASK_PARKED and us failing the\n\t\t * wait_task_inactive() in kthread_park().\n\t\t */\n\t\tset_special_state(TASK_PARKED);\n\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Thread is going to call schedule(), do not preempt it,\n\t\t * or the caller of kthread_park() may spend more time in\n\t\t * wait_task_inactive().\n\t\t */\n\t\tpreempt_disable();\n\t\tcomplete(&self->parked);\n\t\tschedule_preempt_disabled();\n\t\tpreempt_enable();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kthread_ready",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KTHREAD_SHOULD_STOP",
            "&self->flags"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_preempt_disabled",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "done"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "housekeeping_cpumask(HK_FLAG_KTHREAD)"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_KTHREAD"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "current",
            "SCHED_NORMAL",
            "&param"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7565-7569",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "create"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&create->done",
            "NULL"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "current"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct kthread_create_info *create = kmalloc(sizeof(*create),\n\t\t\t\t\t\t     GFP_KERNEL);\n\nstatic int kthread(void *_create)\n{\n\tstatic const struct sched_param param = { .sched_priority = 0 };\n\t/* Copy data: it's on kthread's stack */\n\tstruct kthread_create_info *create = _create;\n\tint (*threadfn)(void *data) = create->threadfn;\n\tvoid *data = create->data;\n\tstruct completion *done;\n\tstruct kthread *self;\n\tint ret;\n\n\tself = to_kthread(current);\n\n\t/* If user was SIGKILLed, I release the structure. */\n\tdone = xchg(&create->done, NULL);\n\tif (!done) {\n\t\tkfree(create);\n\t\tkthread_exit(-EINTR);\n\t}\n\n\tself->threadfn = threadfn;\n\tself->data = data;\n\n\t/*\n\t * The new thread inherited kthreadd's priority and CPU mask. Reset\n\t * back to default in case they have been changed.\n\t */\n\tsched_setscheduler_nocheck(current, SCHED_NORMAL, &param);\n\tset_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_KTHREAD));\n\n\t/* OK, tell user we're spawned, wait for stop or wakeup */\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tcreate->result = current;\n\t/*\n\t * Thread is going to call schedule(), do not preempt it,\n\t * or the creator may spend more time in wait_task_inactive().\n\t */\n\tpreempt_disable();\n\tcomplete(done);\n\tschedule_preempt_disabled();\n\tpreempt_enable();\n\n\tret = -EINTR;\n\tif (!test_bit(KTHREAD_SHOULD_STOP, &self->flags)) {\n\t\tcgroup_kthread_ready();\n\t\t__kthread_parkme(self);\n\t\tret = threadfn(data);\n\t}\n\tkthread_exit(ret);\n}"
  },
  {
    "function_name": "kthread_complete_and_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "322-328",
    "snippet": "void __noreturn kthread_complete_and_exit(struct completion *comp, long code)\n{\n\tif (comp)\n\t\tcomplete(comp);\n\n\tkthread_exit(code);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "code"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "303-308",
          "snippet": "void __noreturn kthread_exit(long result)\n{\n\tstruct kthread *kthread = to_kthread(current);\n\tkthread->result = result;\n\tdo_exit(0);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid __noreturn kthread_exit(long result)\n{\n\tstruct kthread *kthread = to_kthread(current);\n\tkthread->result = result;\n\tdo_exit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "comp"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid __noreturn kthread_complete_and_exit(struct completion *comp, long code)\n{\n\tif (comp)\n\t\tcomplete(comp);\n\n\tkthread_exit(code);\n}"
  },
  {
    "function_name": "kthread_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "303-308",
    "snippet": "void __noreturn kthread_exit(long result)\n{\n\tstruct kthread *kthread = to_kthread(current);\n\tkthread->result = result;\n\tdo_exit(0);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "0"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "734-859",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "current"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid __noreturn kthread_exit(long result)\n{\n\tstruct kthread *kthread = to_kthread(current);\n\tkthread->result = result;\n\tdo_exit(0);\n}"
  },
  {
    "function_name": "kthread_parkme",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "287-290",
    "snippet": "void kthread_parkme(void)\n{\n\t__kthread_parkme(to_kthread(current));\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kthread_parkme",
          "args": [
            "to_kthread(current)"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_parkme",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "258-285",
          "snippet": "static void __kthread_parkme(struct kthread *self)\n{\n\tfor (;;) {\n\t\t/*\n\t\t * TASK_PARKED is a special state; we must serialize against\n\t\t * possible pending wakeups to avoid store-store collisions on\n\t\t * task->state.\n\t\t *\n\t\t * Such a collision might possibly result in the task state\n\t\t * changin from TASK_PARKED and us failing the\n\t\t * wait_task_inactive() in kthread_park().\n\t\t */\n\t\tset_special_state(TASK_PARKED);\n\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Thread is going to call schedule(), do not preempt it,\n\t\t * or the caller of kthread_park() may spend more time in\n\t\t * wait_task_inactive().\n\t\t */\n\t\tpreempt_disable();\n\t\tcomplete(&self->parked);\n\t\tschedule_preempt_disabled();\n\t\tpreempt_enable();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nstatic void __kthread_parkme(struct kthread *self)\n{\n\tfor (;;) {\n\t\t/*\n\t\t * TASK_PARKED is a special state; we must serialize against\n\t\t * possible pending wakeups to avoid store-store collisions on\n\t\t * task->state.\n\t\t *\n\t\t * Such a collision might possibly result in the task state\n\t\t * changin from TASK_PARKED and us failing the\n\t\t * wait_task_inactive() in kthread_park().\n\t\t */\n\t\tset_special_state(TASK_PARKED);\n\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Thread is going to call schedule(), do not preempt it,\n\t\t * or the caller of kthread_park() may spend more time in\n\t\t * wait_task_inactive().\n\t\t */\n\t\tpreempt_disable();\n\t\tcomplete(&self->parked);\n\t\tschedule_preempt_disabled();\n\t\tpreempt_enable();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "current"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_parkme(void)\n{\n\t__kthread_parkme(to_kthread(current));\n}"
  },
  {
    "function_name": "__kthread_parkme",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "258-285",
    "snippet": "static void __kthread_parkme(struct kthread *self)\n{\n\tfor (;;) {\n\t\t/*\n\t\t * TASK_PARKED is a special state; we must serialize against\n\t\t * possible pending wakeups to avoid store-store collisions on\n\t\t * task->state.\n\t\t *\n\t\t * Such a collision might possibly result in the task state\n\t\t * changin from TASK_PARKED and us failing the\n\t\t * wait_task_inactive() in kthread_park().\n\t\t */\n\t\tset_special_state(TASK_PARKED);\n\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Thread is going to call schedule(), do not preempt it,\n\t\t * or the caller of kthread_park() may spend more time in\n\t\t * wait_task_inactive().\n\t\t */\n\t\tpreempt_disable();\n\t\tcomplete(&self->parked);\n\t\tschedule_preempt_disabled();\n\t\tpreempt_enable();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_preempt_disabled",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&self->parked"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KTHREAD_SHOULD_PARK",
            "&self->flags"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_special_state",
          "args": [
            "TASK_PARKED"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nstatic void __kthread_parkme(struct kthread *self)\n{\n\tfor (;;) {\n\t\t/*\n\t\t * TASK_PARKED is a special state; we must serialize against\n\t\t * possible pending wakeups to avoid store-store collisions on\n\t\t * task->state.\n\t\t *\n\t\t * Such a collision might possibly result in the task state\n\t\t * changin from TASK_PARKED and us failing the\n\t\t * wait_task_inactive() in kthread_park().\n\t\t */\n\t\tset_special_state(TASK_PARKED);\n\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Thread is going to call schedule(), do not preempt it,\n\t\t * or the caller of kthread_park() may spend more time in\n\t\t * wait_task_inactive().\n\t\t */\n\t\tpreempt_disable();\n\t\tcomplete(&self->parked);\n\t\tschedule_preempt_disabled();\n\t\tpreempt_enable();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
  },
  {
    "function_name": "kthread_probe_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "248-256",
    "snippet": "void *kthread_probe_data(struct task_struct *task)\n{\n\tstruct kthread *kthread = __to_kthread(task);\n\tvoid *data = NULL;\n\n\tif (kthread)\n\t\tcopy_from_kernel_nofault(&data, &kthread->data, sizeof(data));\n\treturn data;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&data",
            "&kthread->data",
            "sizeof(data)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__to_kthread",
          "args": [
            "task"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_probe_data(struct task_struct *task)\n{\n\tstruct kthread *kthread = __to_kthread(task);\n\tvoid *data = NULL;\n\n\tif (kthread)\n\t\tcopy_from_kernel_nofault(&data, &kthread->data, sizeof(data));\n\treturn data;\n}"
  },
  {
    "function_name": "kthread_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "233-236",
    "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "task"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
  },
  {
    "function_name": "kthread_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "216-222",
    "snippet": "void *kthread_func(struct task_struct *task)\n{\n\tstruct kthread *kthread = __to_kthread(task);\n\tif (kthread)\n\t\treturn kthread->threadfn;\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__to_kthread",
          "args": [
            "task"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_func(struct task_struct *task)\n{\n\tstruct kthread *kthread = __to_kthread(task);\n\tif (kthread)\n\t\treturn kthread->threadfn;\n\treturn NULL;\n}"
  },
  {
    "function_name": "kthread_freezable_should_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "194-207",
    "snippet": "bool kthread_freezable_should_stop(bool *was_frozen)\n{\n\tbool frozen = false;\n\n\tmight_sleep();\n\n\tif (unlikely(freezing(current)))\n\t\tfrozen = __refrigerator(true);\n\n\tif (was_frozen)\n\t\t*was_frozen = frozen;\n\n\treturn kthread_should_stop();\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__refrigerator",
          "args": [
            "true"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__refrigerator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "56-91",
          "snippet": "bool __refrigerator(bool check_kthr_stop)\n{\n\t/* Hmm, should we be allowed to suspend when there are realtime\n\t   processes around? */\n\tbool was_frozen = false;\n\tunsigned int save = get_current_state();\n\n\tpr_debug(\"%s entered refrigerator\\n\", current->comm);\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\tspin_lock_irq(&freezer_lock);\n\t\tcurrent->flags |= PF_FROZEN;\n\t\tif (!freezing(current) ||\n\t\t    (check_kthr_stop && kthread_should_stop()))\n\t\t\tcurrent->flags &= ~PF_FROZEN;\n\t\tspin_unlock_irq(&freezer_lock);\n\n\t\tif (!(current->flags & PF_FROZEN))\n\t\t\tbreak;\n\t\twas_frozen = true;\n\t\tschedule();\n\t}\n\n\tpr_debug(\"%s left refrigerator\\n\", current->comm);\n\n\t/*\n\t * Restore saved task state before returning.  The mb'd version\n\t * needs to be used; otherwise, it might silently break\n\t * synchronization which depends on ordered task state change.\n\t */\n\tset_current_state(save);\n\n\treturn was_frozen;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool __refrigerator(bool check_kthr_stop)\n{\n\t/* Hmm, should we be allowed to suspend when there are realtime\n\t   processes around? */\n\tbool was_frozen = false;\n\tunsigned int save = get_current_state();\n\n\tpr_debug(\"%s entered refrigerator\\n\", current->comm);\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\tspin_lock_irq(&freezer_lock);\n\t\tcurrent->flags |= PF_FROZEN;\n\t\tif (!freezing(current) ||\n\t\t    (check_kthr_stop && kthread_should_stop()))\n\t\t\tcurrent->flags &= ~PF_FROZEN;\n\t\tspin_unlock_irq(&freezer_lock);\n\n\t\tif (!(current->flags & PF_FROZEN))\n\t\t\tbreak;\n\t\twas_frozen = true;\n\t\tschedule();\n\t}\n\n\tpr_debug(\"%s left refrigerator\\n\", current->comm);\n\n\t/*\n\t * Restore saved task state before returning.  The mb'd version\n\t * needs to be used; otherwise, it might silently break\n\t * synchronization which depends on ordered task state change.\n\t */\n\tset_current_state(save);\n\n\treturn was_frozen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "freezing(current)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "37-52",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_freezable_should_stop(bool *was_frozen)\n{\n\tbool frozen = false;\n\n\tmight_sleep();\n\n\tif (unlikely(freezing(current)))\n\t\tfrozen = __refrigerator(true);\n\n\tif (was_frozen)\n\t\t*was_frozen = frozen;\n\n\treturn kthread_should_stop();\n}"
  },
  {
    "function_name": "kthread_should_park",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "179-182",
    "snippet": "bool kthread_should_park(void)\n{\n\treturn __kthread_should_park(current);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kthread_should_park",
          "args": [
            "current"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__kthread_should_park",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "162-165",
          "snippet": "bool __kthread_should_park(struct task_struct *k)\n{\n\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool __kthread_should_park(struct task_struct *k)\n{\n\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_park(void)\n{\n\treturn __kthread_should_park(current);\n}"
  },
  {
    "function_name": "__kthread_should_park",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "162-165",
    "snippet": "bool __kthread_should_park(struct task_struct *k)\n{\n\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KTHREAD_SHOULD_PARK",
            "&to_kthread(k)->flags"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "k"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool __kthread_should_park(struct task_struct *k)\n{\n\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);\n}"
  },
  {
    "function_name": "kthread_should_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "156-159",
    "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KTHREAD_SHOULD_STOP",
            "&to_kthread(current)->flags"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "current"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
  },
  {
    "function_name": "free_kthread_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "130-147",
    "snippet": "void free_kthread_struct(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\n\t/*\n\t * Can be NULL if kmalloc() in set_kthread_struct() failed.\n\t */\n\tkthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n#ifdef CONFIG_BLK_CGROUP\n\tWARN_ON_ONCE(kthread->blkcg_css);\n#endif\n\tk->worker_private = NULL;\n\tkfree(kthread->full_name);\n\tkfree(kthread);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kthread"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "kthread->blkcg_css"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "k"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid free_kthread_struct(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\n\t/*\n\t * Can be NULL if kmalloc() in set_kthread_struct() failed.\n\t */\n\tkthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n#ifdef CONFIG_BLK_CGROUP\n\tWARN_ON_ONCE(kthread->blkcg_css);\n#endif\n\tk->worker_private = NULL;\n\tkfree(kthread->full_name);\n\tkfree(kthread);\n}"
  },
  {
    "function_name": "set_kthread_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "111-128",
    "snippet": "bool set_kthread_struct(struct task_struct *p)\n{\n\tstruct kthread *kthread;\n\n\tif (WARN_ON_ONCE(to_kthread(p)))\n\t\treturn false;\n\n\tkthread = kzalloc(sizeof(*kthread), GFP_KERNEL);\n\tif (!kthread)\n\t\treturn false;\n\n\tinit_completion(&kthread->exited);\n\tinit_completion(&kthread->parked);\n\tp->vfork_done = &kthread->exited;\n\n\tp->worker_private = kthread;\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&kthread->parked"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&kthread->exited"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*kthread)",
            "GFP_KERNEL"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "to_kthread(p)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "p"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool set_kthread_struct(struct task_struct *p)\n{\n\tstruct kthread *kthread;\n\n\tif (WARN_ON_ONCE(to_kthread(p)))\n\t\treturn false;\n\n\tkthread = kzalloc(sizeof(*kthread), GFP_KERNEL);\n\tif (!kthread)\n\t\treturn false;\n\n\tinit_completion(&kthread->exited);\n\tinit_completion(&kthread->parked);\n\tp->vfork_done = &kthread->exited;\n\n\tp->worker_private = kthread;\n\treturn true;\n}"
  },
  {
    "function_name": "get_kthread_comm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "99-109",
    "snippet": "void get_kthread_comm(char *buf, size_t buf_size, struct task_struct *tsk)\n{\n\tstruct kthread *kthread = to_kthread(tsk);\n\n\tif (!kthread || !kthread->full_name) {\n\t\t__get_task_comm(buf, buf_size, tsk);\n\t\treturn;\n\t}\n\n\tstrscpy_pad(buf, kthread->full_name, buf_size);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy_pad",
          "args": [
            "buf",
            "kthread->full_name",
            "buf_size"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_task_comm",
          "args": [
            "buf",
            "buf_size",
            "tsk"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kthread",
          "args": [
            "tsk"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__to_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "91-97",
          "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid get_kthread_comm(char *buf, size_t buf_size, struct task_struct *tsk)\n{\n\tstruct kthread *kthread = to_kthread(tsk);\n\n\tif (!kthread || !kthread->full_name) {\n\t\t__get_task_comm(buf, buf_size, tsk);\n\t\treturn;\n\t}\n\n\tstrscpy_pad(buf, kthread->full_name, buf_size);\n}"
  },
  {
    "function_name": "__to_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "91-97",
    "snippet": "static inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *__to_kthread(struct task_struct *p)\n{\n\tvoid *kthread = p->worker_private;\n\tif (kthread && !(p->flags & PF_KTHREAD))\n\t\tkthread = NULL;\n\treturn kthread;\n}"
  },
  {
    "function_name": "to_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
    "lines": "74-78",
    "snippet": "static inline struct kthread *to_kthread(struct task_struct *k)\n{\n\tWARN_ON(!(k->flags & PF_KTHREAD));\n\treturn k->worker_private;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/numa.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>",
      "#include <linux/file.h>",
      "#include <linux/unistd.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/err.h>",
      "#include <linux/completion.h>",
      "#include <linux/kthread.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mm.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(k->flags & PF_KTHREAD)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline struct kthread *to_kthread(struct task_struct *k)\n{\n\tWARN_ON(!(k->flags & PF_KTHREAD));\n\treturn k->worker_private;\n}"
  }
]