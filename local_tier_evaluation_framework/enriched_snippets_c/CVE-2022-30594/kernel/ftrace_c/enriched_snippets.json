[
  {
    "function_name": "ftrace_enable_sysctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7849-7891",
    "snippet": "int\nftrace_enable_sysctl(struct ctl_table *table, int write,\n\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write || (last_ftrace_enabled == !!ftrace_enabled))\n\t\tgoto out;\n\n\tif (ftrace_enabled) {\n\n\t\t/* we are starting ftrace again */\n\t\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) != &ftrace_list_end)\n\t\t\tupdate_ftrace_function();\n\n\t\tftrace_startup_sysctl();\n\n\t} else {\n\t\tif (is_permanent_ops_registered()) {\n\t\t\tftrace_enabled = true;\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* stopping ftrace calls (just send to ftrace_stub) */\n\t\tftrace_trace_function = ftrace_stub;\n\n\t\tftrace_shutdown_sysctl();\n\t}\n\n\tlast_ftrace_enabled = !!ftrace_enabled;\n out:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static int last_ftrace_enabled;",
      "static int ftrace_disabled",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "ftrace_func_t ftrace_trace_function"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7889
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown_sysctl",
          "args": [],
          "line": 7884
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown_sysctl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3069-3083",
          "snippet": "static void ftrace_shutdown_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* ftrace_start_up is true if ftrace is running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_DISABLE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_STOP_FUNC_RET;\n\t\tftrace_run_update_code(command);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void ftrace_shutdown_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* ftrace_start_up is true if ftrace is running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_DISABLE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_STOP_FUNC_RET;\n\t\tftrace_run_update_code(command);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_permanent_ops_registered",
          "args": [],
          "line": 7875
        },
        "resolved": true,
        "details": {
          "function_name": "is_permanent_ops_registered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7837-7847",
          "snippet": "static bool is_permanent_ops_registered(void)\n{\n\tstruct ftrace_ops *op;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PERMANENT)\n\t\t\treturn true;\n\t} while_for_each_ftrace_op(op);\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic bool is_permanent_ops_registered(void)\n{\n\tstruct ftrace_ops *op;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PERMANENT)\n\t\t\treturn true;\n\t} while_for_each_ftrace_op(op);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup_sysctl",
          "args": [],
          "line": 7872
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_sysctl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3051-3067",
          "snippet": "static void ftrace_startup_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* Force update next time */\n\tsaved_ftrace_func = NULL;\n\t/* ftrace_start_up is true if we want ftrace running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_UPDATE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_START_FUNC_RET;\n\t\tftrace_startup_enable(command);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void ftrace_startup_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* Force update next time */\n\tsaved_ftrace_func = NULL;\n\t/* ftrace_start_up is true if we want ftrace running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_UPDATE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_START_FUNC_RET;\n\t\tftrace_startup_enable(command);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ftrace_function",
          "args": [],
          "line": 7870
        },
        "resolved": true,
        "details": {
          "function_name": "update_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "174-251",
          "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_ops_list",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 7868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7869
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 7860
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_ms_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1597-1601",
          "snippet": "int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 7857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7855
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic int last_ftrace_enabled;\nstatic int ftrace_disabled;\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\n\nint\nftrace_enable_sysctl(struct ctl_table *table, int write,\n\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write || (last_ftrace_enabled == !!ftrace_enabled))\n\t\tgoto out;\n\n\tif (ftrace_enabled) {\n\n\t\t/* we are starting ftrace again */\n\t\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) != &ftrace_list_end)\n\t\t\tupdate_ftrace_function();\n\n\t\tftrace_startup_sysctl();\n\n\t} else {\n\t\tif (is_permanent_ops_registered()) {\n\t\t\tftrace_enabled = true;\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* stopping ftrace calls (just send to ftrace_stub) */\n\t\tftrace_trace_function = ftrace_stub;\n\n\t\tftrace_shutdown_sysctl();\n\t}\n\n\tlast_ftrace_enabled = !!ftrace_enabled;\n out:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "is_permanent_ops_registered",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7837-7847",
    "snippet": "static bool is_permanent_ops_registered(void)\n{\n\tstruct ftrace_ops *op;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PERMANENT)\n\t\t\treturn true;\n\t} while_for_each_ftrace_op(op);\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops __rcu *ftrace_ops_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 7844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 7841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic bool is_permanent_ops_registered(void)\n{\n\tstruct ftrace_ops *op;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PERMANENT)\n\t\t\treturn true;\n\t} while_for_each_ftrace_op(op);\n\n\treturn false;\n}"
  },
  {
    "function_name": "unregister_ftrace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7825-7834",
    "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7831
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown",
          "args": [
            "ops",
            "0"
          ],
          "line": 7830
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2937-3049",
          "snippet": "int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tsynchronize_rcu_tasks_rude();\n\n\t\t/*\n\t\t * When the kernel is preemptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchronize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tsynchronize_rcu_tasks_rude();\n\n\t\t/*\n\t\t * When the kernel is preemptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchronize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7829
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_ftrace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7803-7816",
    "snippet": "int register_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tftrace_ops_init(ops);\n\n\tmutex_lock(&ftrace_lock);\n\n\tret = ftrace_startup(ops, 0);\n\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7813
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup",
          "args": [
            "ops",
            "0"
          ],
          "line": 7811
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2893-2935",
          "snippet": "int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tftrace_trampoline_free(ops);\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tftrace_trampoline_free(ops);\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7809
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 7807
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint register_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tftrace_ops_init(ops);\n\n\tmutex_lock(&ftrace_lock);\n\n\tret = ftrace_startup(ops, 0);\n\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_is_dead",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7787-7790",
    "snippet": "int ftrace_is_dead(void)\n{\n\treturn ftrace_disabled;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nint ftrace_is_dead(void)\n{\n\treturn ftrace_disabled;\n}"
  },
  {
    "function_name": "ftrace_kill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7775-7780",
    "snippet": "void ftrace_kill(void)\n{\n\tftrace_disabled = 1;\n\tftrace_enabled = 0;\n\tftrace_trace_function = ftrace_stub;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static int ftrace_disabled",
      "ftrace_func_t ftrace_trace_function"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic int ftrace_disabled;\nftrace_func_t ftrace_trace_function;\n\nvoid ftrace_kill(void)\n{\n\tftrace_disabled = 1;\n\tftrace_enabled = 0;\n\tftrace_trace_function = ftrace_stub;\n}"
  },
  {
    "function_name": "ftrace_init_tracefs_toplevel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7758-7766",
    "snippet": "void __init ftrace_init_tracefs_toplevel(struct trace_array *tr,\n\t\t\t\t\t struct dentry *d_tracer)\n{\n\t/* Only the top level directory has the dyn_tracefs and profile */\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\n\tftrace_init_dyn_tracefs(d_tracer);\n\tftrace_profile_tracefs(d_tracer);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_profile_tracefs",
          "args": [
            "d_tracer"
          ],
          "line": 7765
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_tracefs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "994-996",
          "snippet": "static __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_init_dyn_tracefs",
          "args": [
            "d_tracer"
          ],
          "line": 7764
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_dyn_tracefs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7193-7193",
          "snippet": "static inline int ftrace_init_dyn_tracefs(struct dentry *d_tracer) { return 0; }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline int ftrace_init_dyn_tracefs(struct dentry *d_tracer) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(tr->flags & TRACE_ARRAY_FL_GLOBAL)"
          ],
          "line": 7762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid __init ftrace_init_tracefs_toplevel(struct trace_array *tr,\n\t\t\t\t\t struct dentry *d_tracer)\n{\n\t/* Only the top level directory has the dyn_tracefs and profile */\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\n\tftrace_init_dyn_tracefs(d_tracer);\n\tftrace_profile_tracefs(d_tracer);\n}"
  },
  {
    "function_name": "ftrace_init_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7750-7756",
    "snippet": "void ftrace_init_tracefs(struct trace_array *tr, struct dentry *d_tracer)\n{\n\ttrace_create_file(\"set_ftrace_pid\", TRACE_MODE_WRITE, d_tracer,\n\t\t\t    tr, &ftrace_pid_fops);\n\ttrace_create_file(\"set_ftrace_notrace_pid\", TRACE_MODE_WRITE,\n\t\t\t  d_tracer, tr, &ftrace_no_pid_fops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ftrace_pid_fops = {\n\t.open\t\t= ftrace_pid_open,\n\t.write\t\t= ftrace_pid_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_pid_release,\n};",
      "static const struct file_operations ftrace_no_pid_fops = {\n\t.open\t\t= ftrace_no_pid_open,\n\t.write\t\t= ftrace_no_pid_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_pid_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"set_ftrace_notrace_pid\"",
            "TRACE_MODE_WRITE",
            "d_tracer",
            "tr",
            "&ftrace_no_pid_fops"
          ],
          "line": 7754
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic const struct file_operations ftrace_pid_fops = {\n\t.open\t\t= ftrace_pid_open,\n\t.write\t\t= ftrace_pid_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_pid_release,\n};\nstatic const struct file_operations ftrace_no_pid_fops = {\n\t.open\t\t= ftrace_no_pid_open,\n\t.write\t\t= ftrace_no_pid_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_pid_release,\n};\n\nvoid ftrace_init_tracefs(struct trace_array *tr, struct dentry *d_tracer)\n{\n\ttrace_create_file(\"set_ftrace_pid\", TRACE_MODE_WRITE, d_tracer,\n\t\t\t    tr, &ftrace_pid_fops);\n\ttrace_create_file(\"set_ftrace_notrace_pid\", TRACE_MODE_WRITE,\n\t\t\t  d_tracer, tr, &ftrace_no_pid_fops);\n}"
  },
  {
    "function_name": "ftrace_pid_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7724-7732",
    "snippet": "static int\nftrace_pid_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 7731
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 7729
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_pid_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "ftrace_no_pid_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7717-7722",
    "snippet": "static ssize_t\nftrace_no_pid_write(struct file *filp, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn pid_write(filp, ubuf, cnt, ppos, TRACE_NO_PIDS);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_write",
          "args": [
            "filp",
            "ubuf",
            "cnt",
            "ppos",
            "TRACE_NO_PIDS"
          ],
          "line": 7721
        },
        "resolved": true,
        "details": {
          "function_name": "pid_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7635-7708",
          "snippet": "static ssize_t\npid_write(struct file *filp, const char __user *ubuf,\n\t  size_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids;\n\tstruct trace_pid_list *other_pids;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\trcu_assign_pointer(tr->function_pids, pid_list);\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\trcu_assign_pointer(tr->function_no_pids, pid_list);\n\t\tbreak;\n\t}\n\n\n\tif (filtered_pids) {\n\t\tsynchronize_rcu();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\npid_write(struct file *filp, const char __user *ubuf,\n\t  size_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids;\n\tstruct trace_pid_list *other_pids;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\trcu_assign_pointer(tr->function_pids, pid_list);\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\trcu_assign_pointer(tr->function_no_pids, pid_list);\n\t\tbreak;\n\t}\n\n\n\tif (filtered_pids) {\n\t\tsynchronize_rcu();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_no_pid_write(struct file *filp, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn pid_write(filp, ubuf, cnt, ppos, TRACE_NO_PIDS);\n}"
  },
  {
    "function_name": "ftrace_pid_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7710-7715",
    "snippet": "static ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t size_t cnt, loff_t *ppos)\n{\n\treturn pid_write(filp, ubuf, cnt, ppos, TRACE_PIDS);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_write",
          "args": [
            "filp",
            "ubuf",
            "cnt",
            "ppos",
            "TRACE_PIDS"
          ],
          "line": 7714
        },
        "resolved": true,
        "details": {
          "function_name": "pid_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7635-7708",
          "snippet": "static ssize_t\npid_write(struct file *filp, const char __user *ubuf,\n\t  size_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids;\n\tstruct trace_pid_list *other_pids;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\trcu_assign_pointer(tr->function_pids, pid_list);\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\trcu_assign_pointer(tr->function_no_pids, pid_list);\n\t\tbreak;\n\t}\n\n\n\tif (filtered_pids) {\n\t\tsynchronize_rcu();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\npid_write(struct file *filp, const char __user *ubuf,\n\t  size_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids;\n\tstruct trace_pid_list *other_pids;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\trcu_assign_pointer(tr->function_pids, pid_list);\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\trcu_assign_pointer(tr->function_no_pids, pid_list);\n\t\tbreak;\n\t}\n\n\n\tif (filtered_pids) {\n\t\tsynchronize_rcu();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t size_t cnt, loff_t *ppos)\n{\n\treturn pid_write(filp, ubuf, cnt, ppos, TRACE_PIDS);\n}"
  },
  {
    "function_name": "pid_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7635-7708",
    "snippet": "static ssize_t\npid_write(struct file *filp, const char __user *ubuf,\n\t  size_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids;\n\tstruct trace_pid_list *other_pids;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\trcu_assign_pointer(tr->function_pids, pid_list);\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\trcu_assign_pointer(tr->function_no_pids, pid_list);\n\t\tbreak;\n\t}\n\n\n\tif (filtered_pids) {\n\t\tsynchronize_rcu();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7702
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup_all",
          "args": [
            "0"
          ],
          "line": 7700
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7195-7195",
          "snippet": "static inline void ftrace_startup_all(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_all(int command) { }"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_update_pid_func",
          "args": [],
          "line": 7699
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_pid_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "360-377",
          "snippet": "static void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\n\nstatic void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "ignore_task_cpu",
            "tr",
            "1"
          ],
          "line": 7697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_switch",
          "args": [
            "ftrace_filter_pid_sched_switch_probe",
            "tr"
          ],
          "line": 7689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_pid_list_free",
          "args": [
            "filtered_pids"
          ],
          "line": 7686
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_list_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "457-495",
          "snippet": "void trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nvoid trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 7685
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->function_no_pids",
            "pid_list"
          ],
          "line": 7679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->function_pids",
            "pid_list"
          ],
          "line": 7676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_pid_write",
          "args": [
            "filtered_pids",
            "&pid_list",
            "ubuf",
            "cnt"
          ],
          "line": 7670
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pid_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7710-7715",
          "snippet": "static ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t size_t cnt, loff_t *ppos)\n{\n\treturn pid_write(filp, ubuf, cnt, ppos, TRACE_PIDS);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t size_t cnt, loff_t *ppos)\n{\n\treturn pid_write(filp, ubuf, cnt, ppos, TRACE_PIDS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 7666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_pids",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 7661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7662
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_no_pids",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 7659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_no_pids",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 7655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_pids",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 7653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7649
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\npid_write(struct file *filp, const char __user *ubuf,\n\t  size_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids;\n\tstruct trace_pid_list *other_pids;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tfiltered_pids = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tother_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\trcu_assign_pointer(tr->function_pids, pid_list);\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\trcu_assign_pointer(tr->function_no_pids, pid_list);\n\t\tbreak;\n\t}\n\n\n\tif (filtered_pids) {\n\t\tsynchronize_rcu();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ignore_task_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7612-7633",
    "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ftrace_ignore_pid",
            "current->pid"
          ],
          "line": 7631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ftrace_ignore_pid",
            "FTRACE_PID_IGNORE"
          ],
          "line": 7628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "no_pid_list",
            "current"
          ],
          "line": 7627
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "538-555",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_no_pids",
            "mutex_is_locked(&ftrace_lock)"
          ],
          "line": 7624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7625
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_pids",
            "mutex_is_locked(&ftrace_lock)"
          ],
          "line": 7622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
  },
  {
    "function_name": "ftrace_no_pid_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7606-7610",
    "snippet": "static int\nftrace_no_pid_open(struct inode *inode, struct file *file)\n{\n\treturn pid_open(inode, file, TRACE_NO_PIDS);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_open",
          "args": [
            "inode",
            "file",
            "TRACE_NO_PIDS"
          ],
          "line": 7609
        },
        "resolved": true,
        "details": {
          "function_name": "pid_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7560-7598",
          "snippet": "static int pid_open(struct inode *inode, struct file *file, int type)\n{\n\tconst struct seq_operations *seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_pid_reset(tr, type);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tseq_ops = &ftrace_pid_sops;\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tseq_ops = &ftrace_no_pid_sops;\n\t\tbreak;\n\tdefault:\n\t\ttrace_array_put(tr);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t} else {\n\t\tm = file->private_data;\n\t\t/* copy tr over to seq ops */\n\t\tm->private = tr;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static const struct seq_operations ftrace_pid_sops = {\n\t.start = fpid_start,\n\t.next = fpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};",
            "static const struct seq_operations ftrace_no_pid_sops = {\n\t.start = fnpid_start,\n\t.next = fnpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic const struct seq_operations ftrace_pid_sops = {\n\t.start = fpid_start,\n\t.next = fpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};\nstatic const struct seq_operations ftrace_no_pid_sops = {\n\t.start = fnpid_start,\n\t.next = fnpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};\n\nstatic int pid_open(struct inode *inode, struct file *file, int type)\n{\n\tconst struct seq_operations *seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_pid_reset(tr, type);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tseq_ops = &ftrace_pid_sops;\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tseq_ops = &ftrace_no_pid_sops;\n\t\tbreak;\n\tdefault:\n\t\ttrace_array_put(tr);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t} else {\n\t\tm = file->private_data;\n\t\t/* copy tr over to seq ops */\n\t\tm->private = tr;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_no_pid_open(struct inode *inode, struct file *file)\n{\n\treturn pid_open(inode, file, TRACE_NO_PIDS);\n}"
  },
  {
    "function_name": "ftrace_pid_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7600-7604",
    "snippet": "static int\nftrace_pid_open(struct inode *inode, struct file *file)\n{\n\treturn pid_open(inode, file, TRACE_PIDS);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_open",
          "args": [
            "inode",
            "file",
            "TRACE_PIDS"
          ],
          "line": 7603
        },
        "resolved": true,
        "details": {
          "function_name": "pid_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7560-7598",
          "snippet": "static int pid_open(struct inode *inode, struct file *file, int type)\n{\n\tconst struct seq_operations *seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_pid_reset(tr, type);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tseq_ops = &ftrace_pid_sops;\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tseq_ops = &ftrace_no_pid_sops;\n\t\tbreak;\n\tdefault:\n\t\ttrace_array_put(tr);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t} else {\n\t\tm = file->private_data;\n\t\t/* copy tr over to seq ops */\n\t\tm->private = tr;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static const struct seq_operations ftrace_pid_sops = {\n\t.start = fpid_start,\n\t.next = fpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};",
            "static const struct seq_operations ftrace_no_pid_sops = {\n\t.start = fnpid_start,\n\t.next = fnpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic const struct seq_operations ftrace_pid_sops = {\n\t.start = fpid_start,\n\t.next = fpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};\nstatic const struct seq_operations ftrace_no_pid_sops = {\n\t.start = fnpid_start,\n\t.next = fnpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};\n\nstatic int pid_open(struct inode *inode, struct file *file, int type)\n{\n\tconst struct seq_operations *seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_pid_reset(tr, type);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tseq_ops = &ftrace_pid_sops;\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tseq_ops = &ftrace_no_pid_sops;\n\t\tbreak;\n\tdefault:\n\t\ttrace_array_put(tr);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t} else {\n\t\tm = file->private_data;\n\t\t/* copy tr over to seq ops */\n\t\tm->private = tr;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_pid_open(struct inode *inode, struct file *file)\n{\n\treturn pid_open(inode, file, TRACE_PIDS);\n}"
  },
  {
    "function_name": "pid_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7560-7598",
    "snippet": "static int pid_open(struct inode *inode, struct file *file, int type)\n{\n\tconst struct seq_operations *seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_pid_reset(tr, type);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tseq_ops = &ftrace_pid_sops;\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tseq_ops = &ftrace_no_pid_sops;\n\t\tbreak;\n\tdefault:\n\t\ttrace_array_put(tr);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t} else {\n\t\tm = file->private_data;\n\t\t/* copy tr over to seq ops */\n\t\tm->private = tr;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static const struct seq_operations ftrace_pid_sops = {\n\t.start = fpid_start,\n\t.next = fpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};",
      "static const struct seq_operations ftrace_no_pid_sops = {\n\t.start = fnpid_start,\n\t.next = fnpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 7590
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "seq_ops"
          ],
          "line": 7588
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 7584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_pid_reset",
          "args": [
            "tr",
            "type"
          ],
          "line": 7573
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pid_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7457-7466",
          "snippet": "static void ftrace_pid_reset(struct trace_array *tr, int type)\n{\n\tmutex_lock(&ftrace_lock);\n\tclear_ftrace_pids(tr, type);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_pid_reset(struct trace_array *tr, int type)\n{\n\tmutex_lock(&ftrace_lock);\n\tclear_ftrace_pids(tr, type);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_check_open_get_tr",
          "args": [
            "tr"
          ],
          "line": 7567
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_check_open_get_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "485-500",
          "snippet": "int tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nint tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic const struct seq_operations ftrace_pid_sops = {\n\t.start = fpid_start,\n\t.next = fpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};\nstatic const struct seq_operations ftrace_no_pid_sops = {\n\t.start = fnpid_start,\n\t.next = fnpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};\n\nstatic int pid_open(struct inode *inode, struct file *file, int type)\n{\n\tconst struct seq_operations *seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_pid_reset(tr, type);\n\n\tswitch (type) {\n\tcase TRACE_PIDS:\n\t\tseq_ops = &ftrace_pid_sops;\n\t\tbreak;\n\tcase TRACE_NO_PIDS:\n\t\tseq_ops = &ftrace_no_pid_sops;\n\t\tbreak;\n\tdefault:\n\t\ttrace_array_put(tr);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t} else {\n\t\tm = file->private_data;\n\t\t/* copy tr over to seq ops */\n\t\tm->private = tr;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fnpid_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7541-7551",
    "snippet": "static void *fnpid_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->function_no_pids);\n\n\tif (v == FTRACE_NO_PIDS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn trace_pid_next(pid_list, v, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_next",
          "args": [
            "pid_list",
            "v",
            "pos"
          ],
          "line": 7550
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "601-616",
          "snippet": "void *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tlong pid = (unsigned long)v;\n\tunsigned int next;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual previous bit */\n\tif (trace_pid_list_next(pid_list, pid, &next) < 0)\n\t\treturn NULL;\n\n\tpid = next;\n\n\t/* Return pid + 1 to allow zero to be represented */\n\treturn (void *)(pid + 1);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tlong pid = (unsigned long)v;\n\tunsigned int next;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual previous bit */\n\tif (trace_pid_list_next(pid_list, pid, &next) < 0)\n\t\treturn NULL;\n\n\tpid = next;\n\n\t/* Return pid + 1 to allow zero to be represented */\n\treturn (void *)(pid + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_no_pids"
          ],
          "line": 7544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic void *fnpid_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->function_no_pids);\n\n\tif (v == FTRACE_NO_PIDS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn trace_pid_next(pid_list, v, pos);\n}"
  },
  {
    "function_name": "fnpid_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7524-7539",
    "snippet": "static void *fnpid_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\tmutex_lock(&ftrace_lock);\n\trcu_read_lock_sched();\n\n\tpid_list = rcu_dereference_sched(tr->function_no_pids);\n\n\tif (!pid_list)\n\t\treturn !(*pos) ? FTRACE_NO_PIDS : NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_start",
          "args": [
            "pid_list",
            "pos"
          ],
          "line": 7538
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "629-645",
          "snippet": "void *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tunsigned int first;\n\tloff_t l = 0;\n\n\tif (trace_pid_list_first(pid_list, &first) < 0)\n\t\treturn NULL;\n\n\tpid = first;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tunsigned int first;\n\tloff_t l = 0;\n\n\tif (trace_pid_list_first(pid_list, &first) < 0)\n\t\treturn NULL;\n\n\tpid = first;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_no_pids"
          ],
          "line": 7533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 7531
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7530
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 7525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic void *fnpid_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\tmutex_lock(&ftrace_lock);\n\trcu_read_lock_sched();\n\n\tpid_list = rcu_dereference_sched(tr->function_no_pids);\n\n\tif (!pid_list)\n\t\treturn !(*pos) ? FTRACE_NO_PIDS : NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}"
  },
  {
    "function_name": "fpid_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7507-7515",
    "snippet": "static int fpid_show(struct seq_file *m, void *v)\n{\n\tif (v == FTRACE_NO_PIDS) {\n\t\tseq_puts(m, \"no pid\\n\");\n\t\treturn 0;\n\t}\n\n\treturn trace_pid_show(m, v);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_show",
          "args": [
            "m",
            "v"
          ],
          "line": 7514
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "655-661",
          "snippet": "int trace_pid_show(struct seq_file *m, void *v)\n{\n\tunsigned long pid = (unsigned long)v - 1;\n\n\tseq_printf(m, \"%lu\\n\", pid);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_pid_show(struct seq_file *m, void *v)\n{\n\tunsigned long pid = (unsigned long)v - 1;\n\n\tseq_printf(m, \"%lu\\n\", pid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"no pid\\n\""
          ],
          "line": 7510
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic int fpid_show(struct seq_file *m, void *v)\n{\n\tif (v == FTRACE_NO_PIDS) {\n\t\tseq_puts(m, \"no pid\\n\");\n\t\treturn 0;\n\t}\n\n\treturn trace_pid_show(m, v);\n}"
  },
  {
    "function_name": "fpid_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7500-7505",
    "snippet": "static void fpid_stop(struct seq_file *m, void *p)\n\t__releases(RCU)\n{\n\trcu_read_unlock_sched();\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7504
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 7503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 7501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void fpid_stop(struct seq_file *m, void *p)\n\t__releases(RCU)\n{\n\trcu_read_unlock_sched();\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "fpid_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7488-7498",
    "snippet": "static void *fpid_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->function_pids);\n\n\tif (v == FTRACE_NO_PIDS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn trace_pid_next(pid_list, v, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_next",
          "args": [
            "pid_list",
            "v",
            "pos"
          ],
          "line": 7497
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "601-616",
          "snippet": "void *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tlong pid = (unsigned long)v;\n\tunsigned int next;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual previous bit */\n\tif (trace_pid_list_next(pid_list, pid, &next) < 0)\n\t\treturn NULL;\n\n\tpid = next;\n\n\t/* Return pid + 1 to allow zero to be represented */\n\treturn (void *)(pid + 1);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tlong pid = (unsigned long)v;\n\tunsigned int next;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual previous bit */\n\tif (trace_pid_list_next(pid_list, pid, &next) < 0)\n\t\treturn NULL;\n\n\tpid = next;\n\n\t/* Return pid + 1 to allow zero to be represented */\n\treturn (void *)(pid + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 7491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic void *fpid_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->function_pids);\n\n\tif (v == FTRACE_NO_PIDS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn trace_pid_next(pid_list, v, pos);\n}"
  },
  {
    "function_name": "fpid_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7471-7486",
    "snippet": "static void *fpid_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\tmutex_lock(&ftrace_lock);\n\trcu_read_lock_sched();\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\n\tif (!pid_list)\n\t\treturn !(*pos) ? FTRACE_NO_PIDS : NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_start",
          "args": [
            "pid_list",
            "pos"
          ],
          "line": 7485
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "629-645",
          "snippet": "void *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tunsigned int first;\n\tloff_t l = 0;\n\n\tif (trace_pid_list_first(pid_list, &first) < 0)\n\t\treturn NULL;\n\n\tpid = first;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tunsigned int first;\n\tloff_t l = 0;\n\n\tif (trace_pid_list_first(pid_list, &first) < 0)\n\t\treturn NULL;\n\n\tpid = first;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 7480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 7478
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7477
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 7472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic void *fpid_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\tmutex_lock(&ftrace_lock);\n\trcu_read_lock_sched();\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\n\tif (!pid_list)\n\t\treturn !(*pos) ? FTRACE_NO_PIDS : NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}"
  },
  {
    "function_name": "ftrace_pid_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7457-7466",
    "snippet": "static void ftrace_pid_reset(struct trace_array *tr, int type)\n{\n\tmutex_lock(&ftrace_lock);\n\tclear_ftrace_pids(tr, type);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7465
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup_all",
          "args": [
            "0"
          ],
          "line": 7463
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7195-7195",
          "snippet": "static inline void ftrace_startup_all(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_all(int command) { }"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_update_pid_func",
          "args": [],
          "line": 7462
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_pid_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "360-377",
          "snippet": "static void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\n\nstatic void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_ftrace_pids",
          "args": [
            "tr",
            "type"
          ],
          "line": 7460
        },
        "resolved": true,
        "details": {
          "function_name": "clear_ftrace_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7410-7446",
          "snippet": "static void clear_ftrace_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\t/* See if the pids still need to be checked after this */\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ftrace_ignore_pid = FTRACE_PID_TRACE;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->function_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->function_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_rcu();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void clear_ftrace_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\t/* See if the pids still need to be checked after this */\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ftrace_ignore_pid = FTRACE_PID_TRACE;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->function_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->function_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_rcu();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7459
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_pid_reset(struct trace_array *tr, int type)\n{\n\tmutex_lock(&ftrace_lock);\n\tclear_ftrace_pids(tr, type);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "ftrace_clear_pids",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7448-7455",
    "snippet": "void ftrace_clear_pids(struct trace_array *tr)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tclear_ftrace_pids(tr, TRACE_PIDS | TRACE_NO_PIDS);\n\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7454
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_ftrace_pids",
          "args": [
            "tr",
            "TRACE_PIDS | TRACE_NO_PIDS"
          ],
          "line": 7452
        },
        "resolved": true,
        "details": {
          "function_name": "clear_ftrace_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7410-7446",
          "snippet": "static void clear_ftrace_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\t/* See if the pids still need to be checked after this */\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ftrace_ignore_pid = FTRACE_PID_TRACE;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->function_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->function_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_rcu();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void clear_ftrace_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\t/* See if the pids still need to be checked after this */\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ftrace_ignore_pid = FTRACE_PID_TRACE;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->function_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->function_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_rcu();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7450
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_clear_pids(struct trace_array *tr)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tclear_ftrace_pids(tr, TRACE_PIDS | TRACE_NO_PIDS);\n\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "clear_ftrace_pids",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7410-7446",
    "snippet": "static void clear_ftrace_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\t/* See if the pids still need to be checked after this */\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ftrace_ignore_pid = FTRACE_PID_TRACE;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->function_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->function_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_rcu();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_list_free",
          "args": [
            "no_pid_list"
          ],
          "line": 7445
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_list_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "457-495",
          "snippet": "void trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nvoid trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 7439
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->function_no_pids",
            "NULL"
          ],
          "line": 7436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->function_pids",
            "NULL"
          ],
          "line": 7433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "ftrace_filter_pid_sched_switch_probe",
            "tr"
          ],
          "line": 7427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "still_need_pid_events",
          "args": [
            "type",
            "pid_list",
            "no_pid_list"
          ],
          "line": 7426
        },
        "resolved": true,
        "details": {
          "function_name": "still_need_pid_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "221-230",
          "snippet": "static inline bool still_need_pid_events(int type, struct trace_pid_list *pid_list,\n\t\t\t\t\t struct trace_pid_list *no_pid_list)\n{\n\t/*\n\t * Turning off what is in @type, return true if the \"other\"\n\t * pid list, still has pids in it.\n\t */\n\treturn (!(type & TRACE_PIDS) && pid_list) ||\n\t\t(!(type & TRACE_NO_PIDS) && no_pid_list);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool still_need_pid_events(int type, struct trace_pid_list *pid_list,\n\t\t\t\t\t struct trace_pid_list *no_pid_list)\n{\n\t/*\n\t * Turning off what is in @type, return true if the \"other\"\n\t * pid list, still has pids in it.\n\t */\n\treturn (!(type & TRACE_PIDS) && pid_list) ||\n\t\t(!(type & TRACE_NO_PIDS) && no_pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_type_enabled",
          "args": [
            "type",
            "pid_list",
            "no_pid_list"
          ],
          "line": 7422
        },
        "resolved": true,
        "details": {
          "function_name": "pid_type_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "213-219",
          "snippet": "static inline bool pid_type_enabled(int type, struct trace_pid_list *pid_list,\n\t\t\t\t    struct trace_pid_list *no_pid_list)\n{\n\t/* Return true if the pid list in type has pids */\n\treturn ((type & TRACE_PIDS) && pid_list) ||\n\t\t((type & TRACE_NO_PIDS) && no_pid_list);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool pid_type_enabled(int type, struct trace_pid_list *pid_list,\n\t\t\t\t    struct trace_pid_list *no_pid_list)\n{\n\t/* Return true if the pid list in type has pids */\n\treturn ((type & TRACE_PIDS) && pid_list) ||\n\t\t((type & TRACE_NO_PIDS) && no_pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_no_pids",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 7418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7419
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_pids",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 7416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void clear_ftrace_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\t/* See if the pids still need to be checked after this */\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ftrace_ignore_pid = FTRACE_PID_TRACE;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->function_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->function_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_rcu();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}"
  },
  {
    "function_name": "ftrace_pid_follow_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7395-7408",
    "snippet": "void ftrace_pid_follow_fork(struct trace_array *tr, bool enable)\n{\n\tif (enable) {\n\t\tregister_trace_sched_process_fork(ftrace_pid_follow_sched_process_fork,\n\t\t\t\t\t\t  tr);\n\t\tregister_trace_sched_process_free(ftrace_pid_follow_sched_process_exit,\n\t\t\t\t\t\t  tr);\n\t} else {\n\t\tunregister_trace_sched_process_fork(ftrace_pid_follow_sched_process_fork,\n\t\t\t\t\t\t    tr);\n\t\tunregister_trace_sched_process_free(ftrace_pid_follow_sched_process_exit,\n\t\t\t\t\t\t    tr);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_process_free",
          "args": [
            "ftrace_pid_follow_sched_process_exit",
            "tr"
          ],
          "line": 7405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_process_fork",
          "args": [
            "ftrace_pid_follow_sched_process_fork",
            "tr"
          ],
          "line": 7403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_process_free",
          "args": [
            "ftrace_pid_follow_sched_process_exit",
            "tr"
          ],
          "line": 7400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_process_fork",
          "args": [
            "ftrace_pid_follow_sched_process_fork",
            "tr"
          ],
          "line": 7398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_pid_follow_fork(struct trace_array *tr, bool enable)\n{\n\tif (enable) {\n\t\tregister_trace_sched_process_fork(ftrace_pid_follow_sched_process_fork,\n\t\t\t\t\t\t  tr);\n\t\tregister_trace_sched_process_free(ftrace_pid_follow_sched_process_exit,\n\t\t\t\t\t\t  tr);\n\t} else {\n\t\tunregister_trace_sched_process_fork(ftrace_pid_follow_sched_process_fork,\n\t\t\t\t\t\t    tr);\n\t\tunregister_trace_sched_process_free(ftrace_pid_follow_sched_process_exit,\n\t\t\t\t\t\t    tr);\n\t}\n}"
  },
  {
    "function_name": "ftrace_pid_follow_sched_process_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7382-7393",
    "snippet": "static void\nftrace_pid_follow_sched_process_exit(void *data, struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n\n\tpid_list = rcu_dereference_sched(tr->function_no_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filter_add_remove_task",
          "args": [
            "pid_list",
            "NULL",
            "task"
          ],
          "line": 7392
        },
        "resolved": true,
        "details": {
          "function_name": "trace_filter_add_remove_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "569-587",
          "snippet": "void trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\ttrace_pid_list_set(pid_list, task->pid);\n\telse\n\t\ttrace_pid_list_clear(pid_list, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\ttrace_pid_list_set(pid_list, task->pid);\n\telse\n\t\ttrace_pid_list_clear(pid_list, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_no_pids"
          ],
          "line": 7391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 7388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nftrace_pid_follow_sched_process_exit(void *data, struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n\n\tpid_list = rcu_dereference_sched(tr->function_no_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n}"
  },
  {
    "function_name": "ftrace_pid_follow_sched_process_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7367-7380",
    "snippet": "static void\nftrace_pid_follow_sched_process_fork(void *data,\n\t\t\t\t     struct task_struct *self,\n\t\t\t\t     struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n\n\tpid_list = rcu_dereference_sched(tr->function_no_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filter_add_remove_task",
          "args": [
            "pid_list",
            "self",
            "task"
          ],
          "line": 7379
        },
        "resolved": true,
        "details": {
          "function_name": "trace_filter_add_remove_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "569-587",
          "snippet": "void trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\ttrace_pid_list_set(pid_list, task->pid);\n\telse\n\t\ttrace_pid_list_clear(pid_list, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\ttrace_pid_list_set(pid_list, task->pid);\n\telse\n\t\ttrace_pid_list_clear(pid_list, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_no_pids"
          ],
          "line": 7378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 7375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nftrace_pid_follow_sched_process_fork(void *data,\n\t\t\t\t     struct task_struct *self,\n\t\t\t\t     struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n\n\tpid_list = rcu_dereference_sched(tr->function_no_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n}"
  },
  {
    "function_name": "ftrace_filter_pid_sched_switch_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7348-7365",
    "snippet": "static void\nftrace_filter_pid_sched_switch_probe(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\tno_pid_list = rcu_dereference_sched(tr->function_no_pids);\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, next))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       next->pid);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ftrace_ignore_pid",
            "next->pid"
          ],
          "line": 7363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ftrace_ignore_pid",
            "FTRACE_PID_IGNORE"
          ],
          "line": 7360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "no_pid_list",
            "next"
          ],
          "line": 7359
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "538-555",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_no_pids"
          ],
          "line": 7357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 7356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nftrace_filter_pid_sched_switch_probe(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\tno_pid_list = rcu_dereference_sched(tr->function_no_pids);\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, next))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       next->pid);\n}"
  },
  {
    "function_name": "ftrace_ops_get_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7335-7346",
    "snippet": "ftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If the function does not handle recursion or needs to be RCU safe,\n\t * then we need to call the assist handler.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_RECURSION |\n\t\t\t  FTRACE_OPS_FL_RCU))\n\t\treturn ftrace_ops_assist_func;\n\n\treturn ops->func;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If the function does not handle recursion or needs to be RCU safe,\n\t * then we need to call the assist handler.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_RECURSION |\n\t\t\t  FTRACE_OPS_FL_RCU))\n\t\treturn ftrace_ops_assist_func;\n\n\treturn ops->func;\n}"
  },
  {
    "function_name": "ftrace_ops_assist_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7308-7321",
    "snippet": "static void ftrace_ops_assist_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tint bit;\n\n\tbit = trace_test_and_set_recursion(ip, parent_ip, TRACE_LIST_START);\n\tif (bit < 0)\n\t\treturn;\n\n\tif (!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching())\n\t\top->func(ip, parent_ip, op, fregs);\n\n\ttrace_clear_recursion(bit);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_clear_recursion",
          "args": [
            "bit"
          ],
          "line": 7320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->func",
          "args": [
            "ip",
            "parent_ip",
            "op",
            "fregs"
          ],
          "line": 7318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 7317
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_test_and_set_recursion",
          "args": [
            "ip",
            "parent_ip",
            "TRACE_LIST_START"
          ],
          "line": 7313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\n\nstatic void ftrace_ops_assist_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tint bit;\n\n\tbit = trace_test_and_set_recursion(ip, parent_ip, TRACE_LIST_START);\n\tif (bit < 0)\n\t\treturn;\n\n\tif (!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching())\n\t\top->func(ip, parent_ip, op, fregs);\n\n\ttrace_clear_recursion(bit);\n}"
  },
  {
    "function_name": "arch_ftrace_ops_list_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7296-7299",
    "snippet": "void arch_ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, NULL);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_ops_list_func",
          "args": [
            "ip",
            "parent_ip",
            "NULL",
            "NULL"
          ],
          "line": 7298
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_ops_list_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7230-7271",
          "snippet": "static nokprobe_inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\t/*\n\t * The ftrace_test_and_set_recursion() will disable preemption,\n\t * which is required since some of the ops may be dynamically\n\t * allocated, they must be freed after a synchronize_rcu().\n\t */\n\tbit = trace_test_and_set_recursion(ip, parent_ip, TRACE_LIST_START);\n\tif (bit < 0)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Stub functions don't need to be called nor tested */\n\t\tif (op->flags & FTRACE_OPS_FL_STUB)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, fregs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\ttrace_clear_recursion(bit);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic nokprobe_inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\t/*\n\t * The ftrace_test_and_set_recursion() will disable preemption,\n\t * which is required since some of the ops may be dynamically\n\t * allocated, they must be freed after a synchronize_rcu().\n\t */\n\tbit = trace_test_and_set_recursion(ip, parent_ip, TRACE_LIST_START);\n\tif (bit < 0)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Stub functions don't need to be called nor tested */\n\t\tif (op->flags & FTRACE_OPS_FL_STUB)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, fregs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\ttrace_clear_recursion(bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid arch_ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, NULL);\n}"
  },
  {
    "function_name": "arch_ftrace_ops_list_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7290-7294",
    "snippet": "void arch_ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, fregs);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_ops_list_func",
          "args": [
            "ip",
            "parent_ip",
            "NULL",
            "fregs"
          ],
          "line": 7293
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_ops_list_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7230-7271",
          "snippet": "static nokprobe_inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\t/*\n\t * The ftrace_test_and_set_recursion() will disable preemption,\n\t * which is required since some of the ops may be dynamically\n\t * allocated, they must be freed after a synchronize_rcu().\n\t */\n\tbit = trace_test_and_set_recursion(ip, parent_ip, TRACE_LIST_START);\n\tif (bit < 0)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Stub functions don't need to be called nor tested */\n\t\tif (op->flags & FTRACE_OPS_FL_STUB)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, fregs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\ttrace_clear_recursion(bit);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic nokprobe_inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\t/*\n\t * The ftrace_test_and_set_recursion() will disable preemption,\n\t * which is required since some of the ops may be dynamically\n\t * allocated, they must be freed after a synchronize_rcu().\n\t */\n\tbit = trace_test_and_set_recursion(ip, parent_ip, TRACE_LIST_START);\n\tif (bit < 0)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Stub functions don't need to be called nor tested */\n\t\tif (op->flags & FTRACE_OPS_FL_STUB)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, fregs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\ttrace_clear_recursion(bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\n\nvoid arch_ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, fregs);\n}"
  },
  {
    "function_name": "__ftrace_ops_list_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7230-7271",
    "snippet": "static nokprobe_inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\t/*\n\t * The ftrace_test_and_set_recursion() will disable preemption,\n\t * which is required since some of the ops may be dynamically\n\t * allocated, they must be freed after a synchronize_rcu().\n\t */\n\tbit = trace_test_and_set_recursion(ip, parent_ip, TRACE_LIST_START);\n\tif (bit < 0)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Stub functions don't need to be called nor tested */\n\t\tif (op->flags & FTRACE_OPS_FL_STUB)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, fregs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\ttrace_clear_recursion(bit);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_clear_recursion",
          "args": [
            "bit"
          ],
          "line": 7270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 7268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->func",
          "args": [
            "ip",
            "parent_ip",
            "op",
            "fregs"
          ],
          "line": 7266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"op=%p %pS\\n\"",
            "op",
            "op"
          ],
          "line": 7263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "!op->func"
          ],
          "line": 7262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_ops_test",
          "args": [
            "op",
            "ip",
            "regs"
          ],
          "line": 7261
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_test",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1471-1496",
          "snippet": "int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\tstruct ftrace_ops_hash hash;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * There's a small race when adding ops that the ftrace handler\n\t * that wants regs, may be called without them. We can not\n\t * allow that handler to be called if regs is NULL.\n\t */\n\tif (regs == NULL && (ops->flags & FTRACE_OPS_FL_SAVE_REGS))\n\t\treturn 0;\n#endif\n\n\trcu_assign_pointer(hash.filter_hash, ops->func_hash->filter_hash);\n\trcu_assign_pointer(hash.notrace_hash, ops->func_hash->notrace_hash);\n\n\tif (hash_contains_ip(ip, &hash))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\tstruct ftrace_ops_hash hash;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * There's a small race when adding ops that the ftrace handler\n\t * that wants regs, may be called without them. We can not\n\t * allow that handler to be called if regs is NULL.\n\t */\n\tif (regs == NULL && (ops->flags & FTRACE_OPS_FL_SAVE_REGS))\n\t\treturn 0;\n#endif\n\n\trcu_assign_pointer(hash.filter_hash, ops->func_hash->filter_hash);\n\trcu_assign_pointer(hash.notrace_hash, ops->func_hash->notrace_hash);\n\n\tif (hash_contains_ip(ip, &hash))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 7260
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 7247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_and_set_recursion",
          "args": [
            "ip",
            "parent_ip",
            "TRACE_LIST_START"
          ],
          "line": 7243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_get_regs",
          "args": [
            "fregs"
          ],
          "line": 7234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic nokprobe_inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\t/*\n\t * The ftrace_test_and_set_recursion() will disable preemption,\n\t * which is required since some of the ops may be dynamically\n\t * allocated, they must be freed after a synchronize_rcu().\n\t */\n\tbit = trace_test_and_set_recursion(ip, parent_ip, TRACE_LIST_START);\n\tif (bit < 0)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Stub functions don't need to be called nor tested */\n\t\tif (op->flags & FTRACE_OPS_FL_STUB)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, fregs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\ttrace_clear_recursion(bit);\n}"
  },
  {
    "function_name": "ftrace_reset_array_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7225-7228",
    "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
  },
  {
    "function_name": "ftrace_init_array_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7213-7223",
    "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ftrace ops had %pS for function\\n\"",
            "tr->ops->func"
          ],
          "line": 7218
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tr->ops->func != ftrace_stub"
          ],
          "line": 7217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
  },
  {
    "function_name": "ftrace_init_global_array_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7206-7211",
    "snippet": "__init void ftrace_init_global_array_ops(struct trace_array *tr)\n{\n\ttr->ops = &global_ops;\n\ttr->ops->private = tr;\n\tftrace_init_trace_array(tr);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_init_trace_array",
          "args": [
            "tr"
          ],
          "line": 7210
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7172-7177",
          "snippet": "void ftrace_init_trace_array(struct trace_array *tr)\n{\n\tINIT_LIST_HEAD(&tr->func_probes);\n\tINIT_LIST_HEAD(&tr->mod_trace);\n\tINIT_LIST_HEAD(&tr->mod_notrace);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_init_trace_array(struct trace_array *tr)\n{\n\tINIT_LIST_HEAD(&tr->func_probes);\n\tINIT_LIST_HEAD(&tr->mod_trace);\n\tINIT_LIST_HEAD(&tr->mod_notrace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\n__init void ftrace_init_global_array_ops(struct trace_array *tr)\n{\n\ttr->ops = &global_ops;\n\ttr->ops->private = tr;\n\tftrace_init_trace_array(tr);\n}"
  },
  {
    "function_name": "ftrace_update_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7200-7202",
    "snippet": "static void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
  },
  {
    "function_name": "ftrace_startup_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7195-7195",
    "snippet": "static inline void ftrace_startup_all(int command) { }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_all(int command) { }"
  },
  {
    "function_name": "ftrace_startup_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7194-7194",
    "snippet": "static inline void ftrace_startup_enable(int command) { }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_enable(int command) { }"
  },
  {
    "function_name": "ftrace_init_dyn_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7193-7193",
    "snippet": "static inline int ftrace_init_dyn_tracefs(struct dentry *d_tracer) { return 0; }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline int ftrace_init_dyn_tracefs(struct dentry *d_tracer) { return 0; }"
  },
  {
    "function_name": "ftrace_nodyn_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7186-7190",
    "snippet": "static int __init ftrace_nodyn_init(void)\n{\n\tftrace_enabled = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\n\nstatic int __init ftrace_nodyn_init(void)\n{\n\tftrace_enabled = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_init_trace_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7172-7177",
    "snippet": "void ftrace_init_trace_array(struct trace_array *tr)\n{\n\tINIT_LIST_HEAD(&tr->func_probes);\n\tINIT_LIST_HEAD(&tr->mod_trace);\n\tINIT_LIST_HEAD(&tr->mod_notrace);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr->mod_notrace"
          ],
          "line": 7176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr->mod_trace"
          ],
          "line": 7175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr->func_probes"
          ],
          "line": 7174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_init_trace_array(struct trace_array *tr)\n{\n\tINIT_LIST_HEAD(&tr->func_probes);\n\tINIT_LIST_HEAD(&tr->mod_trace);\n\tINIT_LIST_HEAD(&tr->mod_notrace);\n}"
  },
  {
    "function_name": "ftrace_update_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7150-7170",
    "snippet": "static void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n\tunsigned long trampoline = ops->trampoline;\n\n\tarch_ftrace_update_trampoline(ops);\n\tif (ops->trampoline && ops->trampoline != trampoline &&\n\t    (ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP)) {\n\t\t/* Add to kallsyms before the perf events */\n\t\tftrace_add_trampoline_to_kallsyms(ops);\n\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t   ops->trampoline, ops->trampoline_size, false,\n\t\t\t\t   FTRACE_TRAMPOLINE_SYM);\n\t\t/*\n\t\t * Record the perf text poke event after the ksymbol register\n\t\t * event.\n\t\t */\n\t\tperf_event_text_poke((void *)ops->trampoline, NULL, 0,\n\t\t\t\t     (void *)ops->trampoline,\n\t\t\t\t     ops->trampoline_size);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\""
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_text_poke",
          "args": [
            "(void *)ops->trampoline",
            "NULL",
            "0",
            "(void *)ops->trampoline",
            "ops->trampoline_size"
          ],
          "line": 7166
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "9050-9080",
          "snippet": "void perf_event_text_poke(const void *addr, const void *old_bytes,\n\t\t\t  size_t old_len, const void *new_bytes, size_t new_len)\n{\n\tstruct perf_text_poke_event text_poke_event;\n\tsize_t tot, pad;\n\n\tif (!atomic_read(&nr_text_poke_events))\n\t\treturn;\n\n\ttot  = sizeof(text_poke_event.old_len) + old_len;\n\ttot += sizeof(text_poke_event.new_len) + new_len;\n\tpad  = ALIGN(tot, sizeof(u64)) - tot;\n\n\ttext_poke_event = (struct perf_text_poke_event){\n\t\t.old_bytes    = old_bytes,\n\t\t.new_bytes    = new_bytes,\n\t\t.pad          = pad,\n\t\t.old_len      = old_len,\n\t\t.new_len      = new_len,\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_TEXT_POKE,\n\t\t\t\t.misc = PERF_RECORD_MISC_KERNEL,\n\t\t\t\t.size = sizeof(text_poke_event.event_id) + tot + pad,\n\t\t\t},\n\t\t\t.addr = (unsigned long)addr,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_text_poke_output, &text_poke_event, NULL);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_text_poke_events",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_text_poke_events;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_text_poke(const void *addr, const void *old_bytes,\n\t\t\t  size_t old_len, const void *new_bytes, size_t new_len)\n{\n\tstruct perf_text_poke_event text_poke_event;\n\tsize_t tot, pad;\n\n\tif (!atomic_read(&nr_text_poke_events))\n\t\treturn;\n\n\ttot  = sizeof(text_poke_event.old_len) + old_len;\n\ttot += sizeof(text_poke_event.new_len) + new_len;\n\tpad  = ALIGN(tot, sizeof(u64)) - tot;\n\n\ttext_poke_event = (struct perf_text_poke_event){\n\t\t.old_bytes    = old_bytes,\n\t\t.new_bytes    = new_bytes,\n\t\t.pad          = pad,\n\t\t.old_len      = old_len,\n\t\t.new_len      = new_len,\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_TEXT_POKE,\n\t\t\t\t.misc = PERF_RECORD_MISC_KERNEL,\n\t\t\t\t.size = sizeof(text_poke_event.event_id) + tot + pad,\n\t\t\t},\n\t\t\t.addr = (unsigned long)addr,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_text_poke_output, &text_poke_event, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_ksymbol",
          "args": [
            "PERF_RECORD_KSYMBOL_TYPE_OOL",
            "ops->trampoline",
            "ops->trampoline_size",
            "false",
            "FTRACE_TRAMPOLINE_SYM"
          ],
          "line": 7159
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_ksymbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8843-8887",
          "snippet": "void perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_ksymbol_events",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_ksymbol_events;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_add_trampoline_to_kallsyms",
          "args": [
            "ops"
          ],
          "line": 7158
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_add_trampoline_to_kallsyms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2831-2835",
          "snippet": "static void ftrace_add_trampoline_to_kallsyms(struct ftrace_ops *ops)\n{\n\tlockdep_assert_held(&ftrace_lock);\n\tlist_add_rcu(&ops->list, &ftrace_ops_trampoline_list);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_add_trampoline_to_kallsyms(struct ftrace_ops *ops)\n{\n\tlockdep_assert_held(&ftrace_lock);\n\tlist_add_rcu(&ops->list, &ftrace_ops_trampoline_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_ftrace_update_trampoline",
          "args": [
            "ops"
          ],
          "line": 7154
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_update_trampoline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7146-7148",
          "snippet": "void __weak arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __weak arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n\tunsigned long trampoline = ops->trampoline;\n\n\tarch_ftrace_update_trampoline(ops);\n\tif (ops->trampoline && ops->trampoline != trampoline &&\n\t    (ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP)) {\n\t\t/* Add to kallsyms before the perf events */\n\t\tftrace_add_trampoline_to_kallsyms(ops);\n\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t   ops->trampoline, ops->trampoline_size, false,\n\t\t\t\t   FTRACE_TRAMPOLINE_SYM);\n\t\t/*\n\t\t * Record the perf text poke event after the ksymbol register\n\t\t * event.\n\t\t */\n\t\tperf_event_text_poke((void *)ops->trampoline, NULL, 0,\n\t\t\t\t     (void *)ops->trampoline,\n\t\t\t\t     ops->trampoline_size);\n\t}\n}"
  },
  {
    "function_name": "arch_ftrace_update_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7146-7148",
    "snippet": "void __weak arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __weak arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
  },
  {
    "function_name": "ftrace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7107-7143",
    "snippet": "void __init ftrace_init(void)\n{\n\textern unsigned long __start_mcount_loc[];\n\textern unsigned long __stop_mcount_loc[];\n\tunsigned long count, flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = ftrace_dyn_arch_init();\n\tlocal_irq_restore(flags);\n\tif (ret)\n\t\tgoto failed;\n\n\tcount = __stop_mcount_loc - __start_mcount_loc;\n\tif (!count) {\n\t\tpr_info(\"ftrace: No functions to be traced?\\n\");\n\t\tgoto failed;\n\t}\n\n\tpr_info(\"ftrace: allocating %ld entries in %ld pages\\n\",\n\t\tcount, count / ENTRIES_PER_PAGE + 1);\n\n\tlast_ftrace_enabled = ftrace_enabled = 1;\n\n\tret = ftrace_process_locs(NULL,\n\t\t\t\t  __start_mcount_loc,\n\t\t\t\t  __stop_mcount_loc);\n\n\tpr_info(\"ftrace: allocated %ld pages with %ld groups\\n\",\n\t\tftrace_number_of_pages, ftrace_number_of_groups);\n\n\tset_ftrace_early_filters();\n\n\treturn;\n failed:\n\tftrace_disabled = 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)"
    ],
    "globals_used": [
      "int ftrace_enabled",
      "static int last_ftrace_enabled;",
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ftrace_early_filters",
          "args": [],
          "line": 7138
        },
        "resolved": true,
        "details": {
          "function_name": "set_ftrace_early_filters",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5825-5837",
          "snippet": "static void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops global_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops global_ops;\n\nstatic void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace: allocated %ld pages with %ld groups\\n\"",
            "ftrace_number_of_pages",
            "ftrace_number_of_groups"
          ],
          "line": 7135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_process_locs",
          "args": [
            "NULL",
            "__start_mcount_loc",
            "__stop_mcount_loc"
          ],
          "line": 7131
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_process_locs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6418-6526",
          "snippet": "static int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\t/*\n\t * Sorting mcount in vmlinux at build time depend on\n\t * CONFIG_BUILDTIME_MCOUNT_SORT, while mcount loc in\n\t * modules can not be sorted at build time.\n\t */\n\tif (!IS_ENABLED(CONFIG_BUILDTIME_MCOUNT_SORT) || mod) {\n\t\tsort(start, count, sizeof(*start),\n\t\t     ftrace_cmp_ips, NULL);\n\t} else {\n\t\ttest_is_sorted(start, count);\n\t}\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\tunsigned long end_offset;\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tend_offset = (pg->index+1) * sizeof(pg->records[0]);\n\t\tif (end_offset > PAGE_SIZE << pg->order) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\t/*\n\t * Sorting mcount in vmlinux at build time depend on\n\t * CONFIG_BUILDTIME_MCOUNT_SORT, while mcount loc in\n\t * modules can not be sorted at build time.\n\t */\n\tif (!IS_ENABLED(CONFIG_BUILDTIME_MCOUNT_SORT) || mod) {\n\t\tsort(start, count, sizeof(*start),\n\t\t     ftrace_cmp_ips, NULL);\n\t} else {\n\t\ttest_is_sorted(start, count);\n\t}\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\tunsigned long end_offset;\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tend_offset = (pg->index+1) * sizeof(pg->records[0]);\n\t\tif (end_offset > PAGE_SIZE << pg->order) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace: allocating %ld entries in %ld pages\\n\"",
            "count",
            "count / ENTRIES_PER_PAGE + 1"
          ],
          "line": 7126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace: No functions to be traced?\\n\""
          ],
          "line": 7122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 7116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_dyn_arch_init",
          "args": [],
          "line": 7115
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dyn_arch_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7102-7105",
          "snippet": "__weak ftrace_dyn_arch_init(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__weak ftrace_dyn_arch_init(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 7114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n\nint ftrace_enabled;\nstatic int last_ftrace_enabled;\nstatic int ftrace_disabled;\n\nvoid __init ftrace_init(void)\n{\n\textern unsigned long __start_mcount_loc[];\n\textern unsigned long __stop_mcount_loc[];\n\tunsigned long count, flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = ftrace_dyn_arch_init();\n\tlocal_irq_restore(flags);\n\tif (ret)\n\t\tgoto failed;\n\n\tcount = __stop_mcount_loc - __start_mcount_loc;\n\tif (!count) {\n\t\tpr_info(\"ftrace: No functions to be traced?\\n\");\n\t\tgoto failed;\n\t}\n\n\tpr_info(\"ftrace: allocating %ld entries in %ld pages\\n\",\n\t\tcount, count / ENTRIES_PER_PAGE + 1);\n\n\tlast_ftrace_enabled = ftrace_enabled = 1;\n\n\tret = ftrace_process_locs(NULL,\n\t\t\t\t  __start_mcount_loc,\n\t\t\t\t  __stop_mcount_loc);\n\n\tpr_info(\"ftrace: allocated %ld pages with %ld groups\\n\",\n\t\tftrace_number_of_pages, ftrace_number_of_groups);\n\n\tset_ftrace_early_filters();\n\n\treturn;\n failed:\n\tftrace_disabled = 1;\n}"
  },
  {
    "function_name": "ftrace_dyn_arch_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7102-7105",
    "snippet": "__weak ftrace_dyn_arch_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__weak ftrace_dyn_arch_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_free_init_mem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7094-7100",
    "snippet": "void __init ftrace_free_init_mem(void)\n{\n\tvoid *start = (void *)(&__init_begin);\n\tvoid *end = (void *)(&__init_end);\n\n\tftrace_free_mem(NULL, start, end);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_free_mem",
          "args": [
            "NULL",
            "start",
            "end"
          ],
          "line": 7099
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_free_mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7022-7092",
          "snippet": "void ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tstruct list_head clear_hash;\n\n\tINIT_LIST_HEAD(&clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\tif (pg->records) {\n\t\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t\t}\n\t\t\tftrace_number_of_groups--;\n\t\t\tkfree(pg);\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nvoid ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tstruct list_head clear_hash;\n\n\tINIT_LIST_HEAD(&clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\tif (pg->records) {\n\t\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t\t}\n\t\t\tftrace_number_of_groups--;\n\t\t\tkfree(pg);\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid __init ftrace_free_init_mem(void)\n{\n\tvoid *start = (void *)(&__init_begin);\n\tvoid *end = (void *)(&__init_end);\n\n\tftrace_free_mem(NULL, start, end);\n}"
  },
  {
    "function_name": "ftrace_free_mem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7022-7092",
    "snippet": "void ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tstruct list_head clear_hash;\n\n\tINIT_LIST_HEAD(&clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\tif (pg->records) {\n\t\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t\t}\n\t\t\tftrace_number_of_groups--;\n\t\t\tkfree(pg);\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops __rcu *ftrace_ops_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "func"
          ],
          "line": 7090
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_func_from_hashes",
          "args": [
            "func"
          ],
          "line": 7089
        },
        "resolved": true,
        "details": {
          "function_name": "clear_func_from_hashes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6990-7005",
          "snippet": "static void\nclear_func_from_hashes(struct ftrace_init_func *func)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->filter_hash);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void\nclear_func_from_hashes(struct ftrace_init_func *func)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->filter_hash);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "func",
            "func_next",
            "&clear_hash",
            "list"
          ],
          "line": 7088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7086
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "rec",
            "rec + 1",
            "(pg->index - (rec - pg->records)) * sizeof(*rec)"
          ],
          "line": 7081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "last_pg",
            "structftrace_page",
            "next"
          ],
          "line": 7076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)pg->records",
            "pg->order"
          ],
          "line": 7071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_ftrace_mod_rec",
          "args": [
            "mod_map",
            "rec"
          ],
          "line": 7064
        },
        "resolved": true,
        "details": {
          "function_name": "save_ftrace_mod_rec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6947-6948",
          "snippet": "static void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec) { }"
        }
      },
      {
        "call_info": {
          "callee": "add_to_clear_hash_list",
          "args": [
            "&clear_hash",
            "rec"
          ],
          "line": 7061
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_clear_hash_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7007-7020",
          "snippet": "static void add_to_clear_hash_list(struct list_head *clear_list,\n\t\t\t\t   struct dyn_ftrace *rec)\n{\n\tstruct ftrace_init_func *func;\n\n\tfunc = kmalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tMEM_FAIL(1, \"alloc failure, ftrace filter could be stale\\n\");\n\t\treturn;\n\t}\n\n\tfunc->ip = rec->ip;\n\tlist_add(&func->list, clear_list);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void add_to_clear_hash_list(struct list_head *clear_list,\n\t\t\t\t   struct dyn_ftrace *rec)\n{\n\tstruct ftrace_init_func *func;\n\n\tfunc = kmalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tMEM_FAIL(1, \"alloc failure, ftrace filter could be stale\\n\");\n\t\treturn;\n\t}\n\n\tfunc->ip = rec->ip;\n\tlist_add(&func->list, clear_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&key",
            "pg->records",
            "pg->index",
            "sizeof(struct dyn_ftrace)",
            "ftrace_cmp_recs"
          ],
          "line": 7054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_ftrace_mod_map",
          "args": [
            "mod",
            "start",
            "end"
          ],
          "line": 7047
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_ftrace_mod_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6949-6954",
          "snippet": "static inline struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7039
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clear_hash"
          ],
          "line": 7034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nvoid ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tstruct list_head clear_hash;\n\n\tINIT_LIST_HEAD(&clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\tif (pg->records) {\n\t\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t\t}\n\t\t\tftrace_number_of_groups--;\n\t\t\tkfree(pg);\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n}"
  },
  {
    "function_name": "add_to_clear_hash_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "7007-7020",
    "snippet": "static void add_to_clear_hash_list(struct list_head *clear_list,\n\t\t\t\t   struct dyn_ftrace *rec)\n{\n\tstruct ftrace_init_func *func;\n\n\tfunc = kmalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tMEM_FAIL(1, \"alloc failure, ftrace filter could be stale\\n\");\n\t\treturn;\n\t}\n\n\tfunc->ip = rec->ip;\n\tlist_add(&func->list, clear_list);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&func->list",
            "clear_list"
          ],
          "line": 7019
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MEM_FAIL",
          "args": [
            "1",
            "\"alloc failure, ftrace filter could be stale\\n\""
          ],
          "line": 7014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*func)",
            "GFP_KERNEL"
          ],
          "line": 7012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void add_to_clear_hash_list(struct list_head *clear_list,\n\t\t\t\t   struct dyn_ftrace *rec)\n{\n\tstruct ftrace_init_func *func;\n\n\tfunc = kmalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tMEM_FAIL(1, \"alloc failure, ftrace filter could be stale\\n\");\n\t\treturn;\n\t}\n\n\tfunc->ip = rec->ip;\n\tlist_add(&func->list, clear_list);\n}"
  },
  {
    "function_name": "clear_func_from_hashes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6990-7005",
    "snippet": "static void\nclear_func_from_hashes(struct ftrace_init_func *func)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->filter_hash);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 7004
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_func_from_hash",
          "args": [
            "func",
            "tr->ops->func_hash->notrace_hash"
          ],
          "line": 7001
        },
        "resolved": true,
        "details": {
          "function_name": "clear_func_from_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6975-6988",
          "snippet": "static void\nclear_func_from_hash(struct ftrace_init_func *func, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = ftrace_lookup_ip(hash, func->ip);\n\t/*\n\t * Do not allow this rec to match again.\n\t * Yeah, it may waste some memory, but will be removed\n\t * if/when the hash is modified again.\n\t */\n\tif (entry)\n\t\tentry->ip = 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nclear_func_from_hash(struct ftrace_init_func *func, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = ftrace_lookup_ip(hash, func->ip);\n\t/*\n\t * Do not allow this rec to match again.\n\t * Yeah, it may waste some memory, but will be removed\n\t * if/when the hash is modified again.\n\t */\n\tif (entry)\n\t\tentry->ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tr->ops->func_hash->regex_lock"
          ],
          "line": 6999
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 6996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void\nclear_func_from_hashes(struct ftrace_init_func *func)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->filter_hash);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}"
  },
  {
    "function_name": "clear_func_from_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6975-6988",
    "snippet": "static void\nclear_func_from_hash(struct ftrace_init_func *func, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = ftrace_lookup_ip(hash, func->ip);\n\t/*\n\t * Do not allow this rec to match again.\n\t * Yeah, it may waste some memory, but will be removed\n\t * if/when the hash is modified again.\n\t */\n\tif (entry)\n\t\tentry->ip = 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "hash",
            "func->ip"
          ],
          "line": 6980
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nclear_func_from_hash(struct ftrace_init_func *func, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = ftrace_lookup_ip(hash, func->ip);\n\t/*\n\t * Do not allow this rec to match again.\n\t * Yeah, it may waste some memory, but will be removed\n\t * if/when the hash is modified again.\n\t */\n\tif (entry)\n\t\tentry->ip = 0;\n}"
  },
  {
    "function_name": "ftrace_mod_get_kallsym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6955-6966",
    "snippet": "int ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name, char *module_name,\n\t\t\t   int *exported)\n{\n\tint ret;\n\n\tpreempt_disable();\n\tret = ftrace_get_trampoline_kallsym(symnum, value, type, name,\n\t\t\t\t\t    module_name, exported);\n\tpreempt_enable();\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 6964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_get_trampoline_kallsym",
          "args": [
            "symnum",
            "value",
            "type",
            "name",
            "module_name",
            "exported"
          ],
          "line": 6962
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_get_trampoline_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6545-6564",
          "snippet": "static int ftrace_get_trampoline_kallsym(unsigned int symnum,\n\t\t\t\t\t unsigned long *value, char *type,\n\t\t\t\t\t char *name, char *module_name,\n\t\t\t\t\t int *exported)\n{\n\tstruct ftrace_ops *op;\n\n\tlist_for_each_entry_rcu(op, &ftrace_ops_trampoline_list, list) {\n\t\tif (!op->trampoline || symnum--)\n\t\t\tcontinue;\n\t\t*value = op->trampoline;\n\t\t*type = 't';\n\t\tstrlcpy(name, FTRACE_TRAMPOLINE_SYM, KSYM_NAME_LEN);\n\t\tstrlcpy(module_name, FTRACE_TRAMPOLINE_MOD, MODULE_NAME_LEN);\n\t\t*exported = 0;\n\t\treturn 0;\n\t}\n\n\treturn -ERANGE;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"",
            "#define FTRACE_TRAMPOLINE_MOD \"__builtin__ftrace\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"\n#define FTRACE_TRAMPOLINE_MOD \"__builtin__ftrace\"\n\nstatic int ftrace_get_trampoline_kallsym(unsigned int symnum,\n\t\t\t\t\t unsigned long *value, char *type,\n\t\t\t\t\t char *name, char *module_name,\n\t\t\t\t\t int *exported)\n{\n\tstruct ftrace_ops *op;\n\n\tlist_for_each_entry_rcu(op, &ftrace_ops_trampoline_list, list) {\n\t\tif (!op->trampoline || symnum--)\n\t\t\tcontinue;\n\t\t*value = op->trampoline;\n\t\t*type = 't';\n\t\tstrlcpy(name, FTRACE_TRAMPOLINE_SYM, KSYM_NAME_LEN);\n\t\tstrlcpy(module_name, FTRACE_TRAMPOLINE_MOD, MODULE_NAME_LEN);\n\t\t*exported = 0;\n\t\treturn 0;\n\t}\n\n\treturn -ERANGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 6961
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name, char *module_name,\n\t\t\t   int *exported)\n{\n\tint ret;\n\n\tpreempt_disable();\n\tret = ftrace_get_trampoline_kallsym(symnum, value, type, name,\n\t\t\t\t\t    module_name, exported);\n\tpreempt_enable();\n\treturn ret;\n}"
  },
  {
    "function_name": "allocate_ftrace_mod_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6949-6954",
    "snippet": "static inline struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "save_ftrace_mod_rec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6947-6948",
    "snippet": "static void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec) { }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec) { }"
  },
  {
    "function_name": "ftrace_mod_get_kallsym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6907-6944",
    "snippet": "int ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name,\n\t\t\t   char *module_name, int *exported)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_func *mod_func;\n\tint ret;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\n\t\tif (symnum >= mod_map->num_funcs) {\n\t\t\tsymnum -= mod_map->num_funcs;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\t\tif (symnum > 1) {\n\t\t\t\tsymnum--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t*value = mod_func->ip;\n\t\t\t*type = 'T';\n\t\t\tstrlcpy(name, mod_func->name, KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = 1;\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tret = ftrace_get_trampoline_kallsym(symnum, value, type, name,\n\t\t\t\t\t    module_name, exported);\n\tpreempt_enable();\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 6942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_get_trampoline_kallsym",
          "args": [
            "symnum",
            "value",
            "type",
            "name",
            "module_name",
            "exported"
          ],
          "line": 6940
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_get_trampoline_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6545-6564",
          "snippet": "static int ftrace_get_trampoline_kallsym(unsigned int symnum,\n\t\t\t\t\t unsigned long *value, char *type,\n\t\t\t\t\t char *name, char *module_name,\n\t\t\t\t\t int *exported)\n{\n\tstruct ftrace_ops *op;\n\n\tlist_for_each_entry_rcu(op, &ftrace_ops_trampoline_list, list) {\n\t\tif (!op->trampoline || symnum--)\n\t\t\tcontinue;\n\t\t*value = op->trampoline;\n\t\t*type = 't';\n\t\tstrlcpy(name, FTRACE_TRAMPOLINE_SYM, KSYM_NAME_LEN);\n\t\tstrlcpy(module_name, FTRACE_TRAMPOLINE_MOD, MODULE_NAME_LEN);\n\t\t*exported = 0;\n\t\treturn 0;\n\t}\n\n\treturn -ERANGE;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"",
            "#define FTRACE_TRAMPOLINE_MOD \"__builtin__ftrace\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"\n#define FTRACE_TRAMPOLINE_MOD \"__builtin__ftrace\"\n\nstatic int ftrace_get_trampoline_kallsym(unsigned int symnum,\n\t\t\t\t\t unsigned long *value, char *type,\n\t\t\t\t\t char *name, char *module_name,\n\t\t\t\t\t int *exported)\n{\n\tstruct ftrace_ops *op;\n\n\tlist_for_each_entry_rcu(op, &ftrace_ops_trampoline_list, list) {\n\t\tif (!op->trampoline || symnum--)\n\t\t\tcontinue;\n\t\t*value = op->trampoline;\n\t\t*type = 't';\n\t\tstrlcpy(name, FTRACE_TRAMPOLINE_SYM, KSYM_NAME_LEN);\n\t\tstrlcpy(module_name, FTRACE_TRAMPOLINE_MOD, MODULE_NAME_LEN);\n\t\t*exported = 0;\n\t\treturn 0;\n\t}\n\n\treturn -ERANGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 6937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 6934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "module_name",
            "mod_map->mod->name",
            "MODULE_NAME_LEN"
          ],
          "line": 6932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "name",
            "mod_func->name",
            "KSYM_NAME_LEN"
          ],
          "line": 6931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "mod_func",
            "&mod_map->funcs",
            "list"
          ],
          "line": 6923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "mod_map",
            "&ftrace_mod_maps",
            "list"
          ],
          "line": 6916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 6915
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name,\n\t\t\t   char *module_name, int *exported)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_func *mod_func;\n\tint ret;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\n\t\tif (symnum >= mod_map->num_funcs) {\n\t\t\tsymnum -= mod_map->num_funcs;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\t\tif (symnum > 1) {\n\t\t\t\tsymnum--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t*value = mod_func->ip;\n\t\t\t*type = 'T';\n\t\t\tstrlcpy(name, mod_func->name, KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = 1;\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tret = ftrace_get_trampoline_kallsym(symnum, value, type, name,\n\t\t\t\t\t    module_name, exported);\n\tpreempt_enable();\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_mod_address_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6885-6905",
    "snippet": "const char *\nftrace_mod_address_lookup(unsigned long addr, unsigned long *size,\n\t\t   unsigned long *off, char **modname, char *sym)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tconst char *ret = NULL;\n\n\t/* mod_map is freed via call_rcu() */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\t\tret = ftrace_func_address_lookup(mod_map, addr, size, off, sym);\n\t\tif (ret) {\n\t\t\tif (modname)\n\t\t\t\t*modname = mod_map->mod->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 6902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_address_lookup",
          "args": [
            "mod_map",
            "addr",
            "size",
            "off",
            "sym"
          ],
          "line": 6895
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_address_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6855-6883",
          "snippet": "static const char *\nftrace_func_address_lookup(struct ftrace_mod_map *mod_map,\n\t\t\t   unsigned long addr, unsigned long *size,\n\t\t\t   unsigned long *off, char *sym)\n{\n\tstruct ftrace_mod_func *found_func =  NULL;\n\tstruct ftrace_mod_func *mod_func;\n\n\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\tif (addr >= mod_func->ip &&\n\t\t    addr < mod_func->ip + mod_func->size) {\n\t\t\tfound_func = mod_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_func) {\n\t\tif (size)\n\t\t\t*size = found_func->size;\n\t\tif (off)\n\t\t\t*off = addr - found_func->ip;\n\t\tif (sym)\n\t\t\tstrlcpy(sym, found_func->name, KSYM_NAME_LEN);\n\n\t\treturn found_func->name;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic const char *\nftrace_func_address_lookup(struct ftrace_mod_map *mod_map,\n\t\t\t   unsigned long addr, unsigned long *size,\n\t\t\t   unsigned long *off, char *sym)\n{\n\tstruct ftrace_mod_func *found_func =  NULL;\n\tstruct ftrace_mod_func *mod_func;\n\n\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\tif (addr >= mod_func->ip &&\n\t\t    addr < mod_func->ip + mod_func->size) {\n\t\t\tfound_func = mod_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_func) {\n\t\tif (size)\n\t\t\t*size = found_func->size;\n\t\tif (off)\n\t\t\t*off = addr - found_func->ip;\n\t\tif (sym)\n\t\t\tstrlcpy(sym, found_func->name, KSYM_NAME_LEN);\n\n\t\treturn found_func->name;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "mod_map",
            "&ftrace_mod_maps",
            "list"
          ],
          "line": 6894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 6893
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nconst char *\nftrace_mod_address_lookup(unsigned long addr, unsigned long *size,\n\t\t   unsigned long *off, char **modname, char *sym)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tconst char *ret = NULL;\n\n\t/* mod_map is freed via call_rcu() */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\t\tret = ftrace_func_address_lookup(mod_map, addr, size, off, sym);\n\t\tif (ret) {\n\t\t\tif (modname)\n\t\t\t\t*modname = mod_map->mod->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_func_address_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6855-6883",
    "snippet": "static const char *\nftrace_func_address_lookup(struct ftrace_mod_map *mod_map,\n\t\t\t   unsigned long addr, unsigned long *size,\n\t\t\t   unsigned long *off, char *sym)\n{\n\tstruct ftrace_mod_func *found_func =  NULL;\n\tstruct ftrace_mod_func *mod_func;\n\n\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\tif (addr >= mod_func->ip &&\n\t\t    addr < mod_func->ip + mod_func->size) {\n\t\t\tfound_func = mod_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_func) {\n\t\tif (size)\n\t\t\t*size = found_func->size;\n\t\tif (off)\n\t\t\t*off = addr - found_func->ip;\n\t\tif (sym)\n\t\t\tstrlcpy(sym, found_func->name, KSYM_NAME_LEN);\n\n\t\treturn found_func->name;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sym",
            "found_func->name",
            "KSYM_NAME_LEN"
          ],
          "line": 6877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "mod_func",
            "&mod_map->funcs",
            "list"
          ],
          "line": 6863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic const char *\nftrace_func_address_lookup(struct ftrace_mod_map *mod_map,\n\t\t\t   unsigned long addr, unsigned long *size,\n\t\t\t   unsigned long *off, char *sym)\n{\n\tstruct ftrace_mod_func *found_func =  NULL;\n\tstruct ftrace_mod_func *mod_func;\n\n\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\tif (addr >= mod_func->ip &&\n\t\t    addr < mod_func->ip + mod_func->size) {\n\t\t\tfound_func = mod_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_func) {\n\t\tif (size)\n\t\t\t*size = found_func->size;\n\t\tif (off)\n\t\t\t*off = addr - found_func->ip;\n\t\tif (sym)\n\t\t\tstrlcpy(sym, found_func->name, KSYM_NAME_LEN);\n\n\t\treturn found_func->name;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "allocate_ftrace_mod_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6833-6853",
    "snippet": "static struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tstruct ftrace_mod_map *mod_map;\n\n\tmod_map = kmalloc(sizeof(*mod_map), GFP_KERNEL);\n\tif (!mod_map)\n\t\treturn NULL;\n\n\tmod_map->mod = mod;\n\tmod_map->start_addr = start;\n\tmod_map->end_addr = end;\n\tmod_map->num_funcs = 0;\n\n\tINIT_LIST_HEAD_RCU(&mod_map->funcs);\n\n\tlist_add_rcu(&mod_map->list, &ftrace_mod_maps);\n\n\treturn mod_map;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&mod_map->list",
            "&ftrace_mod_maps"
          ],
          "line": 6850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD_RCU",
          "args": [
            "&mod_map->funcs"
          ],
          "line": 6848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*mod_map)",
            "GFP_KERNEL"
          ],
          "line": 6839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tstruct ftrace_mod_map *mod_map;\n\n\tmod_map = kmalloc(sizeof(*mod_map), GFP_KERNEL);\n\tif (!mod_map)\n\t\treturn NULL;\n\n\tmod_map->mod = mod;\n\tmod_map->start_addr = start;\n\tmod_map->end_addr = end;\n\tmod_map->num_funcs = 0;\n\n\tINIT_LIST_HEAD_RCU(&mod_map->funcs);\n\n\tlist_add_rcu(&mod_map->list, &ftrace_mod_maps);\n\n\treturn mod_map;\n}"
  },
  {
    "function_name": "save_ftrace_mod_rec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6801-6831",
    "snippet": "static void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tstruct ftrace_mod_func *mod_func;\n\tunsigned long symsize;\n\tunsigned long offset;\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\tconst char *ret;\n\n\tret = kallsyms_lookup(rec->ip, &symsize, &offset, &modname, str);\n\tif (!ret)\n\t\treturn;\n\n\tmod_func = kmalloc(sizeof(*mod_func), GFP_KERNEL);\n\tif (!mod_func)\n\t\treturn;\n\n\tmod_func->name = kstrdup(str, GFP_KERNEL);\n\tif (!mod_func->name) {\n\t\tkfree(mod_func);\n\t\treturn;\n\t}\n\n\tmod_func->ip = rec->ip - offset;\n\tmod_func->size = symsize;\n\n\tmod_map->num_funcs++;\n\n\tlist_add_rcu(&mod_func->list, &mod_map->funcs);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&mod_func->list",
            "&mod_map->funcs"
          ],
          "line": 6830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mod_func"
          ],
          "line": 6821
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 6819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*mod_func)",
            "GFP_KERNEL"
          ],
          "line": 6815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "rec->ip",
            "&symsize",
            "&offset",
            "&modname",
            "str"
          ],
          "line": 6811
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tstruct ftrace_mod_func *mod_func;\n\tunsigned long symsize;\n\tunsigned long offset;\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\tconst char *ret;\n\n\tret = kallsyms_lookup(rec->ip, &symsize, &offset, &modname, str);\n\tif (!ret)\n\t\treturn;\n\n\tmod_func = kmalloc(sizeof(*mod_func), GFP_KERNEL);\n\tif (!mod_func)\n\t\treturn;\n\n\tmod_func->name = kstrdup(str, GFP_KERNEL);\n\tif (!mod_func->name) {\n\t\tkfree(mod_func);\n\t\treturn;\n\t}\n\n\tmod_func->ip = rec->ip - offset;\n\tmod_func->size = symsize;\n\n\tmod_map->num_funcs++;\n\n\tlist_add_rcu(&mod_func->list, &mod_map->funcs);\n}"
  },
  {
    "function_name": "ftrace_module_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6792-6799",
    "snippet": "void ftrace_module_init(struct module *mod)\n{\n\tif (ftrace_disabled || !mod->num_ftrace_callsites)\n\t\treturn;\n\n\tftrace_process_locs(mod, mod->ftrace_callsites,\n\t\t\t    mod->ftrace_callsites + mod->num_ftrace_callsites);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_process_locs",
          "args": [
            "mod",
            "mod->ftrace_callsites",
            "mod->ftrace_callsites + mod->num_ftrace_callsites"
          ],
          "line": 6797
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_process_locs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6418-6526",
          "snippet": "static int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\t/*\n\t * Sorting mcount in vmlinux at build time depend on\n\t * CONFIG_BUILDTIME_MCOUNT_SORT, while mcount loc in\n\t * modules can not be sorted at build time.\n\t */\n\tif (!IS_ENABLED(CONFIG_BUILDTIME_MCOUNT_SORT) || mod) {\n\t\tsort(start, count, sizeof(*start),\n\t\t     ftrace_cmp_ips, NULL);\n\t} else {\n\t\ttest_is_sorted(start, count);\n\t}\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\tunsigned long end_offset;\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tend_offset = (pg->index+1) * sizeof(pg->records[0]);\n\t\tif (end_offset > PAGE_SIZE << pg->order) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\t/*\n\t * Sorting mcount in vmlinux at build time depend on\n\t * CONFIG_BUILDTIME_MCOUNT_SORT, while mcount loc in\n\t * modules can not be sorted at build time.\n\t */\n\tif (!IS_ENABLED(CONFIG_BUILDTIME_MCOUNT_SORT) || mod) {\n\t\tsort(start, count, sizeof(*start),\n\t\t     ftrace_cmp_ips, NULL);\n\t} else {\n\t\ttest_is_sorted(start, count);\n\t}\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\tunsigned long end_offset;\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tend_offset = (pg->index+1) * sizeof(pg->records[0]);\n\t\tif (end_offset > PAGE_SIZE << pg->order) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nvoid ftrace_module_init(struct module *mod)\n{\n\tif (ftrace_disabled || !mod->num_ftrace_callsites)\n\t\treturn;\n\n\tftrace_process_locs(mod, mod->ftrace_callsites,\n\t\t\t    mod->ftrace_callsites + mod->num_ftrace_callsites);\n}"
  },
  {
    "function_name": "ftrace_module_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6720-6790",
    "snippet": "void ftrace_module_enable(struct module *mod)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the tracing is enabled, go ahead and enable the record.\n\t *\n\t * The reason not to enable the record immediately is the\n\t * inherent check of ftrace_make_nop/ftrace_make_call for\n\t * correct previous instructions.  Making first the NOP\n\t * conversion puts the module to the correct state, thus\n\t * passing the ftrace_make_call check.\n\t *\n\t * We also delay this to after the module code already set the\n\t * text to read-only, as we now need to set it back to read-write\n\t * so that we can modify the text.\n\t */\n\tif (ftrace_start_up)\n\t\tftrace_arch_code_modify_prepare();\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint cnt;\n\t\t/*\n\t\t * do_for_each_ftrace_rec() is a double loop.\n\t\t * module text shares the pg. If a record is\n\t\t * not part of this module, then skip this pg,\n\t\t * which the \"break\" will do.\n\t\t */\n\t\tif (!within_module_core(rec->ip, mod) &&\n\t\t    !within_module_init(rec->ip, mod))\n\t\t\tbreak;\n\n\t\tcnt = 0;\n\n\t\t/*\n\t\t * When adding a module, we need to check if tracers are\n\t\t * currently enabled and if they are, and can trace this record,\n\t\t * we need to enable the module functions as well as update the\n\t\t * reference counts for those function records.\n\t\t */\n\t\tif (ftrace_start_up)\n\t\t\tcnt += referenced_filters(rec);\n\n\t\trec->flags &= ~FTRACE_FL_DISABLED;\n\t\trec->flags += cnt;\n\n\t\tif (ftrace_start_up && cnt) {\n\t\t\tint failed = __ftrace_replace_code(rec, 1);\n\t\t\tif (failed) {\n\t\t\t\tftrace_bug(failed, rec);\n\t\t\t\tgoto out_loop;\n\t\t\t}\n\t\t}\n\n\t} while_for_each_ftrace_rec();\n\n out_loop:\n\tif (ftrace_start_up)\n\t\tftrace_arch_code_modify_post_process();\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tprocess_cached_mods(mod->name);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_cached_mods",
          "args": [
            "mod->name"
          ],
          "line": 6789
        },
        "resolved": true,
        "details": {
          "function_name": "process_cached_mods",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4277-4296",
          "snippet": "static void process_cached_mods(const char *mod_name)\n{\n\tstruct trace_array *tr;\n\tchar *mod;\n\n\tmod = kstrdup(mod_name, GFP_KERNEL);\n\tif (!mod)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!list_empty(&tr->mod_trace))\n\t\t\tprocess_mod_list(&tr->mod_trace, tr->ops, mod, true);\n\t\tif (!list_empty(&tr->mod_notrace))\n\t\t\tprocess_mod_list(&tr->mod_notrace, tr->ops, mod, false);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\tkfree(mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void process_cached_mods(const char *mod_name)\n{\n\tstruct trace_array *tr;\n\tchar *mod;\n\n\tmod = kstrdup(mod_name, GFP_KERNEL);\n\tif (!mod)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!list_empty(&tr->mod_trace))\n\t\t\tprocess_mod_list(&tr->mod_trace, tr->ops, mod, true);\n\t\tif (!list_empty(&tr->mod_notrace))\n\t\t\tprocess_mod_list(&tr->mod_notrace, tr->ops, mod, false);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\tkfree(mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6787
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_arch_code_modify_post_process",
          "args": [],
          "line": 6784
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_arch_code_modify_post_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2702-2705",
          "snippet": "int __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 6780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_bug",
          "args": [
            "failed",
            "rec"
          ],
          "line": 6775
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2015-2069",
          "snippet": "void ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tpr_info(\"------------[ ftrace bug ]------------\\n\");\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n\n\tFTRACE_WARN_ON_ONCE(1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tpr_info(\"------------[ ftrace bug ]------------\\n\");\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n\n\tFTRACE_WARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_replace_code",
          "args": [
            "rec",
            "1"
          ],
          "line": 6773
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_replace_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2537-2571",
          "snippet": "static int\n__ftrace_replace_code(struct dyn_ftrace *rec, bool enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknown ftrace bug */\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\n__ftrace_replace_code(struct dyn_ftrace *rec, bool enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknown ftrace bug */\n}"
        }
      },
      {
        "call_info": {
          "callee": "referenced_filters",
          "args": [
            "rec"
          ],
          "line": 6767
        },
        "resolved": true,
        "details": {
          "function_name": "referenced_filters",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6572-6594",
          "snippet": "static int referenced_filters(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tint cnt = 0;\n\n\tfor (ops = ftrace_ops_list; ops != &ftrace_list_end; ops = ops->next) {\n\t\tif (ops_references_rec(ops, rec)) {\n\t\t\tif (WARN_ON_ONCE(ops->flags & FTRACE_OPS_FL_DIRECT))\n\t\t\t\tcontinue;\n\t\t\tif (WARN_ON_ONCE(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\t\t\tcontinue;\n\t\t\tcnt++;\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t\tif (cnt == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\t\t}\n\t}\n\n\treturn cnt;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int referenced_filters(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tint cnt = 0;\n\n\tfor (ops = ftrace_ops_list; ops != &ftrace_list_end; ops = ops->next) {\n\t\tif (ops_references_rec(ops, rec)) {\n\t\t\tif (WARN_ON_ONCE(ops->flags & FTRACE_OPS_FL_DIRECT))\n\t\t\t\tcontinue;\n\t\t\tif (WARN_ON_ONCE(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\t\t\tcontinue;\n\t\t\tcnt++;\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t\tif (cnt == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\t\t}\n\t}\n\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "rec->ip",
            "mod"
          ],
          "line": 6755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_core",
          "args": [
            "rec->ip",
            "mod"
          ],
          "line": 6754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 6746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_arch_code_modify_prepare",
          "args": [],
          "line": 6744
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_arch_code_modify_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2693-2696",
          "snippet": "int __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6725
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nvoid ftrace_module_enable(struct module *mod)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the tracing is enabled, go ahead and enable the record.\n\t *\n\t * The reason not to enable the record immediately is the\n\t * inherent check of ftrace_make_nop/ftrace_make_call for\n\t * correct previous instructions.  Making first the NOP\n\t * conversion puts the module to the correct state, thus\n\t * passing the ftrace_make_call check.\n\t *\n\t * We also delay this to after the module code already set the\n\t * text to read-only, as we now need to set it back to read-write\n\t * so that we can modify the text.\n\t */\n\tif (ftrace_start_up)\n\t\tftrace_arch_code_modify_prepare();\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint cnt;\n\t\t/*\n\t\t * do_for_each_ftrace_rec() is a double loop.\n\t\t * module text shares the pg. If a record is\n\t\t * not part of this module, then skip this pg,\n\t\t * which the \"break\" will do.\n\t\t */\n\t\tif (!within_module_core(rec->ip, mod) &&\n\t\t    !within_module_init(rec->ip, mod))\n\t\t\tbreak;\n\n\t\tcnt = 0;\n\n\t\t/*\n\t\t * When adding a module, we need to check if tracers are\n\t\t * currently enabled and if they are, and can trace this record,\n\t\t * we need to enable the module functions as well as update the\n\t\t * reference counts for those function records.\n\t\t */\n\t\tif (ftrace_start_up)\n\t\t\tcnt += referenced_filters(rec);\n\n\t\trec->flags &= ~FTRACE_FL_DISABLED;\n\t\trec->flags += cnt;\n\n\t\tif (ftrace_start_up && cnt) {\n\t\t\tint failed = __ftrace_replace_code(rec, 1);\n\t\t\tif (failed) {\n\t\t\t\tftrace_bug(failed, rec);\n\t\t\t\tgoto out_loop;\n\t\t\t}\n\t\t}\n\n\t} while_for_each_ftrace_rec();\n\n out_loop:\n\tif (ftrace_start_up)\n\t\tftrace_arch_code_modify_post_process();\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tprocess_cached_mods(mod->name);\n}"
  },
  {
    "function_name": "ftrace_release_mod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6652-6718",
    "snippet": "void ftrace_release_mod(struct module *mod)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_map *n;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page **last_pg;\n\tstruct ftrace_page *tmp_page = NULL;\n\tstruct ftrace_page *pg;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {\n\t\tif (mod_map->mod == mod) {\n\t\t\tlist_del_rcu(&mod_map->list);\n\t\t\tcall_rcu(&mod_map->rcu, ftrace_free_mod_map);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Each module has its own ftrace_pages, remove\n\t * them from the list.\n\t */\n\tlast_pg = &ftrace_pages_start;\n\tfor (pg = ftrace_pages_start; pg; pg = *last_pg) {\n\t\trec = &pg->records[0];\n\t\tif (within_module_core(rec->ip, mod) ||\n\t\t    within_module_init(rec->ip, mod)) {\n\t\t\t/*\n\t\t\t * As core pages are first, the first\n\t\t\t * page should never be a module page.\n\t\t\t */\n\t\t\tif (WARN_ON(pg == ftrace_pages_start))\n\t\t\t\tgoto out_unlock;\n\n\t\t\t/* Check if we are deleting the last page */\n\t\t\tif (pg == ftrace_pages)\n\t\t\t\tftrace_pages = next_to_ftrace_page(last_pg);\n\n\t\t\tftrace_update_tot_cnt -= pg->index;\n\t\t\t*last_pg = pg->next;\n\n\t\t\tpg->next = tmp_page;\n\t\t\ttmp_page = pg;\n\t\t} else\n\t\t\tlast_pg = &pg->next;\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tfor (pg = tmp_page; pg; pg = tmp_page) {\n\n\t\t/* Needs to be called outside of ftrace_lock */\n\t\tclear_mod_from_hashes(pg);\n\n\t\tif (pg->records) {\n\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t}\n\t\ttmp_page = pg->next;\n\t\tkfree(pg);\n\t\tftrace_number_of_groups--;\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pg"
          ],
          "line": 6715
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)pg->records",
            "pg->order"
          ],
          "line": 6711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_mod_from_hashes",
          "args": [
            "pg"
          ],
          "line": 6708
        },
        "resolved": true,
        "details": {
          "function_name": "clear_mod_from_hashes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6620-6634",
          "snippet": "static void clear_mod_from_hashes(struct ftrace_page *pg)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->filter_hash);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void clear_mod_from_hashes(struct ftrace_page *pg)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->filter_hash);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6703
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_to_ftrace_page",
          "args": [
            "last_pg"
          ],
          "line": 6692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pg == ftrace_pages_start"
          ],
          "line": 6687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "rec->ip",
            "mod"
          ],
          "line": 6682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_core",
          "args": [
            "rec->ip",
            "mod"
          ],
          "line": 6681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&mod_map->rcu",
            "ftrace_free_mod_map"
          ],
          "line": 6669
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&mod_map->list"
          ],
          "line": 6668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mod_map",
            "n",
            "&ftrace_mod_maps",
            "list"
          ],
          "line": 6666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6661
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nvoid ftrace_release_mod(struct module *mod)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_map *n;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page **last_pg;\n\tstruct ftrace_page *tmp_page = NULL;\n\tstruct ftrace_page *pg;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {\n\t\tif (mod_map->mod == mod) {\n\t\t\tlist_del_rcu(&mod_map->list);\n\t\t\tcall_rcu(&mod_map->rcu, ftrace_free_mod_map);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Each module has its own ftrace_pages, remove\n\t * them from the list.\n\t */\n\tlast_pg = &ftrace_pages_start;\n\tfor (pg = ftrace_pages_start; pg; pg = *last_pg) {\n\t\trec = &pg->records[0];\n\t\tif (within_module_core(rec->ip, mod) ||\n\t\t    within_module_init(rec->ip, mod)) {\n\t\t\t/*\n\t\t\t * As core pages are first, the first\n\t\t\t * page should never be a module page.\n\t\t\t */\n\t\t\tif (WARN_ON(pg == ftrace_pages_start))\n\t\t\t\tgoto out_unlock;\n\n\t\t\t/* Check if we are deleting the last page */\n\t\t\tif (pg == ftrace_pages)\n\t\t\t\tftrace_pages = next_to_ftrace_page(last_pg);\n\n\t\t\tftrace_update_tot_cnt -= pg->index;\n\t\t\t*last_pg = pg->next;\n\n\t\t\tpg->next = tmp_page;\n\t\t\ttmp_page = pg;\n\t\t} else\n\t\t\tlast_pg = &pg->next;\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tfor (pg = tmp_page; pg; pg = tmp_page) {\n\n\t\t/* Needs to be called outside of ftrace_lock */\n\t\tclear_mod_from_hashes(pg);\n\n\t\tif (pg->records) {\n\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t}\n\t\ttmp_page = pg->next;\n\t\tkfree(pg);\n\t\tftrace_number_of_groups--;\n\t}\n}"
  },
  {
    "function_name": "ftrace_free_mod_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6636-6650",
    "snippet": "static void ftrace_free_mod_map(struct rcu_head *rcu)\n{\n\tstruct ftrace_mod_map *mod_map = container_of(rcu, struct ftrace_mod_map, rcu);\n\tstruct ftrace_mod_func *mod_func;\n\tstruct ftrace_mod_func *n;\n\n\t/* All the contents of mod_map are now not visible to readers */\n\tlist_for_each_entry_safe(mod_func, n, &mod_map->funcs, list) {\n\t\tkfree(mod_func->name);\n\t\tlist_del(&mod_func->list);\n\t\tkfree(mod_func);\n\t}\n\n\tkfree(mod_map);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mod_map"
          ],
          "line": 6649
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mod_func->list"
          ],
          "line": 6645
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mod_func",
            "n",
            "&mod_map->funcs",
            "list"
          ],
          "line": 6643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structftrace_mod_map",
            "rcu"
          ],
          "line": 6638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_free_mod_map(struct rcu_head *rcu)\n{\n\tstruct ftrace_mod_map *mod_map = container_of(rcu, struct ftrace_mod_map, rcu);\n\tstruct ftrace_mod_func *mod_func;\n\tstruct ftrace_mod_func *n;\n\n\t/* All the contents of mod_map are now not visible to readers */\n\tlist_for_each_entry_safe(mod_func, n, &mod_map->funcs, list) {\n\t\tkfree(mod_func->name);\n\t\tlist_del(&mod_func->list);\n\t\tkfree(mod_func);\n\t}\n\n\tkfree(mod_map);\n}"
  },
  {
    "function_name": "clear_mod_from_hashes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6620-6634",
    "snippet": "static void clear_mod_from_hashes(struct ftrace_page *pg)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->filter_hash);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 6633
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_mod_from_hash",
          "args": [
            "pg",
            "tr->ops->func_hash->notrace_hash"
          ],
          "line": 6630
        },
        "resolved": true,
        "details": {
          "function_name": "clear_mod_from_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6596-6617",
          "snippet": "static void\nclear_mod_from_hash(struct ftrace_page *pg, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint i;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tfor (i = 0; i < pg->index; i++) {\n\t\trec = &pg->records[i];\n\t\tentry = __ftrace_lookup_ip(hash, rec->ip);\n\t\t/*\n\t\t * Do not allow this rec to match again.\n\t\t * Yeah, it may waste some memory, but will be removed\n\t\t * if/when the hash is modified again.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->ip = 0;\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nclear_mod_from_hash(struct ftrace_page *pg, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint i;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tfor (i = 0; i < pg->index; i++) {\n\t\trec = &pg->records[i];\n\t\tentry = __ftrace_lookup_ip(hash, rec->ip);\n\t\t/*\n\t\t * Do not allow this rec to match again.\n\t\t * Yeah, it may waste some memory, but will be removed\n\t\t * if/when the hash is modified again.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->ip = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tr->ops->func_hash->regex_lock"
          ],
          "line": 6628
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 6625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void clear_mod_from_hashes(struct ftrace_page *pg)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->filter_hash);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}"
  },
  {
    "function_name": "clear_mod_from_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6596-6617",
    "snippet": "static void\nclear_mod_from_hash(struct ftrace_page *pg, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint i;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tfor (i = 0; i < pg->index; i++) {\n\t\trec = &pg->records[i];\n\t\tentry = __ftrace_lookup_ip(hash, rec->ip);\n\t\t/*\n\t\t * Do not allow this rec to match again.\n\t\t * Yeah, it may waste some memory, but will be removed\n\t\t * if/when the hash is modified again.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->ip = 0;\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 6608
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1108-1123",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 6603
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nclear_mod_from_hash(struct ftrace_page *pg, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint i;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tfor (i = 0; i < pg->index; i++) {\n\t\trec = &pg->records[i];\n\t\tentry = __ftrace_lookup_ip(hash, rec->ip);\n\t\t/*\n\t\t * Do not allow this rec to match again.\n\t\t * Yeah, it may waste some memory, but will be removed\n\t\t * if/when the hash is modified again.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->ip = 0;\n\t}\n}"
  },
  {
    "function_name": "referenced_filters",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6572-6594",
    "snippet": "static int referenced_filters(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tint cnt = 0;\n\n\tfor (ops = ftrace_ops_list; ops != &ftrace_list_end; ops = ops->next) {\n\t\tif (ops_references_rec(ops, rec)) {\n\t\t\tif (WARN_ON_ONCE(ops->flags & FTRACE_OPS_FL_DIRECT))\n\t\t\t\tcontinue;\n\t\t\tif (WARN_ON_ONCE(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\t\t\tcontinue;\n\t\t\tcnt++;\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t\tif (cnt == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\t\t}\n\t}\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ops->flags & FTRACE_OPS_FL_IPMODIFY"
          ],
          "line": 6581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ops->flags & FTRACE_OPS_FL_DIRECT"
          ],
          "line": 6579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops_references_rec",
          "args": [
            "ops",
            "rec"
          ],
          "line": 6578
        },
        "resolved": true,
        "details": {
          "function_name": "ops_references_rec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3107-3128",
          "snippet": "static inline bool\nops_references_rec(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\t/* If ops isn't enabled, ignore it */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/* If ops traces all then it includes this function */\n\tif (ops_traces_mod(ops))\n\t\treturn true;\n\n\t/* The function must be in the filter */\n\tif (!ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t    !__ftrace_lookup_ip(ops->func_hash->filter_hash, rec->ip))\n\t\treturn false;\n\n\t/* If in notrace hash, we ignore it too */\n\tif (ftrace_lookup_ip(ops->func_hash->notrace_hash, rec->ip))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline bool\nops_references_rec(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\t/* If ops isn't enabled, ignore it */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/* If ops traces all then it includes this function */\n\tif (ops_traces_mod(ops))\n\t\treturn true;\n\n\t/* The function must be in the filter */\n\tif (!ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t    !__ftrace_lookup_ip(ops->func_hash->filter_hash, rec->ip))\n\t\treturn false;\n\n\t/* If in notrace hash, we ignore it too */\n\tif (ftrace_lookup_ip(ops->func_hash->notrace_hash, rec->ip))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int referenced_filters(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tint cnt = 0;\n\n\tfor (ops = ftrace_ops_list; ops != &ftrace_list_end; ops = ops->next) {\n\t\tif (ops_references_rec(ops, rec)) {\n\t\t\tif (WARN_ON_ONCE(ops->flags & FTRACE_OPS_FL_DIRECT))\n\t\t\t\tcontinue;\n\t\t\tif (WARN_ON_ONCE(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\t\t\tcontinue;\n\t\t\tcnt++;\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t\tif (cnt == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\t\t}\n\t}\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "ftrace_get_trampoline_kallsym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6545-6564",
    "snippet": "static int ftrace_get_trampoline_kallsym(unsigned int symnum,\n\t\t\t\t\t unsigned long *value, char *type,\n\t\t\t\t\t char *name, char *module_name,\n\t\t\t\t\t int *exported)\n{\n\tstruct ftrace_ops *op;\n\n\tlist_for_each_entry_rcu(op, &ftrace_ops_trampoline_list, list) {\n\t\tif (!op->trampoline || symnum--)\n\t\t\tcontinue;\n\t\t*value = op->trampoline;\n\t\t*type = 't';\n\t\tstrlcpy(name, FTRACE_TRAMPOLINE_SYM, KSYM_NAME_LEN);\n\t\tstrlcpy(module_name, FTRACE_TRAMPOLINE_MOD, MODULE_NAME_LEN);\n\t\t*exported = 0;\n\t\treturn 0;\n\t}\n\n\treturn -ERANGE;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"",
      "#define FTRACE_TRAMPOLINE_MOD \"__builtin__ftrace\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "module_name",
            "FTRACE_TRAMPOLINE_MOD",
            "MODULE_NAME_LEN"
          ],
          "line": 6558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "name",
            "FTRACE_TRAMPOLINE_SYM",
            "KSYM_NAME_LEN"
          ],
          "line": 6557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "op",
            "&ftrace_ops_trampoline_list",
            "list"
          ],
          "line": 6552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"\n#define FTRACE_TRAMPOLINE_MOD \"__builtin__ftrace\"\n\nstatic int ftrace_get_trampoline_kallsym(unsigned int symnum,\n\t\t\t\t\t unsigned long *value, char *type,\n\t\t\t\t\t char *name, char *module_name,\n\t\t\t\t\t int *exported)\n{\n\tstruct ftrace_ops *op;\n\n\tlist_for_each_entry_rcu(op, &ftrace_ops_trampoline_list, list) {\n\t\tif (!op->trampoline || symnum--)\n\t\t\tcontinue;\n\t\t*value = op->trampoline;\n\t\t*type = 't';\n\t\tstrlcpy(name, FTRACE_TRAMPOLINE_SYM, KSYM_NAME_LEN);\n\t\tstrlcpy(module_name, FTRACE_TRAMPOLINE_MOD, MODULE_NAME_LEN);\n\t\t*exported = 0;\n\t\treturn 0;\n\t}\n\n\treturn -ERANGE;\n}"
  },
  {
    "function_name": "ftrace_process_locs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6418-6526",
    "snippet": "static int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\t/*\n\t * Sorting mcount in vmlinux at build time depend on\n\t * CONFIG_BUILDTIME_MCOUNT_SORT, while mcount loc in\n\t * modules can not be sorted at build time.\n\t */\n\tif (!IS_ENABLED(CONFIG_BUILDTIME_MCOUNT_SORT) || mod) {\n\t\tsort(start, count, sizeof(*start),\n\t\t     ftrace_cmp_ips, NULL);\n\t} else {\n\t\ttest_is_sorted(start, count);\n\t}\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\tunsigned long end_offset;\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tend_offset = (pg->index+1) * sizeof(pg->records[0]);\n\t\tif (end_offset > PAGE_SIZE << pg->order) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6523
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_code",
          "args": [
            "mod",
            "start_pg"
          ],
          "line": 6518
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3130-3183",
          "snippet": "static int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)\n{\n\tbool init_nop = ftrace_need_init_nop();\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *p;\n\tu64 start, stop;\n\tunsigned long update_cnt = 0;\n\tunsigned long rec_flags = 0;\n\tint i;\n\n\tstart = ftrace_now(raw_smp_processor_id());\n\n\t/*\n\t * When a module is loaded, this function is called to convert\n\t * the calls to mcount in its text to nops, and also to create\n\t * an entry in the ftrace data. Now, if ftrace is activated\n\t * after this call, but before the module sets its text to\n\t * read-only, the modification of enabling ftrace can fail if\n\t * the read-only is done while ftrace is converting the calls.\n\t * To prevent this, the module's records are set as disabled\n\t * and will be enabled after the call to set the module's text\n\t * to read-only.\n\t */\n\tif (mod)\n\t\trec_flags |= FTRACE_FL_DISABLED;\n\n\tfor (pg = new_pgs; pg; pg = pg->next) {\n\n\t\tfor (i = 0; i < pg->index; i++) {\n\n\t\t\t/* If something went wrong, bail without enabling anything */\n\t\t\tif (unlikely(ftrace_disabled))\n\t\t\t\treturn -1;\n\n\t\t\tp = &pg->records[i];\n\t\t\tp->flags = rec_flags;\n\n\t\t\t/*\n\t\t\t * Do the initial record conversion from mcount jump\n\t\t\t * to the NOP instructions.\n\t\t\t */\n\t\t\tif (init_nop && !ftrace_nop_initialize(mod, p))\n\t\t\t\tbreak;\n\n\t\t\tupdate_cnt++;\n\t\t}\n\t}\n\n\tstop = ftrace_now(raw_smp_processor_id());\n\tftrace_update_time = stop - start;\n\tftrace_update_tot_cnt += update_cnt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)\n{\n\tbool init_nop = ftrace_need_init_nop();\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *p;\n\tu64 start, stop;\n\tunsigned long update_cnt = 0;\n\tunsigned long rec_flags = 0;\n\tint i;\n\n\tstart = ftrace_now(raw_smp_processor_id());\n\n\t/*\n\t * When a module is loaded, this function is called to convert\n\t * the calls to mcount in its text to nops, and also to create\n\t * an entry in the ftrace data. Now, if ftrace is activated\n\t * after this call, but before the module sets its text to\n\t * read-only, the modification of enabling ftrace can fail if\n\t * the read-only is done while ftrace is converting the calls.\n\t * To prevent this, the module's records are set as disabled\n\t * and will be enabled after the call to set the module's text\n\t * to read-only.\n\t */\n\tif (mod)\n\t\trec_flags |= FTRACE_FL_DISABLED;\n\n\tfor (pg = new_pgs; pg; pg = pg->next) {\n\n\t\tfor (i = 0; i < pg->index; i++) {\n\n\t\t\t/* If something went wrong, bail without enabling anything */\n\t\t\tif (unlikely(ftrace_disabled))\n\t\t\t\treturn -1;\n\n\t\t\tp = &pg->records[i];\n\t\t\tp->flags = rec_flags;\n\n\t\t\t/*\n\t\t\t * Do the initial record conversion from mcount jump\n\t\t\t * to the NOP instructions.\n\t\t\t */\n\t\t\tif (init_nop && !ftrace_nop_initialize(mod, p))\n\t\t\t\tbreak;\n\n\t\t\tupdate_cnt++;\n\t\t}\n\t}\n\n\tstop = ftrace_now(raw_smp_processor_id());\n\tftrace_update_time = stop - start;\n\tftrace_update_tot_cnt += update_cnt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pg->next"
          ],
          "line": 6503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!pg->next"
          ],
          "line": 6493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_call_adjust",
          "args": [
            "*p++"
          ],
          "line": 6480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ftrace_pages->next"
          ],
          "line": 6467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ftrace_pages || ftrace_pages_start"
          ],
          "line": 6460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6452
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_allocate_pages",
          "args": [
            "count"
          ],
          "line": 6448
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_allocate_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3221-3272",
          "snippet": "static struct ftrace_page *\nftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn NULL;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\tpg = start_pg;\n\twhile (pg) {\n\t\tif (pg->records) {\n\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t}\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t\tftrace_number_of_groups--;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_page *\nftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn NULL;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\tpg = start_pg;\n\twhile (pg) {\n\t\tif (pg->records) {\n\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t}\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t\tftrace_number_of_groups--;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_is_sorted",
          "args": [
            "start",
            "count"
          ],
          "line": 6445
        },
        "resolved": true,
        "details": {
          "function_name": "test_is_sorted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6413-6415",
          "snippet": "static void test_is_sorted(unsigned long *start, unsigned long count)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void test_is_sorted(unsigned long *start, unsigned long count)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "start",
            "count",
            "sizeof(*start)",
            "ftrace_cmp_ips",
            "NULL"
          ],
          "line": 6442
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_BUILDTIME_MCOUNT_SORT"
          ],
          "line": 6441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\t/*\n\t * Sorting mcount in vmlinux at build time depend on\n\t * CONFIG_BUILDTIME_MCOUNT_SORT, while mcount loc in\n\t * modules can not be sorted at build time.\n\t */\n\tif (!IS_ENABLED(CONFIG_BUILDTIME_MCOUNT_SORT) || mod) {\n\t\tsort(start, count, sizeof(*start),\n\t\t     ftrace_cmp_ips, NULL);\n\t} else {\n\t\ttest_is_sorted(start, count);\n\t}\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\tunsigned long end_offset;\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tend_offset = (pg->index+1) * sizeof(pg->records[0]);\n\t\tif (end_offset > PAGE_SIZE << pg->order) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "test_is_sorted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6413-6415",
    "snippet": "static void test_is_sorted(unsigned long *start, unsigned long count)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void test_is_sorted(unsigned long *start, unsigned long count)\n{\n}"
  },
  {
    "function_name": "test_is_sorted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6398-6411",
    "snippet": "static void test_is_sorted(unsigned long *start, unsigned long count)\n{\n\tint i;\n\n\tfor (i = 1; i < count; i++) {\n\t\tif (WARN(start[i - 1] > start[i],\n\t\t\t \"[%d] %pS at %lx is not sorted with %pS at %lx\\n\", i,\n\t\t\t (void *)start[i - 1], start[i - 1],\n\t\t\t (void *)start[i], start[i]))\n\t\t\tbreak;\n\t}\n\tif (i == count)\n\t\tpr_info(\"ftrace section at %px sorted properly\\n\", start);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace section at %px sorted properly\\n\"",
            "start"
          ],
          "line": 6410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "start[i - 1] > start[i]",
            "\"[%d] %pS at %lx is not sorted with %pS at %lx\\n\"",
            "i",
            "(void *)start[i - 1]",
            "start[i - 1]",
            "(void *)start[i]",
            "start[i]"
          ],
          "line": 6403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void test_is_sorted(unsigned long *start, unsigned long count)\n{\n\tint i;\n\n\tfor (i = 1; i < count; i++) {\n\t\tif (WARN(start[i - 1] > start[i],\n\t\t\t \"[%d] %pS at %lx is not sorted with %pS at %lx\\n\", i,\n\t\t\t (void *)start[i - 1], start[i - 1],\n\t\t\t (void *)start[i], start[i]))\n\t\t\tbreak;\n\t}\n\tif (i == count)\n\t\tpr_info(\"ftrace section at %px sorted properly\\n\", start);\n}"
  },
  {
    "function_name": "ftrace_cmp_ips",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6385-6395",
    "snippet": "static int ftrace_cmp_ips(const void *a, const void *b)\n{\n\tconst unsigned long *ipa = a;\n\tconst unsigned long *ipb = b;\n\n\tif (*ipa > *ipb)\n\t\treturn 1;\n\tif (*ipa < *ipb)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_cmp_ips(const void *a, const void *b)\n{\n\tconst unsigned long *ipa = a;\n\tconst unsigned long *ipb = b;\n\n\tif (*ipa > *ipb)\n\t\treturn 1;\n\tif (*ipa < *ipb)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_init_dyn_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6362-6383",
    "snippet": "static __init int ftrace_init_dyn_tracefs(struct dentry *d_tracer)\n{\n\n\ttrace_create_file(\"available_filter_functions\", TRACE_MODE_READ,\n\t\t\td_tracer, NULL, &ftrace_avail_fops);\n\n\ttrace_create_file(\"enabled_functions\", TRACE_MODE_READ,\n\t\t\td_tracer, NULL, &ftrace_enabled_fops);\n\n\tftrace_create_filter_files(&global_ops, d_tracer);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\ttrace_create_file(\"set_graph_function\", TRACE_MODE_WRITE, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_fops);\n\ttrace_create_file(\"set_graph_notrace\", TRACE_MODE_WRITE, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_notrace_fops);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"set_graph_notrace\"",
            "TRACE_MODE_WRITE",
            "d_tracer",
            "NULL",
            "&ftrace_graph_notrace_fops"
          ],
          "line": 6377
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_create_filter_files",
          "args": [
            "&global_ops",
            "d_tracer"
          ],
          "line": 6371
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_create_filter_files",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6331-6340",
          "snippet": "void ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops global_ops;\n\nstatic __init int ftrace_init_dyn_tracefs(struct dentry *d_tracer)\n{\n\n\ttrace_create_file(\"available_filter_functions\", TRACE_MODE_READ,\n\t\t\td_tracer, NULL, &ftrace_avail_fops);\n\n\ttrace_create_file(\"enabled_functions\", TRACE_MODE_READ,\n\t\t\td_tracer, NULL, &ftrace_enabled_fops);\n\n\tftrace_create_filter_files(&global_ops, d_tracer);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\ttrace_create_file(\"set_graph_function\", TRACE_MODE_WRITE, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_fops);\n\ttrace_create_file(\"set_graph_notrace\", TRACE_MODE_WRITE, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_notrace_fops);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_destroy_filter_files",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6352-6360",
    "snippet": "void ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= FTRACE_OPS_FL_DELETED;\n\tftrace_free_filter(ops);\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6359
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_free_filter",
          "args": [
            "ops"
          ],
          "line": 6358
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_free_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1252-1257",
          "snippet": "void ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown",
          "args": [
            "ops",
            "0"
          ],
          "line": 6356
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2937-3049",
          "snippet": "int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tsynchronize_rcu_tasks_rude();\n\n\t\t/*\n\t\t * When the kernel is preemptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchronize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tsynchronize_rcu_tasks_rude();\n\n\t\t/*\n\t\t * When the kernel is preemptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchronize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6354
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= FTRACE_OPS_FL_DELETED;\n\tftrace_free_filter(ops);\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "ftrace_create_filter_files",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6331-6340",
    "snippet": "void ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"set_ftrace_notrace\"",
            "TRACE_MODE_WRITE",
            "parent",
            "ops",
            "&ftrace_notrace_fops"
          ],
          "line": 6338
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", TRACE_MODE_WRITE, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}"
  },
  {
    "function_name": "ftrace_graph_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6279-6312",
    "snippet": "static ssize_t\nftrace_graph_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tssize_t read, ret = 0;\n\tstruct ftrace_graph_data *fgd = file->private_data;\n\tstruct trace_parser *parser;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\t/* Read mode uses seq functions */\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tfgd = m->private;\n\t}\n\n\tparser = &fgd->parser;\n\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\n\t\tret = ftrace_graph_set_hash(fgd->new_hash,\n\t\t\t\t\t    parser->buffer);\n\t\ttrace_parser_clear(parser);\n\t}\n\n\tif (!ret)\n\t\tret = read;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parser_clear",
          "args": [
            "parser"
          ],
          "line": 6305
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1138-1142",
          "snippet": "static inline void trace_parser_clear(struct trace_parser *parser)\n{\n\tparser->cont = false;\n\tparser->idx = 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_parser_clear(struct trace_parser *parser)\n{\n\tparser->cont = false;\n\tparser->idx = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_set_hash",
          "args": [
            "fgd->new_hash",
            "parser->buffer"
          ],
          "line": 6303
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_set_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6224-6277",
          "snippet": "static int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_cont",
          "args": [
            "parser"
          ],
          "line": 6301
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_cont",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1133-1136",
          "snippet": "static inline bool trace_parser_cont(struct trace_parser *parser)\n{\n\treturn parser->cont;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_cont(struct trace_parser *parser)\n{\n\treturn parser->cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "parser"
          ],
          "line": 6300
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1128-1131",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_user",
          "args": [
            "parser",
            "ubuf",
            "cnt",
            "ppos"
          ],
          "line": 6298
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1575-1650",
          "snippet": "int trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_graph_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tssize_t read, ret = 0;\n\tstruct ftrace_graph_data *fgd = file->private_data;\n\tstruct trace_parser *parser;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\t/* Read mode uses seq functions */\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tfgd = m->private;\n\t}\n\n\tparser = &fgd->parser;\n\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\n\t\tret = ftrace_graph_set_hash(fgd->new_hash,\n\t\t\t\t\t    parser->buffer);\n\t\ttrace_parser_clear(parser);\n\t}\n\n\tif (!ret)\n\t\tret = read;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_set_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6224-6277",
    "snippet": "static int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6271
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 6269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 6264
        },
        "resolved": true,
        "details": {
          "function_name": "free_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1170-1177",
          "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_hash_entry",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 6260
        },
        "resolved": true,
        "details": {
          "function_name": "add_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1156-1168",
          "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 6253
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_record",
          "args": [
            "rec",
            "&func_g",
            "NULL",
            "0"
          ],
          "line": 6252
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3993-4029",
          "snippet": "static int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 6247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 6242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6240
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_g.search"
          ],
          "line": 6238
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_parse_regex",
          "args": [
            "buffer",
            "strlen(buffer)",
            "&func_g.search",
            "&not"
          ],
          "line": 6235
        },
        "resolved": true,
        "details": {
          "function_name": "filter_parse_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "915-954",
          "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_graph_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6154-6222",
    "snippet": "static int\nftrace_graph_release(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tstruct ftrace_hash *old_hash, *new_hash;\n\tstruct trace_parser *parser;\n\tint ret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tfgd = m->private;\n\t\tseq_release(inode, file);\n\t} else {\n\t\tfgd = file->private_data;\n\t}\n\n\n\tif (file->f_mode & FMODE_WRITE) {\n\n\t\tparser = &fgd->parser;\n\n\t\tif (trace_parser_loaded((parser))) {\n\t\t\tret = ftrace_graph_set_hash(fgd->new_hash,\n\t\t\t\t\t\t    parser->buffer);\n\t\t}\n\n\t\ttrace_parser_put(parser);\n\n\t\tnew_hash = __ftrace_hash_move(fgd->new_hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmutex_lock(&graph_lock);\n\n\t\tif (fgd->type == GRAPH_FILTER_FUNCTION) {\n\t\t\told_hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\t\t\trcu_assign_pointer(ftrace_graph_hash, new_hash);\n\t\t} else {\n\t\t\told_hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\t\t\trcu_assign_pointer(ftrace_graph_notrace_hash, new_hash);\n\t\t}\n\n\t\tmutex_unlock(&graph_lock);\n\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tif (old_hash != EMPTY_HASH)\n\t\t\tsynchronize_rcu_tasks_rude();\n\n\t\tfree_ftrace_hash(old_hash);\n\t}\n\n out:\n\tfree_ftrace_hash(fgd->new_hash);\n\tkfree(fgd);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fgd"
          ],
          "line": 6219
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "fgd->new_hash"
          ],
          "line": 6218
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks_rude",
          "args": [],
          "line": 6212
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_rude",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "999-1002",
          "snippet": "void synchronize_rcu_tasks_rude(void)\n{\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_rude);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_rude(void)\n{\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_rude);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&graph_lock"
          ],
          "line": 6201
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "ftrace_graph_notrace_hash",
            "new_hash"
          ],
          "line": 6198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_notrace_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 6196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 6197
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "ftrace_graph_hash",
            "new_hash"
          ],
          "line": 6194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 6192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&graph_lock"
          ],
          "line": 6189
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_hash_move",
          "args": [
            "fgd->new_hash"
          ],
          "line": 6183
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_move",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1392-1404",
          "snippet": "static struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tint size = src->count;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\treturn dup_hash(src, size);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tint size = src->count;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\treturn dup_hash(src, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "parser"
          ],
          "line": 6181
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1558-1562",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_set_hash",
          "args": [
            "fgd->new_hash",
            "parser->buffer"
          ],
          "line": 6177
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_set_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6224-6277",
          "snippet": "static int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "(parser)"
          ],
          "line": 6176
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1128-1131",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 6166
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic int\nftrace_graph_release(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tstruct ftrace_hash *old_hash, *new_hash;\n\tstruct trace_parser *parser;\n\tint ret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tfgd = m->private;\n\t\tseq_release(inode, file);\n\t} else {\n\t\tfgd = file->private_data;\n\t}\n\n\n\tif (file->f_mode & FMODE_WRITE) {\n\n\t\tparser = &fgd->parser;\n\n\t\tif (trace_parser_loaded((parser))) {\n\t\t\tret = ftrace_graph_set_hash(fgd->new_hash,\n\t\t\t\t\t\t    parser->buffer);\n\t\t}\n\n\t\ttrace_parser_put(parser);\n\n\t\tnew_hash = __ftrace_hash_move(fgd->new_hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmutex_lock(&graph_lock);\n\n\t\tif (fgd->type == GRAPH_FILTER_FUNCTION) {\n\t\t\told_hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\t\t\trcu_assign_pointer(ftrace_graph_hash, new_hash);\n\t\t} else {\n\t\t\told_hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\t\t\trcu_assign_pointer(ftrace_graph_notrace_hash, new_hash);\n\t\t}\n\n\t\tmutex_unlock(&graph_lock);\n\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tif (old_hash != EMPTY_HASH)\n\t\t\tsynchronize_rcu_tasks_rude();\n\n\t\tfree_ftrace_hash(old_hash);\n\t}\n\n out:\n\tfree_ftrace_hash(fgd->new_hash);\n\tkfree(fgd);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_notrace_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6126-6152",
    "snippet": "static int\nftrace_graph_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tfgd = kmalloc(sizeof(*fgd), GFP_KERNEL);\n\tif (fgd == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&graph_lock);\n\n\tfgd->hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\tfgd->type = GRAPH_FILTER_NOTRACE;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\tret = __ftrace_graph_open(inode, file, fgd);\n\tif (ret < 0)\n\t\tkfree(fgd);\n\n\tmutex_unlock(&graph_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&graph_lock"
          ],
          "line": 6150
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fgd"
          ],
          "line": 6148
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_graph_open",
          "args": [
            "inode",
            "file",
            "fgd"
          ],
          "line": 6146
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_graph_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6041-6096",
          "snippet": "static int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_notrace_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 6141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 6142
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&graph_lock"
          ],
          "line": 6139
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fgd)",
            "GFP_KERNEL"
          ],
          "line": 6135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 6132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_graph_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tfgd = kmalloc(sizeof(*fgd), GFP_KERNEL);\n\tif (fgd == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&graph_lock);\n\n\tfgd->hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\tfgd->type = GRAPH_FILTER_NOTRACE;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\tret = __ftrace_graph_open(inode, file, fgd);\n\tif (ret < 0)\n\t\tkfree(fgd);\n\n\tmutex_unlock(&graph_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6098-6124",
    "snippet": "static int\nftrace_graph_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tfgd = kmalloc(sizeof(*fgd), GFP_KERNEL);\n\tif (fgd == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&graph_lock);\n\n\tfgd->hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\tfgd->type = GRAPH_FILTER_FUNCTION;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\tret = __ftrace_graph_open(inode, file, fgd);\n\tif (ret < 0)\n\t\tkfree(fgd);\n\n\tmutex_unlock(&graph_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&graph_lock"
          ],
          "line": 6122
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fgd"
          ],
          "line": 6120
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_graph_open",
          "args": [
            "inode",
            "file",
            "fgd"
          ],
          "line": 6118
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_graph_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6041-6096",
          "snippet": "static int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 6113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 6114
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&graph_lock"
          ],
          "line": 6111
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fgd)",
            "GFP_KERNEL"
          ],
          "line": 6107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 6104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_graph_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tfgd = kmalloc(sizeof(*fgd), GFP_KERNEL);\n\tif (fgd == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&graph_lock);\n\n\tfgd->hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\tfgd->type = GRAPH_FILTER_FUNCTION;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\tret = __ftrace_graph_open(inode, file, fgd);\n\tif (ret < 0)\n\t\tkfree(fgd);\n\n\tmutex_unlock(&graph_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ftrace_graph_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6041-6096",
    "snippet": "static int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "&fgd->parser"
          ],
          "line": 6084
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1558-1562",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "new_hash"
          ],
          "line": 6076
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&ftrace_graph_seq_ops"
          ],
          "line": 6070
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "size_bits",
            "fgd->hash"
          ],
          "line": 6061
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1310-1346",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "size_bits"
          ],
          "line": 6059
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1259-1279",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_get_init",
          "args": [
            "&fgd->parser",
            "FTRACE_BUFF_MAX"
          ],
          "line": 6055
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_get_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1543-1553",
          "snippet": "int trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 6048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "g_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6012-6032",
    "snippet": "static int g_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_func_entry *entry = v;\n\n\tif (!entry)\n\t\treturn 0;\n\n\tif (entry == FTRACE_GRAPH_EMPTY) {\n\t\tstruct ftrace_graph_data *fgd = m->private;\n\n\t\tif (fgd->type == GRAPH_FILTER_FUNCTION)\n\t\t\tseq_puts(m, \"#### all functions enabled ####\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#### no functions disabled ####\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"%ps\\n\", (void *)entry->ip);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_GRAPH_EMPTY\t((void *)1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%ps\\n\"",
            "(void *)entry->ip"
          ],
          "line": 6029
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#### no functions disabled ####\\n\""
          ],
          "line": 6025
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_GRAPH_EMPTY\t((void *)1)\n\nstatic int g_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_func_entry *entry = v;\n\n\tif (!entry)\n\t\treturn 0;\n\n\tif (entry == FTRACE_GRAPH_EMPTY) {\n\t\tstruct ftrace_graph_data *fgd = m->private;\n\n\t\tif (fgd->type == GRAPH_FILTER_FUNCTION)\n\t\t\tseq_puts(m, \"#### all functions enabled ####\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#### no functions disabled ####\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"%ps\\n\", (void *)entry->ip);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "g_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "6007-6010",
    "snippet": "static void g_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&graph_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&graph_lock"
          ],
          "line": 6009
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void g_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&graph_lock);\n}"
  },
  {
    "function_name": "g_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5985-6005",
    "snippet": "static void *g_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\n\tmutex_lock(&graph_lock);\n\n\tif (fgd->type == GRAPH_FILTER_FUNCTION)\n\t\tfgd->hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\telse\n\t\tfgd->hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\n\t/* Nothing, tell g_show to print all functions are enabled */\n\tif (ftrace_hash_empty(fgd->hash) && !*pos)\n\t\treturn FTRACE_GRAPH_EMPTY;\n\n\tfgd->idx = 0;\n\tfgd->entry = NULL;\n\treturn __g_next(m, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_GRAPH_EMPTY\t((void *)1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__g_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 6004
        },
        "resolved": true,
        "details": {
          "function_name": "__g_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5947-5976",
          "snippet": "static void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "fgd->hash"
          ],
          "line": 5999
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_notrace_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 5995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 5996
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 5992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&graph_lock"
          ],
          "line": 5989
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_GRAPH_EMPTY\t((void *)1)\n\nstatic void *g_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\n\tmutex_lock(&graph_lock);\n\n\tif (fgd->type == GRAPH_FILTER_FUNCTION)\n\t\tfgd->hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\telse\n\t\tfgd->hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\n\t/* Nothing, tell g_show to print all functions are enabled */\n\tif (ftrace_hash_empty(fgd->hash) && !*pos)\n\t\treturn FTRACE_GRAPH_EMPTY;\n\n\tfgd->idx = 0;\n\tfgd->entry = NULL;\n\treturn __g_next(m, pos);\n}"
  },
  {
    "function_name": "g_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5978-5983",
    "snippet": "static void *\ng_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __g_next(m, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__g_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 5982
        },
        "resolved": true,
        "details": {
          "function_name": "__g_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5947-5976",
          "snippet": "static void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\ng_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __g_next(m, pos);\n}"
  },
  {
    "function_name": "__g_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5947-5976",
    "snippet": "static void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "head",
            "hlist"
          ],
          "line": 5969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_continue",
          "args": [
            "entry",
            "hlist"
          ],
          "line": 5959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_regex_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5839-5891",
    "snippet": "int ftrace_regex_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = (struct seq_file *)file->private_data;\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash **orig_hash;\n\tstruct trace_parser *parser;\n\tint filter_hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer = m->private;\n\t\tseq_release(inode, file);\n\t} else\n\t\titer = file->private_data;\n\n\tparser = &iter->parser;\n\tif (trace_parser_loaded(parser)) {\n\t\tint enable = !(iter->flags & FTRACE_ITER_NOTRACE);\n\n\t\tftrace_process_regex(iter, parser->buffer,\n\t\t\t\t     parser->idx, enable);\n\t}\n\n\ttrace_parser_put(parser);\n\n\tmutex_lock(&iter->ops->func_hash->regex_lock);\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tfilter_hash = !!(iter->flags & FTRACE_ITER_FILTER);\n\n\t\tif (filter_hash) {\n\t\t\torig_hash = &iter->ops->func_hash->filter_hash;\n\t\t\tif (iter->tr && !list_empty(&iter->tr->mod_trace))\n\t\t\t\titer->hash->flags |= FTRACE_HASH_FL_MOD;\n\t\t} else\n\t\t\torig_hash = &iter->ops->func_hash->notrace_hash;\n\n\t\tmutex_lock(&ftrace_lock);\n\t\tftrace_hash_move_and_update_ops(iter->ops, orig_hash,\n\t\t\t\t\t\t      iter->hash, filter_hash);\n\t\tmutex_unlock(&ftrace_lock);\n\t} else {\n\t\t/* For read only, the hash is the ops hash */\n\t\titer->hash = NULL;\n\t}\n\n\tmutex_unlock(&iter->ops->func_hash->regex_lock);\n\tfree_ftrace_hash(iter->hash);\n\tif (iter->tr)\n\t\ttrace_array_put(iter->tr);\n\tkfree(iter);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iter"
          ],
          "line": 5888
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "iter->tr"
          ],
          "line": 5887
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "iter->hash"
          ],
          "line": 5885
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&iter->ops->func_hash->regex_lock"
          ],
          "line": 5884
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "iter->ops",
            "orig_hash",
            "iter->hash",
            "filter_hash"
          ],
          "line": 5876
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4123-4141",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5875
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&iter->tr->mod_trace"
          ],
          "line": 5870
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "parser"
          ],
          "line": 5861
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1558-1562",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_process_regex",
          "args": [
            "iter",
            "parser->buffer",
            "parser->idx",
            "enable"
          ],
          "line": 5857
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_process_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4870-4905",
          "snippet": "static int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "parser"
          ],
          "line": 5854
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1128-1131",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 5849
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_regex_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = (struct seq_file *)file->private_data;\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash **orig_hash;\n\tstruct trace_parser *parser;\n\tint filter_hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer = m->private;\n\t\tseq_release(inode, file);\n\t} else\n\t\titer = file->private_data;\n\n\tparser = &iter->parser;\n\tif (trace_parser_loaded(parser)) {\n\t\tint enable = !(iter->flags & FTRACE_ITER_NOTRACE);\n\n\t\tftrace_process_regex(iter, parser->buffer,\n\t\t\t\t     parser->idx, enable);\n\t}\n\n\ttrace_parser_put(parser);\n\n\tmutex_lock(&iter->ops->func_hash->regex_lock);\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tfilter_hash = !!(iter->flags & FTRACE_ITER_FILTER);\n\n\t\tif (filter_hash) {\n\t\t\torig_hash = &iter->ops->func_hash->filter_hash;\n\t\t\tif (iter->tr && !list_empty(&iter->tr->mod_trace))\n\t\t\t\titer->hash->flags |= FTRACE_HASH_FL_MOD;\n\t\t} else\n\t\t\torig_hash = &iter->ops->func_hash->notrace_hash;\n\n\t\tmutex_lock(&ftrace_lock);\n\t\tftrace_hash_move_and_update_ops(iter->ops, orig_hash,\n\t\t\t\t\t\t      iter->hash, filter_hash);\n\t\tmutex_unlock(&ftrace_lock);\n\t} else {\n\t\t/* For read only, the hash is the ops hash */\n\t\titer->hash = NULL;\n\t}\n\n\tmutex_unlock(&iter->ops->func_hash->regex_lock);\n\tfree_ftrace_hash(iter->hash);\n\tif (iter->tr)\n\t\ttrace_array_put(iter->tr);\n\tkfree(iter);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_ftrace_early_filters",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5825-5837",
    "snippet": "static void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ftrace_early_graph",
          "args": [
            "ftrace_graph_notrace_buf",
            "0"
          ],
          "line": 5835
        },
        "resolved": true,
        "details": {
          "function_name": "set_ftrace_early_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5786-5809",
          "snippet": "static void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tstruct ftrace_hash *hash;\n\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\tif (MEM_FAIL(!hash, \"Failed to allocate hash\\n\"))\n\t\treturn;\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\t/* we allow only one expression at a time */\n\t\tret = ftrace_graph_set_hash(hash, func);\n\t\tif (ret)\n\t\t\tprintk(KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\", func);\n\t}\n\n\tif (enable)\n\t\tftrace_graph_hash = hash;\n\telse\n\t\tftrace_graph_notrace_hash = hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tstruct ftrace_hash *hash;\n\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\tif (MEM_FAIL(!hash, \"Failed to allocate hash\\n\"))\n\t\treturn;\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\t/* we allow only one expression at a time */\n\t\tret = ftrace_graph_set_hash(hash, func);\n\t\tif (ret)\n\t\t\tprintk(KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\", func);\n\t}\n\n\tif (enable)\n\t\tftrace_graph_hash = hash;\n\telse\n\t\tftrace_graph_notrace_hash = hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_early_filter",
          "args": [
            "&global_ops",
            "ftrace_notrace_buf",
            "0"
          ],
          "line": 5830
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_early_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5812-5823",
          "snippet": "void __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops global_ops;\n\nstatic void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}"
  },
  {
    "function_name": "ftrace_set_early_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5812-5823",
    "snippet": "void __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "ops",
            "func",
            "strlen(func)",
            "0",
            "enable"
          ],
          "line": 5821
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5658-5663",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func"
          ],
          "line": 5821
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 5820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 5817
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}"
  },
  {
    "function_name": "set_ftrace_early_graph",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5786-5809",
    "snippet": "static void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tstruct ftrace_hash *hash;\n\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\tif (MEM_FAIL(!hash, \"Failed to allocate hash\\n\"))\n\t\treturn;\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\t/* we allow only one expression at a time */\n\t\tret = ftrace_graph_set_hash(hash, func);\n\t\tif (ret)\n\t\t\tprintk(KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\", func);\n\t}\n\n\tif (enable)\n\t\tftrace_graph_hash = hash;\n\telse\n\t\tftrace_graph_notrace_hash = hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\"",
            "func"
          ],
          "line": 5801
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_set_hash",
          "args": [
            "hash",
            "func"
          ],
          "line": 5799
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_set_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6224-6277",
          "snippet": "static int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 5797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEM_FAIL",
          "args": [
            "!hash",
            "\"Failed to allocate hash\\n\""
          ],
          "line": 5793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS"
          ],
          "line": 5792
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1259-1279",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tstruct ftrace_hash *hash;\n\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\tif (MEM_FAIL(!hash, \"Failed to allocate hash\\n\"))\n\t\treturn;\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\t/* we allow only one expression at a time */\n\t\tret = ftrace_graph_set_hash(hash, func);\n\t\tif (ret)\n\t\t\tprintk(KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\", func);\n\t}\n\n\tif (enable)\n\t\tftrace_graph_hash = hash;\n\telse\n\t\tftrace_graph_notrace_hash = hash;\n}"
  },
  {
    "function_name": "set_graph_max_depth_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5777-5783",
    "snippet": "static int __init set_graph_max_depth_function(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tfgraph_max_depth = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 5781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int __init set_graph_max_depth_function(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tfgraph_max_depth = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_graph_notrace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5770-5774",
    "snippet": "static int __init set_graph_notrace_function(char *str)\n{\n\tstrlcpy(ftrace_graph_notrace_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ftrace_graph_notrace_buf",
            "str",
            "FTRACE_FILTER_SIZE"
          ],
          "line": 5772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE\n\nstatic int __init set_graph_notrace_function(char *str)\n{\n\tstrlcpy(ftrace_graph_notrace_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_graph_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5763-5767",
    "snippet": "static int __init set_graph_function(char *str)\n{\n\tstrlcpy(ftrace_graph_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ftrace_graph_buf",
            "str",
            "FTRACE_FILTER_SIZE"
          ],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE\n\nstatic int __init set_graph_function(char *str)\n{\n\tstrlcpy(ftrace_graph_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_ftrace_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5750-5755",
    "snippet": "static int __init set_ftrace_filter(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_filter_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ftrace_filter_buf",
            "str",
            "FTRACE_FILTER_SIZE"
          ],
          "line": 5753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE\n\nstatic int __init set_ftrace_filter(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_filter_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_ftrace_notrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5742-5747",
    "snippet": "static int __init set_ftrace_notrace(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_notrace_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ftrace_notrace_buf",
            "str",
            "FTRACE_FILTER_SIZE"
          ],
          "line": 5745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE\n\nstatic int __init set_ftrace_notrace(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_notrace_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_set_global_notrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5726-5729",
    "snippet": "void ftrace_set_global_notrace(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "&global_ops",
            "buf",
            "len",
            "reset",
            "0"
          ],
          "line": 5728
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5658-5663",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops global_ops;\n\nvoid ftrace_set_global_notrace(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 0);\n}"
  },
  {
    "function_name": "ftrace_set_global_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5710-5713",
    "snippet": "void ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "&global_ops",
            "buf",
            "len",
            "reset",
            "1"
          ],
          "line": 5712
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5658-5663",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops global_ops;\n\nvoid ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}"
  },
  {
    "function_name": "ftrace_set_notrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5694-5699",
    "snippet": "int ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "ops",
            "buf",
            "len",
            "reset",
            "0"
          ],
          "line": 5698
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5658-5663",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 5697
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}"
  },
  {
    "function_name": "ftrace_set_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5675-5680",
    "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "ops",
            "buf",
            "len",
            "reset",
            "1"
          ],
          "line": 5679
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5658-5663",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 5678
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
  },
  {
    "function_name": "ftrace_set_regex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5658-5663",
    "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_hash",
          "args": [
            "ops",
            "buf",
            "len",
            "0",
            "0",
            "reset",
            "enable"
          ],
          "line": 5662
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4979-5026",
          "snippet": "static int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
  },
  {
    "function_name": "ftrace_ops_set_global_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5648-5655",
    "snippet": "void ftrace_ops_set_global_filter(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_INITIALIZED)\n\t\treturn;\n\n\tftrace_ops_init(ops);\n\tops->func_hash = &global_ops.local_hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 5653
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_ops_set_global_filter(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_INITIALIZED)\n\t\treturn;\n\n\tftrace_ops_init(ops);\n\tops->func_hash = &global_ops.local_hash;\n}"
  },
  {
    "function_name": "ftrace_set_filter_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5633-5638",
    "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_addr",
          "args": [
            "ops",
            "ip",
            "remove",
            "reset",
            "1"
          ],
          "line": 5637
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5028-5033",
          "snippet": "static int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, NULL, 0, ip, remove, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, NULL, 0, ip, remove, reset, enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 5636
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
  },
  {
    "function_name": "modify_ftrace_direct_multi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5568-5619",
    "snippet": "int modify_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_func_entry *entry, *iter;\n\tstatic struct ftrace_ops tmp_ops = {\n\t\t.func\t\t= ftrace_stub,\n\t\t.flags\t\t= FTRACE_OPS_FL_STUB,\n\t};\n\tint i, size;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\n\t/* Enable the tmp_ops to have the same functions as the direct ops */\n\tftrace_ops_init(&tmp_ops);\n\ttmp_ops.func_hash = ops->func_hash;\n\n\terr = register_ftrace_function(&tmp_ops);\n\tif (err)\n\t\tgoto out_direct;\n\n\t/*\n\t * Now the ftrace_ops_list_func() is called to do the direct callers.\n\t * We can safely change the direct functions attached to each entry.\n\t */\n\tmutex_lock(&ftrace_lock);\n\n\thash = ops->func_hash->filter_hash;\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(iter, &hash->buckets[i], hlist) {\n\t\t\tentry = __ftrace_lookup_ip(direct_functions, iter->ip);\n\t\t\tif (!entry)\n\t\t\t\tcontinue;\n\t\t\tentry->direct = addr;\n\t\t}\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/* Removing the tmp_ops will add the updated direct callers to the functions */\n\tunregister_ftrace_function(&tmp_ops);\n\n out_direct:\n\tmutex_unlock(&direct_mutex);\n\treturn err;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5617
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&tmp_ops"
          ],
          "line": 5614
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "direct_functions",
            "iter->ip"
          ],
          "line": 5604
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1108-1123",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "iter",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 5603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5598
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "&tmp_ops"
          ],
          "line": 5587
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_direct_multi",
          "args": [
            "ops"
          ],
          "line": 5579
        },
        "resolved": true,
        "details": {
          "function_name": "check_direct_multi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5410-5417",
          "snippet": "static int check_direct_multi(struct ftrace_ops *ops)\n{\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED))\n\t\treturn -EINVAL;\n\tif ((ops->flags & MULTI_FLAGS) != MULTI_FLAGS)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define MULTI_FLAGS (FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_DIRECT | \\\n\t\t     FTRACE_OPS_FL_SAVE_REGS)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define MULTI_FLAGS (FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_DIRECT | \\\n\t\t     FTRACE_OPS_FL_SAVE_REGS)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int check_direct_multi(struct ftrace_ops *ops)\n{\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED))\n\t\treturn -EINVAL;\n\tif ((ops->flags & MULTI_FLAGS) != MULTI_FLAGS)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint modify_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_func_entry *entry, *iter;\n\tstatic struct ftrace_ops tmp_ops = {\n\t\t.func\t\t= ftrace_stub,\n\t\t.flags\t\t= FTRACE_OPS_FL_STUB,\n\t};\n\tint i, size;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\n\t/* Enable the tmp_ops to have the same functions as the direct ops */\n\tftrace_ops_init(&tmp_ops);\n\ttmp_ops.func_hash = ops->func_hash;\n\n\terr = register_ftrace_function(&tmp_ops);\n\tif (err)\n\t\tgoto out_direct;\n\n\t/*\n\t * Now the ftrace_ops_list_func() is called to do the direct callers.\n\t * We can safely change the direct functions attached to each entry.\n\t */\n\tmutex_lock(&ftrace_lock);\n\n\thash = ops->func_hash->filter_hash;\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(iter, &hash->buckets[i], hlist) {\n\t\t\tentry = __ftrace_lookup_ip(direct_functions, iter->ip);\n\t\t\tif (!entry)\n\t\t\t\tcontinue;\n\t\t\tentry->direct = addr;\n\t\t}\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/* Removing the tmp_ops will add the updated direct callers to the functions */\n\tunregister_ftrace_function(&tmp_ops);\n\n out_direct:\n\tmutex_unlock(&direct_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "unregister_ftrace_direct_multi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5531-5550",
    "snippet": "int unregister_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\terr = unregister_ftrace_function(ops);\n\tremove_direct_functions_hash(hash, addr);\n\tmutex_unlock(&direct_mutex);\n\n\t/* cleanup for possible another register call */\n\tops->func = NULL;\n\tops->trampoline = 0;\n\treturn err;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5544
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_direct_functions_hash",
          "args": [
            "hash",
            "addr"
          ],
          "line": 5543
        },
        "resolved": true,
        "details": {
          "function_name": "remove_direct_functions_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5419-5434",
          "snippet": "static void remove_direct_functions_hash(struct ftrace_hash *hash, unsigned long addr)\n{\n\tstruct ftrace_func_entry *entry, *del;\n\tint size, i;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tdel = __ftrace_lookup_ip(direct_functions, entry->ip);\n\t\t\tif (del && del->direct == addr) {\n\t\t\t\tremove_hash_entry(direct_functions, del);\n\t\t\t\tkfree(del);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void remove_direct_functions_hash(struct ftrace_hash *hash, unsigned long addr)\n{\n\tstruct ftrace_func_entry *entry, *del;\n\tint size, i;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tdel = __ftrace_lookup_ip(direct_functions, entry->ip);\n\t\t\tif (del && del->direct == addr) {\n\t\t\t\tremove_hash_entry(direct_functions, del);\n\t\t\t\tkfree(del);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 5542
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5541
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_direct_multi",
          "args": [
            "ops"
          ],
          "line": 5536
        },
        "resolved": true,
        "details": {
          "function_name": "check_direct_multi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5410-5417",
          "snippet": "static int check_direct_multi(struct ftrace_ops *ops)\n{\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED))\n\t\treturn -EINVAL;\n\tif ((ops->flags & MULTI_FLAGS) != MULTI_FLAGS)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define MULTI_FLAGS (FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_DIRECT | \\\n\t\t     FTRACE_OPS_FL_SAVE_REGS)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define MULTI_FLAGS (FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_DIRECT | \\\n\t\t     FTRACE_OPS_FL_SAVE_REGS)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int check_direct_multi(struct ftrace_ops *ops)\n{\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED))\n\t\treturn -EINVAL;\n\tif ((ops->flags & MULTI_FLAGS) != MULTI_FLAGS)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\terr = unregister_ftrace_function(ops);\n\tremove_direct_functions_hash(hash, addr);\n\tmutex_unlock(&direct_mutex);\n\n\t/* cleanup for possible another register call */\n\tops->func = NULL;\n\tops->trampoline = 0;\n\treturn err;\n}"
  },
  {
    "function_name": "register_ftrace_direct_multi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5458-5515",
    "snippet": "int register_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash, *free_hash = NULL;\n\tstruct ftrace_func_entry *entry, *new;\n\tint err = -EBUSY, size, i;\n\n\tif (ops->func || ops->trampoline)\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED))\n\t\treturn -EINVAL;\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\treturn -EINVAL;\n\n\thash = ops->func_hash->filter_hash;\n\tif (ftrace_hash_empty(hash))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\n\t/* Make sure requested entries are not already registered.. */\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_find_rec_direct(entry->ip))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* ... and insert them to direct_functions hash. */\n\terr = -ENOMEM;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tnew = ftrace_add_rec_direct(entry->ip, addr, &free_hash);\n\t\t\tif (!new)\n\t\t\t\tgoto out_remove;\n\t\t\tentry->direct = addr;\n\t\t}\n\t}\n\n\tops->func = call_direct_funcs;\n\tops->flags = MULTI_FLAGS;\n\tops->trampoline = FTRACE_REGS_ADDR;\n\n\terr = register_ftrace_function(ops);\n\n out_remove:\n\tif (err)\n\t\tremove_direct_functions_hash(hash, addr);\n\n out_unlock:\n\tmutex_unlock(&direct_mutex);\n\n\tif (free_hash) {\n\t\tsynchronize_rcu_tasks();\n\t\tfree_ftrace_hash(free_hash);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define MULTI_FLAGS (FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_DIRECT | \\\n\t\t     FTRACE_OPS_FL_SAVE_REGS)"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "free_hash"
          ],
          "line": 5512
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks",
          "args": [],
          "line": 5511
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1556-1560",
          "snippet": "void synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5508
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_direct_functions_hash",
          "args": [
            "hash",
            "addr"
          ],
          "line": 5505
        },
        "resolved": true,
        "details": {
          "function_name": "remove_direct_functions_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5419-5434",
          "snippet": "static void remove_direct_functions_hash(struct ftrace_hash *hash, unsigned long addr)\n{\n\tstruct ftrace_func_entry *entry, *del;\n\tint size, i;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tdel = __ftrace_lookup_ip(direct_functions, entry->ip);\n\t\t\tif (del && del->direct == addr) {\n\t\t\t\tremove_hash_entry(direct_functions, del);\n\t\t\t\tkfree(del);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void remove_direct_functions_hash(struct ftrace_hash *hash, unsigned long addr)\n{\n\tstruct ftrace_func_entry *entry, *del;\n\tint size, i;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tdel = __ftrace_lookup_ip(direct_functions, entry->ip);\n\t\t\tif (del && del->direct == addr) {\n\t\t\t\tremove_hash_entry(direct_functions, del);\n\t\t\t\tkfree(del);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 5501
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_add_rec_direct",
          "args": [
            "entry->ip",
            "addr",
            "&free_hash"
          ],
          "line": 5490
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_add_rec_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2393-2424",
          "snippet": "static struct ftrace_func_entry*\nftrace_add_rec_direct(unsigned long ip, unsigned long addr,\n\t\t      struct ftrace_hash **free_hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(direct_functions) ||\n\t    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {\n\t\tstruct ftrace_hash *new_hash;\n\t\tint size = ftrace_hash_empty(direct_functions) ? 0 :\n\t\t\tdirect_functions->count + 1;\n\n\t\tif (size < 32)\n\t\t\tsize = 32;\n\n\t\tnew_hash = dup_hash(direct_functions, size);\n\t\tif (!new_hash)\n\t\t\treturn NULL;\n\n\t\t*free_hash = direct_functions;\n\t\tdirect_functions = new_hash;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->ip = ip;\n\tentry->direct = addr;\n\t__add_hash_entry(direct_functions, entry);\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_func_entry*\nftrace_add_rec_direct(unsigned long ip, unsigned long addr,\n\t\t      struct ftrace_hash **free_hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(direct_functions) ||\n\t    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {\n\t\tstruct ftrace_hash *new_hash;\n\t\tint size = ftrace_hash_empty(direct_functions) ? 0 :\n\t\t\tdirect_functions->count + 1;\n\n\t\tif (size < 32)\n\t\t\tsize = 32;\n\n\t\tnew_hash = dup_hash(direct_functions, size);\n\t\tif (!new_hash)\n\t\t\treturn NULL;\n\n\t\t*free_hash = direct_functions;\n\t\tdirect_functions = new_hash;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->ip = ip;\n\tentry->direct = addr;\n\t__add_hash_entry(direct_functions, entry);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 5489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_rec_direct",
          "args": [
            "entry->ip"
          ],
          "line": 5481
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_rec_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2382-2391",
          "snippet": "unsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 5480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5475
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 5472
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define MULTI_FLAGS (FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_DIRECT | \\\n\t\t     FTRACE_OPS_FL_SAVE_REGS)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint register_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash, *free_hash = NULL;\n\tstruct ftrace_func_entry *entry, *new;\n\tint err = -EBUSY, size, i;\n\n\tif (ops->func || ops->trampoline)\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED))\n\t\treturn -EINVAL;\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\treturn -EINVAL;\n\n\thash = ops->func_hash->filter_hash;\n\tif (ftrace_hash_empty(hash))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\n\t/* Make sure requested entries are not already registered.. */\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_find_rec_direct(entry->ip))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* ... and insert them to direct_functions hash. */\n\terr = -ENOMEM;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tnew = ftrace_add_rec_direct(entry->ip, addr, &free_hash);\n\t\t\tif (!new)\n\t\t\t\tgoto out_remove;\n\t\t\tentry->direct = addr;\n\t\t}\n\t}\n\n\tops->func = call_direct_funcs;\n\tops->flags = MULTI_FLAGS;\n\tops->trampoline = FTRACE_REGS_ADDR;\n\n\terr = register_ftrace_function(ops);\n\n out_remove:\n\tif (err)\n\t\tremove_direct_functions_hash(hash, addr);\n\n out_unlock:\n\tmutex_unlock(&direct_mutex);\n\n\tif (free_hash) {\n\t\tsynchronize_rcu_tasks();\n\t\tfree_ftrace_hash(free_hash);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "remove_direct_functions_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5419-5434",
    "snippet": "static void remove_direct_functions_hash(struct ftrace_hash *hash, unsigned long addr)\n{\n\tstruct ftrace_func_entry *entry, *del;\n\tint size, i;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tdel = __ftrace_lookup_ip(direct_functions, entry->ip);\n\t\t\tif (del && del->direct == addr) {\n\t\t\t\tremove_hash_entry(direct_functions, del);\n\t\t\t\tkfree(del);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "del"
          ],
          "line": 5430
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "direct_functions",
            "del"
          ],
          "line": 5429
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1179-1185",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "direct_functions",
            "entry->ip"
          ],
          "line": 5427
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1108-1123",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 5426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void remove_direct_functions_hash(struct ftrace_hash *hash, unsigned long addr)\n{\n\tstruct ftrace_func_entry *entry, *del;\n\tint size, i;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tdel = __ftrace_lookup_ip(direct_functions, entry->ip);\n\t\t\tif (del && del->direct == addr) {\n\t\t\t\tremove_hash_entry(direct_functions, del);\n\t\t\t\tkfree(del);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_direct_multi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5410-5417",
    "snippet": "static int check_direct_multi(struct ftrace_ops *ops)\n{\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED))\n\t\treturn -EINVAL;\n\tif ((ops->flags & MULTI_FLAGS) != MULTI_FLAGS)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define MULTI_FLAGS (FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_DIRECT | \\\n\t\t     FTRACE_OPS_FL_SAVE_REGS)"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define MULTI_FLAGS (FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_DIRECT | \\\n\t\t     FTRACE_OPS_FL_SAVE_REGS)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int check_direct_multi(struct ftrace_ops *ops)\n{\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED))\n\t\treturn -EINVAL;\n\tif ((ops->flags & MULTI_FLAGS) != MULTI_FLAGS)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "modify_ftrace_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5346-5404",
    "snippet": "int modify_ftrace_direct(unsigned long ip,\n\t\t\t unsigned long old_addr, unsigned long new_addr)\n{\n\tstruct ftrace_direct_func *direct, *new_direct = NULL;\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&direct_mutex);\n\n\tmutex_lock(&ftrace_lock);\n\tentry = find_direct_entry(&ip, &rec);\n\tif (!entry)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (entry->direct != old_addr)\n\t\tgoto out_unlock;\n\n\tdirect = ftrace_find_direct_func(old_addr);\n\tif (WARN_ON(!direct))\n\t\tgoto out_unlock;\n\tif (direct->count > 1) {\n\t\tret = -ENOMEM;\n\t\tnew_direct = ftrace_alloc_direct_func(new_addr);\n\t\tif (!new_direct)\n\t\t\tgoto out_unlock;\n\t\tdirect->count--;\n\t\tnew_direct->count++;\n\t} else {\n\t\tdirect->addr = new_addr;\n\t}\n\n\t/*\n\t * If there's no other ftrace callback on the rec->ip location,\n\t * then it can be changed directly by the architecture.\n\t * If there is another caller, then we just need to change the\n\t * direct caller helper to point to @new_addr.\n\t */\n\tif (ftrace_rec_count(rec) == 1) {\n\t\tret = ftrace_modify_direct_caller(entry, rec, old_addr, new_addr);\n\t} else {\n\t\tentry->direct = new_addr;\n\t\tret = 0;\n\t}\n\n\tif (unlikely(ret && new_direct)) {\n\t\tdirect->count++;\n\t\tlist_del_rcu(&new_direct->next);\n\t\tsynchronize_rcu_tasks();\n\t\tkfree(new_direct);\n\t\tftrace_direct_func_count--;\n\t}\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\tmutex_unlock(&direct_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5402
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_direct"
          ],
          "line": 5396
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks",
          "args": [],
          "line": 5395
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1556-1560",
          "snippet": "void synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&new_direct->next"
          ],
          "line": 5394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret && new_direct"
          ],
          "line": 5392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_modify_direct_caller",
          "args": [
            "entry",
            "rec",
            "old_addr",
            "new_addr"
          ],
          "line": 5386
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_direct_caller",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5281-5330",
          "snippet": "int __weak ftrace_modify_direct_caller(struct ftrace_func_entry *entry,\n\t\t\t\t       struct dyn_ftrace *rec,\n\t\t\t\t       unsigned long old_addr,\n\t\t\t\t       unsigned long new_addr)\n{\n\tunsigned long ip = rec->ip;\n\tint ret;\n\n\t/*\n\t * The ftrace_lock was used to determine if the record\n\t * had more than one registered user to it. If it did,\n\t * we needed to prevent that from changing to do the quick\n\t * switch. But if it did not (only a direct caller was attached)\n\t * then this function is called. But this function can deal\n\t * with attached callers to the rec that we care about, and\n\t * since this function uses standard ftrace calls that take\n\t * the ftrace_lock mutex, we need to release it.\n\t */\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * By setting a stub function at the same address, we force\n\t * the code to call the iterator and the direct_ops helper.\n\t * This means that @ip does not call the direct call, and\n\t * we can simply modify it.\n\t */\n\tret = ftrace_set_filter_ip(&stub_ops, ip, 0, 0);\n\tif (ret)\n\t\tgoto out_lock;\n\n\tret = register_ftrace_function(&stub_ops);\n\tif (ret) {\n\t\tftrace_set_filter_ip(&stub_ops, ip, 1, 0);\n\t\tgoto out_lock;\n\t}\n\n\tentry->direct = new_addr;\n\n\t/*\n\t * By removing the stub, we put back the direct call, calling\n\t * the @new_addr.\n\t */\n\tunregister_ftrace_function(&stub_ops);\n\tftrace_set_filter_ip(&stub_ops, ip, 1, 0);\n\n out_lock:\n\tmutex_lock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_modify_direct_caller(struct ftrace_func_entry *entry,\n\t\t\t\t       struct dyn_ftrace *rec,\n\t\t\t\t       unsigned long old_addr,\n\t\t\t\t       unsigned long new_addr)\n{\n\tunsigned long ip = rec->ip;\n\tint ret;\n\n\t/*\n\t * The ftrace_lock was used to determine if the record\n\t * had more than one registered user to it. If it did,\n\t * we needed to prevent that from changing to do the quick\n\t * switch. But if it did not (only a direct caller was attached)\n\t * then this function is called. But this function can deal\n\t * with attached callers to the rec that we care about, and\n\t * since this function uses standard ftrace calls that take\n\t * the ftrace_lock mutex, we need to release it.\n\t */\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * By setting a stub function at the same address, we force\n\t * the code to call the iterator and the direct_ops helper.\n\t * This means that @ip does not call the direct call, and\n\t * we can simply modify it.\n\t */\n\tret = ftrace_set_filter_ip(&stub_ops, ip, 0, 0);\n\tif (ret)\n\t\tgoto out_lock;\n\n\tret = register_ftrace_function(&stub_ops);\n\tif (ret) {\n\t\tftrace_set_filter_ip(&stub_ops, ip, 1, 0);\n\t\tgoto out_lock;\n\t}\n\n\tentry->direct = new_addr;\n\n\t/*\n\t * By removing the stub, we put back the direct call, calling\n\t * the @new_addr.\n\t */\n\tunregister_ftrace_function(&stub_ops);\n\tftrace_set_filter_ip(&stub_ops, ip, 1, 0);\n\n out_lock:\n\tmutex_lock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 5385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_alloc_direct_func",
          "args": [
            "new_addr"
          ],
          "line": 5370
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_alloc_direct_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5076-5088",
          "snippet": "static struct ftrace_direct_func *ftrace_alloc_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\n\tdirect = kmalloc(sizeof(*direct), GFP_KERNEL);\n\tif (!direct)\n\t\treturn NULL;\n\tdirect->addr = addr;\n\tdirect->count = 0;\n\tlist_add_rcu(&direct->next, &ftrace_direct_funcs);\n\tftrace_direct_func_count++;\n\treturn direct;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_direct_func *ftrace_alloc_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\n\tdirect = kmalloc(sizeof(*direct), GFP_KERNEL);\n\tif (!direct)\n\t\treturn NULL;\n\tdirect->addr = addr;\n\tdirect->count = 0;\n\tlist_add_rcu(&direct->next, &ftrace_direct_funcs);\n\tftrace_direct_func_count++;\n\treturn direct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!direct"
          ],
          "line": 5366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_direct_func",
          "args": [
            "old_addr"
          ],
          "line": 5365
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_direct_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5058-5074",
          "snippet": "struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *entry;\n\tbool found = false;\n\n\t/* May be called by fgraph trampoline (protected by rcu tasks) */\n\tlist_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {\n\t\tif (entry->addr == addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn entry;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *entry;\n\tbool found = false;\n\n\t/* May be called by fgraph trampoline (protected by rcu tasks) */\n\tlist_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {\n\t\tif (entry->addr == addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn entry;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_direct_entry",
          "args": [
            "&ip",
            "&rec"
          ],
          "line": 5357
        },
        "resolved": true,
        "details": {
          "function_name": "find_direct_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5189-5214",
          "snippet": "static struct ftrace_func_entry *find_direct_entry(unsigned long *ip,\n\t\t\t\t\t\t   struct dyn_ftrace **recp)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(*ip, *ip);\n\tif (!rec)\n\t\treturn NULL;\n\n\tentry = __ftrace_lookup_ip(direct_functions, rec->ip);\n\tif (!entry) {\n\t\tWARN_ON(rec->flags & FTRACE_FL_DIRECT);\n\t\treturn NULL;\n\t}\n\n\tWARN_ON(!(rec->flags & FTRACE_FL_DIRECT));\n\n\t/* Passed in ip just needs to be on the call site */\n\t*ip = rec->ip;\n\n\tif (recp)\n\t\t*recp = rec;\n\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_func_entry *find_direct_entry(unsigned long *ip,\n\t\t\t\t\t\t   struct dyn_ftrace **recp)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(*ip, *ip);\n\tif (!rec)\n\t\treturn NULL;\n\n\tentry = __ftrace_lookup_ip(direct_functions, rec->ip);\n\tif (!entry) {\n\t\tWARN_ON(rec->flags & FTRACE_FL_DIRECT);\n\t\treturn NULL;\n\t}\n\n\tWARN_ON(!(rec->flags & FTRACE_FL_DIRECT));\n\n\t/* Passed in ip just needs to be on the call site */\n\t*ip = rec->ip;\n\n\tif (recp)\n\t\t*recp = rec;\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5356
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint modify_ftrace_direct(unsigned long ip,\n\t\t\t unsigned long old_addr, unsigned long new_addr)\n{\n\tstruct ftrace_direct_func *direct, *new_direct = NULL;\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&direct_mutex);\n\n\tmutex_lock(&ftrace_lock);\n\tentry = find_direct_entry(&ip, &rec);\n\tif (!entry)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (entry->direct != old_addr)\n\t\tgoto out_unlock;\n\n\tdirect = ftrace_find_direct_func(old_addr);\n\tif (WARN_ON(!direct))\n\t\tgoto out_unlock;\n\tif (direct->count > 1) {\n\t\tret = -ENOMEM;\n\t\tnew_direct = ftrace_alloc_direct_func(new_addr);\n\t\tif (!new_direct)\n\t\t\tgoto out_unlock;\n\t\tdirect->count--;\n\t\tnew_direct->count++;\n\t} else {\n\t\tdirect->addr = new_addr;\n\t}\n\n\t/*\n\t * If there's no other ftrace callback on the rec->ip location,\n\t * then it can be changed directly by the architecture.\n\t * If there is another caller, then we just need to change the\n\t * direct caller helper to point to @new_addr.\n\t */\n\tif (ftrace_rec_count(rec) == 1) {\n\t\tret = ftrace_modify_direct_caller(entry, rec, old_addr, new_addr);\n\t} else {\n\t\tentry->direct = new_addr;\n\t\tret = 0;\n\t}\n\n\tif (unlikely(ret && new_direct)) {\n\t\tdirect->count++;\n\t\tlist_del_rcu(&new_direct->next);\n\t\tsynchronize_rcu_tasks();\n\t\tkfree(new_direct);\n\t\tftrace_direct_func_count--;\n\t}\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\tmutex_unlock(&direct_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_modify_direct_caller",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5281-5330",
    "snippet": "int __weak ftrace_modify_direct_caller(struct ftrace_func_entry *entry,\n\t\t\t\t       struct dyn_ftrace *rec,\n\t\t\t\t       unsigned long old_addr,\n\t\t\t\t       unsigned long new_addr)\n{\n\tunsigned long ip = rec->ip;\n\tint ret;\n\n\t/*\n\t * The ftrace_lock was used to determine if the record\n\t * had more than one registered user to it. If it did,\n\t * we needed to prevent that from changing to do the quick\n\t * switch. But if it did not (only a direct caller was attached)\n\t * then this function is called. But this function can deal\n\t * with attached callers to the rec that we care about, and\n\t * since this function uses standard ftrace calls that take\n\t * the ftrace_lock mutex, we need to release it.\n\t */\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * By setting a stub function at the same address, we force\n\t * the code to call the iterator and the direct_ops helper.\n\t * This means that @ip does not call the direct call, and\n\t * we can simply modify it.\n\t */\n\tret = ftrace_set_filter_ip(&stub_ops, ip, 0, 0);\n\tif (ret)\n\t\tgoto out_lock;\n\n\tret = register_ftrace_function(&stub_ops);\n\tif (ret) {\n\t\tftrace_set_filter_ip(&stub_ops, ip, 1, 0);\n\t\tgoto out_lock;\n\t}\n\n\tentry->direct = new_addr;\n\n\t/*\n\t * By removing the stub, we put back the direct call, calling\n\t * the @new_addr.\n\t */\n\tunregister_ftrace_function(&stub_ops);\n\tftrace_set_filter_ip(&stub_ops, ip, 1, 0);\n\n out_lock:\n\tmutex_lock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5327
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&stub_ops",
            "ip",
            "1",
            "0"
          ],
          "line": 5324
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5633-5638",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&stub_ops"
          ],
          "line": 5323
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5299
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_modify_direct_caller(struct ftrace_func_entry *entry,\n\t\t\t\t       struct dyn_ftrace *rec,\n\t\t\t\t       unsigned long old_addr,\n\t\t\t\t       unsigned long new_addr)\n{\n\tunsigned long ip = rec->ip;\n\tint ret;\n\n\t/*\n\t * The ftrace_lock was used to determine if the record\n\t * had more than one registered user to it. If it did,\n\t * we needed to prevent that from changing to do the quick\n\t * switch. But if it did not (only a direct caller was attached)\n\t * then this function is called. But this function can deal\n\t * with attached callers to the rec that we care about, and\n\t * since this function uses standard ftrace calls that take\n\t * the ftrace_lock mutex, we need to release it.\n\t */\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * By setting a stub function at the same address, we force\n\t * the code to call the iterator and the direct_ops helper.\n\t * This means that @ip does not call the direct call, and\n\t * we can simply modify it.\n\t */\n\tret = ftrace_set_filter_ip(&stub_ops, ip, 0, 0);\n\tif (ret)\n\t\tgoto out_lock;\n\n\tret = register_ftrace_function(&stub_ops);\n\tif (ret) {\n\t\tftrace_set_filter_ip(&stub_ops, ip, 1, 0);\n\t\tgoto out_lock;\n\t}\n\n\tentry->direct = new_addr;\n\n\t/*\n\t * By removing the stub, we put back the direct call, calling\n\t * the @new_addr.\n\t */\n\tunregister_ftrace_function(&stub_ops);\n\tftrace_set_filter_ip(&stub_ops, ip, 1, 0);\n\n out_lock:\n\tmutex_lock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_ftrace_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5216-5256",
    "snippet": "int unregister_ftrace_direct(unsigned long ip, unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *hash;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&direct_mutex);\n\n\tentry = find_direct_entry(&ip, NULL);\n\tif (!entry)\n\t\tgoto out_unlock;\n\n\thash = direct_ops.func_hash->filter_hash;\n\tif (hash->count == 1)\n\t\tunregister_ftrace_function(&direct_ops);\n\n\tret = ftrace_set_filter_ip(&direct_ops, ip, 1, 0);\n\n\tWARN_ON(ret);\n\n\tremove_hash_entry(direct_functions, entry);\n\n\tdirect = ftrace_find_direct_func(addr);\n\tif (!WARN_ON(!direct)) {\n\t\t/* This is the good path (see the ! before WARN) */\n\t\tdirect->count--;\n\t\tWARN_ON(direct->count < 0);\n\t\tif (!direct->count) {\n\t\t\tlist_del_rcu(&direct->next);\n\t\t\tsynchronize_rcu_tasks();\n\t\t\tkfree(direct);\n\t\t\tkfree(entry);\n\t\t\tftrace_direct_func_count--;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&direct_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5253
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 5248
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks",
          "args": [],
          "line": 5246
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1556-1560",
          "snippet": "void synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&direct->next"
          ],
          "line": 5245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "direct->count < 0"
          ],
          "line": 5243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!direct"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_direct_func",
          "args": [
            "addr"
          ],
          "line": 5239
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_direct_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5058-5074",
          "snippet": "struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *entry;\n\tbool found = false;\n\n\t/* May be called by fgraph trampoline (protected by rcu tasks) */\n\tlist_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {\n\t\tif (entry->addr == addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn entry;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *entry;\n\tbool found = false;\n\n\t/* May be called by fgraph trampoline (protected by rcu tasks) */\n\tlist_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {\n\t\tif (entry->addr == addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn entry;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "direct_functions",
            "entry"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1179-1185",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 5235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&direct_ops",
            "ip",
            "1",
            "0"
          ],
          "line": 5233
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5633-5638",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&direct_ops"
          ],
          "line": 5231
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_direct_entry",
          "args": [
            "&ip",
            "NULL"
          ],
          "line": 5225
        },
        "resolved": true,
        "details": {
          "function_name": "find_direct_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5189-5214",
          "snippet": "static struct ftrace_func_entry *find_direct_entry(unsigned long *ip,\n\t\t\t\t\t\t   struct dyn_ftrace **recp)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(*ip, *ip);\n\tif (!rec)\n\t\treturn NULL;\n\n\tentry = __ftrace_lookup_ip(direct_functions, rec->ip);\n\tif (!entry) {\n\t\tWARN_ON(rec->flags & FTRACE_FL_DIRECT);\n\t\treturn NULL;\n\t}\n\n\tWARN_ON(!(rec->flags & FTRACE_FL_DIRECT));\n\n\t/* Passed in ip just needs to be on the call site */\n\t*ip = rec->ip;\n\n\tif (recp)\n\t\t*recp = rec;\n\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_func_entry *find_direct_entry(unsigned long *ip,\n\t\t\t\t\t\t   struct dyn_ftrace **recp)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(*ip, *ip);\n\tif (!rec)\n\t\treturn NULL;\n\n\tentry = __ftrace_lookup_ip(direct_functions, rec->ip);\n\tif (!entry) {\n\t\tWARN_ON(rec->flags & FTRACE_FL_DIRECT);\n\t\treturn NULL;\n\t}\n\n\tWARN_ON(!(rec->flags & FTRACE_FL_DIRECT));\n\n\t/* Passed in ip just needs to be on the call site */\n\t*ip = rec->ip;\n\n\tif (recp)\n\t\t*recp = rec;\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5223
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint unregister_ftrace_direct(unsigned long ip, unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *hash;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&direct_mutex);\n\n\tentry = find_direct_entry(&ip, NULL);\n\tif (!entry)\n\t\tgoto out_unlock;\n\n\thash = direct_ops.func_hash->filter_hash;\n\tif (hash->count == 1)\n\t\tunregister_ftrace_function(&direct_ops);\n\n\tret = ftrace_set_filter_ip(&direct_ops, ip, 1, 0);\n\n\tWARN_ON(ret);\n\n\tremove_hash_entry(direct_functions, entry);\n\n\tdirect = ftrace_find_direct_func(addr);\n\tif (!WARN_ON(!direct)) {\n\t\t/* This is the good path (see the ! before WARN) */\n\t\tdirect->count--;\n\t\tWARN_ON(direct->count < 0);\n\t\tif (!direct->count) {\n\t\t\tlist_del_rcu(&direct->next);\n\t\t\tsynchronize_rcu_tasks();\n\t\t\tkfree(direct);\n\t\t\tkfree(entry);\n\t\t\tftrace_direct_func_count--;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&direct_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_direct_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5189-5214",
    "snippet": "static struct ftrace_func_entry *find_direct_entry(unsigned long *ip,\n\t\t\t\t\t\t   struct dyn_ftrace **recp)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(*ip, *ip);\n\tif (!rec)\n\t\treturn NULL;\n\n\tentry = __ftrace_lookup_ip(direct_functions, rec->ip);\n\tif (!entry) {\n\t\tWARN_ON(rec->flags & FTRACE_FL_DIRECT);\n\t\treturn NULL;\n\t}\n\n\tWARN_ON(!(rec->flags & FTRACE_FL_DIRECT));\n\n\t/* Passed in ip just needs to be on the call site */\n\t*ip = rec->ip;\n\n\tif (recp)\n\t\t*recp = rec;\n\n\treturn entry;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(rec->flags & FTRACE_FL_DIRECT)"
          ],
          "line": 5205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rec->flags & FTRACE_FL_DIRECT"
          ],
          "line": 5201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "direct_functions",
            "rec->ip"
          ],
          "line": 5199
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1108-1123",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_rec",
          "args": [
            "*ip",
            "*ip"
          ],
          "line": 5195
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1525-1545",
          "snippet": "static struct dyn_ftrace *lookup_rec(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec = NULL;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\treturn rec;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct dyn_ftrace *lookup_rec(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec = NULL;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\treturn rec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_func_entry *find_direct_entry(unsigned long *ip,\n\t\t\t\t\t\t   struct dyn_ftrace **recp)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(*ip, *ip);\n\tif (!rec)\n\t\treturn NULL;\n\n\tentry = __ftrace_lookup_ip(direct_functions, rec->ip);\n\tif (!entry) {\n\t\tWARN_ON(rec->flags & FTRACE_FL_DIRECT);\n\t\treturn NULL;\n\t}\n\n\tWARN_ON(!(rec->flags & FTRACE_FL_DIRECT));\n\n\t/* Passed in ip just needs to be on the call site */\n\t*ip = rec->ip;\n\n\tif (recp)\n\t\t*recp = rec;\n\n\treturn entry;\n}"
  },
  {
    "function_name": "register_ftrace_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5107-5186",
    "snippet": "int register_ftrace_direct(unsigned long ip, unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *free_hash = NULL;\n\tstruct dyn_ftrace *rec;\n\tint ret = -EBUSY;\n\n\tmutex_lock(&direct_mutex);\n\n\t/* See if there's a direct function at @ip already */\n\tif (ftrace_find_rec_direct(ip))\n\t\tgoto out_unlock;\n\n\tret = -ENODEV;\n\trec = lookup_rec(ip, ip);\n\tif (!rec)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check if the rec says it has a direct call but we didn't\n\t * find one earlier?\n\t */\n\tif (WARN_ON(rec->flags & FTRACE_FL_DIRECT))\n\t\tgoto out_unlock;\n\n\t/* Make sure the ip points to the exact record */\n\tif (ip != rec->ip) {\n\t\tip = rec->ip;\n\t\t/* Need to check this ip for a direct. */\n\t\tif (ftrace_find_rec_direct(ip))\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = -ENOMEM;\n\tdirect = ftrace_find_direct_func(addr);\n\tif (!direct) {\n\t\tdirect = ftrace_alloc_direct_func(addr);\n\t\tif (!direct)\n\t\t\tgoto out_unlock;\n\t}\n\n\tentry = ftrace_add_rec_direct(ip, addr, &free_hash);\n\tif (!entry)\n\t\tgoto out_unlock;\n\n\tret = ftrace_set_filter_ip(&direct_ops, ip, 0, 0);\n\tif (ret)\n\t\tremove_hash_entry(direct_functions, entry);\n\n\tif (!ret && !(direct_ops.flags & FTRACE_OPS_FL_ENABLED)) {\n\t\tret = register_ftrace_function(&direct_ops);\n\t\tif (ret)\n\t\t\tftrace_set_filter_ip(&direct_ops, ip, 1, 0);\n\t}\n\n\tif (ret) {\n\t\tkfree(entry);\n\t\tif (!direct->count) {\n\t\t\tlist_del_rcu(&direct->next);\n\t\t\tsynchronize_rcu_tasks();\n\t\t\tkfree(direct);\n\t\t\tif (free_hash)\n\t\t\t\tfree_ftrace_hash(free_hash);\n\t\t\tfree_hash = NULL;\n\t\t\tftrace_direct_func_count--;\n\t\t}\n\t} else {\n\t\tdirect->count++;\n\t}\n out_unlock:\n\tmutex_unlock(&direct_mutex);\n\n\tif (free_hash) {\n\t\tsynchronize_rcu_tasks();\n\t\tfree_ftrace_hash(free_hash);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "free_hash"
          ],
          "line": 5182
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks",
          "args": [],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1556-1560",
          "snippet": "void synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5178
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "direct"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&direct->next"
          ],
          "line": 5166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&direct_ops",
            "ip",
            "1",
            "0"
          ],
          "line": 5160
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5633-5638",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&direct_ops"
          ],
          "line": 5158
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "direct_functions",
            "entry"
          ],
          "line": 5155
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1179-1185",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_add_rec_direct",
          "args": [
            "ip",
            "addr",
            "&free_hash"
          ],
          "line": 5149
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_add_rec_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2393-2424",
          "snippet": "static struct ftrace_func_entry*\nftrace_add_rec_direct(unsigned long ip, unsigned long addr,\n\t\t      struct ftrace_hash **free_hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(direct_functions) ||\n\t    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {\n\t\tstruct ftrace_hash *new_hash;\n\t\tint size = ftrace_hash_empty(direct_functions) ? 0 :\n\t\t\tdirect_functions->count + 1;\n\n\t\tif (size < 32)\n\t\t\tsize = 32;\n\n\t\tnew_hash = dup_hash(direct_functions, size);\n\t\tif (!new_hash)\n\t\t\treturn NULL;\n\n\t\t*free_hash = direct_functions;\n\t\tdirect_functions = new_hash;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->ip = ip;\n\tentry->direct = addr;\n\t__add_hash_entry(direct_functions, entry);\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_func_entry*\nftrace_add_rec_direct(unsigned long ip, unsigned long addr,\n\t\t      struct ftrace_hash **free_hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(direct_functions) ||\n\t    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {\n\t\tstruct ftrace_hash *new_hash;\n\t\tint size = ftrace_hash_empty(direct_functions) ? 0 :\n\t\t\tdirect_functions->count + 1;\n\n\t\tif (size < 32)\n\t\t\tsize = 32;\n\n\t\tnew_hash = dup_hash(direct_functions, size);\n\t\tif (!new_hash)\n\t\t\treturn NULL;\n\n\t\t*free_hash = direct_functions;\n\t\tdirect_functions = new_hash;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->ip = ip;\n\tentry->direct = addr;\n\t__add_hash_entry(direct_functions, entry);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_alloc_direct_func",
          "args": [
            "addr"
          ],
          "line": 5144
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_alloc_direct_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5076-5088",
          "snippet": "static struct ftrace_direct_func *ftrace_alloc_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\n\tdirect = kmalloc(sizeof(*direct), GFP_KERNEL);\n\tif (!direct)\n\t\treturn NULL;\n\tdirect->addr = addr;\n\tdirect->count = 0;\n\tlist_add_rcu(&direct->next, &ftrace_direct_funcs);\n\tftrace_direct_func_count++;\n\treturn direct;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_direct_func *ftrace_alloc_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\n\tdirect = kmalloc(sizeof(*direct), GFP_KERNEL);\n\tif (!direct)\n\t\treturn NULL;\n\tdirect->addr = addr;\n\tdirect->count = 0;\n\tlist_add_rcu(&direct->next, &ftrace_direct_funcs);\n\tftrace_direct_func_count++;\n\treturn direct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_direct_func",
          "args": [
            "addr"
          ],
          "line": 5142
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_direct_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5058-5074",
          "snippet": "struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *entry;\n\tbool found = false;\n\n\t/* May be called by fgraph trampoline (protected by rcu tasks) */\n\tlist_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {\n\t\tif (entry->addr == addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn entry;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *entry;\n\tbool found = false;\n\n\t/* May be called by fgraph trampoline (protected by rcu tasks) */\n\tlist_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {\n\t\tif (entry->addr == addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn entry;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_rec_direct",
          "args": [
            "ip"
          ],
          "line": 5137
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_rec_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2382-2391",
          "snippet": "unsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rec->flags & FTRACE_FL_DIRECT"
          ],
          "line": 5130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rec",
          "args": [
            "ip",
            "ip"
          ],
          "line": 5122
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1525-1545",
          "snippet": "static struct dyn_ftrace *lookup_rec(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec = NULL;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\treturn rec;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct dyn_ftrace *lookup_rec(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec = NULL;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\treturn rec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&direct_mutex"
          ],
          "line": 5115
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint register_ftrace_direct(unsigned long ip, unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *free_hash = NULL;\n\tstruct dyn_ftrace *rec;\n\tint ret = -EBUSY;\n\n\tmutex_lock(&direct_mutex);\n\n\t/* See if there's a direct function at @ip already */\n\tif (ftrace_find_rec_direct(ip))\n\t\tgoto out_unlock;\n\n\tret = -ENODEV;\n\trec = lookup_rec(ip, ip);\n\tif (!rec)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check if the rec says it has a direct call but we didn't\n\t * find one earlier?\n\t */\n\tif (WARN_ON(rec->flags & FTRACE_FL_DIRECT))\n\t\tgoto out_unlock;\n\n\t/* Make sure the ip points to the exact record */\n\tif (ip != rec->ip) {\n\t\tip = rec->ip;\n\t\t/* Need to check this ip for a direct. */\n\t\tif (ftrace_find_rec_direct(ip))\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = -ENOMEM;\n\tdirect = ftrace_find_direct_func(addr);\n\tif (!direct) {\n\t\tdirect = ftrace_alloc_direct_func(addr);\n\t\tif (!direct)\n\t\t\tgoto out_unlock;\n\t}\n\n\tentry = ftrace_add_rec_direct(ip, addr, &free_hash);\n\tif (!entry)\n\t\tgoto out_unlock;\n\n\tret = ftrace_set_filter_ip(&direct_ops, ip, 0, 0);\n\tif (ret)\n\t\tremove_hash_entry(direct_functions, entry);\n\n\tif (!ret && !(direct_ops.flags & FTRACE_OPS_FL_ENABLED)) {\n\t\tret = register_ftrace_function(&direct_ops);\n\t\tif (ret)\n\t\t\tftrace_set_filter_ip(&direct_ops, ip, 1, 0);\n\t}\n\n\tif (ret) {\n\t\tkfree(entry);\n\t\tif (!direct->count) {\n\t\t\tlist_del_rcu(&direct->next);\n\t\t\tsynchronize_rcu_tasks();\n\t\t\tkfree(direct);\n\t\t\tif (free_hash)\n\t\t\t\tfree_ftrace_hash(free_hash);\n\t\t\tfree_hash = NULL;\n\t\t\tftrace_direct_func_count--;\n\t\t}\n\t} else {\n\t\tdirect->count++;\n\t}\n out_unlock:\n\tmutex_unlock(&direct_mutex);\n\n\tif (free_hash) {\n\t\tsynchronize_rcu_tasks();\n\t\tfree_ftrace_hash(free_hash);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_alloc_direct_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5076-5088",
    "snippet": "static struct ftrace_direct_func *ftrace_alloc_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\n\tdirect = kmalloc(sizeof(*direct), GFP_KERNEL);\n\tif (!direct)\n\t\treturn NULL;\n\tdirect->addr = addr;\n\tdirect->count = 0;\n\tlist_add_rcu(&direct->next, &ftrace_direct_funcs);\n\tftrace_direct_func_count++;\n\treturn direct;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&direct->next",
            "&ftrace_direct_funcs"
          ],
          "line": 5085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*direct)",
            "GFP_KERNEL"
          ],
          "line": 5080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_direct_func *ftrace_alloc_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *direct;\n\n\tdirect = kmalloc(sizeof(*direct), GFP_KERNEL);\n\tif (!direct)\n\t\treturn NULL;\n\tdirect->addr = addr;\n\tdirect->count = 0;\n\tlist_add_rcu(&direct->next, &ftrace_direct_funcs);\n\tftrace_direct_func_count++;\n\treturn direct;\n}"
  },
  {
    "function_name": "ftrace_find_direct_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5058-5074",
    "snippet": "struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *entry;\n\tbool found = false;\n\n\t/* May be called by fgraph trampoline (protected by rcu tasks) */\n\tlist_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {\n\t\tif (entry->addr == addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn entry;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "entry",
            "&ftrace_direct_funcs",
            "next"
          ],
          "line": 5064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)\n{\n\tstruct ftrace_direct_func *entry;\n\tbool found = false;\n\n\t/* May be called by fgraph trampoline (protected by rcu tasks) */\n\tlist_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {\n\t\tif (entry->addr == addr) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\treturn entry;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_set_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "5028-5033",
    "snippet": "static int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, NULL, 0, ip, remove, reset, enable);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_hash",
          "args": [
            "ops",
            "NULL",
            "0",
            "ip",
            "remove",
            "reset",
            "enable"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4979-5026",
          "snippet": "static int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, NULL, 0, ip, remove, reset, enable);\n}"
  },
  {
    "function_name": "ftrace_set_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4979-5026",
    "snippet": "static int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "hash"
          ],
          "line": 5024
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ops->func_hash->regex_lock"
          ],
          "line": 5022
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "ops",
            "orig_hash",
            "hash",
            "enable"
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4123-4141",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5017
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_addr",
          "args": [
            "hash",
            "ip",
            "remove"
          ],
          "line": 5012
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4960-4977",
          "snippet": "static int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_records",
          "args": [
            "hash",
            "buf",
            "len"
          ],
          "line": 5007
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_records",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4086-4090",
          "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS",
            "*orig_hash"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1310-1346",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS"
          ],
          "line": 4998
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1259-1279",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_match_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4960-4977",
    "snippet": "static int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_hash_entry",
          "args": [
            "hash",
            "ip"
          ],
          "line": 4976
        },
        "resolved": true,
        "details": {
          "function_name": "add_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1156-1168",
          "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 4972
        },
        "resolved": true,
        "details": {
          "function_name": "free_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1170-1177",
          "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "hash",
            "ip"
          ],
          "line": 4969
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_location",
          "args": [
            "ip"
          ],
          "line": 4965
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_location",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1579-1582",
          "snippet": "unsigned long ftrace_location(unsigned long ip)\n{\n\treturn ftrace_location_range(ip, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location(unsigned long ip)\n{\n\treturn ftrace_location_range(ip, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}"
  },
  {
    "function_name": "ftrace_notrace_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4953-4958",
    "snippet": "ssize_t\nftrace_notrace_write(struct file *file, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_write",
          "args": [
            "file",
            "ubuf",
            "cnt",
            "ppos",
            "0"
          ],
          "line": 4957
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4907-4944",
          "snippet": "static ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nssize_t\nftrace_notrace_write(struct file *file, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 0);\n}"
  },
  {
    "function_name": "ftrace_filter_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4946-4951",
    "snippet": "ssize_t\nftrace_filter_write(struct file *file, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_write",
          "args": [
            "file",
            "ubuf",
            "cnt",
            "ppos",
            "1"
          ],
          "line": 4950
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4907-4944",
          "snippet": "static ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nssize_t\nftrace_filter_write(struct file *file, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 1);\n}"
  },
  {
    "function_name": "ftrace_regex_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4907-4944",
    "snippet": "static ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parser_clear",
          "args": [
            "parser"
          ],
          "line": 4936
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1138-1142",
          "snippet": "static inline void trace_parser_clear(struct trace_parser *parser)\n{\n\tparser->cont = false;\n\tparser->idx = 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_parser_clear(struct trace_parser *parser)\n{\n\tparser->cont = false;\n\tparser->idx = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_process_regex",
          "args": [
            "iter",
            "parser->buffer",
            "parser->idx",
            "enable"
          ],
          "line": 4934
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_process_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4870-4905",
          "snippet": "static int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_cont",
          "args": [
            "parser"
          ],
          "line": 4933
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_cont",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1133-1136",
          "snippet": "static inline bool trace_parser_cont(struct trace_parser *parser)\n{\n\treturn parser->cont;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_cont(struct trace_parser *parser)\n{\n\treturn parser->cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "parser"
          ],
          "line": 4932
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1128-1131",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_user",
          "args": [
            "parser",
            "ubuf",
            "cnt",
            "ppos"
          ],
          "line": 4930
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1575-1650",
          "snippet": "int trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_process_regex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4870-4905",
    "snippet": "static int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4902
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->func",
          "args": [
            "tr",
            "hash",
            "func",
            "command",
            "next",
            "enable"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p->name",
            "command"
          ],
          "line": 4896
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&ftrace_commands",
            "list"
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4894
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&next",
            "\":\""
          ],
          "line": 4892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_match_records",
          "args": [
            "hash",
            "func",
            "len"
          ],
          "line": 4882
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_records",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4086-4090",
          "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&next",
            "\":\""
          ],
          "line": 4879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_ftrace_command",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4851-4868",
    "snippet": "__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4865
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->list"
          ],
          "line": 4860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "p->name"
          ],
          "line": 4858
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "&ftrace_commands",
            "list"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4856
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_ftrace_command",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4828-4845",
    "snippet": "__init int register_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &ftrace_commands);\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4842
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cmd->list",
            "&ftrace_commands"
          ],
          "line": 4840
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "p->name"
          ],
          "line": 4835
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&ftrace_commands",
            "list"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4833
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int register_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &ftrace_commands);\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "clear_ftrace_function_probes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4813-4819",
    "snippet": "void clear_ftrace_function_probes(struct trace_array *tr)\n{\n\tstruct ftrace_func_probe *probe, *n;\n\n\tlist_for_each_entry_safe(probe, n, &tr->func_probes, list)\n\t\tunregister_ftrace_function_probe_func(NULL, tr, probe->probe_ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function_probe_func",
          "args": [
            "NULL",
            "tr",
            "probe->probe_ops"
          ],
          "line": 4818
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function_probe_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4684-4811",
          "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "probe",
            "n",
            "&tr->func_probes",
            "list"
          ],
          "line": 4817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid clear_ftrace_function_probes(struct trace_array *tr)\n{\n\tstruct ftrace_func_probe *probe, *n;\n\n\tlist_for_each_entry_safe(probe, n, &tr->func_probes, list)\n\t\tunregister_ftrace_function_probe_func(NULL, tr, probe->probe_ops);\n}"
  },
  {
    "function_name": "unregister_ftrace_function_probe_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4684-4811",
    "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4809
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_probe",
          "args": [
            "probe"
          ],
          "line": 4804
        },
        "resolved": true,
        "details": {
          "function_name": "release_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4507-4530",
          "snippet": "static void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "hash"
          ],
          "line": 4802
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 4796
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_ops->free",
          "args": [
            "probe_ops",
            "tr",
            "entry->ip",
            "probe->data"
          ],
          "line": 4795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&entry->hlist"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "&hhd",
            "hlist"
          ],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 4790
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_run_modify_code",
          "args": [
            "&probe->ops",
            "FTRACE_UPDATE_CALLS",
            "&old_hash_ops"
          ],
          "line": 4788
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_modify_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2809-2819",
          "snippet": "static void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 4787
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "&probe->ops",
            "orig_hash",
            "hash",
            "1"
          ],
          "line": 4783
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4123-4141",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown",
          "args": [
            "&probe->ops",
            "0"
          ],
          "line": 4781
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2937-3049",
          "snippet": "int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tsynchronize_rcu_tasks_rude();\n\n\t\t/*\n\t\t * When the kernel is preemptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchronize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tsynchronize_rcu_tasks_rude();\n\n\t\t/*\n\t\t * When the kernel is preemptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchronize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "probe->ref < count"
          ],
          "line": 4776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4774
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&entry->hlist",
            "&hhd"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 4763
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1179-1185",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match",
          "args": [
            "str",
            "&func_g"
          ],
          "line": 4759
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3910-3943",
          "snippet": "static int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "entry->ip",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 4757
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 4754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&hhd"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS",
            "old_hash"
          ],
          "line": 4746
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1310-1346",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_probe_locked",
          "args": [
            "probe"
          ],
          "line": 4729
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_probe_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4532-4539",
          "snippet": "static void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "probe",
            "&tr->func_probes",
            "list"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "not"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_g.search"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_parse_regex",
          "args": [
            "glob",
            "strlen(glob)",
            "&func_g.search",
            "&not"
          ],
          "line": 4707
        },
        "resolved": true,
        "details": {
          "function_name": "filter_parse_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "915-954",
          "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "glob",
            "\"*\""
          ],
          "line": 4702
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "register_ftrace_function_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4541-4682",
    "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_ops->free",
          "args": [
            "probe_ops",
            "tr",
            "entry->ip",
            "probe->data"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "old_hash",
            "entry->ip"
          ],
          "line": 4676
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_probe",
          "args": [
            "probe"
          ],
          "line": 4665
        },
        "resolved": true,
        "details": {
          "function_name": "release_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4507-4530",
          "snippet": "static void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "hash"
          ],
          "line": 4663
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probe->ops.func_hash->regex_lock"
          ],
          "line": 4662
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup",
          "args": [
            "&probe->ops",
            "0"
          ],
          "line": 4654
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2893-2935",
          "snippet": "int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tftrace_trampoline_free(ops);\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tftrace_trampoline_free(ops);\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "&probe->ops",
            "orig_hash",
            "hash",
            "1"
          ],
          "line": 4645
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4123-4141",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_ops->free",
          "args": [
            "probe_ops",
            "tr",
            "0",
            "probe->data"
          ],
          "line": 4627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_ops->init",
          "args": [
            "probe_ops",
            "tr",
            "entry->ip",
            "data",
            "&probe->data"
          ],
          "line": 4622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 4613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_match_records",
          "args": [
            "hash",
            "glob",
            "strlen(glob)"
          ],
          "line": 4602
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_records",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4086-4090",
          "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "glob"
          ],
          "line": 4602
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS",
            "old_hash"
          ],
          "line": 4595
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1310-1346",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_probe_locked",
          "args": [
            "probe"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_probe_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4532-4539",
          "snippet": "static void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&probe->list",
            "&tr->func_probes"
          ],
          "line": 4580
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "&probe->ops"
          ],
          "line": 4579
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*probe)",
            "GFP_KERNEL"
          ],
          "line": 4571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "probe",
            "&tr->func_probes",
            "list"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "glob[0] == '!'"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tr"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
  },
  {
    "function_name": "acquire_probe_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4532-4539",
    "snippet": "static void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}"
  },
  {
    "function_name": "release_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4507-4530",
    "snippet": "static void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "probe"
          ],
          "line": 4527
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&probe->list"
          ],
          "line": 4526
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_ops->free",
          "args": [
            "probe_ops",
            "probe->tr",
            "0",
            "probe->data"
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "probe->ref <= 0"
          ],
          "line": 4513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4511
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "free_ftrace_func_mapper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4483-4505",
    "snippet": "void free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size, i;\n\n\tif (!mapper)\n\t\treturn;\n\n\tif (free_func && mapper->hash.count) {\n\t\tsize = 1 << mapper->hash.size_bits;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "&mapper->hash"
          ],
          "line": 4504
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_func",
          "args": [
            "map"
          ],
          "line": 4500
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_func_nop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/core.c",
          "lines": "468-472",
          "snippet": "static void klp_free_func_nop(struct klp_func *func)\n{\n\tkfree(func->old_name);\n\tkfree(func);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"state.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/memory.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void klp_init_func_early(struct klp_object *obj,\n\t\t\t\tstruct klp_func *func);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/memory.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_init_func_early(struct klp_object *obj,\n\t\t\t\tstruct klp_func *func);\n\nstatic void klp_free_func_nop(struct klp_func *func)\n{\n\tkfree(func->old_name);\n\tkfree(func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "hhd",
            "hlist"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size, i;\n\n\tif (!mapper)\n\t\treturn;\n\n\tif (free_func && mapper->hash.count) {\n\t\tsize = 1 << mapper->hash.size_bits;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}"
  },
  {
    "function_name": "ftrace_func_mapper_remove_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4455-4473",
    "snippet": "void *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 4470
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "&mapper->hash",
            "entry"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1179-1185",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "&mapper->hash",
            "ip"
          ],
          "line": 4462
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}"
  },
  {
    "function_name": "ftrace_func_mapper_add_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4423-4443",
    "snippet": "int ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_hash_entry",
          "args": [
            "&mapper->hash",
            "&map->entry"
          ],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "__add_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1144-1154",
          "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*map)",
            "GFP_KERNEL"
          ],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "&mapper->hash",
            "ip"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_func_mapper_find_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4401-4413",
    "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "&mapper->hash",
            "ip"
          ],
          "line": 4407
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
  },
  {
    "function_name": "allocate_ftrace_func_mapper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4377-4388",
    "snippet": "struct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS"
          ],
          "line": 4386
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1259-1279",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstruct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}"
  },
  {
    "function_name": "function_trace_probe_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4344-4361",
    "snippet": "static void function_trace_probe_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t      struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = container_of(op, struct ftrace_func_probe, ops);\n\tprobe_ops = probe->probe_ops;\n\n\t/*\n\t * Disable preemption for these calls to prevent a RCU grace\n\t * period. This syncs the hash iteration and freeing of items\n\t * on the hash. rcu_read_lock is too dangerous here.\n\t */\n\tpreempt_disable_notrace();\n\tprobe_ops->func(ip, parent_ip, probe->tr, probe_ops, probe->data);\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_ops->func",
          "args": [
            "ip",
            "parent_ip",
            "probe->tr",
            "probe_ops",
            "probe->data"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op",
            "structftrace_func_probe",
            "ops"
          ],
          "line": 4350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void function_trace_probe_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t      struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = container_of(op, struct ftrace_func_probe, ops);\n\tprobe_ops = probe->probe_ops;\n\n\t/*\n\t * Disable preemption for these calls to prevent a RCU grace\n\t * period. This syncs the hash iteration and freeing of items\n\t * on the hash. rcu_read_lock is too dangerous here.\n\t */\n\tpreempt_disable_notrace();\n\tprobe_ops->func(ip, parent_ip, probe->tr, probe_ops, probe->data);\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "ftrace_mod_cmd_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4338-4341",
    "snippet": "static int __init ftrace_mod_cmd_init(void)\n{\n\treturn register_ftrace_command(&ftrace_mod_cmd);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_command",
          "args": [
            "&ftrace_mod_cmd"
          ],
          "line": 4340
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4851-4868",
          "snippet": "__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int __init ftrace_mod_cmd_init(void)\n{\n\treturn register_ftrace_command(&ftrace_mod_cmd);\n}"
  },
  {
    "function_name": "ftrace_mod_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4304-4331",
    "snippet": "static int\nftrace_mod_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t    char *func_orig, char *cmd, char *module, int enable)\n{\n\tchar *func;\n\tint ret;\n\n\t/* match_records() modifies func, and we need the original */\n\tfunc = kstrdup(func_orig, GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * cmd == 'mod' because we only registered this func\n\t * for the 'mod' ftrace_func_command.\n\t * But if you register one func with multiple commands,\n\t * you can tell which command was used by the cmd\n\t * parameter.\n\t */\n\tret = match_records(hash, func, strlen(func), module);\n\tkfree(func);\n\n\tif (!ret)\n\t\treturn cache_mod(tr, func_orig, module, enable);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_mod",
          "args": [
            "tr",
            "func_orig",
            "module",
            "enable"
          ],
          "line": 4327
        },
        "resolved": true,
        "details": {
          "function_name": "cache_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4160-4202",
          "snippet": "static int cache_mod(struct trace_array *tr,\n\t\t     const char *func, char *module, int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct list_head *head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* We do not cache inverse filters */\n\tif (func[0] == '!') {\n\t\tfunc++;\n\t\tret = -EINVAL;\n\n\t\t/* Look to remove this hash */\n\t\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\t\t\tif (strcmp(ftrace_mod->module, module) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* no func matches all */\n\t\t\tif (strcmp(func, \"*\") == 0 ||\n\t\t\t    (ftrace_mod->func &&\n\t\t\t     strcmp(ftrace_mod->func, func) == 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tfree_ftrace_mod(ftrace_mod);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\t/* We only care about modules that have not been loaded yet */\n\tif (module_exists(module))\n\t\tgoto out;\n\n\t/* Save this string off, and execute it when the module is loaded */\n\tret = ftrace_add_mod(tr, func, module, enable);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int cache_mod(struct trace_array *tr,\n\t\t     const char *func, char *module, int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct list_head *head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* We do not cache inverse filters */\n\tif (func[0] == '!') {\n\t\tfunc++;\n\t\tret = -EINVAL;\n\n\t\t/* Look to remove this hash */\n\t\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\t\t\tif (strcmp(ftrace_mod->module, module) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* no func matches all */\n\t\t\tif (strcmp(func, \"*\") == 0 ||\n\t\t\t    (ftrace_mod->func &&\n\t\t\t     strcmp(ftrace_mod->func, func) == 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tfree_ftrace_mod(ftrace_mod);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\t/* We only care about modules that have not been loaded yet */\n\tif (module_exists(module))\n\t\tgoto out;\n\n\t/* Save this string off, and execute it when the module is loaded */\n\tret = ftrace_add_mod(tr, func, module, enable);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "func"
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_records",
          "args": [
            "hash",
            "func",
            "strlen(func)",
            "module"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "match_records",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4031-4084",
          "snippet": "static int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tif (func_g.type == MATCH_INDEX) {\n\t\tfound = add_rec_by_index(hash, &func_g, clear_filter);\n\t\tgoto out_unlock;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tif (func_g.type == MATCH_INDEX) {\n\t\tfound = add_rec_by_index(hash, &func_g, clear_filter);\n\t\tgoto out_unlock;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "func_orig",
            "GFP_KERNEL"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_mod_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t    char *func_orig, char *cmd, char *module, int enable)\n{\n\tchar *func;\n\tint ret;\n\n\t/* match_records() modifies func, and we need the original */\n\tfunc = kstrdup(func_orig, GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * cmd == 'mod' because we only registered this func\n\t * for the 'mod' ftrace_func_command.\n\t * But if you register one func with multiple commands,\n\t * you can tell which command was used by the cmd\n\t * parameter.\n\t */\n\tret = match_records(hash, func, strlen(func), module);\n\tkfree(func);\n\n\tif (!ret)\n\t\treturn cache_mod(tr, func_orig, module, enable);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}"
  },
  {
    "function_name": "process_cached_mods",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4277-4296",
    "snippet": "static void process_cached_mods(const char *mod_name)\n{\n\tstruct trace_array *tr;\n\tchar *mod;\n\n\tmod = kstrdup(mod_name, GFP_KERNEL);\n\tif (!mod)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!list_empty(&tr->mod_trace))\n\t\t\tprocess_mod_list(&tr->mod_trace, tr->ops, mod, true);\n\t\tif (!list_empty(&tr->mod_notrace))\n\t\t\tprocess_mod_list(&tr->mod_notrace, tr->ops, mod, false);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\tkfree(mod);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mod"
          ],
          "line": 4295
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 4293
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_mod_list",
          "args": [
            "&tr->mod_notrace",
            "tr->ops",
            "mod",
            "false"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "process_mod_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4209-4275",
          "snippet": "static void process_mod_list(struct list_head *head, struct ftrace_ops *ops,\n\t\t\t     char *mod, bool enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct ftrace_hash **orig_hash, *new_hash;\n\tLIST_HEAD(process_mods);\n\tchar *func;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tnew_hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS,\n\t\t\t\t\t      *orig_hash);\n\tif (!new_hash)\n\t\tgoto out; /* warn? */\n\n\tmutex_lock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\n\t\tif (strcmp(ftrace_mod->module, mod) != 0)\n\t\t\tcontinue;\n\n\t\tif (ftrace_mod->func)\n\t\t\tfunc = kstrdup(ftrace_mod->func, GFP_KERNEL);\n\t\telse\n\t\t\tfunc = kstrdup(\"*\", GFP_KERNEL);\n\n\t\tif (!func) /* warn? */\n\t\t\tcontinue;\n\n\t\tlist_move(&ftrace_mod->list, &process_mods);\n\n\t\t/* Use the newly allocated func, as it may be \"*\" */\n\t\tkfree(ftrace_mod->func);\n\t\tftrace_mod->func = func;\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, &process_mods, list) {\n\n\t\tfunc = ftrace_mod->func;\n\n\t\t/* Grabs ftrace_lock, which is why we have this extra step */\n\t\tmatch_records(new_hash, func, strlen(func), mod);\n\t\tfree_ftrace_mod(ftrace_mod);\n\t}\n\n\tif (enable && list_empty(head))\n\t\tnew_hash->flags &= ~FTRACE_HASH_FL_MOD;\n\n\tmutex_lock(&ftrace_lock);\n\n\tftrace_hash_move_and_update_ops(ops, orig_hash,\n\t\t\t\t\t      new_hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(new_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void process_mod_list(struct list_head *head, struct ftrace_ops *ops,\n\t\t\t     char *mod, bool enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct ftrace_hash **orig_hash, *new_hash;\n\tLIST_HEAD(process_mods);\n\tchar *func;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tnew_hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS,\n\t\t\t\t\t      *orig_hash);\n\tif (!new_hash)\n\t\tgoto out; /* warn? */\n\n\tmutex_lock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\n\t\tif (strcmp(ftrace_mod->module, mod) != 0)\n\t\t\tcontinue;\n\n\t\tif (ftrace_mod->func)\n\t\t\tfunc = kstrdup(ftrace_mod->func, GFP_KERNEL);\n\t\telse\n\t\t\tfunc = kstrdup(\"*\", GFP_KERNEL);\n\n\t\tif (!func) /* warn? */\n\t\t\tcontinue;\n\n\t\tlist_move(&ftrace_mod->list, &process_mods);\n\n\t\t/* Use the newly allocated func, as it may be \"*\" */\n\t\tkfree(ftrace_mod->func);\n\t\tftrace_mod->func = func;\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, &process_mods, list) {\n\n\t\tfunc = ftrace_mod->func;\n\n\t\t/* Grabs ftrace_lock, which is why we have this extra step */\n\t\tmatch_records(new_hash, func, strlen(func), mod);\n\t\tfree_ftrace_mod(ftrace_mod);\n\t}\n\n\tif (enable && list_empty(head))\n\t\tnew_hash->flags &= ~FTRACE_HASH_FL_MOD;\n\n\tmutex_lock(&ftrace_lock);\n\n\tftrace_hash_move_and_update_ops(ops, orig_hash,\n\t\t\t\t\t      new_hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(new_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tr->mod_notrace"
          ],
          "line": 4290
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 4287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "mod_name",
            "GFP_KERNEL"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void process_cached_mods(const char *mod_name)\n{\n\tstruct trace_array *tr;\n\tchar *mod;\n\n\tmod = kstrdup(mod_name, GFP_KERNEL);\n\tif (!mod)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!list_empty(&tr->mod_trace))\n\t\t\tprocess_mod_list(&tr->mod_trace, tr->ops, mod, true);\n\t\tif (!list_empty(&tr->mod_notrace))\n\t\t\tprocess_mod_list(&tr->mod_notrace, tr->ops, mod, false);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\tkfree(mod);\n}"
  },
  {
    "function_name": "process_mod_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4209-4275",
    "snippet": "static void process_mod_list(struct list_head *head, struct ftrace_ops *ops,\n\t\t\t     char *mod, bool enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct ftrace_hash **orig_hash, *new_hash;\n\tLIST_HEAD(process_mods);\n\tchar *func;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tnew_hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS,\n\t\t\t\t\t      *orig_hash);\n\tif (!new_hash)\n\t\tgoto out; /* warn? */\n\n\tmutex_lock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\n\t\tif (strcmp(ftrace_mod->module, mod) != 0)\n\t\t\tcontinue;\n\n\t\tif (ftrace_mod->func)\n\t\t\tfunc = kstrdup(ftrace_mod->func, GFP_KERNEL);\n\t\telse\n\t\t\tfunc = kstrdup(\"*\", GFP_KERNEL);\n\n\t\tif (!func) /* warn? */\n\t\t\tcontinue;\n\n\t\tlist_move(&ftrace_mod->list, &process_mods);\n\n\t\t/* Use the newly allocated func, as it may be \"*\" */\n\t\tkfree(ftrace_mod->func);\n\t\tftrace_mod->func = func;\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, &process_mods, list) {\n\n\t\tfunc = ftrace_mod->func;\n\n\t\t/* Grabs ftrace_lock, which is why we have this extra step */\n\t\tmatch_records(new_hash, func, strlen(func), mod);\n\t\tfree_ftrace_mod(ftrace_mod);\n\t}\n\n\tif (enable && list_empty(head))\n\t\tnew_hash->flags &= ~FTRACE_HASH_FL_MOD;\n\n\tmutex_lock(&ftrace_lock);\n\n\tftrace_hash_move_and_update_ops(ops, orig_hash,\n\t\t\t\t\t      new_hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(new_hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "new_hash"
          ],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ops->func_hash->regex_lock"
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "ops",
            "orig_hash",
            "new_hash",
            "enable"
          ],
          "line": 4267
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4123-4141",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4265
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 4262
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_mod",
          "args": [
            "ftrace_mod"
          ],
          "line": 4259
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1206-1212",
          "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_records",
          "args": [
            "new_hash",
            "func",
            "strlen(func)",
            "mod"
          ],
          "line": 4258
        },
        "resolved": true,
        "details": {
          "function_name": "match_records",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4031-4084",
          "snippet": "static int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tif (func_g.type == MATCH_INDEX) {\n\t\tfound = add_rec_by_index(hash, &func_g, clear_filter);\n\t\tgoto out_unlock;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tif (func_g.type == MATCH_INDEX) {\n\t\tfound = add_rec_by_index(hash, &func_g, clear_filter);\n\t\tgoto out_unlock;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func"
          ],
          "line": 4258
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ftrace_mod",
            "n",
            "&process_mods",
            "list"
          ],
          "line": 4253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ftrace_mod->func"
          ],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&ftrace_mod->list",
            "&process_mods"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"*\"",
            "GFP_KERNEL"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "ftrace_mod->func",
            "GFP_KERNEL"
          ],
          "line": 4237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ftrace_mod->module",
            "mod"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ftrace_mod",
            "n",
            "head",
            "list"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS",
            "*orig_hash"
          ],
          "line": 4224
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1310-1346",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "process_mods"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void process_mod_list(struct list_head *head, struct ftrace_ops *ops,\n\t\t\t     char *mod, bool enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct ftrace_hash **orig_hash, *new_hash;\n\tLIST_HEAD(process_mods);\n\tchar *func;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tnew_hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS,\n\t\t\t\t\t      *orig_hash);\n\tif (!new_hash)\n\t\tgoto out; /* warn? */\n\n\tmutex_lock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\n\t\tif (strcmp(ftrace_mod->module, mod) != 0)\n\t\t\tcontinue;\n\n\t\tif (ftrace_mod->func)\n\t\t\tfunc = kstrdup(ftrace_mod->func, GFP_KERNEL);\n\t\telse\n\t\t\tfunc = kstrdup(\"*\", GFP_KERNEL);\n\n\t\tif (!func) /* warn? */\n\t\t\tcontinue;\n\n\t\tlist_move(&ftrace_mod->list, &process_mods);\n\n\t\t/* Use the newly allocated func, as it may be \"*\" */\n\t\tkfree(ftrace_mod->func);\n\t\tftrace_mod->func = func;\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, &process_mods, list) {\n\n\t\tfunc = ftrace_mod->func;\n\n\t\t/* Grabs ftrace_lock, which is why we have this extra step */\n\t\tmatch_records(new_hash, func, strlen(func), mod);\n\t\tfree_ftrace_mod(ftrace_mod);\n\t}\n\n\tif (enable && list_empty(head))\n\t\tnew_hash->flags &= ~FTRACE_HASH_FL_MOD;\n\n\tmutex_lock(&ftrace_lock);\n\n\tftrace_hash_move_and_update_ops(ops, orig_hash,\n\t\t\t\t\t      new_hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(new_hash);\n}"
  },
  {
    "function_name": "cache_mod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4160-4202",
    "snippet": "static int cache_mod(struct trace_array *tr,\n\t\t     const char *func, char *module, int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct list_head *head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* We do not cache inverse filters */\n\tif (func[0] == '!') {\n\t\tfunc++;\n\t\tret = -EINVAL;\n\n\t\t/* Look to remove this hash */\n\t\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\t\t\tif (strcmp(ftrace_mod->module, module) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* no func matches all */\n\t\t\tif (strcmp(func, \"*\") == 0 ||\n\t\t\t    (ftrace_mod->func &&\n\t\t\t     strcmp(ftrace_mod->func, func) == 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tfree_ftrace_mod(ftrace_mod);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\t/* We only care about modules that have not been loaded yet */\n\tif (module_exists(module))\n\t\tgoto out;\n\n\t/* Save this string off, and execute it when the module is loaded */\n\tret = ftrace_add_mod(tr, func, module, enable);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4199
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_add_mod",
          "args": [
            "tr",
            "func",
            "module",
            "enable"
          ],
          "line": 4197
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_add_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1282-1308",
          "snippet": "static int ftrace_add_mod(struct trace_array *tr,\n\t\t\t  const char *func, const char *module,\n\t\t\t  int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct list_head *mod_head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\n\tftrace_mod = kzalloc(sizeof(*ftrace_mod), GFP_KERNEL);\n\tif (!ftrace_mod)\n\t\treturn -ENOMEM;\n\n\tftrace_mod->func = kstrdup(func, GFP_KERNEL);\n\tftrace_mod->module = kstrdup(module, GFP_KERNEL);\n\tftrace_mod->enable = enable;\n\n\tif (!ftrace_mod->func || !ftrace_mod->module)\n\t\tgoto out_free;\n\n\tlist_add(&ftrace_mod->list, mod_head);\n\n\treturn 0;\n\n out_free:\n\tfree_ftrace_mod(ftrace_mod);\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_add_mod(struct trace_array *tr,\n\t\t\t  const char *func, const char *module,\n\t\t\t  int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct list_head *mod_head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\n\tftrace_mod = kzalloc(sizeof(*ftrace_mod), GFP_KERNEL);\n\tif (!ftrace_mod)\n\t\treturn -ENOMEM;\n\n\tftrace_mod->func = kstrdup(func, GFP_KERNEL);\n\tftrace_mod->module = kstrdup(module, GFP_KERNEL);\n\tftrace_mod->enable = enable;\n\n\tif (!ftrace_mod->func || !ftrace_mod->module)\n\t\tgoto out_free;\n\n\tlist_add(&ftrace_mod->list, mod_head);\n\n\treturn 0;\n\n out_free:\n\tfree_ftrace_mod(ftrace_mod);\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_exists",
          "args": [
            "module"
          ],
          "line": 4193
        },
        "resolved": true,
        "details": {
          "function_name": "module_exists",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4143-4158",
          "snippet": "static bool module_exists(const char *module)\n{\n\t/* All modules have the symbol __this_module */\n\tstatic const char this_mod[] = \"__this_module\";\n\tchar modname[MAX_PARAM_PREFIX_LEN + sizeof(this_mod) + 2];\n\tunsigned long val;\n\tint n;\n\n\tn = snprintf(modname, sizeof(modname), \"%s:%s\", module, this_mod);\n\n\tif (n > sizeof(modname) - 1)\n\t\treturn false;\n\n\tval = module_kallsyms_lookup_name(modname);\n\treturn val != 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool module_exists(const char *module)\n{\n\t/* All modules have the symbol __this_module */\n\tstatic const char this_mod[] = \"__this_module\";\n\tchar modname[MAX_PARAM_PREFIX_LEN + sizeof(this_mod) + 2];\n\tunsigned long val;\n\tint n;\n\n\tn = snprintf(modname, sizeof(modname), \"%s:%s\", module, this_mod);\n\n\tif (n > sizeof(modname) - 1)\n\t\treturn false;\n\n\tval = module_kallsyms_lookup_name(modname);\n\treturn val != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_mod",
          "args": [
            "ftrace_mod"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1206-1212",
          "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ftrace_mod->func",
            "func"
          ],
          "line": 4182
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ftrace_mod",
            "n",
            "head",
            "list"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4167
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int cache_mod(struct trace_array *tr,\n\t\t     const char *func, char *module, int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct list_head *head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* We do not cache inverse filters */\n\tif (func[0] == '!') {\n\t\tfunc++;\n\t\tret = -EINVAL;\n\n\t\t/* Look to remove this hash */\n\t\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\t\t\tif (strcmp(ftrace_mod->module, module) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* no func matches all */\n\t\t\tif (strcmp(func, \"*\") == 0 ||\n\t\t\t    (ftrace_mod->func &&\n\t\t\t     strcmp(ftrace_mod->func, func) == 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tfree_ftrace_mod(ftrace_mod);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\t/* We only care about modules that have not been loaded yet */\n\tif (module_exists(module))\n\t\tgoto out;\n\n\t/* Save this string off, and execute it when the module is loaded */\n\tret = ftrace_add_mod(tr, func, module, enable);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "module_exists",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4143-4158",
    "snippet": "static bool module_exists(const char *module)\n{\n\t/* All modules have the symbol __this_module */\n\tstatic const char this_mod[] = \"__this_module\";\n\tchar modname[MAX_PARAM_PREFIX_LEN + sizeof(this_mod) + 2];\n\tunsigned long val;\n\tint n;\n\n\tn = snprintf(modname, sizeof(modname), \"%s:%s\", module, this_mod);\n\n\tif (n > sizeof(modname) - 1)\n\t\treturn false;\n\n\tval = module_kallsyms_lookup_name(modname);\n\treturn val != 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_kallsyms_lookup_name",
          "args": [
            "modname"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4466-4487",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "modname",
            "sizeof(modname)",
            "\"%s:%s\"",
            "module",
            "this_mod"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool module_exists(const char *module)\n{\n\t/* All modules have the symbol __this_module */\n\tstatic const char this_mod[] = \"__this_module\";\n\tchar modname[MAX_PARAM_PREFIX_LEN + sizeof(this_mod) + 2];\n\tunsigned long val;\n\tint n;\n\n\tn = snprintf(modname, sizeof(modname), \"%s:%s\", module, this_mod);\n\n\tif (n > sizeof(modname) - 1)\n\t\treturn false;\n\n\tval = module_kallsyms_lookup_name(modname);\n\treturn val != 0;\n}"
  },
  {
    "function_name": "ftrace_hash_move_and_update_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4123-4141",
    "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash_rcu",
          "args": [
            "old_hash"
          ],
          "line": 4138
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_update_code",
          "args": [
            "ops",
            "&old_hash_ops"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_update_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4092-4121",
          "snippet": "static void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED) {\n\t\tftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is the shared global_ops filter, then we need to\n\t * check if there is another ops that shares it, is enabled.\n\t * If so, we still need to run the modify code.\n\t */\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & FTRACE_OPS_FL_ENABLED) {\n\t\t\tftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);\n\t\t\t/* Only need to do this once */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "struct ftrace_ops global_ops;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED) {\n\t\tftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is the shared global_ops filter, then we need to\n\t * check if there is another ops that shares it, is enabled.\n\t * If so, we still need to run the modify code.\n\t */\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & FTRACE_OPS_FL_ENABLED) {\n\t\t\tftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);\n\t\t\t/* Only need to do this once */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move",
          "args": [
            "ops",
            "enable",
            "orig_hash",
            "hash"
          ],
          "line": 4135
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4123-4141",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_ops_update_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4092-4121",
    "snippet": "static void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED) {\n\t\tftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is the shared global_ops filter, then we need to\n\t * check if there is another ops that shares it, is enabled.\n\t * If so, we still need to run the modify code.\n\t */\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & FTRACE_OPS_FL_ENABLED) {\n\t\t\tftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);\n\t\t\t/* Only need to do this once */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 4120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_run_modify_code",
          "args": [
            "op",
            "FTRACE_UPDATE_CALLS",
            "old_hash"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_modify_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2809-2819",
          "snippet": "static void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED) {\n\t\tftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is the shared global_ops filter, then we need to\n\t * check if there is another ops that shares it, is enabled.\n\t * If so, we still need to run the modify code.\n\t */\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & FTRACE_OPS_FL_ENABLED) {\n\t\t\tftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);\n\t\t\t/* Only need to do this once */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}"
  },
  {
    "function_name": "ftrace_match_records",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4086-4090",
    "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_records",
          "args": [
            "hash",
            "buff",
            "len",
            "NULL"
          ],
          "line": 4089
        },
        "resolved": true,
        "details": {
          "function_name": "match_records",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4031-4084",
          "snippet": "static int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tif (func_g.type == MATCH_INDEX) {\n\t\tfound = add_rec_by_index(hash, &func_g, clear_filter);\n\t\tgoto out_unlock;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tif (func_g.type == MATCH_INDEX) {\n\t\tfound = add_rec_by_index(hash, &func_g, clear_filter);\n\t\tgoto out_unlock;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
  },
  {
    "function_name": "match_records",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "4031-4084",
    "snippet": "static int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tif (func_g.type == MATCH_INDEX) {\n\t\tfound = add_rec_by_index(hash, &func_g, clear_filter);\n\t\tgoto out_unlock;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_record",
          "args": [
            "hash",
            "rec",
            "clear_filter"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "enter_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3945-3966",
          "snippet": "static int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_record",
          "args": [
            "rec",
            "&func_g",
            "mod_match",
            "exclude_mod"
          ],
          "line": 4071
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3993-4029",
          "snippet": "static int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rec_by_index",
          "args": [
            "hash",
            "&func_g",
            "clear_filter"
          ],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "add_rec_by_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3968-3991",
          "snippet": "static int\nadd_rec_by_index(struct ftrace_hash *hash, struct ftrace_glob *func_g,\n\t\t int clear_filter)\n{\n\tlong index = simple_strtoul(func_g->search, NULL, 0);\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\n\t/* The index starts at 1 */\n\tif (--index < 0)\n\t\treturn 0;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tif (pg->index <= index) {\n\t\t\tindex -= pg->index;\n\t\t\t/* this is a double loop, break goes to the next page */\n\t\t\tbreak;\n\t\t}\n\t\trec = &pg->records[index];\n\t\tenter_record(hash, rec, clear_filter);\n\t\treturn 1;\n\t} while_for_each_ftrace_rec();\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nadd_rec_by_index(struct ftrace_hash *hash, struct ftrace_glob *func_g,\n\t\t int clear_filter)\n{\n\tlong index = simple_strtoul(func_g->search, NULL, 0);\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\n\t/* The index starts at 1 */\n\tif (--index < 0)\n\t\treturn 0;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tif (pg->index <= index) {\n\t\t\tindex -= pg->index;\n\t\t\t/* this is a double loop, break goes to the next page */\n\t\t\tbreak;\n\t\t}\n\t\trec = &pg->records[index];\n\t\tenter_record(hash, rec, clear_filter);\n\t\treturn 1;\n\t} while_for_each_ftrace_rec();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4056
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mod_g.search"
          ],
          "line": 4053
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_parse_regex",
          "args": [
            "mod",
            "strlen(mod)",
            "&mod_g.search",
            "&exclude_mod"
          ],
          "line": 4051
        },
        "resolved": true,
        "details": {
          "function_name": "filter_parse_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "915-954",
          "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tif (func_g.type == MATCH_INDEX) {\n\t\tfound = add_rec_by_index(hash, &func_g, clear_filter);\n\t\tgoto out_unlock;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}"
  },
  {
    "function_name": "ftrace_match_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3993-4029",
    "snippet": "static int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_match",
          "args": [
            "str",
            "func_g"
          ],
          "line": 4028
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3910-3943",
          "snippet": "static int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "rec->ip",
            "NULL",
            "NULL",
            "&modname",
            "str"
          ],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}"
  },
  {
    "function_name": "add_rec_by_index",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3968-3991",
    "snippet": "static int\nadd_rec_by_index(struct ftrace_hash *hash, struct ftrace_glob *func_g,\n\t\t int clear_filter)\n{\n\tlong index = simple_strtoul(func_g->search, NULL, 0);\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\n\t/* The index starts at 1 */\n\tif (--index < 0)\n\t\treturn 0;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tif (pg->index <= index) {\n\t\t\tindex -= pg->index;\n\t\t\t/* this is a double loop, break goes to the next page */\n\t\t\tbreak;\n\t\t}\n\t\trec = &pg->records[index];\n\t\tenter_record(hash, rec, clear_filter);\n\t\treturn 1;\n\t} while_for_each_ftrace_rec();\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_record",
          "args": [
            "hash",
            "rec",
            "clear_filter"
          ],
          "line": 3987
        },
        "resolved": true,
        "details": {
          "function_name": "enter_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3945-3966",
          "snippet": "static int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "func_g->search",
            "NULL",
            "0"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nadd_rec_by_index(struct ftrace_hash *hash, struct ftrace_glob *func_g,\n\t\t int clear_filter)\n{\n\tlong index = simple_strtoul(func_g->search, NULL, 0);\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\n\t/* The index starts at 1 */\n\tif (--index < 0)\n\t\treturn 0;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tif (pg->index <= index) {\n\t\t\tindex -= pg->index;\n\t\t\t/* this is a double loop, break goes to the next page */\n\t\t\tbreak;\n\t\t}\n\t\trec = &pg->records[index];\n\t\tenter_record(hash, rec, clear_filter);\n\t\treturn 1;\n\t} while_for_each_ftrace_rec();\n\treturn 0;\n}"
  },
  {
    "function_name": "enter_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3945-3966",
    "snippet": "static int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_hash_entry",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 3963
        },
        "resolved": true,
        "details": {
          "function_name": "add_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1156-1168",
          "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 3957
        },
        "resolved": true,
        "details": {
          "function_name": "free_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1170-1177",
          "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3910-3943",
    "snippet": "static int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "glob_match",
          "args": [
            "g->search",
            "str"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "str + slen - g->len",
            "g->search",
            "g->len"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "g->search"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "g->search",
            "g->len"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "g->search"
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_ftrace_match_adjust",
          "args": [
            "str",
            "g->search"
          ],
          "line": 3915
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_match_adjust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3905-3908",
          "snippet": "char * __weak arch_ftrace_match_adjust(char *str, const char *search)\n{\n\treturn str;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nchar * __weak arch_ftrace_match_adjust(char *str, const char *search)\n{\n\treturn str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}"
  },
  {
    "function_name": "arch_ftrace_match_adjust",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3905-3908",
    "snippet": "char * __weak arch_ftrace_match_adjust(char *str, const char *search)\n{\n\treturn str;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nchar * __weak arch_ftrace_match_adjust(char *str, const char *search)\n{\n\treturn str;\n}"
  },
  {
    "function_name": "ftrace_notrace_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3883-3891",
    "snippet": "static int\nftrace_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\t/* Checks for tracefs lockdown */\n\treturn ftrace_regex_open(ops, FTRACE_ITER_NOTRACE,\n\t\t\t\t inode, file);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_open",
          "args": [
            "ops",
            "FTRACE_ITER_NOTRACE",
            "inode",
            "file"
          ],
          "line": 3889
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3784-3870",
          "snippet": "int\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = -ENOMEM;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto out;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX))\n\t\tgoto out;\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n out:\n\tif (ret) {\n\t\tkfree(iter);\n\t\tif (tr)\n\t\t\ttrace_array_put(tr);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = -ENOMEM;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto out;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX))\n\t\tgoto out;\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n out:\n\tif (ret) {\n\t\tkfree(iter);\n\t\tif (tr)\n\t\t\ttrace_array_put(tr);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\t/* Checks for tracefs lockdown */\n\treturn ftrace_regex_open(ops, FTRACE_ITER_NOTRACE,\n\t\t\t\t inode, file);\n}"
  },
  {
    "function_name": "ftrace_filter_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3872-3881",
    "snippet": "static int\nftrace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\t/* Checks for tracefs lockdown */\n\treturn ftrace_regex_open(ops,\n\t\t\tFTRACE_ITER_FILTER | FTRACE_ITER_DO_PROBES,\n\t\t\tinode, file);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_open",
          "args": [
            "ops",
            "FTRACE_ITER_FILTER | FTRACE_ITER_DO_PROBES",
            "inode",
            "file"
          ],
          "line": 3878
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3784-3870",
          "snippet": "int\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = -ENOMEM;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto out;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX))\n\t\tgoto out;\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n out:\n\tif (ret) {\n\t\tkfree(iter);\n\t\tif (tr)\n\t\t\ttrace_array_put(tr);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = -ENOMEM;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto out;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX))\n\t\tgoto out;\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n out:\n\tif (ret) {\n\t\tkfree(iter);\n\t\tif (tr)\n\t\t\ttrace_array_put(tr);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\t/* Checks for tracefs lockdown */\n\treturn ftrace_regex_open(ops,\n\t\t\tFTRACE_ITER_FILTER | FTRACE_ITER_DO_PROBES,\n\t\t\tinode, file);\n}"
  },
  {
    "function_name": "ftrace_regex_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3784-3870",
    "snippet": "int\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = -ENOMEM;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto out;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX))\n\t\tgoto out;\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n out:\n\tif (ret) {\n\t\tkfree(iter);\n\t\tif (tr)\n\t\t\ttrace_array_put(tr);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iter"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ops->func_hash->regex_lock"
          ],
          "line": 3860
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "&iter->parser"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1558-1562",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "iter->hash"
          ],
          "line": 3853
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&show_ftrace_seq_ops"
          ],
          "line": 3847
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "size_bits",
            "hash"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1310-1346",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_ftrace_mod_list",
          "args": [
            "mod_head"
          ],
          "line": 3830
        },
        "resolved": true,
        "details": {
          "function_name": "clear_ftrace_mod_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1214-1226",
          "snippet": "static void clear_ftrace_mod_list(struct list_head *head)\n{\n\tstruct ftrace_mod_load *p, *n;\n\n\t/* stack tracer isn't supported yet */\n\tif (!head)\n\t\treturn;\n\n\tmutex_lock(&ftrace_lock);\n\tlist_for_each_entry_safe(p, n, head, list)\n\t\tfree_ftrace_mod(p);\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void clear_ftrace_mod_list(struct list_head *head)\n{\n\tstruct ftrace_mod_load *p, *n;\n\n\t/* stack tracer isn't supported yet */\n\tif (!head)\n\t\treturn;\n\n\tmutex_lock(&ftrace_lock);\n\tlist_for_each_entry_safe(p, n, head, list)\n\t\tfree_ftrace_mod(p);\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "size_bits"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1259-1279",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ops->func_hash->regex_lock"
          ],
          "line": 3813
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_get_init",
          "args": [
            "&iter->parser",
            "FTRACE_BUFF_MAX"
          ],
          "line": 3806
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_get_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1543-1553",
          "snippet": "int trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*iter)",
            "GFP_KERNEL"
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_check_open_get_tr",
          "args": [
            "tr"
          ],
          "line": 3799
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_check_open_get_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "485-500",
          "snippet": "int tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nint tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 3794
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = -ENOMEM;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto out;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX))\n\t\tgoto out;\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n out:\n\tif (ret) {\n\t\tkfree(iter);\n\t\tif (tr)\n\t\t\ttrace_array_put(tr);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_enabled_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3743-3766",
    "snippet": "static int\nftrace_enabled_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\t/*\n\t * This shows us what functions are currently being\n\t * traced and by what. Not sure if we want lockdown\n\t * to hide such critical information for an admin.\n\t * Although, perhaps it can show information we don't\n\t * want people to see, but if something is tracing\n\t * something, we probably want to know about it.\n\t */\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->pg = ftrace_pages_start;\n\titer->flags = FTRACE_ITER_ENABLED;\n\titer->ops = &global_ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&show_ftrace_seq_ops",
            "sizeof(*iter)"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_enabled_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\t/*\n\t * This shows us what functions are currently being\n\t * traced and by what. Not sure if we want lockdown\n\t * to hide such critical information for an admin.\n\t * Although, perhaps it can show information we don't\n\t * want people to see, but if something is tracing\n\t * something, we probably want to know about it.\n\t */\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->pg = ftrace_pages_start;\n\titer->flags = FTRACE_ITER_ENABLED;\n\titer->ops = &global_ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_avail_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3720-3741",
    "snippet": "static int\nftrace_avail_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->pg = ftrace_pages_start;\n\titer->ops = &global_ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&show_ftrace_seq_ops",
            "sizeof(*iter)"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 3726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_avail_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->pg = ftrace_pages_start;\n\titer->ops = &global_ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "t_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3651-3711",
    "snippet": "static int t_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec;\n\n\tif (iter->flags & FTRACE_ITER_PROBE)\n\t\treturn t_probe_show(m, iter);\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_show(m, iter);\n\n\tif (iter->flags & FTRACE_ITER_PRINTALL) {\n\t\tif (iter->flags & FTRACE_ITER_NOTRACE)\n\t\t\tseq_puts(m, \"#### no functions disabled ####\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#### all functions enabled ####\\n\");\n\t\treturn 0;\n\t}\n\n\trec = iter->func;\n\n\tif (!rec)\n\t\treturn 0;\n\n\tseq_printf(m, \"%ps\", (void *)rec->ip);\n\tif (iter->flags & FTRACE_ITER_ENABLED) {\n\t\tstruct ftrace_ops *ops;\n\n\t\tseq_printf(m, \" (%ld)%s%s%s\",\n\t\t\t   ftrace_rec_count(rec),\n\t\t\t   rec->flags & FTRACE_FL_REGS ? \" R\" : \"  \",\n\t\t\t   rec->flags & FTRACE_FL_IPMODIFY ? \" I\" : \"  \",\n\t\t\t   rec->flags & FTRACE_FL_DIRECT ? \" D\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tseq_printf(m, \"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t   (void *)ops->trampoline,\n\t\t\t\t\t\t   (void *)ops->func);\n\t\t\t\t\tadd_trampoline_func(m, ops, rec);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tseq_puts(m, \"\\ttramp: ERROR!\");\n\t\t} else {\n\t\t\tadd_trampoline_func(m, NULL, rec);\n\t\t}\n\t\tif (rec->flags & FTRACE_FL_DIRECT) {\n\t\t\tunsigned long direct;\n\n\t\t\tdirect = ftrace_find_rec_direct(rec->ip);\n\t\t\tif (direct)\n\t\t\t\tseq_printf(m, \"\\n\\tdirect-->%pS\", (void *)direct);\n\t\t}\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 3708
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n\\tdirect-->%pS\"",
            "(void *)direct"
          ],
          "line": 3704
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_rec_direct",
          "args": [
            "rec->ip"
          ],
          "line": 3702
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_rec_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2382-2391",
          "snippet": "unsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_trampoline_func",
          "args": [
            "m",
            "NULL",
            "rec"
          ],
          "line": 3697
        },
        "resolved": true,
        "details": {
          "function_name": "add_trampoline_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3641-3649",
          "snippet": "static void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->%pS\", ptr);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->%pS\", ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\ttramp: ERROR!\""
          ],
          "line": 3695
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_next",
          "args": [
            "rec",
            "ops"
          ],
          "line": 3692
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2269-2285",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_any",
          "args": [
            "rec"
          ],
          "line": 3685
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_any",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2233-2249",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_mod_show",
          "args": [
            "m",
            "iter"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3478-3499",
          "snippet": "static int\nt_mod_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (WARN_ON_ONCE(!iter->mod_list) ||\n\t\t\t iter->mod_list == &tr->mod_trace ||\n\t\t\t iter->mod_list == &tr->mod_notrace)\n\t\treturn -EIO;\n\n\tftrace_mod = list_entry(iter->mod_list, struct ftrace_mod_load, list);\n\n\tif (ftrace_mod->func)\n\t\tseq_printf(m, \"%s\", ftrace_mod->func);\n\telse\n\t\tseq_putc(m, '*');\n\n\tseq_printf(m, \":mod:%s\\n\", ftrace_mod->module);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nt_mod_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (WARN_ON_ONCE(!iter->mod_list) ||\n\t\t\t iter->mod_list == &tr->mod_trace ||\n\t\t\t iter->mod_list == &tr->mod_notrace)\n\t\treturn -EIO;\n\n\tftrace_mod = list_entry(iter->mod_list, struct ftrace_mod_load, list);\n\n\tif (ftrace_mod->func)\n\t\tseq_printf(m, \"%s\", ftrace_mod->func);\n\telse\n\t\tseq_putc(m, '*');\n\n\tseq_printf(m, \":mod:%s\\n\", ftrace_mod->module);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_probe_show",
          "args": [
            "m",
            "iter"
          ],
          "line": 3657
        },
        "resolved": true,
        "details": {
          "function_name": "t_probe_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3401-3423",
          "snippet": "static int\nt_probe_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_func_entry *probe_entry;\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = iter->probe;\n\tprobe_entry = iter->probe_entry;\n\n\tif (WARN_ON_ONCE(!probe || !probe_entry))\n\t\treturn -EIO;\n\n\tprobe_ops = probe->probe_ops;\n\n\tif (probe_ops->print)\n\t\treturn probe_ops->print(m, probe_entry->ip, probe_ops, probe->data);\n\n\tseq_printf(m, \"%ps:%ps\\n\", (void *)probe_entry->ip,\n\t\t   (void *)probe_ops->func);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nt_probe_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_func_entry *probe_entry;\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = iter->probe;\n\tprobe_entry = iter->probe_entry;\n\n\tif (WARN_ON_ONCE(!probe || !probe_entry))\n\t\treturn -EIO;\n\n\tprobe_ops = probe->probe_ops;\n\n\tif (probe_ops->print)\n\t\treturn probe_ops->print(m, probe_entry->ip, probe_ops, probe->data);\n\n\tseq_printf(m, \"%ps:%ps\\n\", (void *)probe_entry->ip,\n\t\t   (void *)probe_ops->func);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec;\n\n\tif (iter->flags & FTRACE_ITER_PROBE)\n\t\treturn t_probe_show(m, iter);\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_show(m, iter);\n\n\tif (iter->flags & FTRACE_ITER_PRINTALL) {\n\t\tif (iter->flags & FTRACE_ITER_NOTRACE)\n\t\t\tseq_puts(m, \"#### no functions disabled ####\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#### all functions enabled ####\\n\");\n\t\treturn 0;\n\t}\n\n\trec = iter->func;\n\n\tif (!rec)\n\t\treturn 0;\n\n\tseq_printf(m, \"%ps\", (void *)rec->ip);\n\tif (iter->flags & FTRACE_ITER_ENABLED) {\n\t\tstruct ftrace_ops *ops;\n\n\t\tseq_printf(m, \" (%ld)%s%s%s\",\n\t\t\t   ftrace_rec_count(rec),\n\t\t\t   rec->flags & FTRACE_FL_REGS ? \" R\" : \"  \",\n\t\t\t   rec->flags & FTRACE_FL_IPMODIFY ? \" I\" : \"  \",\n\t\t\t   rec->flags & FTRACE_FL_DIRECT ? \" D\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tseq_printf(m, \"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t   (void *)ops->trampoline,\n\t\t\t\t\t\t   (void *)ops->func);\n\t\t\t\t\tadd_trampoline_func(m, ops, rec);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tseq_puts(m, \"\\ttramp: ERROR!\");\n\t\t} else {\n\t\t\tadd_trampoline_func(m, NULL, rec);\n\t\t}\n\t\tif (rec->flags & FTRACE_FL_DIRECT) {\n\t\t\tunsigned long direct;\n\n\t\t\tdirect = ftrace_find_rec_direct(rec->ip);\n\t\t\tif (direct)\n\t\t\t\tseq_printf(m, \"\\n\\tdirect-->%pS\", (void *)direct);\n\t\t}\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_trampoline_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3641-3649",
    "snippet": "static void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->%pS\", ptr);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" ->%pS\"",
            "ptr"
          ],
          "line": 3648
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_ftrace_trampoline_func",
          "args": [
            "ops",
            "rec"
          ],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_trampoline_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3635-3639",
          "snippet": "void * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->%pS\", ptr);\n}"
  },
  {
    "function_name": "arch_ftrace_trampoline_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3635-3639",
    "snippet": "void * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3630-3633",
    "snippet": "static void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3575-3628",
    "snippet": "static void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn NULL;\n\n\t/*\n\t * If an lseek was done, then reset and start from beginning.\n\t */\n\tif (*pos < iter->pos)\n\t\treset_iter_read(iter);\n\n\t/*\n\t * For set_ftrace_filter reading, if we have the filter\n\t * off, we can short cut and just print out that all\n\t * functions are enabled.\n\t */\n\tif ((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t    ftrace_hash_empty(iter->hash)) {\n\t\titer->func_pos = 1; /* Account for the message */\n\t\tif (*pos > 0)\n\t\t\treturn t_mod_start(m, pos);\n\t\titer->flags |= FTRACE_ITER_PRINTALL;\n\t\t/* reset in case of seek/pread */\n\t\titer->flags &= ~FTRACE_ITER_PROBE;\n\t\treturn iter;\n\t}\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_start(m, pos);\n\n\t/*\n\t * Unfortunately, we need to restart at ftrace_pages_start\n\t * every time we let go of the ftrace_mutex. This is because\n\t * those pointers can change without the lock.\n\t */\n\titer->pg = ftrace_pages_start;\n\titer->idx = 0;\n\tfor (l = 0; l <= *pos; ) {\n\t\tp = t_func_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\n\tif (!p)\n\t\treturn t_mod_start(m, pos);\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_mod_start",
          "args": [
            "m",
            "pos"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3447-3476",
          "snippet": "static void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_func_next",
          "args": [
            "m",
            "&l"
          ],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "t_func_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3501-3536",
          "snippet": "static void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "iter->hash"
          ],
          "line": 3598
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_iter_read",
          "args": [
            "iter"
          ],
          "line": 3590
        },
        "resolved": true,
        "details": {
          "function_name": "reset_iter_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3568-3573",
          "snippet": "static void reset_iter_read(struct ftrace_iterator *iter)\n{\n\titer->pos = 0;\n\titer->func_pos = 0;\n\titer->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_PROBE | FTRACE_ITER_MOD);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void reset_iter_read(struct ftrace_iterator *iter)\n{\n\titer->pos = 0;\n\titer->func_pos = 0;\n\titer->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_PROBE | FTRACE_ITER_MOD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn NULL;\n\n\t/*\n\t * If an lseek was done, then reset and start from beginning.\n\t */\n\tif (*pos < iter->pos)\n\t\treset_iter_read(iter);\n\n\t/*\n\t * For set_ftrace_filter reading, if we have the filter\n\t * off, we can short cut and just print out that all\n\t * functions are enabled.\n\t */\n\tif ((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t    ftrace_hash_empty(iter->hash)) {\n\t\titer->func_pos = 1; /* Account for the message */\n\t\tif (*pos > 0)\n\t\t\treturn t_mod_start(m, pos);\n\t\titer->flags |= FTRACE_ITER_PRINTALL;\n\t\t/* reset in case of seek/pread */\n\t\titer->flags &= ~FTRACE_ITER_PROBE;\n\t\treturn iter;\n\t}\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_start(m, pos);\n\n\t/*\n\t * Unfortunately, we need to restart at ftrace_pages_start\n\t * every time we let go of the ftrace_mutex. This is because\n\t * those pointers can change without the lock.\n\t */\n\titer->pg = ftrace_pages_start;\n\titer->idx = 0;\n\tfor (l = 0; l <= *pos; ) {\n\t\tp = t_func_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\n\tif (!p)\n\t\treturn t_mod_start(m, pos);\n\n\treturn iter;\n}"
  },
  {
    "function_name": "reset_iter_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3568-3573",
    "snippet": "static void reset_iter_read(struct ftrace_iterator *iter)\n{\n\titer->pos = 0;\n\titer->func_pos = 0;\n\titer->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_PROBE | FTRACE_ITER_MOD);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void reset_iter_read(struct ftrace_iterator *iter)\n{\n\titer->pos = 0;\n\titer->func_pos = 0;\n\titer->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_PROBE | FTRACE_ITER_MOD);\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3538-3566",
    "snippet": "static void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tloff_t l = *pos; /* t_probe_start() must use original pos */\n\tvoid *ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn NULL;\n\n\tif (iter->flags & FTRACE_ITER_PROBE)\n\t\treturn t_probe_next(m, pos);\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_next(m, pos);\n\n\tif (iter->flags & FTRACE_ITER_PRINTALL) {\n\t\t/* next must increment pos, and t_probe_start does not */\n\t\t(*pos)++;\n\t\treturn t_mod_start(m, &l);\n\t}\n\n\tret = t_func_next(m, pos);\n\n\tif (!ret)\n\t\treturn t_mod_start(m, &l);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_mod_start",
          "args": [
            "m",
            "&l"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3447-3476",
          "snippet": "static void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_func_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "t_func_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3501-3536",
          "snippet": "static void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_mod_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3425-3445",
          "snippet": "static void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_probe_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "t_probe_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3294-3370",
          "snippet": "static void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\n\t/*\n\t * A probe being registered may temporarily have an empty hash\n\t * and it's at the end of the func_probes list.\n\t */\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn NULL;\n\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\n\t/*\n\t * A probe being registered may temporarily have an empty hash\n\t * and it's at the end of the func_probes list.\n\t */\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn NULL;\n\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tloff_t l = *pos; /* t_probe_start() must use original pos */\n\tvoid *ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn NULL;\n\n\tif (iter->flags & FTRACE_ITER_PROBE)\n\t\treturn t_probe_next(m, pos);\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_next(m, pos);\n\n\tif (iter->flags & FTRACE_ITER_PRINTALL) {\n\t\t/* next must increment pos, and t_probe_start does not */\n\t\t(*pos)++;\n\t\treturn t_mod_start(m, &l);\n\t}\n\n\tret = t_func_next(m, pos);\n\n\tif (!ret)\n\t\treturn t_mod_start(m, &l);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "t_func_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3501-3536",
    "snippet": "static void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "iter->hash",
            "rec->ip"
          ],
          "line": 3519
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "t_mod_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3478-3499",
    "snippet": "static int\nt_mod_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (WARN_ON_ONCE(!iter->mod_list) ||\n\t\t\t iter->mod_list == &tr->mod_trace ||\n\t\t\t iter->mod_list == &tr->mod_notrace)\n\t\treturn -EIO;\n\n\tftrace_mod = list_entry(iter->mod_list, struct ftrace_mod_load, list);\n\n\tif (ftrace_mod->func)\n\t\tseq_printf(m, \"%s\", ftrace_mod->func);\n\telse\n\t\tseq_putc(m, '*');\n\n\tseq_printf(m, \":mod:%s\\n\", ftrace_mod->module);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\":mod:%s\\n\"",
            "ftrace_mod->module"
          ],
          "line": 3496
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'*'"
          ],
          "line": 3494
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "iter->mod_list",
            "structftrace_mod_load",
            "list"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!iter->mod_list"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nt_mod_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (WARN_ON_ONCE(!iter->mod_list) ||\n\t\t\t iter->mod_list == &tr->mod_trace ||\n\t\t\t iter->mod_list == &tr->mod_notrace)\n\t\treturn -EIO;\n\n\tftrace_mod = list_entry(iter->mod_list, struct ftrace_mod_load, list);\n\n\tif (ftrace_mod->func)\n\t\tseq_printf(m, \"%s\", ftrace_mod->func);\n\telse\n\t\tseq_putc(m, '*');\n\n\tseq_printf(m, \":mod:%s\\n\", ftrace_mod->module);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "t_mod_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3447-3476",
    "snippet": "static void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_probe_start",
          "args": [
            "m",
            "pos"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "t_probe_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3372-3399",
          "snippet": "static void *t_probe_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (!(iter->flags & FTRACE_ITER_DO_PROBES))\n\t\treturn NULL;\n\n\tif (iter->mod_pos > *pos)\n\t\treturn NULL;\n\n\titer->probe = NULL;\n\titer->probe_entry = NULL;\n\titer->pidx = 0;\n\tfor (l = 0; l <= (*pos - iter->mod_pos); ) {\n\t\tp = t_probe_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_PROBE;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_probe_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (!(iter->flags & FTRACE_ITER_DO_PROBES))\n\t\treturn NULL;\n\n\tif (iter->mod_pos > *pos)\n\t\treturn NULL;\n\n\titer->probe = NULL;\n\titer->probe_entry = NULL;\n\titer->pidx = 0;\n\tfor (l = 0; l <= (*pos - iter->mod_pos); ) {\n\t\tp = t_probe_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_PROBE;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_mod_next",
          "args": [
            "m",
            "&l"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3425-3445",
          "snippet": "static void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "t_mod_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3425-3445",
    "snippet": "static void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "t_probe_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3401-3423",
    "snippet": "static int\nt_probe_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_func_entry *probe_entry;\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = iter->probe;\n\tprobe_entry = iter->probe_entry;\n\n\tif (WARN_ON_ONCE(!probe || !probe_entry))\n\t\treturn -EIO;\n\n\tprobe_ops = probe->probe_ops;\n\n\tif (probe_ops->print)\n\t\treturn probe_ops->print(m, probe_entry->ip, probe_ops, probe->data);\n\n\tseq_printf(m, \"%ps:%ps\\n\", (void *)probe_entry->ip,\n\t\t   (void *)probe_ops->func);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%ps:%ps\\n\"",
            "(void *)probe_entry->ip",
            "(void *)probe_ops->func"
          ],
          "line": 3419
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_ops->print",
          "args": [
            "m",
            "probe_entry->ip",
            "probe_ops",
            "probe->data"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!probe || !probe_entry"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nt_probe_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_func_entry *probe_entry;\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = iter->probe;\n\tprobe_entry = iter->probe_entry;\n\n\tif (WARN_ON_ONCE(!probe || !probe_entry))\n\t\treturn -EIO;\n\n\tprobe_ops = probe->probe_ops;\n\n\tif (probe_ops->print)\n\t\treturn probe_ops->print(m, probe_entry->ip, probe_ops, probe->data);\n\n\tseq_printf(m, \"%ps:%ps\\n\", (void *)probe_entry->ip,\n\t\t   (void *)probe_ops->func);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "t_probe_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3372-3399",
    "snippet": "static void *t_probe_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (!(iter->flags & FTRACE_ITER_DO_PROBES))\n\t\treturn NULL;\n\n\tif (iter->mod_pos > *pos)\n\t\treturn NULL;\n\n\titer->probe = NULL;\n\titer->probe_entry = NULL;\n\titer->pidx = 0;\n\tfor (l = 0; l <= (*pos - iter->mod_pos); ) {\n\t\tp = t_probe_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_PROBE;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_probe_next",
          "args": [
            "m",
            "&l"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "t_probe_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3294-3370",
          "snippet": "static void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\n\t/*\n\t * A probe being registered may temporarily have an empty hash\n\t * and it's at the end of the func_probes list.\n\t */\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn NULL;\n\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\n\t/*\n\t * A probe being registered may temporarily have an empty hash\n\t * and it's at the end of the func_probes list.\n\t */\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn NULL;\n\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_probe_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (!(iter->flags & FTRACE_ITER_DO_PROBES))\n\t\treturn NULL;\n\n\tif (iter->mod_pos > *pos)\n\t\treturn NULL;\n\n\titer->probe = NULL;\n\titer->probe_entry = NULL;\n\titer->pidx = 0;\n\tfor (l = 0; l <= (*pos - iter->mod_pos); ) {\n\t\tp = t_probe_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_PROBE;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "t_probe_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3294-3370",
    "snippet": "static void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\n\t/*\n\t * A probe being registered may temporarily have an empty hash\n\t * and it's at the end of the func_probes list.\n\t */\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn NULL;\n\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "hnd",
            "structftrace_func_entry",
            "hlist"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!hnd"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "hhd"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structftrace_func_probe",
            "list"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structftrace_func_probe",
            "list"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "func_probes"
          ],
          "line": 3313
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\n\t/*\n\t * A probe being registered may temporarily have an empty hash\n\t * and it's at the end of the func_probes list.\n\t */\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn NULL;\n\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}"
  },
  {
    "function_name": "ftrace_allocate_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3221-3272",
    "snippet": "static struct ftrace_page *\nftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn NULL;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\tpg = start_pg;\n\twhile (pg) {\n\t\tif (pg->records) {\n\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t}\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t\tftrace_number_of_groups--;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace: FAILED to allocate memory for functions\\n\""
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pg"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)pg->records",
            "pg->order"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pg)",
            "GFP_KERNEL"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_allocate_records",
          "args": [
            "pg",
            "num_to_init"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_allocate_records",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3185-3219",
          "snippet": "static int ftrace_allocate_records(struct ftrace_page *pg, int count)\n{\n\tint order;\n\tint pages;\n\tint cnt;\n\n\tif (WARN_ON(!count))\n\t\treturn -EINVAL;\n\n\t/* We want to fill as much as possible, with no empty pages */\n\tpages = DIV_ROUND_UP(count, ENTRIES_PER_PAGE);\n\torder = fls(pages) - 1;\n\n again:\n\tpg->records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\n\n\tif (!pg->records) {\n\t\t/* if we can't allocate this size, try something smaller */\n\t\tif (!order)\n\t\t\treturn -ENOMEM;\n\t\torder >>= 1;\n\t\tgoto again;\n\t}\n\n\tftrace_number_of_pages += 1 << order;\n\tftrace_number_of_groups++;\n\n\tcnt = (PAGE_SIZE << order) / ENTRY_SIZE;\n\tpg->order = order;\n\n\tif (cnt > count)\n\t\tcnt = count;\n\n\treturn cnt;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)",
            "#define ENTRY_SIZE sizeof(struct dyn_ftrace)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n#define ENTRY_SIZE sizeof(struct dyn_ftrace)\n\nstatic int ftrace_allocate_records(struct ftrace_page *pg, int count)\n{\n\tint order;\n\tint pages;\n\tint cnt;\n\n\tif (WARN_ON(!count))\n\t\treturn -EINVAL;\n\n\t/* We want to fill as much as possible, with no empty pages */\n\tpages = DIV_ROUND_UP(count, ENTRIES_PER_PAGE);\n\torder = fls(pages) - 1;\n\n again:\n\tpg->records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\n\n\tif (!pg->records) {\n\t\t/* if we can't allocate this size, try something smaller */\n\t\tif (!order)\n\t\t\treturn -ENOMEM;\n\t\torder >>= 1;\n\t\tgoto again;\n\t}\n\n\tftrace_number_of_pages += 1 << order;\n\tftrace_number_of_groups++;\n\n\tcnt = (PAGE_SIZE << order) / ENTRY_SIZE;\n\tpg->order = order;\n\n\tif (cnt > count)\n\t\tcnt = count;\n\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pg)",
            "GFP_KERNEL"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_page *\nftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn NULL;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\tpg = start_pg;\n\twhile (pg) {\n\t\tif (pg->records) {\n\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t}\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t\tftrace_number_of_groups--;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_allocate_records",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3185-3219",
    "snippet": "static int ftrace_allocate_records(struct ftrace_page *pg, int count)\n{\n\tint order;\n\tint pages;\n\tint cnt;\n\n\tif (WARN_ON(!count))\n\t\treturn -EINVAL;\n\n\t/* We want to fill as much as possible, with no empty pages */\n\tpages = DIV_ROUND_UP(count, ENTRIES_PER_PAGE);\n\torder = fls(pages) - 1;\n\n again:\n\tpg->records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\n\n\tif (!pg->records) {\n\t\t/* if we can't allocate this size, try something smaller */\n\t\tif (!order)\n\t\t\treturn -ENOMEM;\n\t\torder >>= 1;\n\t\tgoto again;\n\t}\n\n\tftrace_number_of_pages += 1 << order;\n\tftrace_number_of_groups++;\n\n\tcnt = (PAGE_SIZE << order) / ENTRY_SIZE;\n\tpg->order = order;\n\n\tif (cnt > count)\n\t\tcnt = count;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)",
      "#define ENTRY_SIZE sizeof(struct dyn_ftrace)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL | __GFP_ZERO",
            "order"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "pages"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "count",
            "ENTRIES_PER_PAGE"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!count"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n#define ENTRY_SIZE sizeof(struct dyn_ftrace)\n\nstatic int ftrace_allocate_records(struct ftrace_page *pg, int count)\n{\n\tint order;\n\tint pages;\n\tint cnt;\n\n\tif (WARN_ON(!count))\n\t\treturn -EINVAL;\n\n\t/* We want to fill as much as possible, with no empty pages */\n\tpages = DIV_ROUND_UP(count, ENTRIES_PER_PAGE);\n\torder = fls(pages) - 1;\n\n again:\n\tpg->records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\n\n\tif (!pg->records) {\n\t\t/* if we can't allocate this size, try something smaller */\n\t\tif (!order)\n\t\t\treturn -ENOMEM;\n\t\torder >>= 1;\n\t\tgoto again;\n\t}\n\n\tftrace_number_of_pages += 1 << order;\n\tftrace_number_of_groups++;\n\n\tcnt = (PAGE_SIZE << order) / ENTRY_SIZE;\n\tpg->order = order;\n\n\tif (cnt > count)\n\t\tcnt = count;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "ftrace_update_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3130-3183",
    "snippet": "static int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)\n{\n\tbool init_nop = ftrace_need_init_nop();\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *p;\n\tu64 start, stop;\n\tunsigned long update_cnt = 0;\n\tunsigned long rec_flags = 0;\n\tint i;\n\n\tstart = ftrace_now(raw_smp_processor_id());\n\n\t/*\n\t * When a module is loaded, this function is called to convert\n\t * the calls to mcount in its text to nops, and also to create\n\t * an entry in the ftrace data. Now, if ftrace is activated\n\t * after this call, but before the module sets its text to\n\t * read-only, the modification of enabling ftrace can fail if\n\t * the read-only is done while ftrace is converting the calls.\n\t * To prevent this, the module's records are set as disabled\n\t * and will be enabled after the call to set the module's text\n\t * to read-only.\n\t */\n\tif (mod)\n\t\trec_flags |= FTRACE_FL_DISABLED;\n\n\tfor (pg = new_pgs; pg; pg = pg->next) {\n\n\t\tfor (i = 0; i < pg->index; i++) {\n\n\t\t\t/* If something went wrong, bail without enabling anything */\n\t\t\tif (unlikely(ftrace_disabled))\n\t\t\t\treturn -1;\n\n\t\t\tp = &pg->records[i];\n\t\t\tp->flags = rec_flags;\n\n\t\t\t/*\n\t\t\t * Do the initial record conversion from mcount jump\n\t\t\t * to the NOP instructions.\n\t\t\t */\n\t\t\tif (init_nop && !ftrace_nop_initialize(mod, p))\n\t\t\t\tbreak;\n\n\t\t\tupdate_cnt++;\n\t\t}\n\t}\n\n\tstop = ftrace_now(raw_smp_processor_id());\n\tftrace_update_time = stop - start;\n\tftrace_update_tot_cnt += update_cnt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_now",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "765-768",
          "snippet": "u64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_nop_initialize",
          "args": [
            "mod",
            "p"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_nop_initialize",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2672-2687",
          "snippet": "static int\nftrace_nop_initialize(struct module *mod, struct dyn_ftrace *rec)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn 0;\n\n\tret = ftrace_init_nop(mod, rec);\n\tif (ret) {\n\t\tftrace_bug_type = FTRACE_BUG_INIT;\n\t\tftrace_bug(ret, rec);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_nop_initialize(struct module *mod, struct dyn_ftrace *rec)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn 0;\n\n\tret = ftrace_init_nop(mod, rec);\n\tif (ret) {\n\t\tftrace_bug_type = FTRACE_BUG_INIT;\n\t\tftrace_bug(ret, rec);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_need_init_nop",
          "args": [],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)\n{\n\tbool init_nop = ftrace_need_init_nop();\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *p;\n\tu64 start, stop;\n\tunsigned long update_cnt = 0;\n\tunsigned long rec_flags = 0;\n\tint i;\n\n\tstart = ftrace_now(raw_smp_processor_id());\n\n\t/*\n\t * When a module is loaded, this function is called to convert\n\t * the calls to mcount in its text to nops, and also to create\n\t * an entry in the ftrace data. Now, if ftrace is activated\n\t * after this call, but before the module sets its text to\n\t * read-only, the modification of enabling ftrace can fail if\n\t * the read-only is done while ftrace is converting the calls.\n\t * To prevent this, the module's records are set as disabled\n\t * and will be enabled after the call to set the module's text\n\t * to read-only.\n\t */\n\tif (mod)\n\t\trec_flags |= FTRACE_FL_DISABLED;\n\n\tfor (pg = new_pgs; pg; pg = pg->next) {\n\n\t\tfor (i = 0; i < pg->index; i++) {\n\n\t\t\t/* If something went wrong, bail without enabling anything */\n\t\t\tif (unlikely(ftrace_disabled))\n\t\t\t\treturn -1;\n\n\t\t\tp = &pg->records[i];\n\t\t\tp->flags = rec_flags;\n\n\t\t\t/*\n\t\t\t * Do the initial record conversion from mcount jump\n\t\t\t * to the NOP instructions.\n\t\t\t */\n\t\t\tif (init_nop && !ftrace_nop_initialize(mod, p))\n\t\t\t\tbreak;\n\n\t\t\tupdate_cnt++;\n\t\t}\n\t}\n\n\tstop = ftrace_now(raw_smp_processor_id());\n\tftrace_update_time = stop - start;\n\tftrace_update_tot_cnt += update_cnt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ops_references_rec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3107-3128",
    "snippet": "static inline bool\nops_references_rec(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\t/* If ops isn't enabled, ignore it */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/* If ops traces all then it includes this function */\n\tif (ops_traces_mod(ops))\n\t\treturn true;\n\n\t/* The function must be in the filter */\n\tif (!ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t    !__ftrace_lookup_ip(ops->func_hash->filter_hash, rec->ip))\n\t\treturn false;\n\n\t/* If in notrace hash, we ignore it too */\n\tif (ftrace_lookup_ip(ops->func_hash->notrace_hash, rec->ip))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "ops->func_hash->notrace_hash",
            "rec->ip"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "ops->func_hash->filter_hash",
            "rec->ip"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1108-1123",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "ops->func_hash->filter_hash"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops_traces_mod",
          "args": [
            "ops"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "ops_traces_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3090-3098",
          "snippet": "static inline int ops_traces_mod(struct ftrace_ops *ops)\n{\n\t/*\n\t * Filter_hash being empty will default to trace module.\n\t * But notrace hash requires a test of individual module functions.\n\t */\n\treturn ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t\tftrace_hash_empty(ops->func_hash->notrace_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline int ops_traces_mod(struct ftrace_ops *ops)\n{\n\t/*\n\t * Filter_hash being empty will default to trace module.\n\t * But notrace hash requires a test of individual module functions.\n\t */\n\treturn ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t\tftrace_hash_empty(ops->func_hash->notrace_hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline bool\nops_references_rec(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\t/* If ops isn't enabled, ignore it */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/* If ops traces all then it includes this function */\n\tif (ops_traces_mod(ops))\n\t\treturn true;\n\n\t/* The function must be in the filter */\n\tif (!ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t    !__ftrace_lookup_ip(ops->func_hash->filter_hash, rec->ip))\n\t\treturn false;\n\n\t/* If in notrace hash, we ignore it too */\n\tif (ftrace_lookup_ip(ops->func_hash->notrace_hash, rec->ip))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "ops_traces_mod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3090-3098",
    "snippet": "static inline int ops_traces_mod(struct ftrace_ops *ops)\n{\n\t/*\n\t * Filter_hash being empty will default to trace module.\n\t * But notrace hash requires a test of individual module functions.\n\t */\n\treturn ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t\tftrace_hash_empty(ops->func_hash->notrace_hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "ops->func_hash->notrace_hash"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline int ops_traces_mod(struct ftrace_ops *ops)\n{\n\t/*\n\t * Filter_hash being empty will default to trace module.\n\t * But notrace hash requires a test of individual module functions.\n\t */\n\treturn ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t\tftrace_hash_empty(ops->func_hash->notrace_hash);\n}"
  },
  {
    "function_name": "ftrace_shutdown_sysctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3069-3083",
    "snippet": "static void ftrace_shutdown_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* ftrace_start_up is true if ftrace is running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_DISABLE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_STOP_FUNC_RET;\n\t\tftrace_run_update_code(command);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_run_update_code",
          "args": [
            "command"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_update_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2788-2807",
          "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void ftrace_shutdown_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* ftrace_start_up is true if ftrace is running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_DISABLE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_STOP_FUNC_RET;\n\t\tftrace_run_update_code(command);\n\t}\n}"
  },
  {
    "function_name": "ftrace_startup_sysctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "3051-3067",
    "snippet": "static void ftrace_startup_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* Force update next time */\n\tsaved_ftrace_func = NULL;\n\t/* ftrace_start_up is true if we want ftrace running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_UPDATE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_START_FUNC_RET;\n\t\tftrace_startup_enable(command);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_startup_enable",
          "args": [
            "command"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7194-7194",
          "snippet": "static inline void ftrace_startup_enable(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_enable(int command) { }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void ftrace_startup_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* Force update next time */\n\tsaved_ftrace_func = NULL;\n\t/* ftrace_start_up is true if we want ftrace running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_UPDATE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_START_FUNC_RET;\n\t\tftrace_startup_enable(command);\n\t}\n}"
  },
  {
    "function_name": "ftrace_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2937-3049",
    "snippet": "int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tsynchronize_rcu_tasks_rude();\n\n\t\t/*\n\t\t * When the kernel is preemptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchronize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "ftrace_func_t ftrace_trace_function",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trampoline_free",
          "args": [
            "ops"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trampoline_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2852-2871",
          "snippet": "static void ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n\tif (ops && (ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP) &&\n\t    ops->trampoline) {\n\t\t/*\n\t\t * Record the text poke event before the ksymbol unregister\n\t\t * event.\n\t\t */\n\t\tperf_event_text_poke((void *)ops->trampoline,\n\t\t\t\t     (void *)ops->trampoline,\n\t\t\t\t     ops->trampoline_size, NULL, 0);\n\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t   ops->trampoline, ops->trampoline_size,\n\t\t\t\t   true, FTRACE_TRAMPOLINE_SYM);\n\t\t/* Remove from kallsyms after the perf events */\n\t\tftrace_remove_trampoline_from_kallsyms(ops);\n\t}\n\n\tarch_ftrace_trampoline_free(ops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\""
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n\tif (ops && (ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP) &&\n\t    ops->trampoline) {\n\t\t/*\n\t\t * Record the text poke event before the ksymbol unregister\n\t\t * event.\n\t\t */\n\t\tperf_event_text_poke((void *)ops->trampoline,\n\t\t\t\t     (void *)ops->trampoline,\n\t\t\t\t     ops->trampoline_size, NULL, 0);\n\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t   ops->trampoline, ops->trampoline_size,\n\t\t\t\t   true, FTRACE_TRAMPOLINE_SYM);\n\t\t/* Remove from kallsyms after the perf events */\n\t\tftrace_remove_trampoline_from_kallsyms(ops);\n\t}\n\n\tarch_ftrace_trampoline_free(ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks",
          "args": [],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1556-1560",
          "snippet": "void synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPTION"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks_rude",
          "args": [],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_rude",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "999-1002",
          "snippet": "void synchronize_rcu_tasks_rude(void)\n{\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_rude);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_rude(void)\n{\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_rude);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"  %pS flags:%lx\\n\"",
            "(void *)rec->ip",
            "rec->flags"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON_ONCE",
          "args": [
            "rec->flags & ~FTRACE_FL_DISABLED"
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_ops_list",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_run_update_code",
          "args": [
            "command"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_update_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2788-2807",
          "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_rec_disable",
          "args": [
            "ops",
            "1"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_disable_modify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1836-1840",
          "snippet": "static void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_ipmodify_disable",
          "args": [
            "ops"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_ipmodify_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1940-1948",
          "snippet": "static void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\t__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\t__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ftrace_start_up < 0"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "340-358",
          "snippet": "int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tsynchronize_rcu_tasks_rude();\n\n\t\t/*\n\t\t * When the kernel is preemptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchronize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_startup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2893-2935",
    "snippet": "int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tftrace_trampoline_free(ops);\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_startup_enable",
          "args": [
            "command"
          ],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7194-7194",
          "snippet": "static inline void ftrace_startup_enable(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_enable(int command) { }"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_rec_enable",
          "args": [
            "ops",
            "1"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_enable_modify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1842-1846",
          "snippet": "static void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_trampoline_free",
          "args": [
            "ops"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trampoline_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2852-2871",
          "snippet": "static void ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n\tif (ops && (ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP) &&\n\t    ops->trampoline) {\n\t\t/*\n\t\t * Record the text poke event before the ksymbol unregister\n\t\t * event.\n\t\t */\n\t\tperf_event_text_poke((void *)ops->trampoline,\n\t\t\t\t     (void *)ops->trampoline,\n\t\t\t\t     ops->trampoline_size, NULL, 0);\n\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t   ops->trampoline, ops->trampoline_size,\n\t\t\t\t   true, FTRACE_TRAMPOLINE_SYM);\n\t\t/* Remove from kallsyms after the perf events */\n\t\tftrace_remove_trampoline_from_kallsyms(ops);\n\t}\n\n\tarch_ftrace_trampoline_free(ops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\""
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n\tif (ops && (ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP) &&\n\t    ops->trampoline) {\n\t\t/*\n\t\t * Record the text poke event before the ksymbol unregister\n\t\t * event.\n\t\t */\n\t\tperf_event_text_poke((void *)ops->trampoline,\n\t\t\t\t     (void *)ops->trampoline,\n\t\t\t\t     ops->trampoline_size, NULL, 0);\n\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t   ops->trampoline, ops->trampoline_size,\n\t\t\t\t   true, FTRACE_TRAMPOLINE_SYM);\n\t\t/* Remove from kallsyms after the perf events */\n\t\tftrace_remove_trampoline_from_kallsyms(ops);\n\t}\n\n\tarch_ftrace_trampoline_free(ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "340-358",
          "snippet": "int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_ipmodify_enable",
          "args": [
            "ops"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_ipmodify_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1929-1937",
          "snippet": "static int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "__register_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "297-338",
          "snippet": "int __register_ftrace_function(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_DELETED)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EBUSY;\n\n#ifndef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * If the ftrace_ops specifies SAVE_REGS, then it only can be used\n\t * if the arch supports it, or SAVE_REGS_IF_SUPPORTED is also set.\n\t * Setting SAVE_REGS_IF_SUPPORTED makes SAVE_REGS irrelevant.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS &&\n\t    !(ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED))\n\t\treturn -EINVAL;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED)\n\t\tops->flags |= FTRACE_OPS_FL_SAVE_REGS;\n#endif\n\tif (!ftrace_enabled && (ops->flags & FTRACE_OPS_FL_PERMANENT))\n\t\treturn -EBUSY;\n\n\tif (!is_kernel_core_data((unsigned long)ops))\n\t\tops->flags |= FTRACE_OPS_FL_DYNAMIC;\n\n\tadd_ftrace_ops(&ftrace_ops_list, ops);\n\n\t/* Always save the function, and reset at unregistering */\n\tops->saved_func = ops->func;\n\n\tif (ftrace_pids_enabled(ops))\n\t\tops->func = ftrace_pid_func;\n\n\tftrace_update_trampoline(ops);\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint __register_ftrace_function(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_DELETED)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EBUSY;\n\n#ifndef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * If the ftrace_ops specifies SAVE_REGS, then it only can be used\n\t * if the arch supports it, or SAVE_REGS_IF_SUPPORTED is also set.\n\t * Setting SAVE_REGS_IF_SUPPORTED makes SAVE_REGS irrelevant.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS &&\n\t    !(ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED))\n\t\treturn -EINVAL;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED)\n\t\tops->flags |= FTRACE_OPS_FL_SAVE_REGS;\n#endif\n\tif (!ftrace_enabled && (ops->flags & FTRACE_OPS_FL_PERMANENT))\n\t\treturn -EBUSY;\n\n\tif (!is_kernel_core_data((unsigned long)ops))\n\t\tops->flags |= FTRACE_OPS_FL_DYNAMIC;\n\n\tadd_ftrace_ops(&ftrace_ops_list, ops);\n\n\t/* Always save the function, and reset at unregistering */\n\tops->saved_func = ops->func;\n\n\tif (ftrace_pids_enabled(ops))\n\t\tops->func = ftrace_pid_func;\n\n\tftrace_update_trampoline(ops);\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tftrace_trampoline_free(ops);\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_startup_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2886-2891",
    "snippet": "static void ftrace_startup_all(int command)\n{\n\tupdate_all_ops = true;\n\tftrace_startup_enable(command);\n\tupdate_all_ops = false;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_startup_enable",
          "args": [
            "command"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7194-7194",
          "snippet": "static inline void ftrace_startup_enable(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_enable(int command) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_startup_all(int command)\n{\n\tupdate_all_ops = true;\n\tftrace_startup_enable(command);\n\tupdate_all_ops = false;\n}"
  },
  {
    "function_name": "ftrace_startup_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2873-2884",
    "snippet": "static void ftrace_startup_enable(int command)\n{\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled)\n\t\treturn;\n\n\tftrace_run_update_code(command);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "ftrace_func_t ftrace_trace_function"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_run_update_code",
          "args": [
            "command"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_update_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2788-2807",
          "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nftrace_func_t ftrace_trace_function;\n\nstatic void ftrace_startup_enable(int command)\n{\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled)\n\t\treturn;\n\n\tftrace_run_update_code(command);\n}"
  },
  {
    "function_name": "ftrace_trampoline_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2852-2871",
    "snippet": "static void ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n\tif (ops && (ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP) &&\n\t    ops->trampoline) {\n\t\t/*\n\t\t * Record the text poke event before the ksymbol unregister\n\t\t * event.\n\t\t */\n\t\tperf_event_text_poke((void *)ops->trampoline,\n\t\t\t\t     (void *)ops->trampoline,\n\t\t\t\t     ops->trampoline_size, NULL, 0);\n\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t   ops->trampoline, ops->trampoline_size,\n\t\t\t\t   true, FTRACE_TRAMPOLINE_SYM);\n\t\t/* Remove from kallsyms after the perf events */\n\t\tftrace_remove_trampoline_from_kallsyms(ops);\n\t}\n\n\tarch_ftrace_trampoline_free(ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\""
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_ftrace_trampoline_free",
          "args": [
            "ops"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_trampoline_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2824-2826",
          "snippet": "void __weak arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __weak arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_remove_trampoline_from_kallsyms",
          "args": [
            "ops"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_remove_trampoline_from_kallsyms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2837-2842",
          "snippet": "static void ftrace_remove_trampoline_from_kallsyms(struct ftrace_ops *ops)\n{\n\tlockdep_assert_held(&ftrace_lock);\n\tlist_del_rcu(&ops->list);\n\tsynchronize_rcu();\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_remove_trampoline_from_kallsyms(struct ftrace_ops *ops)\n{\n\tlockdep_assert_held(&ftrace_lock);\n\tlist_del_rcu(&ops->list);\n\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_ksymbol",
          "args": [
            "PERF_RECORD_KSYMBOL_TYPE_OOL",
            "ops->trampoline",
            "ops->trampoline_size",
            "true",
            "FTRACE_TRAMPOLINE_SYM"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_ksymbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8843-8887",
          "snippet": "void perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_ksymbol_events",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_ksymbol_events;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_text_poke",
          "args": [
            "(void *)ops->trampoline",
            "(void *)ops->trampoline",
            "ops->trampoline_size",
            "NULL",
            "0"
          ],
          "line": 2860
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "9050-9080",
          "snippet": "void perf_event_text_poke(const void *addr, const void *old_bytes,\n\t\t\t  size_t old_len, const void *new_bytes, size_t new_len)\n{\n\tstruct perf_text_poke_event text_poke_event;\n\tsize_t tot, pad;\n\n\tif (!atomic_read(&nr_text_poke_events))\n\t\treturn;\n\n\ttot  = sizeof(text_poke_event.old_len) + old_len;\n\ttot += sizeof(text_poke_event.new_len) + new_len;\n\tpad  = ALIGN(tot, sizeof(u64)) - tot;\n\n\ttext_poke_event = (struct perf_text_poke_event){\n\t\t.old_bytes    = old_bytes,\n\t\t.new_bytes    = new_bytes,\n\t\t.pad          = pad,\n\t\t.old_len      = old_len,\n\t\t.new_len      = new_len,\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_TEXT_POKE,\n\t\t\t\t.misc = PERF_RECORD_MISC_KERNEL,\n\t\t\t\t.size = sizeof(text_poke_event.event_id) + tot + pad,\n\t\t\t},\n\t\t\t.addr = (unsigned long)addr,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_text_poke_output, &text_poke_event, NULL);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_text_poke_events",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_text_poke_events;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_text_poke(const void *addr, const void *old_bytes,\n\t\t\t  size_t old_len, const void *new_bytes, size_t new_len)\n{\n\tstruct perf_text_poke_event text_poke_event;\n\tsize_t tot, pad;\n\n\tif (!atomic_read(&nr_text_poke_events))\n\t\treturn;\n\n\ttot  = sizeof(text_poke_event.old_len) + old_len;\n\ttot += sizeof(text_poke_event.new_len) + new_len;\n\tpad  = ALIGN(tot, sizeof(u64)) - tot;\n\n\ttext_poke_event = (struct perf_text_poke_event){\n\t\t.old_bytes    = old_bytes,\n\t\t.new_bytes    = new_bytes,\n\t\t.pad          = pad,\n\t\t.old_len      = old_len,\n\t\t.new_len      = new_len,\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_TEXT_POKE,\n\t\t\t\t.misc = PERF_RECORD_MISC_KERNEL,\n\t\t\t\t.size = sizeof(text_poke_event.event_id) + tot + pad,\n\t\t\t},\n\t\t\t.addr = (unsigned long)addr,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_text_poke_output, &text_poke_event, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_TRAMPOLINE_SYM \"ftrace_trampoline\"\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n\tif (ops && (ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP) &&\n\t    ops->trampoline) {\n\t\t/*\n\t\t * Record the text poke event before the ksymbol unregister\n\t\t * event.\n\t\t */\n\t\tperf_event_text_poke((void *)ops->trampoline,\n\t\t\t\t     (void *)ops->trampoline,\n\t\t\t\t     ops->trampoline_size, NULL, 0);\n\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t   ops->trampoline, ops->trampoline_size,\n\t\t\t\t   true, FTRACE_TRAMPOLINE_SYM);\n\t\t/* Remove from kallsyms after the perf events */\n\t\tftrace_remove_trampoline_from_kallsyms(ops);\n\t}\n\n\tarch_ftrace_trampoline_free(ops);\n}"
  },
  {
    "function_name": "ftrace_remove_trampoline_from_kallsyms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2837-2842",
    "snippet": "static void ftrace_remove_trampoline_from_kallsyms(struct ftrace_ops *ops)\n{\n\tlockdep_assert_held(&ftrace_lock);\n\tlist_del_rcu(&ops->list);\n\tsynchronize_rcu();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&ops->list"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_remove_trampoline_from_kallsyms(struct ftrace_ops *ops)\n{\n\tlockdep_assert_held(&ftrace_lock);\n\tlist_del_rcu(&ops->list);\n\tsynchronize_rcu();\n}"
  },
  {
    "function_name": "ftrace_add_trampoline_to_kallsyms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2831-2835",
    "snippet": "static void ftrace_add_trampoline_to_kallsyms(struct ftrace_ops *ops)\n{\n\tlockdep_assert_held(&ftrace_lock);\n\tlist_add_rcu(&ops->list, &ftrace_ops_trampoline_list);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&ops->list",
            "&ftrace_ops_trampoline_list"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_add_trampoline_to_kallsyms(struct ftrace_ops *ops)\n{\n\tlockdep_assert_held(&ftrace_lock);\n\tlist_add_rcu(&ops->list, &ftrace_ops_trampoline_list);\n}"
  },
  {
    "function_name": "arch_ftrace_trampoline_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2824-2826",
    "snippet": "void __weak arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __weak arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n}"
  },
  {
    "function_name": "ftrace_run_modify_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2809-2819",
    "snippet": "static void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_run_update_code",
          "args": [
            "command"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_update_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2788-2807",
          "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}"
  },
  {
    "function_name": "ftrace_run_update_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2788-2807",
    "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "ret"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_arch_code_modify_post_process",
          "args": [],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_arch_code_modify_post_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2702-2705",
          "snippet": "int __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_ftrace_update_code",
          "args": [
            "command"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_update_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2783-2786",
          "snippet": "void __weak arch_ftrace_update_code(int command)\n{\n\tftrace_run_stop_machine(command);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid __weak arch_ftrace_update_code(int command)\n{\n\tftrace_run_stop_machine(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "ret"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_arch_code_modify_prepare",
          "args": [],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_arch_code_modify_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2693-2696",
          "snippet": "int __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
  },
  {
    "function_name": "arch_ftrace_update_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2783-2786",
    "snippet": "void __weak arch_ftrace_update_code(int command)\n{\n\tftrace_run_stop_machine(command);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_run_stop_machine",
          "args": [
            "command"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_stop_machine",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2771-2774",
          "snippet": "void ftrace_run_stop_machine(int command)\n{\n\tstop_machine(__ftrace_modify_code, &command, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_run_stop_machine(int command)\n{\n\tstop_machine(__ftrace_modify_code, &command, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid __weak arch_ftrace_update_code(int command)\n{\n\tftrace_run_stop_machine(command);\n}"
  },
  {
    "function_name": "ftrace_run_stop_machine",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2771-2774",
    "snippet": "void ftrace_run_stop_machine(int command)\n{\n\tstop_machine(__ftrace_modify_code, &command, NULL);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_machine",
          "args": [
            "__ftrace_modify_code",
            "&command",
            "NULL"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_from_inactive_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "658-687",
          "snippet": "int stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(stop_cpus_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_MUTEX(stop_cpus_mutex);\n\nint stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_run_stop_machine(int command)\n{\n\tstop_machine(__ftrace_modify_code, &command, NULL);\n}"
  },
  {
    "function_name": "__ftrace_modify_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2755-2762",
    "snippet": "static int __ftrace_modify_code(void *data)\n{\n\tint *command = data;\n\n\tftrace_modify_all_code(*command);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_all_code",
          "args": [
            "*command"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_all_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2707-2753",
          "snippet": "void ftrace_modify_all_code(int command)\n{\n\tint update = command & FTRACE_UPDATE_TRACE_FUNC;\n\tint mod_flags = 0;\n\tint err = 0;\n\n\tif (command & FTRACE_MAY_SLEEP)\n\t\tmod_flags = FTRACE_MODIFY_MAY_SLEEP_FL;\n\n\t/*\n\t * If the ftrace_caller calls a ftrace_ops func directly,\n\t * we need to make sure that it only traces functions it\n\t * expects to trace. When doing the switch of functions,\n\t * we need to update to the ftrace_ops_list_func first\n\t * before the transition between old and new calls are set,\n\t * as the ftrace_ops_list_func will check the ops hashes\n\t * to make sure the ops are having the right functions\n\t * traced.\n\t */\n\tif (update) {\n\t\terr = ftrace_update_ftrace_func(ftrace_ops_list_func);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(mod_flags | FTRACE_MODIFY_ENABLE_FL);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(mod_flags);\n\n\tif (update && ftrace_trace_function != ftrace_ops_list_func) {\n\t\tfunction_trace_op = set_function_trace_op;\n\t\tsmp_wmb();\n\t\t/* If irqs are disabled, we are in stop machine */\n\t\tif (!irqs_disabled())\n\t\t\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t\terr = ftrace_update_ftrace_func(ftrace_trace_function);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\terr = ftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\terr = ftrace_disable_ftrace_graph_caller();\n\tFTRACE_WARN_ON(err);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_modify_all_code(int command)\n{\n\tint update = command & FTRACE_UPDATE_TRACE_FUNC;\n\tint mod_flags = 0;\n\tint err = 0;\n\n\tif (command & FTRACE_MAY_SLEEP)\n\t\tmod_flags = FTRACE_MODIFY_MAY_SLEEP_FL;\n\n\t/*\n\t * If the ftrace_caller calls a ftrace_ops func directly,\n\t * we need to make sure that it only traces functions it\n\t * expects to trace. When doing the switch of functions,\n\t * we need to update to the ftrace_ops_list_func first\n\t * before the transition between old and new calls are set,\n\t * as the ftrace_ops_list_func will check the ops hashes\n\t * to make sure the ops are having the right functions\n\t * traced.\n\t */\n\tif (update) {\n\t\terr = ftrace_update_ftrace_func(ftrace_ops_list_func);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(mod_flags | FTRACE_MODIFY_ENABLE_FL);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(mod_flags);\n\n\tif (update && ftrace_trace_function != ftrace_ops_list_func) {\n\t\tfunction_trace_op = set_function_trace_op;\n\t\tsmp_wmb();\n\t\t/* If irqs are disabled, we are in stop machine */\n\t\tif (!irqs_disabled())\n\t\t\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t\terr = ftrace_update_ftrace_func(ftrace_trace_function);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\terr = ftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\terr = ftrace_disable_ftrace_graph_caller();\n\tFTRACE_WARN_ON(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int __ftrace_modify_code(void *data)\n{\n\tint *command = data;\n\n\tftrace_modify_all_code(*command);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_modify_all_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2707-2753",
    "snippet": "void ftrace_modify_all_code(int command)\n{\n\tint update = command & FTRACE_UPDATE_TRACE_FUNC;\n\tint mod_flags = 0;\n\tint err = 0;\n\n\tif (command & FTRACE_MAY_SLEEP)\n\t\tmod_flags = FTRACE_MODIFY_MAY_SLEEP_FL;\n\n\t/*\n\t * If the ftrace_caller calls a ftrace_ops func directly,\n\t * we need to make sure that it only traces functions it\n\t * expects to trace. When doing the switch of functions,\n\t * we need to update to the ftrace_ops_list_func first\n\t * before the transition between old and new calls are set,\n\t * as the ftrace_ops_list_func will check the ops hashes\n\t * to make sure the ops are having the right functions\n\t * traced.\n\t */\n\tif (update) {\n\t\terr = ftrace_update_ftrace_func(ftrace_ops_list_func);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(mod_flags | FTRACE_MODIFY_ENABLE_FL);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(mod_flags);\n\n\tif (update && ftrace_trace_function != ftrace_ops_list_func) {\n\t\tfunction_trace_op = set_function_trace_op;\n\t\tsmp_wmb();\n\t\t/* If irqs are disabled, we are in stop machine */\n\t\tif (!irqs_disabled())\n\t\t\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t\terr = ftrace_update_ftrace_func(ftrace_trace_function);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\terr = ftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\terr = ftrace_disable_ftrace_graph_caller();\n\tFTRACE_WARN_ON(err);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops *function_trace_op",
      "static struct ftrace_ops *set_function_trace_op;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "ftrace_func_t ftrace_trace_function",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "err"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_disable_ftrace_graph_caller",
          "args": [],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_enable_ftrace_graph_caller",
          "args": [],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "err"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_ftrace_func",
          "args": [
            "ftrace_trace_function"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "ftrace_sync_ipi",
            "NULL",
            "1"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "1012-1017",
          "snippet": "void smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_replace_code",
          "args": [
            "mod_flags"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_replace_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2573-2598",
          "snippet": "void __weak ftrace_replace_code(int mod_flags)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tbool enable = mod_flags & FTRACE_MODIFY_ENABLE_FL;\n\tint schedulable = mod_flags & FTRACE_MODIFY_MAY_SLEEP_FL;\n\tint failed;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tfailed = __ftrace_replace_code(rec, enable);\n\t\tif (failed) {\n\t\t\tftrace_bug(failed, rec);\n\t\t\t/* Stop processing */\n\t\t\treturn;\n\t\t}\n\t\tif (schedulable)\n\t\t\tcond_resched();\n\t} while_for_each_ftrace_rec();\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nvoid __weak ftrace_replace_code(int mod_flags)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tbool enable = mod_flags & FTRACE_MODIFY_ENABLE_FL;\n\tint schedulable = mod_flags & FTRACE_MODIFY_MAY_SLEEP_FL;\n\tint failed;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tfailed = __ftrace_replace_code(rec, enable);\n\t\tif (failed) {\n\t\t\tftrace_bug(failed, rec);\n\t\t\t/* Stop processing */\n\t\t\treturn;\n\t\t}\n\t\tif (schedulable)\n\t\t\tcond_resched();\n\t} while_for_each_ftrace_rec();\n}"
        }
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "err"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_ftrace_func",
          "args": [
            "ftrace_ops_list_func"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_modify_all_code(int command)\n{\n\tint update = command & FTRACE_UPDATE_TRACE_FUNC;\n\tint mod_flags = 0;\n\tint err = 0;\n\n\tif (command & FTRACE_MAY_SLEEP)\n\t\tmod_flags = FTRACE_MODIFY_MAY_SLEEP_FL;\n\n\t/*\n\t * If the ftrace_caller calls a ftrace_ops func directly,\n\t * we need to make sure that it only traces functions it\n\t * expects to trace. When doing the switch of functions,\n\t * we need to update to the ftrace_ops_list_func first\n\t * before the transition between old and new calls are set,\n\t * as the ftrace_ops_list_func will check the ops hashes\n\t * to make sure the ops are having the right functions\n\t * traced.\n\t */\n\tif (update) {\n\t\terr = ftrace_update_ftrace_func(ftrace_ops_list_func);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(mod_flags | FTRACE_MODIFY_ENABLE_FL);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(mod_flags);\n\n\tif (update && ftrace_trace_function != ftrace_ops_list_func) {\n\t\tfunction_trace_op = set_function_trace_op;\n\t\tsmp_wmb();\n\t\t/* If irqs are disabled, we are in stop machine */\n\t\tif (!irqs_disabled())\n\t\t\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t\terr = ftrace_update_ftrace_func(ftrace_trace_function);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\terr = ftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\terr = ftrace_disable_ftrace_graph_caller();\n\tFTRACE_WARN_ON(err);\n}"
  },
  {
    "function_name": "ftrace_arch_code_modify_post_process",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2702-2705",
    "snippet": "int __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_arch_code_modify_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2693-2696",
    "snippet": "int __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_nop_initialize",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2672-2687",
    "snippet": "static int\nftrace_nop_initialize(struct module *mod, struct dyn_ftrace *rec)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn 0;\n\n\tret = ftrace_init_nop(mod, rec);\n\tif (ret) {\n\t\tftrace_bug_type = FTRACE_BUG_INIT;\n\t\tftrace_bug(ret, rec);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_bug",
          "args": [
            "ret",
            "rec"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2015-2069",
          "snippet": "void ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tpr_info(\"------------[ ftrace bug ]------------\\n\");\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n\n\tFTRACE_WARN_ON_ONCE(1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tpr_info(\"------------[ ftrace bug ]------------\\n\");\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n\n\tFTRACE_WARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_init_nop",
          "args": [
            "mod",
            "rec"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_nop_initialize(struct module *mod, struct dyn_ftrace *rec)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn 0;\n\n\tret = ftrace_init_nop(mod, rec);\n\tif (ret) {\n\t\tftrace_bug_type = FTRACE_BUG_INIT;\n\t\tftrace_bug(ret, rec);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_rec_iter_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2667-2670",
    "snippet": "struct dyn_ftrace *ftrace_rec_iter_record(struct ftrace_rec_iter *iter)\n{\n\treturn &iter->pg->records[iter->index];\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct dyn_ftrace *ftrace_rec_iter_record(struct ftrace_rec_iter *iter)\n{\n\treturn &iter->pg->records[iter->index];\n}"
  },
  {
    "function_name": "ftrace_rec_iter_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2642-2659",
    "snippet": "struct ftrace_rec_iter *ftrace_rec_iter_next(struct ftrace_rec_iter *iter)\n{\n\titer->index++;\n\n\tif (iter->index >= iter->pg->index) {\n\t\titer->pg = iter->pg->next;\n\t\titer->index = 0;\n\n\t\t/* Could have empty pages */\n\t\twhile (iter->pg && !iter->pg->index)\n\t\t\titer->pg = iter->pg->next;\n\t}\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_rec_iter *ftrace_rec_iter_next(struct ftrace_rec_iter *iter)\n{\n\titer->index++;\n\n\tif (iter->index >= iter->pg->index) {\n\t\titer->pg = iter->pg->next;\n\t\titer->index = 0;\n\n\t\t/* Could have empty pages */\n\t\twhile (iter->pg && !iter->pg->index)\n\t\t\titer->pg = iter->pg->next;\n\t}\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "ftrace_rec_iter_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2614-2634",
    "snippet": "struct ftrace_rec_iter *ftrace_rec_iter_start(void)\n{\n\t/*\n\t * We only use a single iterator.\n\t * Protected by the ftrace_lock mutex.\n\t */\n\tstatic struct ftrace_rec_iter ftrace_rec_iter;\n\tstruct ftrace_rec_iter *iter = &ftrace_rec_iter;\n\n\titer->pg = ftrace_pages_start;\n\titer->index = 0;\n\n\t/* Could have empty pages */\n\twhile (iter->pg && !iter->pg->index)\n\t\titer->pg = iter->pg->next;\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_rec_iter *ftrace_rec_iter_start(void)\n{\n\t/*\n\t * We only use a single iterator.\n\t * Protected by the ftrace_lock mutex.\n\t */\n\tstatic struct ftrace_rec_iter ftrace_rec_iter;\n\tstruct ftrace_rec_iter *iter = &ftrace_rec_iter;\n\n\titer->pg = ftrace_pages_start;\n\titer->index = 0;\n\n\t/* Could have empty pages */\n\twhile (iter->pg && !iter->pg->index)\n\t\titer->pg = iter->pg->next;\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "ftrace_replace_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2573-2598",
    "snippet": "void __weak ftrace_replace_code(int mod_flags)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tbool enable = mod_flags & FTRACE_MODIFY_ENABLE_FL;\n\tint schedulable = mod_flags & FTRACE_MODIFY_MAY_SLEEP_FL;\n\tint failed;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tfailed = __ftrace_replace_code(rec, enable);\n\t\tif (failed) {\n\t\t\tftrace_bug(failed, rec);\n\t\t\t/* Stop processing */\n\t\t\treturn;\n\t\t}\n\t\tif (schedulable)\n\t\t\tcond_resched();\n\t} while_for_each_ftrace_rec();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_bug",
          "args": [
            "failed",
            "rec"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_bug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2015-2069",
          "snippet": "void ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tpr_info(\"------------[ ftrace bug ]------------\\n\");\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n\n\tFTRACE_WARN_ON_ONCE(1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tpr_info(\"------------[ ftrace bug ]------------\\n\");\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n\n\tFTRACE_WARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_replace_code",
          "args": [
            "rec",
            "enable"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_replace_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2537-2571",
          "snippet": "static int\n__ftrace_replace_code(struct dyn_ftrace *rec, bool enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknown ftrace bug */\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\n__ftrace_replace_code(struct dyn_ftrace *rec, bool enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknown ftrace bug */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nvoid __weak ftrace_replace_code(int mod_flags)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tbool enable = mod_flags & FTRACE_MODIFY_ENABLE_FL;\n\tint schedulable = mod_flags & FTRACE_MODIFY_MAY_SLEEP_FL;\n\tint failed;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tfailed = __ftrace_replace_code(rec, enable);\n\t\tif (failed) {\n\t\t\tftrace_bug(failed, rec);\n\t\t\t/* Stop processing */\n\t\t\treturn;\n\t\t}\n\t\tif (schedulable)\n\t\t\tcond_resched();\n\t} while_for_each_ftrace_rec();\n}"
  },
  {
    "function_name": "__ftrace_replace_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2537-2571",
    "snippet": "static int\n__ftrace_replace_code(struct dyn_ftrace *rec, bool enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknown ftrace bug */\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_call",
          "args": [
            "rec",
            "ftrace_old_addr",
            "ftrace_addr"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_make_nop",
          "args": [
            "NULL",
            "rec",
            "ftrace_old_addr"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_make_call",
          "args": [
            "rec",
            "ftrace_addr"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_record",
          "args": [
            "rec",
            "enable"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2214-2217",
          "snippet": "int ftrace_update_record(struct dyn_ftrace *rec, bool enable)\n{\n\treturn ftrace_check_record(rec, enable, true);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_update_record(struct dyn_ftrace *rec, bool enable)\n{\n\treturn ftrace_check_record(rec, enable, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_get_addr_curr",
          "args": [
            "rec"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_get_addr_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2506-2535",
          "snippet": "unsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\t/* Direct calls take precedence over trampolines */\n\tif (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\t/* Direct calls take precedence over trampolines */\n\tif (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_get_addr_new",
          "args": [
            "rec"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_get_addr_new",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2465-2494",
          "snippet": "unsigned long ftrace_get_addr_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\tif ((rec->flags & FTRACE_FL_DIRECT) &&\n\t    (ftrace_rec_count(rec) == 1)) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP) {\n\t\tops = ftrace_find_tramp_ops_new(rec);\n\t\tif (FTRACE_WARN_ON(!ops || !ops->trampoline)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip, rec->flags);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\tif ((rec->flags & FTRACE_FL_DIRECT) &&\n\t    (ftrace_rec_count(rec) == 1)) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP) {\n\t\tops = ftrace_find_tramp_ops_new(rec);\n\t\tif (FTRACE_WARN_ON(!ops || !ops->trampoline)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip, rec->flags);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\n__ftrace_replace_code(struct dyn_ftrace *rec, bool enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknown ftrace bug */\n}"
  },
  {
    "function_name": "ftrace_get_addr_curr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2506-2535",
    "snippet": "unsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\t/* Direct calls take precedence over trampolines */\n\tif (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Bad trampoline accounting at: %p (%pS)\\n\"",
            "(void *)rec->ip",
            "(void *)rec->ip"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "!ops"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_curr",
          "args": [
            "rec"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2287-2355",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\t/*\n\t * Need to check removed ops first.\n\t * If they are being removed, and this rec has a tramp,\n\t * and this rec is in the ops list, then it would be the\n\t * one with the tramp.\n\t */\n\tif (removed_ops) {\n\t\tif (hash_contains_ip(ip, &removed_ops->old_hash))\n\t\t\treturn removed_ops;\n\t}\n\n\t/*\n\t * Need to find the current trampoline for a rec.\n\t * Now, a trampoline is only attached to a rec if there\n\t * was a single 'ops' attached to it. But this can be called\n\t * when we are adding another op to the rec or removing the\n\t * current one. Thus, if the op is being added, we can\n\t * ignore it because it hasn't attached itself to the rec\n\t * yet.\n\t *\n\t * If an ops is being modified (hooking to different functions)\n\t * then we don't care about the new functions that are being\n\t * added, just the old ones (that are probably being removed).\n\t *\n\t * If we are adding an ops to a function that already is using\n\t * a trampoline, it needs to be removed (trampolines are only\n\t * for single ops connected), then an ops that is not being\n\t * modified also needs to be checked.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the ops is being added, it hasn't gotten to\n\t\t * the point to be removed from this tree yet.\n\t\t */\n\t\tif (op->flags & FTRACE_OPS_FL_ADDING)\n\t\t\tcontinue;\n\n\n\t\t/*\n\t\t * If the ops is being modified and is in the old\n\t\t * hash, then it is probably being removed from this\n\t\t * function.\n\t\t */\n\t\tif ((op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, &op->old_hash))\n\t\t\treturn op;\n\t\t/*\n\t\t * If the ops is not being added or modified, and it's\n\t\t * in its normal filter hash, then this must be the one\n\t\t * we want!\n\t\t */\n\t\tif (!(op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\t/*\n\t * Need to check removed ops first.\n\t * If they are being removed, and this rec has a tramp,\n\t * and this rec is in the ops list, then it would be the\n\t * one with the tramp.\n\t */\n\tif (removed_ops) {\n\t\tif (hash_contains_ip(ip, &removed_ops->old_hash))\n\t\t\treturn removed_ops;\n\t}\n\n\t/*\n\t * Need to find the current trampoline for a rec.\n\t * Now, a trampoline is only attached to a rec if there\n\t * was a single 'ops' attached to it. But this can be called\n\t * when we are adding another op to the rec or removing the\n\t * current one. Thus, if the op is being added, we can\n\t * ignore it because it hasn't attached itself to the rec\n\t * yet.\n\t *\n\t * If an ops is being modified (hooking to different functions)\n\t * then we don't care about the new functions that are being\n\t * added, just the old ones (that are probably being removed).\n\t *\n\t * If we are adding an ops to a function that already is using\n\t * a trampoline, it needs to be removed (trampolines are only\n\t * for single ops connected), then an ops that is not being\n\t * modified also needs to be checked.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the ops is being added, it hasn't gotten to\n\t\t * the point to be removed from this tree yet.\n\t\t */\n\t\tif (op->flags & FTRACE_OPS_FL_ADDING)\n\t\t\tcontinue;\n\n\n\t\t/*\n\t\t * If the ops is being modified and is in the old\n\t\t * hash, then it is probably being removed from this\n\t\t * function.\n\t\t */\n\t\tif ((op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, &op->old_hash))\n\t\t\treturn op;\n\t\t/*\n\t\t * If the ops is not being added or modified, and it's\n\t\t * in its normal filter hash, then this must be the one\n\t\t * we want!\n\t\t */\n\t\tif (!(op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_rec_direct",
          "args": [
            "rec->ip"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_rec_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2382-2391",
          "snippet": "unsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\t/* Direct calls take precedence over trampolines */\n\tif (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
  },
  {
    "function_name": "ftrace_get_addr_new",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2465-2494",
    "snippet": "unsigned long ftrace_get_addr_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\tif ((rec->flags & FTRACE_FL_DIRECT) &&\n\t    (ftrace_rec_count(rec) == 1)) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP) {\n\t\tops = ftrace_find_tramp_ops_new(rec);\n\t\tif (FTRACE_WARN_ON(!ops || !ops->trampoline)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip, rec->flags);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\"",
            "(void *)rec->ip",
            "(void *)rec->ip",
            "rec->flags"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "!ops || !ops->trampoline"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_new",
          "args": [
            "rec"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_new",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2357-2370",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_rec_direct",
          "args": [
            "rec->ip"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_rec_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2382-2391",
          "snippet": "unsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\tif ((rec->flags & FTRACE_FL_DIRECT) &&\n\t    (ftrace_rec_count(rec) == 1)) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP) {\n\t\tops = ftrace_find_tramp_ops_new(rec);\n\t\tif (FTRACE_WARN_ON(!ops || !ops->trampoline)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip, rec->flags);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
  },
  {
    "function_name": "call_direct_funcs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2426-2437",
    "snippet": "static void call_direct_funcs(unsigned long ip, unsigned long pip,\n\t\t\t      struct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\tunsigned long addr;\n\n\taddr = ftrace_find_rec_direct(ip);\n\tif (!addr)\n\t\treturn;\n\n\tarch_ftrace_set_direct_caller(regs, addr);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_ftrace_set_direct_caller",
          "args": [
            "regs",
            "addr"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_rec_direct",
          "args": [
            "ip"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_rec_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2382-2391",
          "snippet": "unsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_get_regs",
          "args": [
            "fregs"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void call_direct_funcs(unsigned long ip, unsigned long pip,\n\t\t\t      struct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\tunsigned long addr;\n\n\taddr = ftrace_find_rec_direct(ip);\n\tif (!addr)\n\t\treturn;\n\n\tarch_ftrace_set_direct_caller(regs, addr);\n}"
  },
  {
    "function_name": "ftrace_add_rec_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2393-2424",
    "snippet": "static struct ftrace_func_entry*\nftrace_add_rec_direct(unsigned long ip, unsigned long addr,\n\t\t      struct ftrace_hash **free_hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(direct_functions) ||\n\t    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {\n\t\tstruct ftrace_hash *new_hash;\n\t\tint size = ftrace_hash_empty(direct_functions) ? 0 :\n\t\t\tdirect_functions->count + 1;\n\n\t\tif (size < 32)\n\t\t\tsize = 32;\n\n\t\tnew_hash = dup_hash(direct_functions, size);\n\t\tif (!new_hash)\n\t\t\treturn NULL;\n\n\t\t*free_hash = direct_functions;\n\t\tdirect_functions = new_hash;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->ip = ip;\n\tentry->direct = addr;\n\t__add_hash_entry(direct_functions, entry);\n\treturn entry;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_hash_entry",
          "args": [
            "direct_functions",
            "entry"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "__add_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1144-1154",
          "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup_hash",
          "args": [
            "direct_functions",
            "size"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "dup_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1356-1390",
          "snippet": "static struct ftrace_hash *dup_hash(struct ftrace_hash *src, int size)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * Use around half the size (max bit of it), but\n\t * a minimum of 2 is fine (as size of 0 or 1 both give 1 for bits).\n\t */\n\tbits = fls(size / 2);\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\treturn new_hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_MAX_BITS 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_MAX_BITS 12\n\nstatic struct ftrace_hash *dup_hash(struct ftrace_hash *src, int size)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * Use around half the size (max bit of it), but\n\t * a minimum of 2 is fine (as size of 0 or 1 both give 1 for bits).\n\t */\n\tbits = fls(size / 2);\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\treturn new_hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "direct_functions"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_func_entry*\nftrace_add_rec_direct(unsigned long ip, unsigned long addr,\n\t\t      struct ftrace_hash **free_hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(direct_functions) ||\n\t    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {\n\t\tstruct ftrace_hash *new_hash;\n\t\tint size = ftrace_hash_empty(direct_functions) ? 0 :\n\t\t\tdirect_functions->count + 1;\n\n\t\tif (size < 32)\n\t\t\tsize = 32;\n\n\t\tnew_hash = dup_hash(direct_functions, size);\n\t\tif (!new_hash)\n\t\t\treturn NULL;\n\n\t\t*free_hash = direct_functions;\n\t\tdirect_functions = new_hash;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->ip = ip;\n\tentry->direct = addr;\n\t__add_hash_entry(direct_functions, entry);\n\treturn entry;\n}"
  },
  {
    "function_name": "ftrace_find_rec_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2382-2391",
    "snippet": "unsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "direct_functions",
            "ip"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1108-1123",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_find_rec_direct(unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = __ftrace_lookup_ip(direct_functions, ip);\n\tif (!entry)\n\t\treturn 0;\n\n\treturn entry->direct;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_new",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2357-2370",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops __rcu *ftrace_ops_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1444-1457",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_curr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2287-2355",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\t/*\n\t * Need to check removed ops first.\n\t * If they are being removed, and this rec has a tramp,\n\t * and this rec is in the ops list, then it would be the\n\t * one with the tramp.\n\t */\n\tif (removed_ops) {\n\t\tif (hash_contains_ip(ip, &removed_ops->old_hash))\n\t\t\treturn removed_ops;\n\t}\n\n\t/*\n\t * Need to find the current trampoline for a rec.\n\t * Now, a trampoline is only attached to a rec if there\n\t * was a single 'ops' attached to it. But this can be called\n\t * when we are adding another op to the rec or removing the\n\t * current one. Thus, if the op is being added, we can\n\t * ignore it because it hasn't attached itself to the rec\n\t * yet.\n\t *\n\t * If an ops is being modified (hooking to different functions)\n\t * then we don't care about the new functions that are being\n\t * added, just the old ones (that are probably being removed).\n\t *\n\t * If we are adding an ops to a function that already is using\n\t * a trampoline, it needs to be removed (trampolines are only\n\t * for single ops connected), then an ops that is not being\n\t * modified also needs to be checked.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the ops is being added, it hasn't gotten to\n\t\t * the point to be removed from this tree yet.\n\t\t */\n\t\tif (op->flags & FTRACE_OPS_FL_ADDING)\n\t\t\tcontinue;\n\n\n\t\t/*\n\t\t * If the ops is being modified and is in the old\n\t\t * hash, then it is probably being removed from this\n\t\t * function.\n\t\t */\n\t\tif ((op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, &op->old_hash))\n\t\t\treturn op;\n\t\t/*\n\t\t * If the ops is not being added or modified, and it's\n\t\t * in its normal filter hash, then this must be the one\n\t\t * we want!\n\t\t */\n\t\tif (!(op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1444-1457",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\t/*\n\t * Need to check removed ops first.\n\t * If they are being removed, and this rec has a tramp,\n\t * and this rec is in the ops list, then it would be the\n\t * one with the tramp.\n\t */\n\tif (removed_ops) {\n\t\tif (hash_contains_ip(ip, &removed_ops->old_hash))\n\t\t\treturn removed_ops;\n\t}\n\n\t/*\n\t * Need to find the current trampoline for a rec.\n\t * Now, a trampoline is only attached to a rec if there\n\t * was a single 'ops' attached to it. But this can be called\n\t * when we are adding another op to the rec or removing the\n\t * current one. Thus, if the op is being added, we can\n\t * ignore it because it hasn't attached itself to the rec\n\t * yet.\n\t *\n\t * If an ops is being modified (hooking to different functions)\n\t * then we don't care about the new functions that are being\n\t * added, just the old ones (that are probably being removed).\n\t *\n\t * If we are adding an ops to a function that already is using\n\t * a trampoline, it needs to be removed (trampolines are only\n\t * for single ops connected), then an ops that is not being\n\t * modified also needs to be checked.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the ops is being added, it hasn't gotten to\n\t\t * the point to be removed from this tree yet.\n\t\t */\n\t\tif (op->flags & FTRACE_OPS_FL_ADDING)\n\t\t\tcontinue;\n\n\n\t\t/*\n\t\t * If the ops is being modified and is in the old\n\t\t * hash, then it is probably being removed from this\n\t\t * function.\n\t\t */\n\t\tif ((op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, &op->old_hash))\n\t\t\treturn op;\n\t\t/*\n\t\t * If the ops is not being added or modified, and it's\n\t\t * in its normal filter hash, then this must be the one\n\t\t * we want!\n\t\t */\n\t\tif (!(op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2269-2285",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1444-1457",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_any_other",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2251-2267",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_any_other(struct dyn_ftrace *rec, struct ftrace_ops *op_exclude)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (op == op_exclude || !op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops __rcu *ftrace_ops_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1444-1457",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any_other(struct dyn_ftrace *rec, struct ftrace_ops *op_exclude)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (op == op_exclude || !op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_any",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2233-2249",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops __rcu *ftrace_ops_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1444-1457",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_test_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2228-2231",
    "snippet": "int ftrace_test_record(struct dyn_ftrace *rec, bool enable)\n{\n\treturn ftrace_check_record(rec, enable, false);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_check_record",
          "args": [
            "rec",
            "enable",
            "false"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_check_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2071-2204",
          "snippet": "static int ftrace_check_record(struct dyn_ftrace *rec, bool enable, bool update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t * Same for direct calls.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) !=\n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) !=\n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\n\t\t/*\n\t\t * Direct calls are special, as count matters.\n\t\t * We must test the record for direct, if the\n\t\t * DIRECT and DIRECT_EN do not match, but only\n\t\t * if the count is 1. That's because, if the\n\t\t * count is something other than one, we do not\n\t\t * want the direct enabled (it will be done via the\n\t\t * direct helper). But if DIRECT_EN is set, and\n\t\t * the count is not one, we need to clear it.\n\t\t */\n\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\tif (!(rec->flags & FTRACE_FL_DIRECT) !=\n\t\t\t    !(rec->flags & FTRACE_FL_DIRECT_EN))\n\t\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t} else if (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t}\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\n\t\t\tif (flag & FTRACE_FL_DIRECT) {\n\t\t\t\t/*\n\t\t\t\t * If there's only one user (direct_ops helper)\n\t\t\t\t * then we can call the direct function\n\t\t\t\t * directly (no ftrace trampoline).\n\t\t\t\t */\n\t\t\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\t\t\tif (rec->flags & FTRACE_FL_DIRECT)\n\t\t\t\t\t\trec->flags |= FTRACE_FL_DIRECT_EN;\n\t\t\t\t\telse\n\t\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can only call directly if there's\n\t\t\t\t\t * only one callback to the function.\n\t\t\t\t\t */\n\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN | FTRACE_FL_DIRECT_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_check_record(struct dyn_ftrace *rec, bool enable, bool update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t * Same for direct calls.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) !=\n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) !=\n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\n\t\t/*\n\t\t * Direct calls are special, as count matters.\n\t\t * We must test the record for direct, if the\n\t\t * DIRECT and DIRECT_EN do not match, but only\n\t\t * if the count is 1. That's because, if the\n\t\t * count is something other than one, we do not\n\t\t * want the direct enabled (it will be done via the\n\t\t * direct helper). But if DIRECT_EN is set, and\n\t\t * the count is not one, we need to clear it.\n\t\t */\n\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\tif (!(rec->flags & FTRACE_FL_DIRECT) !=\n\t\t\t    !(rec->flags & FTRACE_FL_DIRECT_EN))\n\t\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t} else if (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t}\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\n\t\t\tif (flag & FTRACE_FL_DIRECT) {\n\t\t\t\t/*\n\t\t\t\t * If there's only one user (direct_ops helper)\n\t\t\t\t * then we can call the direct function\n\t\t\t\t * directly (no ftrace trampoline).\n\t\t\t\t */\n\t\t\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\t\t\tif (rec->flags & FTRACE_FL_DIRECT)\n\t\t\t\t\t\trec->flags |= FTRACE_FL_DIRECT_EN;\n\t\t\t\t\telse\n\t\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can only call directly if there's\n\t\t\t\t\t * only one callback to the function.\n\t\t\t\t\t */\n\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN | FTRACE_FL_DIRECT_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_test_record(struct dyn_ftrace *rec, bool enable)\n{\n\treturn ftrace_check_record(rec, enable, false);\n}"
  },
  {
    "function_name": "ftrace_update_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2214-2217",
    "snippet": "int ftrace_update_record(struct dyn_ftrace *rec, bool enable)\n{\n\treturn ftrace_check_record(rec, enable, true);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_check_record",
          "args": [
            "rec",
            "enable",
            "true"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_check_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2071-2204",
          "snippet": "static int ftrace_check_record(struct dyn_ftrace *rec, bool enable, bool update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t * Same for direct calls.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) !=\n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) !=\n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\n\t\t/*\n\t\t * Direct calls are special, as count matters.\n\t\t * We must test the record for direct, if the\n\t\t * DIRECT and DIRECT_EN do not match, but only\n\t\t * if the count is 1. That's because, if the\n\t\t * count is something other than one, we do not\n\t\t * want the direct enabled (it will be done via the\n\t\t * direct helper). But if DIRECT_EN is set, and\n\t\t * the count is not one, we need to clear it.\n\t\t */\n\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\tif (!(rec->flags & FTRACE_FL_DIRECT) !=\n\t\t\t    !(rec->flags & FTRACE_FL_DIRECT_EN))\n\t\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t} else if (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t}\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\n\t\t\tif (flag & FTRACE_FL_DIRECT) {\n\t\t\t\t/*\n\t\t\t\t * If there's only one user (direct_ops helper)\n\t\t\t\t * then we can call the direct function\n\t\t\t\t * directly (no ftrace trampoline).\n\t\t\t\t */\n\t\t\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\t\t\tif (rec->flags & FTRACE_FL_DIRECT)\n\t\t\t\t\t\trec->flags |= FTRACE_FL_DIRECT_EN;\n\t\t\t\t\telse\n\t\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can only call directly if there's\n\t\t\t\t\t * only one callback to the function.\n\t\t\t\t\t */\n\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN | FTRACE_FL_DIRECT_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_check_record(struct dyn_ftrace *rec, bool enable, bool update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t * Same for direct calls.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) !=\n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) !=\n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\n\t\t/*\n\t\t * Direct calls are special, as count matters.\n\t\t * We must test the record for direct, if the\n\t\t * DIRECT and DIRECT_EN do not match, but only\n\t\t * if the count is 1. That's because, if the\n\t\t * count is something other than one, we do not\n\t\t * want the direct enabled (it will be done via the\n\t\t * direct helper). But if DIRECT_EN is set, and\n\t\t * the count is not one, we need to clear it.\n\t\t */\n\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\tif (!(rec->flags & FTRACE_FL_DIRECT) !=\n\t\t\t    !(rec->flags & FTRACE_FL_DIRECT_EN))\n\t\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t} else if (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t}\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\n\t\t\tif (flag & FTRACE_FL_DIRECT) {\n\t\t\t\t/*\n\t\t\t\t * If there's only one user (direct_ops helper)\n\t\t\t\t * then we can call the direct function\n\t\t\t\t * directly (no ftrace trampoline).\n\t\t\t\t */\n\t\t\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\t\t\tif (rec->flags & FTRACE_FL_DIRECT)\n\t\t\t\t\t\trec->flags |= FTRACE_FL_DIRECT_EN;\n\t\t\t\t\telse\n\t\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can only call directly if there's\n\t\t\t\t\t * only one callback to the function.\n\t\t\t\t\t */\n\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN | FTRACE_FL_DIRECT_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_update_record(struct dyn_ftrace *rec, bool enable)\n{\n\treturn ftrace_check_record(rec, enable, true);\n}"
  },
  {
    "function_name": "ftrace_check_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2071-2204",
    "snippet": "static int ftrace_check_record(struct dyn_ftrace *rec, bool enable, bool update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t * Same for direct calls.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) !=\n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) !=\n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\n\t\t/*\n\t\t * Direct calls are special, as count matters.\n\t\t * We must test the record for direct, if the\n\t\t * DIRECT and DIRECT_EN do not match, but only\n\t\t * if the count is 1. That's because, if the\n\t\t * count is something other than one, we do not\n\t\t * want the direct enabled (it will be done via the\n\t\t * direct helper). But if DIRECT_EN is set, and\n\t\t * the count is not one, we need to clear it.\n\t\t */\n\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\tif (!(rec->flags & FTRACE_FL_DIRECT) !=\n\t\t\t    !(rec->flags & FTRACE_FL_DIRECT_EN))\n\t\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t} else if (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t}\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\n\t\t\tif (flag & FTRACE_FL_DIRECT) {\n\t\t\t\t/*\n\t\t\t\t * If there's only one user (direct_ops helper)\n\t\t\t\t * then we can call the direct function\n\t\t\t\t * directly (no ftrace trampoline).\n\t\t\t\t */\n\t\t\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\t\t\tif (rec->flags & FTRACE_FL_DIRECT)\n\t\t\t\t\t\trec->flags |= FTRACE_FL_DIRECT_EN;\n\t\t\t\t\telse\n\t\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can only call directly if there's\n\t\t\t\t\t * only one callback to the function.\n\t\t\t\t\t */\n\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN | FTRACE_FL_DIRECT_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_check_record(struct dyn_ftrace *rec, bool enable, bool update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t * Same for direct calls.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) !=\n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) !=\n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\n\t\t/*\n\t\t * Direct calls are special, as count matters.\n\t\t * We must test the record for direct, if the\n\t\t * DIRECT and DIRECT_EN do not match, but only\n\t\t * if the count is 1. That's because, if the\n\t\t * count is something other than one, we do not\n\t\t * want the direct enabled (it will be done via the\n\t\t * direct helper). But if DIRECT_EN is set, and\n\t\t * the count is not one, we need to clear it.\n\t\t */\n\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\tif (!(rec->flags & FTRACE_FL_DIRECT) !=\n\t\t\t    !(rec->flags & FTRACE_FL_DIRECT_EN))\n\t\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t} else if (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\t\tflag |= FTRACE_FL_DIRECT;\n\t\t}\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\n\t\t\tif (flag & FTRACE_FL_DIRECT) {\n\t\t\t\t/*\n\t\t\t\t * If there's only one user (direct_ops helper)\n\t\t\t\t * then we can call the direct function\n\t\t\t\t * directly (no ftrace trampoline).\n\t\t\t\t */\n\t\t\t\tif (ftrace_rec_count(rec) == 1) {\n\t\t\t\t\tif (rec->flags & FTRACE_FL_DIRECT)\n\t\t\t\t\t\trec->flags |= FTRACE_FL_DIRECT_EN;\n\t\t\t\t\telse\n\t\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can only call directly if there's\n\t\t\t\t\t * only one callback to the function.\n\t\t\t\t\t */\n\t\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT_EN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN | FTRACE_FL_DIRECT_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}"
  },
  {
    "function_name": "ftrace_bug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "2015-2069",
    "snippet": "void ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tpr_info(\"------------[ ftrace bug ]------------\\n\");\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n\n\tFTRACE_WARN_ON_ONCE(1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n expected tramp: %lx\\n\"",
            "ip"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_get_addr_curr",
          "args": [
            "rec"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_get_addr_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2506-2535",
          "snippet": "unsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\t/* Direct calls take precedence over trampolines */\n\tif (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tunsigned long addr;\n\n\t/* Direct calls take precedence over trampolines */\n\tif (rec->flags & FTRACE_FL_DIRECT_EN) {\n\t\taddr = ftrace_find_rec_direct(rec->ip);\n\t\tif (addr)\n\t\t\treturn addr;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\ttramp: ERROR!\""
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_next",
          "args": [
            "rec",
            "ops"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2269-2285",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\ttramp: %pS (%pS)\"",
            "(void *)ops->trampoline",
            "(void *)ops->func"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_any",
          "args": [
            "rec"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_any",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2233-2249",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" (%ld)%s\"",
            "ftrace_rec_count(rec)",
            "rec->flags & FTRACE_FL_REGS ? \" R\" : \"  \""
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace record flags: %lx\\n\"",
            "rec->flags"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_bug_type",
          "args": [],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "print_bug_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1983-2001",
          "snippet": "static void print_bug_type(void)\n{\n\tswitch (ftrace_bug_type) {\n\tcase FTRACE_BUG_UNKNOWN:\n\t\tbreak;\n\tcase FTRACE_BUG_INIT:\n\t\tpr_info(\"Initializing ftrace call sites\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_NOP:\n\t\tpr_info(\"Setting ftrace call site to NOP\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_CALL:\n\t\tpr_info(\"Setting ftrace call site to call ftrace function\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_UPDATE:\n\t\tpr_info(\"Updating ftrace call site to call a different ftrace function\\n\");\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void print_bug_type(void)\n{\n\tswitch (ftrace_bug_type) {\n\tcase FTRACE_BUG_UNKNOWN:\n\t\tbreak;\n\tcase FTRACE_BUG_INIT:\n\t\tpr_info(\"Initializing ftrace call sites\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_NOP:\n\t\tpr_info(\"Setting ftrace call site to NOP\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_CALL:\n\t\tpr_info(\"Setting ftrace call site to call ftrace function\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_UPDATE:\n\t\tpr_info(\"Updating ftrace call site to call a different ftrace function\\n\");\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "KERN_INFO",
            "ip"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace faulted on unknown error \""
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "KERN_INFO",
            "ip"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace faulted on writing \""
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_ins",
          "args": [
            "\" expected: \"",
            "ftrace_expected"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "print_ip_ins",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1964-1978",
          "snippet": "static void print_ip_ins(const char *fmt, const unsigned char *p)\n{\n\tchar ins[MCOUNT_INSN_SIZE];\n\tint i;\n\n\tif (copy_from_kernel_nofault(ins, p, MCOUNT_INSN_SIZE)) {\n\t\tprintk(KERN_CONT \"%s[FAULT] %px\\n\", fmt, p);\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%s\", fmt);\n\n\tfor (i = 0; i < MCOUNT_INSN_SIZE; i++)\n\t\tprintk(KERN_CONT \"%s%02x\", i ? \":\" : \"\", ins[i]);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void print_ip_ins(const char *fmt, const unsigned char *p)\n{\n\tchar ins[MCOUNT_INSN_SIZE];\n\tint i;\n\n\tif (copy_from_kernel_nofault(ins, p, MCOUNT_INSN_SIZE)) {\n\t\tprintk(KERN_CONT \"%s[FAULT] %px\\n\", fmt, p);\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%s\", fmt);\n\n\tfor (i = 0; i < MCOUNT_INSN_SIZE; i++)\n\t\tprintk(KERN_CONT \"%s%02x\", i ? \":\" : \"\", ins[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "KERN_INFO",
            "ip"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace failed to modify \""
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "KERN_INFO",
            "ip"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace faulted on modifying \""
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"------------[ ftrace bug ]------------\\n\""
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tpr_info(\"------------[ ftrace bug ]------------\\n\");\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(KERN_INFO, ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n\n\tFTRACE_WARN_ON_ONCE(1);\n}"
  },
  {
    "function_name": "print_bug_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1983-2001",
    "snippet": "static void print_bug_type(void)\n{\n\tswitch (ftrace_bug_type) {\n\tcase FTRACE_BUG_UNKNOWN:\n\t\tbreak;\n\tcase FTRACE_BUG_INIT:\n\t\tpr_info(\"Initializing ftrace call sites\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_NOP:\n\t\tpr_info(\"Setting ftrace call site to NOP\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_CALL:\n\t\tpr_info(\"Setting ftrace call site to call ftrace function\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_UPDATE:\n\t\tpr_info(\"Updating ftrace call site to call a different ftrace function\\n\");\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Updating ftrace call site to call a different ftrace function\\n\""
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Setting ftrace call site to call ftrace function\\n\""
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Setting ftrace call site to NOP\\n\""
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Initializing ftrace call sites\\n\""
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void print_bug_type(void)\n{\n\tswitch (ftrace_bug_type) {\n\tcase FTRACE_BUG_UNKNOWN:\n\t\tbreak;\n\tcase FTRACE_BUG_INIT:\n\t\tpr_info(\"Initializing ftrace call sites\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_NOP:\n\t\tpr_info(\"Setting ftrace call site to NOP\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_CALL:\n\t\tpr_info(\"Setting ftrace call site to call ftrace function\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_UPDATE:\n\t\tpr_info(\"Updating ftrace call site to call a different ftrace function\\n\");\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "print_ip_ins",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1964-1978",
    "snippet": "static void print_ip_ins(const char *fmt, const unsigned char *p)\n{\n\tchar ins[MCOUNT_INSN_SIZE];\n\tint i;\n\n\tif (copy_from_kernel_nofault(ins, p, MCOUNT_INSN_SIZE)) {\n\t\tprintk(KERN_CONT \"%s[FAULT] %px\\n\", fmt, p);\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%s\", fmt);\n\n\tfor (i = 0; i < MCOUNT_INSN_SIZE; i++)\n\t\tprintk(KERN_CONT \"%s%02x\", i ? \":\" : \"\", ins[i]);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%s%02x\"",
            "i ? \":\" : \"\"",
            "ins[i]"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "230-242",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%s\"",
            "fmt"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "ins",
            "p",
            "MCOUNT_INSN_SIZE"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void print_ip_ins(const char *fmt, const unsigned char *p)\n{\n\tchar ins[MCOUNT_INSN_SIZE];\n\tint i;\n\n\tif (copy_from_kernel_nofault(ins, p, MCOUNT_INSN_SIZE)) {\n\t\tprintk(KERN_CONT \"%s[FAULT] %px\\n\", fmt, p);\n\t\treturn;\n\t}\n\n\tprintk(KERN_CONT \"%s\", fmt);\n\n\tfor (i = 0; i < MCOUNT_INSN_SIZE; i++)\n\t\tprintk(KERN_CONT \"%s%02x\", i ? \":\" : \"\", ins[i]);\n}"
  },
  {
    "function_name": "ftrace_hash_ipmodify_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1950-1962",
    "snippet": "static int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,\n\t\t\t\t       struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_hash *old_hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\told_hash = NULL;\n\n\tif (ftrace_hash_empty(new_hash))\n\t\tnew_hash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_update_ipmodify",
          "args": [
            "ops",
            "old_hash",
            "new_hash"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_update_ipmodify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1857-1927",
          "snippet": "static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "new_hash"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,\n\t\t\t\t       struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_hash *old_hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\told_hash = NULL;\n\n\tif (ftrace_hash_empty(new_hash))\n\t\tnew_hash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);\n}"
  },
  {
    "function_name": "ftrace_hash_ipmodify_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1940-1948",
    "snippet": "static void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\t__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_update_ipmodify",
          "args": [
            "ops",
            "hash",
            "EMPTY_HASH"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_update_ipmodify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1857-1927",
          "snippet": "static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\t__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);\n}"
  },
  {
    "function_name": "ftrace_hash_ipmodify_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1929-1937",
    "snippet": "static int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_update_ipmodify",
          "args": [
            "ops",
            "EMPTY_HASH",
            "hash"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_update_ipmodify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1857-1927",
          "snippet": "static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);\n}"
  },
  {
    "function_name": "__ftrace_hash_update_ipmodify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1857-1927",
    "snippet": "static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "new_hash",
            "rec->ip"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "ftrace_hash_rec_enable_modify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1842-1846",
    "snippet": "static void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_hash_rec_update_modify",
          "args": [
            "ops",
            "filter_hash",
            "1"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_update_modify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1813-1834",
          "snippet": "static void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "struct ftrace_ops global_ops;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}"
  },
  {
    "function_name": "ftrace_hash_rec_disable_modify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1836-1840",
    "snippet": "static void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_hash_rec_update_modify",
          "args": [
            "ops",
            "filter_hash",
            "0"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_update_modify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1813-1834",
          "snippet": "static void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "struct ftrace_ops global_ops;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}"
  },
  {
    "function_name": "ftrace_hash_rec_update_modify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1813-1834",
    "snippet": "static void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_hash_rec_update",
          "args": [
            "op",
            "filter_hash",
            "inc"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_rec_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1631-1799",
          "snippet": "static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags |= FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * Only the internal direct_ops should have the\n\t\t\t * DIRECT flag set. Thus, if it is removing a\n\t\t\t * function, then that function should no longer\n\t\t\t * be direct.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The TRAMP needs to be set only if rec count\n\t\t\t * is decremented to one, and the ops that is\n\t\t\t * left has a trampoline. As TRAMP can only be\n\t\t\t * enabled if there is only a single ops attached\n\t\t\t * to it.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 &&\n\t\t\t    ftrace_find_tramp_ops_any_other(rec, ops))\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, true) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags |= FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * Only the internal direct_ops should have the\n\t\t\t * DIRECT flag set. Thus, if it is removing a\n\t\t\t * function, then that function should no longer\n\t\t\t * be direct.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The TRAMP needs to be set only if rec count\n\t\t\t * is decremented to one, and the ops that is\n\t\t\t * left has a trampoline. As TRAMP can only be\n\t\t\t * enabled if there is only a single ops attached\n\t\t\t * to it.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 &&\n\t\t\t    ftrace_find_tramp_ops_any_other(rec, ops))\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, true) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstruct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}"
  },
  {
    "function_name": "ftrace_hash_rec_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1807-1811",
    "snippet": "static bool ftrace_hash_rec_enable(struct ftrace_ops *ops,\n\t\t\t\t   int filter_hash)\n{\n\treturn __ftrace_hash_rec_update(ops, filter_hash, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_rec_update",
          "args": [
            "ops",
            "filter_hash",
            "1"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_rec_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1631-1799",
          "snippet": "static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags |= FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * Only the internal direct_ops should have the\n\t\t\t * DIRECT flag set. Thus, if it is removing a\n\t\t\t * function, then that function should no longer\n\t\t\t * be direct.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The TRAMP needs to be set only if rec count\n\t\t\t * is decremented to one, and the ops that is\n\t\t\t * left has a trampoline. As TRAMP can only be\n\t\t\t * enabled if there is only a single ops attached\n\t\t\t * to it.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 &&\n\t\t\t    ftrace_find_tramp_ops_any_other(rec, ops))\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, true) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags |= FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * Only the internal direct_ops should have the\n\t\t\t * DIRECT flag set. Thus, if it is removing a\n\t\t\t * function, then that function should no longer\n\t\t\t * be direct.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The TRAMP needs to be set only if rec count\n\t\t\t * is decremented to one, and the ops that is\n\t\t\t * left has a trampoline. As TRAMP can only be\n\t\t\t * enabled if there is only a single ops attached\n\t\t\t * to it.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 &&\n\t\t\t    ftrace_find_tramp_ops_any_other(rec, ops))\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, true) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_hash_rec_enable(struct ftrace_ops *ops,\n\t\t\t\t   int filter_hash)\n{\n\treturn __ftrace_hash_rec_update(ops, filter_hash, 1);\n}"
  },
  {
    "function_name": "ftrace_hash_rec_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1801-1805",
    "snippet": "static bool ftrace_hash_rec_disable(struct ftrace_ops *ops,\n\t\t\t\t    int filter_hash)\n{\n\treturn __ftrace_hash_rec_update(ops, filter_hash, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_rec_update",
          "args": [
            "ops",
            "filter_hash",
            "0"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_rec_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1631-1799",
          "snippet": "static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags |= FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * Only the internal direct_ops should have the\n\t\t\t * DIRECT flag set. Thus, if it is removing a\n\t\t\t * function, then that function should no longer\n\t\t\t * be direct.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The TRAMP needs to be set only if rec count\n\t\t\t * is decremented to one, and the ops that is\n\t\t\t * left has a trampoline. As TRAMP can only be\n\t\t\t * enabled if there is only a single ops attached\n\t\t\t * to it.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 &&\n\t\t\t    ftrace_find_tramp_ops_any_other(rec, ops))\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, true) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags |= FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * Only the internal direct_ops should have the\n\t\t\t * DIRECT flag set. Thus, if it is removing a\n\t\t\t * function, then that function should no longer\n\t\t\t * be direct.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The TRAMP needs to be set only if rec count\n\t\t\t * is decremented to one, and the ops that is\n\t\t\t * left has a trampoline. As TRAMP can only be\n\t\t\t * enabled if there is only a single ops attached\n\t\t\t * to it.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 &&\n\t\t\t    ftrace_find_tramp_ops_any_other(rec, ops))\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, true) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_hash_rec_disable(struct ftrace_ops *ops,\n\t\t\t\t    int filter_hash)\n{\n\treturn __ftrace_hash_rec_update(ops, filter_hash, 0);\n}"
  },
  {
    "function_name": "__ftrace_hash_rec_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1631-1799",
    "snippet": "static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags |= FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * Only the internal direct_ops should have the\n\t\t\t * DIRECT flag set. Thus, if it is removing a\n\t\t\t * function, then that function should no longer\n\t\t\t * be direct.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The TRAMP needs to be set only if rec count\n\t\t\t * is decremented to one, and the ops that is\n\t\t\t * left has a trampoline. As TRAMP can only be\n\t\t\t * enabled if there is only a single ops attached\n\t\t\t * to it.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 &&\n\t\t\t    ftrace_find_tramp_ops_any_other(rec, ops))\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, true) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_test_record",
          "args": [
            "rec",
            "true"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_test_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2228-2231",
          "snippet": "int ftrace_test_record(struct dyn_ftrace *rec, bool enable)\n{\n\treturn ftrace_check_record(rec, enable, false);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_test_record(struct dyn_ftrace *rec, bool enable)\n{\n\treturn ftrace_check_record(rec, enable, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_any_other",
          "args": [
            "rec",
            "ops"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_any_other",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "2251-2267",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_any_other(struct dyn_ftrace *rec, struct ftrace_ops *op_exclude)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (op == op_exclude || !op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any_other(struct dyn_ftrace *rec, struct ftrace_ops *op_exclude)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (op == op_exclude || !op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_rec_ops_needs_regs",
          "args": [
            "rec"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "test_rec_ops_needs_regs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1605-1622",
          "snippet": "static bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tbool keep_regs = false;\n\n\tfor (ops = ftrace_ops_list;\n\t     ops != &ftrace_list_end; ops = ops->next) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (ftrace_ops_test(ops, rec->ip, rec)) {\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tkeep_regs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  keep_regs;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tbool keep_regs = false;\n\n\tfor (ops = ftrace_ops_list;\n\t     ops != &ftrace_list_end; ops = ops->next) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (ftrace_ops_test(ops, rec->ip, rec)) {\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tkeep_regs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  keep_regs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "ftrace_rec_count(rec) == 0"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "ftrace_rec_count(rec) == FTRACE_REF_MAX"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "other_hash"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "other_hash",
            "rec->ip"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1135-1142",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags |= FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * Only the internal direct_ops should have the\n\t\t\t * DIRECT flag set. Thus, if it is removing a\n\t\t\t * function, then that function should no longer\n\t\t\t * be direct.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_DIRECT)\n\t\t\t\trec->flags &= ~FTRACE_FL_DIRECT;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The TRAMP needs to be set only if rec count\n\t\t\t * is decremented to one, and the ops that is\n\t\t\t * left has a trampoline. As TRAMP can only be\n\t\t\t * enabled if there is only a single ops attached\n\t\t\t * to it.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 &&\n\t\t\t    ftrace_find_tramp_ops_any_other(rec, ops))\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, true) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}"
  },
  {
    "function_name": "test_rec_ops_needs_regs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1605-1622",
    "snippet": "static bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tbool keep_regs = false;\n\n\tfor (ops = ftrace_ops_list;\n\t     ops != &ftrace_list_end; ops = ops->next) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (ftrace_ops_test(ops, rec->ip, rec)) {\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tkeep_regs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  keep_regs;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_ops_test",
          "args": [
            "ops",
            "rec->ip",
            "rec"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_test",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1471-1496",
          "snippet": "int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\tstruct ftrace_ops_hash hash;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * There's a small race when adding ops that the ftrace handler\n\t * that wants regs, may be called without them. We can not\n\t * allow that handler to be called if regs is NULL.\n\t */\n\tif (regs == NULL && (ops->flags & FTRACE_OPS_FL_SAVE_REGS))\n\t\treturn 0;\n#endif\n\n\trcu_assign_pointer(hash.filter_hash, ops->func_hash->filter_hash);\n\trcu_assign_pointer(hash.notrace_hash, ops->func_hash->notrace_hash);\n\n\tif (hash_contains_ip(ip, &hash))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\tstruct ftrace_ops_hash hash;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * There's a small race when adding ops that the ftrace handler\n\t * that wants regs, may be called without them. We can not\n\t * allow that handler to be called if regs is NULL.\n\t */\n\tif (regs == NULL && (ops->flags & FTRACE_OPS_FL_SAVE_REGS))\n\t\treturn 0;\n#endif\n\n\trcu_assign_pointer(hash.filter_hash, ops->func_hash->filter_hash);\n\trcu_assign_pointer(hash.notrace_hash, ops->func_hash->notrace_hash);\n\n\tif (hash_contains_ip(ip, &hash))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tbool keep_regs = false;\n\n\tfor (ops = ftrace_ops_list;\n\t     ops != &ftrace_list_end; ops = ops->next) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (ftrace_ops_test(ops, rec->ip, rec)) {\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tkeep_regs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  keep_regs;\n}"
  },
  {
    "function_name": "ftrace_text_reserved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1594-1602",
    "snippet": "int ftrace_text_reserved(const void *start, const void *end)\n{\n\tunsigned long ret;\n\n\tret = ftrace_location_range((unsigned long)start,\n\t\t\t\t    (unsigned long)end);\n\n\treturn (int)!!ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_location_range",
          "args": [
            "(unsigned long)start",
            "(unsigned long)end"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_location_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1559-1568",
          "snippet": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\treturn rec->ip;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\treturn rec->ip;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_text_reserved(const void *start, const void *end)\n{\n\tunsigned long ret;\n\n\tret = ftrace_location_range((unsigned long)start,\n\t\t\t\t    (unsigned long)end);\n\n\treturn (int)!!ret;\n}"
  },
  {
    "function_name": "ftrace_location",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1579-1582",
    "snippet": "unsigned long ftrace_location(unsigned long ip)\n{\n\treturn ftrace_location_range(ip, ip);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_location_range",
          "args": [
            "ip",
            "ip"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_location_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1559-1568",
          "snippet": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\treturn rec->ip;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\treturn rec->ip;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location(unsigned long ip)\n{\n\treturn ftrace_location_range(ip, ip);\n}"
  },
  {
    "function_name": "ftrace_location_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1559-1568",
    "snippet": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\treturn rec->ip;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_rec",
          "args": [
            "start",
            "end"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1525-1545",
          "snippet": "static struct dyn_ftrace *lookup_rec(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec = NULL;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\treturn rec;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct dyn_ftrace *lookup_rec(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec = NULL;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\treturn rec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\treturn rec->ip;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lookup_rec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1525-1545",
    "snippet": "static struct dyn_ftrace *lookup_rec(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec = NULL;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\treturn rec;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&key",
            "pg->records",
            "pg->index",
            "sizeof(struct dyn_ftrace)",
            "ftrace_cmp_recs"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct dyn_ftrace *lookup_rec(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec = NULL;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\tbreak;\n\t}\n\treturn rec;\n}"
  },
  {
    "function_name": "ftrace_cmp_recs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1513-1523",
    "snippet": "static int ftrace_cmp_recs(const void *a, const void *b)\n{\n\tconst struct dyn_ftrace *key = a;\n\tconst struct dyn_ftrace *rec = b;\n\n\tif (key->flags < rec->ip)\n\t\treturn -1;\n\tif (key->ip >= rec->ip + MCOUNT_INSN_SIZE)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_cmp_recs(const void *a, const void *b)\n{\n\tconst struct dyn_ftrace *key = a;\n\tconst struct dyn_ftrace *rec = b;\n\n\tif (key->flags < rec->ip)\n\t\treturn -1;\n\tif (key->ip >= rec->ip + MCOUNT_INSN_SIZE)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_ops_test",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1471-1496",
    "snippet": "int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\tstruct ftrace_ops_hash hash;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * There's a small race when adding ops that the ftrace handler\n\t * that wants regs, may be called without them. We can not\n\t * allow that handler to be called if regs is NULL.\n\t */\n\tif (regs == NULL && (ops->flags & FTRACE_OPS_FL_SAVE_REGS))\n\t\treturn 0;\n#endif\n\n\trcu_assign_pointer(hash.filter_hash, ops->func_hash->filter_hash);\n\trcu_assign_pointer(hash.notrace_hash, ops->func_hash->notrace_hash);\n\n\tif (hash_contains_ip(ip, &hash))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "&hash"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1444-1457",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "hash.notrace_hash",
            "ops->func_hash->notrace_hash"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "hash.filter_hash",
            "ops->func_hash->filter_hash"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\tstruct ftrace_ops_hash hash;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * There's a small race when adding ops that the ftrace handler\n\t * that wants regs, may be called without them. We can not\n\t * allow that handler to be called if regs is NULL.\n\t */\n\tif (regs == NULL && (ops->flags & FTRACE_OPS_FL_SAVE_REGS))\n\t\treturn 0;\n#endif\n\n\trcu_assign_pointer(hash.filter_hash, ops->func_hash->filter_hash);\n\trcu_assign_pointer(hash.notrace_hash, ops->func_hash->notrace_hash);\n\n\tif (hash_contains_ip(ip, &hash))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hash_contains_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1444-1457",
    "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "hash->notrace_hash",
            "ip"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1108-1123",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash->notrace_hash"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an empty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
  },
  {
    "function_name": "ftrace_hash_move",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1406-1442",
    "snippet": "static int\nftrace_hash_move(struct ftrace_ops *ops, int enable,\n\t\t struct ftrace_hash **dst, struct ftrace_hash *src)\n{\n\tstruct ftrace_hash *new_hash;\n\tint ret;\n\n\t/* Reject setting notrace hash on IPMODIFY ftrace_ops */\n\tif (ops->flags & FTRACE_OPS_FL_IPMODIFY && !enable)\n\t\treturn -EINVAL;\n\n\tnew_hash = __ftrace_hash_move(src);\n\tif (!new_hash)\n\t\treturn -ENOMEM;\n\n\t/* Make sure this can be applied if it is IPMODIFY ftrace_ops */\n\tif (enable) {\n\t\t/* IPMODIFY should be updated only when filter_hash updating */\n\t\tret = ftrace_hash_ipmodify_update(ops, new_hash);\n\t\tif (ret < 0) {\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Remove the current set, update the hash and add\n\t * them back.\n\t */\n\tftrace_hash_rec_disable_modify(ops, enable);\n\n\trcu_assign_pointer(*dst, new_hash);\n\n\tftrace_hash_rec_enable_modify(ops, enable);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_hash_rec_enable_modify",
          "args": [
            "ops",
            "enable"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_enable_modify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1842-1846",
          "snippet": "static void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*dst",
            "new_hash"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_rec_disable_modify",
          "args": [
            "ops",
            "enable"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_disable_modify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1836-1840",
          "snippet": "static void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "new_hash"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_ipmodify_update",
          "args": [
            "ops",
            "new_hash"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_ipmodify_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1950-1962",
          "snippet": "static int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,\n\t\t\t\t       struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_hash *old_hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\told_hash = NULL;\n\n\tif (ftrace_hash_empty(new_hash))\n\t\tnew_hash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,\n\t\t\t\t       struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_hash *old_hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\told_hash = NULL;\n\n\tif (ftrace_hash_empty(new_hash))\n\t\tnew_hash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_hash_move",
          "args": [
            "src"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_move",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1392-1404",
          "snippet": "static struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tint size = src->count;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\treturn dup_hash(src, size);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tint size = src->count;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\treturn dup_hash(src, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_hash_move(struct ftrace_ops *ops, int enable,\n\t\t struct ftrace_hash **dst, struct ftrace_hash *src)\n{\n\tstruct ftrace_hash *new_hash;\n\tint ret;\n\n\t/* Reject setting notrace hash on IPMODIFY ftrace_ops */\n\tif (ops->flags & FTRACE_OPS_FL_IPMODIFY && !enable)\n\t\treturn -EINVAL;\n\n\tnew_hash = __ftrace_hash_move(src);\n\tif (!new_hash)\n\t\treturn -ENOMEM;\n\n\t/* Make sure this can be applied if it is IPMODIFY ftrace_ops */\n\tif (enable) {\n\t\t/* IPMODIFY should be updated only when filter_hash updating */\n\t\tret = ftrace_hash_ipmodify_update(ops, new_hash);\n\t\tif (ret < 0) {\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Remove the current set, update the hash and add\n\t * them back.\n\t */\n\tftrace_hash_rec_disable_modify(ops, enable);\n\n\trcu_assign_pointer(*dst, new_hash);\n\n\tftrace_hash_rec_enable_modify(ops, enable);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_hash_move",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1392-1404",
    "snippet": "static struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tint size = src->count;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\treturn dup_hash(src, size);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dup_hash",
          "args": [
            "src",
            "size"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "dup_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1356-1390",
          "snippet": "static struct ftrace_hash *dup_hash(struct ftrace_hash *src, int size)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * Use around half the size (max bit of it), but\n\t * a minimum of 2 is fine (as size of 0 or 1 both give 1 for bits).\n\t */\n\tbits = fls(size / 2);\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\treturn new_hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_MAX_BITS 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_MAX_BITS 12\n\nstatic struct ftrace_hash *dup_hash(struct ftrace_hash *src, int size)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * Use around half the size (max bit of it), but\n\t * a minimum of 2 is fine (as size of 0 or 1 both give 1 for bits).\n\t */\n\tbits = fls(size / 2);\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\treturn new_hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "src"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tint size = src->count;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\treturn dup_hash(src, size);\n}"
  },
  {
    "function_name": "dup_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1356-1390",
    "snippet": "static struct ftrace_hash *dup_hash(struct ftrace_hash *src, int size)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * Use around half the size (max bit of it), but\n\t * a minimum of 2 is fine (as size of 0 or 1 both give 1 for bits).\n\t */\n\tbits = fls(size / 2);\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\treturn new_hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_MAX_BITS 12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_hash_entry",
          "args": [
            "new_hash",
            "entry"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "__add_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1144-1154",
          "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "src",
            "entry"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1179-1185",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "entry",
            "tn",
            "hhd",
            "hlist"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "bits"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1259-1279",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "size / 2"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_MAX_BITS 12\n\nstatic struct ftrace_hash *dup_hash(struct ftrace_hash *src, int size)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * Use around half the size (max bit of it), but\n\t * a minimum of 2 is fine (as size of 0 or 1 both give 1 for bits).\n\t */\n\tbits = fls(size / 2);\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\treturn new_hash;\n}"
  },
  {
    "function_name": "alloc_and_copy_ftrace_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1310-1346",
    "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "new_hash"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "new_hash->count != hash->count"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_hash_entry",
          "args": [
            "new_hash",
            "entry->ip"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "add_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1156-1168",
          "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "size_bits"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1259-1279",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_add_mod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1282-1308",
    "snippet": "static int ftrace_add_mod(struct trace_array *tr,\n\t\t\t  const char *func, const char *module,\n\t\t\t  int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct list_head *mod_head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\n\tftrace_mod = kzalloc(sizeof(*ftrace_mod), GFP_KERNEL);\n\tif (!ftrace_mod)\n\t\treturn -ENOMEM;\n\n\tftrace_mod->func = kstrdup(func, GFP_KERNEL);\n\tftrace_mod->module = kstrdup(module, GFP_KERNEL);\n\tftrace_mod->enable = enable;\n\n\tif (!ftrace_mod->func || !ftrace_mod->module)\n\t\tgoto out_free;\n\n\tlist_add(&ftrace_mod->list, mod_head);\n\n\treturn 0;\n\n out_free:\n\tfree_ftrace_mod(ftrace_mod);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_mod",
          "args": [
            "ftrace_mod"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1206-1212",
          "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ftrace_mod->list",
            "mod_head"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "module",
            "GFP_KERNEL"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "func",
            "GFP_KERNEL"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ftrace_mod)",
            "GFP_KERNEL"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_add_mod(struct trace_array *tr,\n\t\t\t  const char *func, const char *module,\n\t\t\t  int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct list_head *mod_head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\n\tftrace_mod = kzalloc(sizeof(*ftrace_mod), GFP_KERNEL);\n\tif (!ftrace_mod)\n\t\treturn -ENOMEM;\n\n\tftrace_mod->func = kstrdup(func, GFP_KERNEL);\n\tftrace_mod->module = kstrdup(module, GFP_KERNEL);\n\tftrace_mod->enable = enable;\n\n\tif (!ftrace_mod->func || !ftrace_mod->module)\n\t\tgoto out_free;\n\n\tlist_add(&ftrace_mod->list, mod_head);\n\n\treturn 0;\n\n out_free:\n\tfree_ftrace_mod(ftrace_mod);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "alloc_ftrace_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1259-1279",
    "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hash"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "size",
            "sizeof(*hash->buckets)",
            "GFP_KERNEL"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*hash)",
            "GFP_KERNEL"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
  },
  {
    "function_name": "ftrace_free_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1252-1257",
    "snippet": "void ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "ops->func_hash->notrace_hash"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "126-135",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}"
  },
  {
    "function_name": "free_ftrace_hash_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1245-1250",
    "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&hash->rcu",
            "__free_ftrace_hash_rcu"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
  },
  {
    "function_name": "__free_ftrace_hash_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1237-1243",
    "snippet": "static void __free_ftrace_hash_rcu(struct rcu_head *rcu)\n{\n\tstruct ftrace_hash *hash;\n\n\thash = container_of(rcu, struct ftrace_hash, rcu);\n\tfree_ftrace_hash(hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "hash"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1245-1250",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structftrace_hash",
            "rcu"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __free_ftrace_hash_rcu(struct rcu_head *rcu)\n{\n\tstruct ftrace_hash *hash;\n\n\thash = container_of(rcu, struct ftrace_hash, rcu);\n\tfree_ftrace_hash(hash);\n}"
  },
  {
    "function_name": "free_ftrace_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1228-1235",
    "snippet": "static void free_ftrace_hash(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tftrace_hash_clear(hash);\n\tkfree(hash->buckets);\n\tkfree(hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hash"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_clear",
          "args": [
            "hash"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1187-1204",
          "snippet": "static void ftrace_hash_clear(struct ftrace_hash *hash)\n{\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tstruct ftrace_func_entry *entry;\n\tint size = 1 << hash->size_bits;\n\tint i;\n\n\tif (!hash->count)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &hash->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist)\n\t\t\tfree_hash_entry(hash, entry);\n\t}\n\tFTRACE_WARN_ON(hash->count);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_hash_clear(struct ftrace_hash *hash)\n{\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tstruct ftrace_func_entry *entry;\n\tint size = 1 << hash->size_bits;\n\tint i;\n\n\tif (!hash->count)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &hash->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist)\n\t\t\tfree_hash_entry(hash, entry);\n\t}\n\tFTRACE_WARN_ON(hash->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tftrace_hash_clear(hash);\n\tkfree(hash->buckets);\n\tkfree(hash);\n}"
  },
  {
    "function_name": "clear_ftrace_mod_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1214-1226",
    "snippet": "static void clear_ftrace_mod_list(struct list_head *head)\n{\n\tstruct ftrace_mod_load *p, *n;\n\n\t/* stack tracer isn't supported yet */\n\tif (!head)\n\t\treturn;\n\n\tmutex_lock(&ftrace_lock);\n\tlist_for_each_entry_safe(p, n, head, list)\n\t\tfree_ftrace_mod(p);\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_mod",
          "args": [
            "p"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1206-1212",
          "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "head",
            "list"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void clear_ftrace_mod_list(struct list_head *head)\n{\n\tstruct ftrace_mod_load *p, *n;\n\n\t/* stack tracer isn't supported yet */\n\tif (!head)\n\t\treturn;\n\n\tmutex_lock(&ftrace_lock);\n\tlist_for_each_entry_safe(p, n, head, list)\n\t\tfree_ftrace_mod(p);\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "free_ftrace_mod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1206-1212",
    "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ftrace_mod"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ftrace_mod->list"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
  },
  {
    "function_name": "ftrace_hash_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1187-1204",
    "snippet": "static void ftrace_hash_clear(struct ftrace_hash *hash)\n{\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tstruct ftrace_func_entry *entry;\n\tint size = 1 << hash->size_bits;\n\tint i;\n\n\tif (!hash->count)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &hash->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist)\n\t\t\tfree_hash_entry(hash, entry);\n\t}\n\tFTRACE_WARN_ON(hash->count);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "hash->count"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "free_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1170-1177",
          "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "entry",
            "tn",
            "hhd",
            "hlist"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_hash_clear(struct ftrace_hash *hash)\n{\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tstruct ftrace_func_entry *entry;\n\tint size = 1 << hash->size_bits;\n\tint i;\n\n\tif (!hash->count)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &hash->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist)\n\t\t\tfree_hash_entry(hash, entry);\n\t}\n\tFTRACE_WARN_ON(hash->count);\n}"
  },
  {
    "function_name": "remove_hash_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1179-1185",
    "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&entry->hlist"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
  },
  {
    "function_name": "free_hash_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1170-1177",
    "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&entry->hlist"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
  },
  {
    "function_name": "add_hash_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1156-1168",
    "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "__add_hash_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1144-1154",
          "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__add_hash_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1144-1154",
    "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&entry->hlist",
            "hhd"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_key",
          "args": [
            "hash",
            "entry->ip"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1098-1105",
          "snippet": "static __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
  },
  {
    "function_name": "ftrace_lookup_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1135-1142",
    "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "hash",
            "ip"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1108-1123",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "812-815",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
  },
  {
    "function_name": "__ftrace_lookup_ip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1108-1123",
    "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu_notrace",
          "args": [
            "entry",
            "hhd",
            "hlist"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_key",
          "args": [
            "hash",
            "ip"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1098-1105",
          "snippet": "static __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_hash_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1098-1105",
    "snippet": "static __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "ip",
            "hash->size_bits"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_ftrace_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1080-1083",
    "snippet": "bool is_ftrace_trampoline(unsigned long addr)\n{\n\treturn ftrace_ops_trampoline(addr) != NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_ops_trampoline",
          "args": [
            "addr"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_trampoline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1046-1072",
          "snippet": "struct ftrace_ops *ftrace_ops_trampoline(unsigned long addr)\n{\n\tstruct ftrace_ops *op = NULL;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they are freed after a synchronize_rcu().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * This is to check for dynamically allocated trampolines.\n\t\t * Trampolines that are in kernel text will have\n\t\t * core_kernel_text() return true.\n\t\t */\n\t\tif (op->trampoline && op->trampoline_size)\n\t\t\tif (addr >= op->trampoline &&\n\t\t\t    addr < op->trampoline + op->trampoline_size) {\n\t\t\t\tpreempt_enable_notrace();\n\t\t\t\treturn op;\n\t\t\t}\n\t} while_for_each_ftrace_op(op);\n\tpreempt_enable_notrace();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstruct ftrace_ops *ftrace_ops_trampoline(unsigned long addr)\n{\n\tstruct ftrace_ops *op = NULL;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they are freed after a synchronize_rcu().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * This is to check for dynamically allocated trampolines.\n\t\t * Trampolines that are in kernel text will have\n\t\t * core_kernel_text() return true.\n\t\t */\n\t\tif (op->trampoline && op->trampoline_size)\n\t\t\tif (addr >= op->trampoline &&\n\t\t\t    addr < op->trampoline + op->trampoline_size) {\n\t\t\t\tpreempt_enable_notrace();\n\t\t\t\treturn op;\n\t\t\t}\n\t} while_for_each_ftrace_op(op);\n\tpreempt_enable_notrace();\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nbool is_ftrace_trampoline(unsigned long addr)\n{\n\treturn ftrace_ops_trampoline(addr) != NULL;\n}"
  },
  {
    "function_name": "ftrace_ops_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "1046-1072",
    "snippet": "struct ftrace_ops *ftrace_ops_trampoline(unsigned long addr)\n{\n\tstruct ftrace_ops *op = NULL;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they are freed after a synchronize_rcu().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * This is to check for dynamically allocated trampolines.\n\t\t * Trampolines that are in kernel text will have\n\t\t * core_kernel_text() return true.\n\t\t */\n\t\tif (op->trampoline && op->trampoline_size)\n\t\t\tif (addr >= op->trampoline &&\n\t\t\t    addr < op->trampoline + op->trampoline_size) {\n\t\t\t\tpreempt_enable_notrace();\n\t\t\t\treturn op;\n\t\t\t}\n\t} while_for_each_ftrace_op(op);\n\tpreempt_enable_notrace();\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstruct ftrace_ops *ftrace_ops_trampoline(unsigned long addr)\n{\n\tstruct ftrace_ops *op = NULL;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they are freed after a synchronize_rcu().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * This is to check for dynamically allocated trampolines.\n\t\t * Trampolines that are in kernel text will have\n\t\t * core_kernel_text() return true.\n\t\t */\n\t\tif (op->trampoline && op->trampoline_size)\n\t\t\tif (addr >= op->trampoline &&\n\t\t\t    addr < op->trampoline + op->trampoline_size) {\n\t\t\t\tpreempt_enable_notrace();\n\t\t\t\treturn op;\n\t\t\t}\n\t} while_for_each_ftrace_op(op);\n\tpreempt_enable_notrace();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_profile_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "994-996",
    "snippet": "static __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n}"
  },
  {
    "function_name": "ftrace_profile_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "952-991",
    "snippet": "static __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct dentry *entry;\n\tchar *name;\n\tint ret;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\t\tname = kasprintf(GFP_KERNEL, \"function%d\", cpu);\n\t\tif (!name) {\n\t\t\t/*\n\t\t\t * The files created are permanent, if something happens\n\t\t\t * we still do not free memory.\n\t\t\t */\n\t\t\tWARN(1,\n\t\t\t     \"Could not allocate stat file for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\treturn;\n\t\t}\n\t\tstat->stat = function_stats;\n\t\tstat->stat.name = name;\n\t\tret = register_stat_tracer(&stat->stat);\n\t\tif (ret) {\n\t\t\tWARN(1,\n\t\t\t     \"Could not register function stat for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\tkfree(name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tentry = tracefs_create_file(\"function_profile_enabled\",\n\t\t\t\t    TRACE_MODE_WRITE, d_tracer, NULL,\n\t\t\t\t    &ftrace_profile_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'function_profile_enabled' entry\\n\");\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'function_profile_enabled' entry\\n\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"function_profile_enabled\"",
            "TRACE_MODE_WRITE",
            "d_tracer",
            "NULL",
            "&ftrace_profile_fops"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Could not register function stat for cpu %d\\n\"",
            "cpu"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_stat_tracer",
          "args": [
            "&stat->stat"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_stat_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "351-364",
          "snippet": "void unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_stat_sessions);",
            "static DEFINE_MUTEX(all_stat_sessions_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(all_stat_sessions);\nstatic DEFINE_MUTEX(all_stat_sessions_mutex);\n\nvoid unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Could not allocate stat file for cpu %d\\n\"",
            "cpu"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"function%d\"",
            "cpu"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "ftrace_profile_stats",
            "cpu"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct dentry *entry;\n\tchar *name;\n\tint ret;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\t\tname = kasprintf(GFP_KERNEL, \"function%d\", cpu);\n\t\tif (!name) {\n\t\t\t/*\n\t\t\t * The files created are permanent, if something happens\n\t\t\t * we still do not free memory.\n\t\t\t */\n\t\t\tWARN(1,\n\t\t\t     \"Could not allocate stat file for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\treturn;\n\t\t}\n\t\tstat->stat = function_stats;\n\t\tstat->stat.name = name;\n\t\tret = register_stat_tracer(&stat->stat);\n\t\tif (ret) {\n\t\t\tWARN(1,\n\t\t\t     \"Could not register function stat for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\tkfree(name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tentry = tracefs_create_file(\"function_profile_enabled\",\n\t\t\t\t    TRACE_MODE_WRITE, d_tracer, NULL,\n\t\t\t\t    &ftrace_profile_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'function_profile_enabled' entry\\n\");\n}"
  },
  {
    "function_name": "ftrace_profile_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "924-933",
    "snippet": "static ssize_t\nftrace_profile_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\t\t/* big enough to hold a number */\n\tint r;\n\n\tr = sprintf(buf, \"%u\\n\", ftrace_profile_enabled);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "r"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "ftrace_profile_enabled"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_profile_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\t\t/* big enough to hold a number */\n\tint r;\n\n\tr = sprintf(buf, \"%u\\n\", ftrace_profile_enabled);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}"
  },
  {
    "function_name": "ftrace_profile_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "879-922",
    "snippet": "static ssize_t\nftrace_profile_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = !!val;\n\n\tmutex_lock(&ftrace_profile_lock);\n\tif (ftrace_profile_enabled ^ val) {\n\t\tif (val) {\n\t\t\tret = ftrace_profile_init();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = register_ftrace_profiler();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tftrace_profile_enabled = 1;\n\t\t} else {\n\t\t\tftrace_profile_enabled = 0;\n\t\t\t/*\n\t\t\t * unregister_ftrace_profiler calls stop_machine\n\t\t\t * so this acts like an synchronize_rcu.\n\t\t\t */\n\t\t\tunregister_ftrace_profiler();\n\t\t}\n\t}\n out:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_profile_lock"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_profiler",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_profiler",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "873-876",
          "snippet": "static void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_function(&ftrace_profile_ops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_function(&ftrace_profile_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_profile_init",
          "args": [],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "669-681",
          "snippet": "static int ftrace_profile_init(void)\n{\n\tint cpu;\n\tint ret = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = ftrace_profile_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_profile_init(void)\n{\n\tint cpu;\n\tint ret = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = ftrace_profile_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_profile_lock"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "cnt",
            "10",
            "&val"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_profile_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = !!val;\n\n\tmutex_lock(&ftrace_profile_lock);\n\tif (ftrace_profile_enabled ^ val) {\n\t\tif (val) {\n\t\t\tret = ftrace_profile_init();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = register_ftrace_profiler();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tftrace_profile_enabled = 1;\n\t\t} else {\n\t\t\tftrace_profile_enabled = 0;\n\t\t\t/*\n\t\t\t * unregister_ftrace_profiler calls stop_machine\n\t\t\t * so this acts like an synchronize_rcu.\n\t\t\t */\n\t\t\tunregister_ftrace_profiler();\n\t\t}\n\t}\n out:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "unregister_ftrace_profiler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "873-876",
    "snippet": "static void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_function(&ftrace_profile_ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&ftrace_profile_ops"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_function(&ftrace_profile_ops);\n}"
  },
  {
    "function_name": "register_ftrace_profiler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "868-871",
    "snippet": "static int register_ftrace_profiler(void)\n{\n\treturn register_ftrace_function(&ftrace_profile_ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&ftrace_profile_ops"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int register_ftrace_profiler(void)\n{\n\treturn register_ftrace_function(&ftrace_profile_ops);\n}"
  },
  {
    "function_name": "unregister_ftrace_profiler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "857-860",
    "snippet": "static void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_graph(&fprofiler_ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_graph",
          "args": [
            "&fprofiler_ops"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_graph(&fprofiler_ops);\n}"
  },
  {
    "function_name": "register_ftrace_profiler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "852-855",
    "snippet": "static int register_ftrace_profiler(void)\n{\n\treturn register_ftrace_graph(&fprofiler_ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_graph",
          "args": [
            "&fprofiler_ops"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int register_ftrace_profiler(void)\n{\n\treturn register_ftrace_graph(&fprofiler_ops);\n}"
  },
  {
    "function_name": "profile_graph_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "804-845",
    "snippet": "static void profile_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct ftrace_ret_stack *ret_stack;\n\tstruct ftrace_profile_stat *stat;\n\tunsigned long long calltime;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\t/* If the calltime was zero'd ignore it */\n\tif (!trace->calltime)\n\t\tgoto out;\n\n\tcalltime = trace->rettime - trace->calltime;\n\n\tif (!fgraph_graph_time) {\n\n\t\t/* Append this call time to the parent time to subtract */\n\t\tret_stack = ftrace_graph_get_ret_stack(current, 1);\n\t\tif (ret_stack)\n\t\t\tret_stack->subtime += calltime;\n\n\t\tret_stack = ftrace_graph_get_ret_stack(current, 0);\n\t\tif (ret_stack && ret_stack->subtime < calltime)\n\t\t\tcalltime -= ret_stack->subtime;\n\t\telse\n\t\t\tcalltime = 0;\n\t}\n\n\trec = ftrace_find_profiled_func(stat, trace->func);\n\tif (rec) {\n\t\trec->time += calltime;\n\t\trec->time_squared += calltime * calltime;\n\t}\n\n out:\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_profiled_func",
          "args": [
            "stat",
            "trace->func"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_profiled_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "684-703",
          "snippet": "static struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_get_ret_stack",
          "args": [
            "current",
            "0"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_get_ret_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "271-280",
          "snippet": "struct ftrace_ret_stack *\nftrace_graph_get_ret_stack(struct task_struct *task, int idx)\n{\n\tidx = task->curr_ret_stack - idx;\n\n\tif (idx >= 0 && idx <= task->curr_ret_stack)\n\t\treturn &task->ret_stack[idx];\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nstruct ftrace_ret_stack *\nftrace_graph_get_ret_stack(struct task_struct *task, int idx)\n{\n\tidx = task->curr_ret_stack - idx;\n\n\tif (idx >= 0 && idx <= task->curr_ret_stack)\n\t\treturn &task->ret_stack[idx];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&ftrace_profile_stats"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void profile_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct ftrace_ret_stack *ret_stack;\n\tstruct ftrace_profile_stat *stat;\n\tunsigned long long calltime;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\t/* If the calltime was zero'd ignore it */\n\tif (!trace->calltime)\n\t\tgoto out;\n\n\tcalltime = trace->rettime - trace->calltime;\n\n\tif (!fgraph_graph_time) {\n\n\t\t/* Append this call time to the parent time to subtract */\n\t\tret_stack = ftrace_graph_get_ret_stack(current, 1);\n\t\tif (ret_stack)\n\t\t\tret_stack->subtime += calltime;\n\n\t\tret_stack = ftrace_graph_get_ret_stack(current, 0);\n\t\tif (ret_stack && ret_stack->subtime < calltime)\n\t\t\tcalltime -= ret_stack->subtime;\n\t\telse\n\t\t\tcalltime = 0;\n\t}\n\n\trec = ftrace_find_profiled_func(stat, trace->func);\n\tif (rec) {\n\t\trec->time += calltime;\n\t\trec->time_squared += calltime * calltime;\n\t}\n\n out:\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "profile_graph_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "787-802",
    "snippet": "static int profile_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct ftrace_ret_stack *ret_stack;\n\n\tfunction_profile_call(trace->func, 0, NULL, NULL);\n\n\t/* If function graph is shutting down, ret_stack can be NULL */\n\tif (!current->ret_stack)\n\t\treturn 0;\n\n\tret_stack = ftrace_graph_get_ret_stack(current, 0);\n\tif (ret_stack)\n\t\tret_stack->subtime = 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_graph_get_ret_stack",
          "args": [
            "current",
            "0"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_get_ret_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "271-280",
          "snippet": "struct ftrace_ret_stack *\nftrace_graph_get_ret_stack(struct task_struct *task, int idx)\n{\n\tidx = task->curr_ret_stack - idx;\n\n\tif (idx >= 0 && idx <= task->curr_ret_stack)\n\t\treturn &task->ret_stack[idx];\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nstruct ftrace_ret_stack *\nftrace_graph_get_ret_stack(struct task_struct *task, int idx)\n{\n\tidx = task->curr_ret_stack - idx;\n\n\tif (idx >= 0 && idx <= task->curr_ret_stack)\n\t\treturn &task->ret_stack[idx];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "function_profile_call",
          "args": [
            "trace->func",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "function_profile_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "750-777",
          "snippet": "static void\nfunction_profile_call(unsigned long ip, unsigned long parent_ip,\n\t\t      struct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tif (!ftrace_profile_enabled)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (!rec) {\n\t\trec = ftrace_profile_alloc(stat, ip);\n\t\tif (!rec)\n\t\t\tgoto out;\n\t}\n\n\trec->counter++;\n out:\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void\nfunction_profile_call(unsigned long ip, unsigned long parent_ip,\n\t\t      struct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tif (!ftrace_profile_enabled)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (!rec) {\n\t\trec = ftrace_profile_alloc(stat, ip);\n\t\tif (!rec)\n\t\t\tgoto out;\n\t}\n\n\trec->counter++;\n out:\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int profile_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct ftrace_ret_stack *ret_stack;\n\n\tfunction_profile_call(trace->func, 0, NULL, NULL);\n\n\t/* If function graph is shutting down, ret_stack can be NULL */\n\tif (!current->ret_stack)\n\t\treturn 0;\n\n\tret_stack = ftrace_graph_get_ret_stack(current, 0);\n\tif (ret_stack)\n\t\tret_stack->subtime = 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_graph_graph_time_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "782-785",
    "snippet": "void ftrace_graph_graph_time_control(bool enable)\n{\n\tfgraph_graph_time = enable;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_graph_time_control(bool enable)\n{\n\tfgraph_graph_time = enable;\n}"
  },
  {
    "function_name": "function_profile_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "750-777",
    "snippet": "static void\nfunction_profile_call(unsigned long ip, unsigned long parent_ip,\n\t\t      struct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tif (!ftrace_profile_enabled)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (!rec) {\n\t\trec = ftrace_profile_alloc(stat, ip);\n\t\tif (!rec)\n\t\t\tgoto out;\n\t}\n\n\trec->counter++;\n out:\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_profile_alloc",
          "args": [
            "stat",
            "ip"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "717-748",
          "snippet": "static struct ftrace_profile *\nftrace_profile_alloc(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec = NULL;\n\n\t/* prevent recursion (from NMIs) */\n\tif (atomic_inc_return(&stat->disabled) != 1)\n\t\tgoto out;\n\n\t/*\n\t * Try to find the function again since an NMI\n\t * could have added it\n\t */\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (rec)\n\t\tgoto out;\n\n\tif (stat->pages->index == PROFILES_PER_PAGE) {\n\t\tif (!stat->pages->next)\n\t\t\tgoto out;\n\t\tstat->pages = stat->pages->next;\n\t}\n\n\trec = &stat->pages->records[stat->pages->index++];\n\trec->ip = ip;\n\tftrace_add_profile(stat, rec);\n\n out:\n\tatomic_dec(&stat->disabled);\n\n\treturn rec;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))\n\nstatic struct ftrace_profile *\nftrace_profile_alloc(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec = NULL;\n\n\t/* prevent recursion (from NMIs) */\n\tif (atomic_inc_return(&stat->disabled) != 1)\n\t\tgoto out;\n\n\t/*\n\t * Try to find the function again since an NMI\n\t * could have added it\n\t */\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (rec)\n\t\tgoto out;\n\n\tif (stat->pages->index == PROFILES_PER_PAGE) {\n\t\tif (!stat->pages->next)\n\t\t\tgoto out;\n\t\tstat->pages = stat->pages->next;\n\t}\n\n\trec = &stat->pages->records[stat->pages->index++];\n\trec->ip = ip;\n\tftrace_add_profile(stat, rec);\n\n out:\n\tatomic_dec(&stat->disabled);\n\n\treturn rec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_profiled_func",
          "args": [
            "stat",
            "ip"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_profiled_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "684-703",
          "snippet": "static struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&ftrace_profile_stats"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void\nfunction_profile_call(unsigned long ip, unsigned long parent_ip,\n\t\t      struct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tif (!ftrace_profile_enabled)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (!rec) {\n\t\trec = ftrace_profile_alloc(stat, ip);\n\t\tif (!rec)\n\t\t\tgoto out;\n\t}\n\n\trec->counter++;\n out:\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "ftrace_profile_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "717-748",
    "snippet": "static struct ftrace_profile *\nftrace_profile_alloc(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec = NULL;\n\n\t/* prevent recursion (from NMIs) */\n\tif (atomic_inc_return(&stat->disabled) != 1)\n\t\tgoto out;\n\n\t/*\n\t * Try to find the function again since an NMI\n\t * could have added it\n\t */\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (rec)\n\t\tgoto out;\n\n\tif (stat->pages->index == PROFILES_PER_PAGE) {\n\t\tif (!stat->pages->next)\n\t\t\tgoto out;\n\t\tstat->pages = stat->pages->next;\n\t}\n\n\trec = &stat->pages->records[stat->pages->index++];\n\trec->ip = ip;\n\tftrace_add_profile(stat, rec);\n\n out:\n\tatomic_dec(&stat->disabled);\n\n\treturn rec;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&stat->disabled"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_add_profile",
          "args": [
            "stat",
            "rec"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_add_profile",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "705-712",
          "snippet": "static void ftrace_add_profile(struct ftrace_profile_stat *stat,\n\t\t\t       struct ftrace_profile *rec)\n{\n\tunsigned long key;\n\n\tkey = hash_long(rec->ip, FTRACE_PROFILE_HASH_BITS);\n\thlist_add_head_rcu(&rec->node, &stat->hash[key]);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic void ftrace_add_profile(struct ftrace_profile_stat *stat,\n\t\t\t       struct ftrace_profile *rec)\n{\n\tunsigned long key;\n\n\tkey = hash_long(rec->ip, FTRACE_PROFILE_HASH_BITS);\n\thlist_add_head_rcu(&rec->node, &stat->hash[key]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_profiled_func",
          "args": [
            "stat",
            "ip"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_profiled_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "684-703",
          "snippet": "static struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&stat->disabled"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))\n\nstatic struct ftrace_profile *\nftrace_profile_alloc(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec = NULL;\n\n\t/* prevent recursion (from NMIs) */\n\tif (atomic_inc_return(&stat->disabled) != 1)\n\t\tgoto out;\n\n\t/*\n\t * Try to find the function again since an NMI\n\t * could have added it\n\t */\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (rec)\n\t\tgoto out;\n\n\tif (stat->pages->index == PROFILES_PER_PAGE) {\n\t\tif (!stat->pages->next)\n\t\t\tgoto out;\n\t\tstat->pages = stat->pages->next;\n\t}\n\n\trec = &stat->pages->records[stat->pages->index++];\n\trec->ip = ip;\n\tftrace_add_profile(stat, rec);\n\n out:\n\tatomic_dec(&stat->disabled);\n\n\treturn rec;\n}"
  },
  {
    "function_name": "ftrace_add_profile",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "705-712",
    "snippet": "static void ftrace_add_profile(struct ftrace_profile_stat *stat,\n\t\t\t       struct ftrace_profile *rec)\n{\n\tunsigned long key;\n\n\tkey = hash_long(rec->ip, FTRACE_PROFILE_HASH_BITS);\n\thlist_add_head_rcu(&rec->node, &stat->hash[key]);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_PROFILE_HASH_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&rec->node",
            "&stat->hash[key]"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "rec->ip",
            "FTRACE_PROFILE_HASH_BITS"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic void ftrace_add_profile(struct ftrace_profile_stat *stat,\n\t\t\t       struct ftrace_profile *rec)\n{\n\tunsigned long key;\n\n\tkey = hash_long(rec->ip, FTRACE_PROFILE_HASH_BITS);\n\thlist_add_head_rcu(&rec->node, &stat->hash[key]);\n}"
  },
  {
    "function_name": "ftrace_find_profiled_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "684-703",
    "snippet": "static struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_PROFILE_HASH_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu_notrace",
          "args": [
            "rec",
            "hhd",
            "node"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "hhd"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "ip",
            "FTRACE_PROFILE_HASH_BITS"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_profile_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "669-681",
    "snippet": "static int ftrace_profile_init(void)\n{\n\tint cpu;\n\tint ret = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = ftrace_profile_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_profile_init_cpu",
          "args": [
            "cpu"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_init_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "635-667",
          "snippet": "static int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)\n\nstatic int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_profile_init(void)\n{\n\tint cpu;\n\tint ret = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = ftrace_profile_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_profile_init_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "635-667",
    "snippet": "static int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stat->hash"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_profile_pages_init",
          "args": [
            "stat"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_pages_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "579-633",
          "snippet": "static int ftrace_profile_pages_init(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\tint functions;\n\tint pages;\n\tint i;\n\n\t/* If we already allocated, do nothing */\n\tif (stat->pages)\n\t\treturn 0;\n\n\tstat->pages = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!stat->pages)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tfunctions = ftrace_update_tot_cnt;\n#else\n\t/*\n\t * We do not know the number of functions that exist because\n\t * dynamic tracing is what counts them. With past experience\n\t * we have around 20K functions. That should be more than enough.\n\t * It is highly unlikely we will execute every function in\n\t * the kernel.\n\t */\n\tfunctions = 20000;\n#endif\n\n\tpg = stat->start = stat->pages;\n\n\tpages = DIV_ROUND_UP(functions, PROFILES_PER_PAGE);\n\n\tfor (i = 1; i < pages; i++) {\n\t\tpg->next = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto out_free;\n\t\tpg = pg->next;\n\t}\n\n\treturn 0;\n\n out_free:\n\tpg = stat->start;\n\twhile (pg) {\n\t\tunsigned long tmp = (unsigned long)pg;\n\n\t\tpg = pg->next;\n\t\tfree_page(tmp);\n\t}\n\n\tstat->pages = NULL;\n\tstat->start = NULL;\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))\n\nstatic int ftrace_profile_pages_init(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\tint functions;\n\tint pages;\n\tint i;\n\n\t/* If we already allocated, do nothing */\n\tif (stat->pages)\n\t\treturn 0;\n\n\tstat->pages = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!stat->pages)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tfunctions = ftrace_update_tot_cnt;\n#else\n\t/*\n\t * We do not know the number of functions that exist because\n\t * dynamic tracing is what counts them. With past experience\n\t * we have around 20K functions. That should be more than enough.\n\t * It is highly unlikely we will execute every function in\n\t * the kernel.\n\t */\n\tfunctions = 20000;\n#endif\n\n\tpg = stat->start = stat->pages;\n\n\tpages = DIV_ROUND_UP(functions, PROFILES_PER_PAGE);\n\n\tfor (i = 1; i < pages; i++) {\n\t\tpg->next = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto out_free;\n\t\tpg = pg->next;\n\t}\n\n\treturn 0;\n\n out_free:\n\tpg = stat->start;\n\twhile (pg) {\n\t\tunsigned long tmp = (unsigned long)pg;\n\n\t\tpg = pg->next;\n\t\tfree_page(tmp);\n\t}\n\n\tstat->pages = NULL;\n\tstat->start = NULL;\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "size",
            "sizeof(struct hlist_head)",
            "GFP_KERNEL"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_profile_reset",
          "args": [
            "stat"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "563-577",
          "snippet": "static void ftrace_profile_reset(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\n\tpg = stat->pages = stat->start;\n\n\twhile (pg) {\n\t\tmemset(pg->records, 0, PROFILE_RECORDS_SIZE);\n\t\tpg->index = 0;\n\t\tpg = pg->next;\n\t}\n\n\tmemset(stat->hash, 0,\n\t       FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)",
            "#define PROFILE_RECORDS_SIZE\t\t\t\t\t\t\\\n\t(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)\n#define PROFILE_RECORDS_SIZE\t\t\t\t\t\t\\\n\t(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))\n\nstatic void ftrace_profile_reset(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\n\tpg = stat->pages = stat->start;\n\n\twhile (pg) {\n\t\tmemset(pg->records, 0, PROFILE_RECORDS_SIZE);\n\t\tpg->index = 0;\n\t\tpg = pg->next;\n\t}\n\n\tmemset(stat->hash, 0,\n\t       FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head));\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "ftrace_profile_stats",
            "cpu"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)\n\nstatic int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_profile_pages_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "579-633",
    "snippet": "static int ftrace_profile_pages_init(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\tint functions;\n\tint pages;\n\tint i;\n\n\t/* If we already allocated, do nothing */\n\tif (stat->pages)\n\t\treturn 0;\n\n\tstat->pages = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!stat->pages)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tfunctions = ftrace_update_tot_cnt;\n#else\n\t/*\n\t * We do not know the number of functions that exist because\n\t * dynamic tracing is what counts them. With past experience\n\t * we have around 20K functions. That should be more than enough.\n\t * It is highly unlikely we will execute every function in\n\t * the kernel.\n\t */\n\tfunctions = 20000;\n#endif\n\n\tpg = stat->start = stat->pages;\n\n\tpages = DIV_ROUND_UP(functions, PROFILES_PER_PAGE);\n\n\tfor (i = 1; i < pages; i++) {\n\t\tpg->next = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto out_free;\n\t\tpg = pg->next;\n\t}\n\n\treturn 0;\n\n out_free:\n\tpg = stat->start;\n\twhile (pg) {\n\t\tunsigned long tmp = (unsigned long)pg;\n\n\t\tpg = pg->next;\n\t\tfree_page(tmp);\n\t}\n\n\tstat->pages = NULL;\n\tstat->start = NULL;\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "tmp"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "functions",
            "PROFILES_PER_PAGE"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))\n\nstatic int ftrace_profile_pages_init(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\tint functions;\n\tint pages;\n\tint i;\n\n\t/* If we already allocated, do nothing */\n\tif (stat->pages)\n\t\treturn 0;\n\n\tstat->pages = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!stat->pages)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tfunctions = ftrace_update_tot_cnt;\n#else\n\t/*\n\t * We do not know the number of functions that exist because\n\t * dynamic tracing is what counts them. With past experience\n\t * we have around 20K functions. That should be more than enough.\n\t * It is highly unlikely we will execute every function in\n\t * the kernel.\n\t */\n\tfunctions = 20000;\n#endif\n\n\tpg = stat->start = stat->pages;\n\n\tpages = DIV_ROUND_UP(functions, PROFILES_PER_PAGE);\n\n\tfor (i = 1; i < pages; i++) {\n\t\tpg->next = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto out_free;\n\t\tpg = pg->next;\n\t}\n\n\treturn 0;\n\n out_free:\n\tpg = stat->start;\n\twhile (pg) {\n\t\tunsigned long tmp = (unsigned long)pg;\n\n\t\tpg = pg->next;\n\t\tfree_page(tmp);\n\t}\n\n\tstat->pages = NULL;\n\tstat->start = NULL;\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ftrace_profile_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "563-577",
    "snippet": "static void ftrace_profile_reset(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\n\tpg = stat->pages = stat->start;\n\n\twhile (pg) {\n\t\tmemset(pg->records, 0, PROFILE_RECORDS_SIZE);\n\t\tpg->index = 0;\n\t\tpg = pg->next;\n\t}\n\n\tmemset(stat->hash, 0,\n\t       FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head));\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)",
      "#define PROFILE_RECORDS_SIZE\t\t\t\t\t\t\\\n\t(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stat->hash",
            "0",
            "FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pg->records",
            "0",
            "PROFILE_RECORDS_SIZE"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)\n#define PROFILE_RECORDS_SIZE\t\t\t\t\t\t\\\n\t(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))\n\nstatic void ftrace_profile_reset(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\n\tpg = stat->pages = stat->start;\n\n\twhile (pg) {\n\t\tmemset(pg->records, 0, PROFILE_RECORDS_SIZE);\n\t\tpg->index = 0;\n\t\tpg = pg->next;\n\t}\n\n\tmemset(stat->hash, 0,\n\t       FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head));\n}"
  },
  {
    "function_name": "function_stat_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "499-561",
    "snippet": "static int function_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_profile *rec = v;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint ret = 0;\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tstatic struct trace_seq s;\n\tunsigned long long avg;\n\tunsigned long long stddev;\n#endif\n\tmutex_lock(&ftrace_profile_lock);\n\n\t/* we raced with function_profile_reset() */\n\tif (unlikely(rec->counter == 0)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tavg = div64_ul(rec->time, rec->counter);\n\tif (tracing_thresh && (avg < tracing_thresh))\n\t\tgoto out;\n#endif\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, NULL, str);\n\tseq_printf(m, \"  %-30.30s  %10lu\", str, rec->counter);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tseq_puts(m, \"    \");\n\n\t/* Sample standard deviation (s^2) */\n\tif (rec->counter <= 1)\n\t\tstddev = 0;\n\telse {\n\t\t/*\n\t\t * Apply Welford's method:\n\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)\n\t\t */\n\t\tstddev = rec->counter * rec->time_squared -\n\t\t\t rec->time * rec->time;\n\n\t\t/*\n\t\t * Divide only 1000 for ns^2 -> us^2 conversion.\n\t\t * trace_print_graph_duration will divide 1000 again.\n\t\t */\n\t\tstddev = div64_ul(stddev,\n\t\t\t\t  rec->counter * (rec->counter - 1) * 1000);\n\t}\n\n\ttrace_seq_init(&s);\n\ttrace_print_graph_duration(rec->time, &s);\n\ttrace_seq_puts(&s, \"    \");\n\ttrace_print_graph_duration(avg, &s);\n\ttrace_seq_puts(&s, \"    \");\n\ttrace_print_graph_duration(stddev, &s);\n\ttrace_print_seq(m, &s);\n#endif\n\tseq_putc(m, '\\n');\nout:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_profile_lock"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_seq",
          "args": [
            "m",
            "&s"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "51-68",
          "snippet": "int trace_print_seq(struct seq_file *m, struct trace_seq *s)\n{\n\tint ret;\n\n\t__trace_seq_init(s);\n\n\tret = seq_buf_print_seq(m, &s->seq);\n\n\t/*\n\t * Only reset this buffer if we successfully wrote to the\n\t * seq_file buffer. This lets the caller try again or\n\t * do something else with the contents.\n\t */\n\tif (!ret)\n\t\ttrace_seq_init(s);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nint trace_print_seq(struct seq_file *m, struct trace_seq *s)\n{\n\tint ret;\n\n\t__trace_seq_init(s);\n\n\tret = seq_buf_print_seq(m, &s->seq);\n\n\t/*\n\t * Only reset this buffer if we successfully wrote to the\n\t * seq_file buffer. This lets the caller try again or\n\t * do something else with the contents.\n\t */\n\tif (!ret)\n\t\ttrace_seq_init(s);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_graph_duration",
          "args": [
            "stddev",
            "&s"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_graph_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "558-589",
          "snippet": "void\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "&s",
            "\"    \""
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "&s"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "36-40",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_ul",
          "args": [
            "stddev",
            "rec->counter * (rec->counter - 1) * 1000"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %-30.30s  %10lu\"",
            "str",
            "rec->counter"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "rec->ip",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_ul",
          "args": [
            "rec->time",
            "rec->counter"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rec->counter == 0"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_profile_lock"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int function_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_profile *rec = v;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint ret = 0;\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tstatic struct trace_seq s;\n\tunsigned long long avg;\n\tunsigned long long stddev;\n#endif\n\tmutex_lock(&ftrace_profile_lock);\n\n\t/* we raced with function_profile_reset() */\n\tif (unlikely(rec->counter == 0)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tavg = div64_ul(rec->time, rec->counter);\n\tif (tracing_thresh && (avg < tracing_thresh))\n\t\tgoto out;\n#endif\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, NULL, str);\n\tseq_printf(m, \"  %-30.30s  %10lu\", str, rec->counter);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tseq_puts(m, \"    \");\n\n\t/* Sample standard deviation (s^2) */\n\tif (rec->counter <= 1)\n\t\tstddev = 0;\n\telse {\n\t\t/*\n\t\t * Apply Welford's method:\n\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)\n\t\t */\n\t\tstddev = rec->counter * rec->time_squared -\n\t\t\t rec->time * rec->time;\n\n\t\t/*\n\t\t * Divide only 1000 for ns^2 -> us^2 conversion.\n\t\t * trace_print_graph_duration will divide 1000 again.\n\t\t */\n\t\tstddev = div64_ul(stddev,\n\t\t\t\t  rec->counter * (rec->counter - 1) * 1000);\n\t}\n\n\ttrace_seq_init(&s);\n\ttrace_print_graph_duration(rec->time, &s);\n\ttrace_seq_puts(&s, \"    \");\n\ttrace_print_graph_duration(avg, &s);\n\ttrace_seq_puts(&s, \"    \");\n\ttrace_print_graph_duration(stddev, &s);\n\ttrace_print_seq(m, &s);\n#endif\n\tseq_putc(m, '\\n');\nout:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "function_stat_headers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "485-497",
    "snippet": "static int function_stat_headers(struct seq_file *m)\n{\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tseq_puts(m, \"  Function                               \"\n\t\t \"Hit    Time            Avg             s^2\\n\"\n\t\t    \"  --------                               \"\n\t\t \"---    ----            ---             ---\\n\");\n#else\n\tseq_puts(m, \"  Function                               Hit\\n\"\n\t\t    \"  --------                               ---\\n\");\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"  Function                               Hit\\n\"\n\t\t    \"  --------                               ---\\n\""
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int function_stat_headers(struct seq_file *m)\n{\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tseq_puts(m, \"  Function                               \"\n\t\t \"Hit    Time            Avg             s^2\\n\"\n\t\t    \"  --------                               \"\n\t\t \"---    ----            ---             ---\\n\");\n#else\n\tseq_puts(m, \"  Function                               Hit\\n\"\n\t\t    \"  --------                               ---\\n\");\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "function_stat_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "471-482",
    "snippet": "static int function_stat_cmp(const void *p1, const void *p2)\n{\n\tconst struct ftrace_profile *a = p1;\n\tconst struct ftrace_profile *b = p2;\n\n\tif (a->counter < b->counter)\n\t\treturn -1;\n\tif (a->counter > b->counter)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int function_stat_cmp(const void *p1, const void *p2)\n{\n\tconst struct ftrace_profile *a = p1;\n\tconst struct ftrace_profile *b = p2;\n\n\tif (a->counter < b->counter)\n\t\treturn -1;\n\tif (a->counter > b->counter)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "function_stat_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "457-468",
    "snippet": "static int function_stat_cmp(const void *p1, const void *p2)\n{\n\tconst struct ftrace_profile *a = p1;\n\tconst struct ftrace_profile *b = p2;\n\n\tif (a->time < b->time)\n\t\treturn -1;\n\tif (a->time > b->time)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int function_stat_cmp(const void *p1, const void *p2)\n{\n\tconst struct ftrace_profile *a = p1;\n\tconst struct ftrace_profile *b = p2;\n\n\tif (a->time < b->time)\n\t\treturn -1;\n\tif (a->time > b->time)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "function_stat_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "444-453",
    "snippet": "static void *function_stat_start(struct tracer_stat *trace)\n{\n\tstruct ftrace_profile_stat *stat =\n\t\tcontainer_of(trace, struct ftrace_profile_stat, stat);\n\n\tif (!stat || !stat->start)\n\t\treturn NULL;\n\n\treturn function_stat_next(&stat->start->records[0], 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "function_stat_next",
          "args": [
            "&stat->start->records[0]",
            "0"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "function_stat_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "420-442",
          "snippet": "static void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & PAGE_MASK);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >= (void *)&pg->records[pg->index]) {\n\t\tpg = pg->next;\n\t\tif (!pg)\n\t\t\treturn NULL;\n\t\trec = &pg->records[0];\n\t\tif (!rec->counter)\n\t\t\tgoto again;\n\t}\n\n\treturn rec;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & PAGE_MASK);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >= (void *)&pg->records[pg->index]) {\n\t\tpg = pg->next;\n\t\tif (!pg)\n\t\t\treturn NULL;\n\t\trec = &pg->records[0];\n\t\tif (!rec->counter)\n\t\t\tgoto again;\n\t}\n\n\treturn rec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "trace",
            "structftrace_profile_stat",
            "stat"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *function_stat_start(struct tracer_stat *trace)\n{\n\tstruct ftrace_profile_stat *stat =\n\t\tcontainer_of(trace, struct ftrace_profile_stat, stat);\n\n\tif (!stat || !stat->start)\n\t\treturn NULL;\n\n\treturn function_stat_next(&stat->start->records[0], 0);\n}"
  },
  {
    "function_name": "function_stat_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "420-442",
    "snippet": "static void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & PAGE_MASK);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >= (void *)&pg->records[pg->index]) {\n\t\tpg = pg->next;\n\t\tif (!pg)\n\t\t\treturn NULL;\n\t\trec = &pg->records[0];\n\t\tif (!rec->counter)\n\t\t\tgoto again;\n\t}\n\n\treturn rec;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & PAGE_MASK);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >= (void *)&pg->records[pg->index]) {\n\t\tpg = pg->next;\n\t\tif (!pg)\n\t\t\treturn NULL;\n\t\trec = &pg->records[0];\n\t\tif (!rec->counter)\n\t\t\tgoto again;\n\t}\n\n\treturn rec;\n}"
  },
  {
    "function_name": "ftrace_update_pid_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "360-377",
    "snippet": "static void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "ftrace_func_t ftrace_trace_function"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ftrace_function",
          "args": [],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "update_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "174-251",
          "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_trampoline",
          "args": [
            "op"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_trampoline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7200-7202",
          "snippet": "static void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_pids_enabled",
          "args": [
            "op"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pids_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "96-106",
          "snippet": "static bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL || tr->function_no_pids != NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL || tr->function_no_pids != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\n\nstatic void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}"
  },
  {
    "function_name": "__unregister_ftrace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "340-358",
    "snippet": "int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ftrace_function",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "update_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "174-251",
          "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_ftrace_ops",
          "args": [
            "&ftrace_ops_list",
            "ops"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "remove_ftrace_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "267-293",
          "snippet": "static int remove_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t     struct ftrace_ops *ops)\n{\n\tstruct ftrace_ops **p;\n\n\t/*\n\t * If we are removing the last function, then simply point\n\t * to the ftrace_stub.\n\t */\n\tif (rcu_dereference_protected(*list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == ops &&\n\t    rcu_dereference_protected(ops->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\t*list = &ftrace_list_end;\n\t\treturn 0;\n\t}\n\n\tfor (p = list; *p != &ftrace_list_end; p = &(*p)->next)\n\t\tif (*p == ops)\n\t\t\tbreak;\n\n\tif (*p != ops)\n\t\treturn -1;\n\n\t*p = (*p)->next;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int remove_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t     struct ftrace_ops *ops)\n{\n\tstruct ftrace_ops **p;\n\n\t/*\n\t * If we are removing the last function, then simply point\n\t * to the ftrace_stub.\n\t */\n\tif (rcu_dereference_protected(*list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == ops &&\n\t    rcu_dereference_protected(ops->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\t*list = &ftrace_list_end;\n\t\treturn 0;\n\t}\n\n\tfor (p = list; *p != &ftrace_list_end; p = &(*p)->next)\n\t\tif (*p == ops)\n\t\t\tbreak;\n\n\tif (*p != ops)\n\t\treturn -1;\n\n\t*p = (*p)->next;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(ops->flags & FTRACE_OPS_FL_ENABLED)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__register_ftrace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "297-338",
    "snippet": "int __register_ftrace_function(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_DELETED)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EBUSY;\n\n#ifndef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * If the ftrace_ops specifies SAVE_REGS, then it only can be used\n\t * if the arch supports it, or SAVE_REGS_IF_SUPPORTED is also set.\n\t * Setting SAVE_REGS_IF_SUPPORTED makes SAVE_REGS irrelevant.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS &&\n\t    !(ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED))\n\t\treturn -EINVAL;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED)\n\t\tops->flags |= FTRACE_OPS_FL_SAVE_REGS;\n#endif\n\tif (!ftrace_enabled && (ops->flags & FTRACE_OPS_FL_PERMANENT))\n\t\treturn -EBUSY;\n\n\tif (!is_kernel_core_data((unsigned long)ops))\n\t\tops->flags |= FTRACE_OPS_FL_DYNAMIC;\n\n\tadd_ftrace_ops(&ftrace_ops_list, ops);\n\n\t/* Always save the function, and reset at unregistering */\n\tops->saved_func = ops->func;\n\n\tif (ftrace_pids_enabled(ops))\n\t\tops->func = ftrace_pid_func;\n\n\tftrace_update_trampoline(ops);\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ftrace_function",
          "args": [],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "update_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "174-251",
          "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_update_trampoline",
          "args": [
            "ops"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_trampoline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7200-7202",
          "snippet": "static void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_pids_enabled",
          "args": [
            "ops"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pids_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "96-106",
          "snippet": "static bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL || tr->function_no_pids != NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL || tr->function_no_pids != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_ftrace_ops",
          "args": [
            "&ftrace_ops_list",
            "ops"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "add_ftrace_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "253-265",
          "snippet": "static void add_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t   struct ftrace_ops *ops)\n{\n\trcu_assign_pointer(ops->next, *list);\n\n\t/*\n\t * We are entering ops into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the ops->next pointer is valid before another CPU sees\n\t * the ops pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, ops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void add_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t   struct ftrace_ops *ops)\n{\n\trcu_assign_pointer(ops->next, *list);\n\n\t/*\n\t * We are entering ops into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the ops->next pointer is valid before another CPU sees\n\t * the ops pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kernel_core_data",
          "args": [
            "(unsigned long)ops"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ops->flags & FTRACE_OPS_FL_ENABLED"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint __register_ftrace_function(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_DELETED)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EBUSY;\n\n#ifndef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * If the ftrace_ops specifies SAVE_REGS, then it only can be used\n\t * if the arch supports it, or SAVE_REGS_IF_SUPPORTED is also set.\n\t * Setting SAVE_REGS_IF_SUPPORTED makes SAVE_REGS irrelevant.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS &&\n\t    !(ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED))\n\t\treturn -EINVAL;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED)\n\t\tops->flags |= FTRACE_OPS_FL_SAVE_REGS;\n#endif\n\tif (!ftrace_enabled && (ops->flags & FTRACE_OPS_FL_PERMANENT))\n\t\treturn -EBUSY;\n\n\tif (!is_kernel_core_data((unsigned long)ops))\n\t\tops->flags |= FTRACE_OPS_FL_DYNAMIC;\n\n\tadd_ftrace_ops(&ftrace_ops_list, ops);\n\n\t/* Always save the function, and reset at unregistering */\n\tops->saved_func = ops->func;\n\n\tif (ftrace_pids_enabled(ops))\n\t\tops->func = ftrace_pid_func;\n\n\tftrace_update_trampoline(ops);\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "remove_ftrace_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "267-293",
    "snippet": "static int remove_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t     struct ftrace_ops *ops)\n{\n\tstruct ftrace_ops **p;\n\n\t/*\n\t * If we are removing the last function, then simply point\n\t * to the ftrace_stub.\n\t */\n\tif (rcu_dereference_protected(*list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == ops &&\n\t    rcu_dereference_protected(ops->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\t*list = &ftrace_list_end;\n\t\treturn 0;\n\t}\n\n\tfor (p = list; *p != &ftrace_list_end; p = &(*p)->next)\n\t\tif (*p == ops)\n\t\t\tbreak;\n\n\tif (*p != ops)\n\t\treturn -1;\n\n\t*p = (*p)->next;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ops->next",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "*list",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int remove_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t     struct ftrace_ops *ops)\n{\n\tstruct ftrace_ops **p;\n\n\t/*\n\t * If we are removing the last function, then simply point\n\t * to the ftrace_stub.\n\t */\n\tif (rcu_dereference_protected(*list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == ops &&\n\t    rcu_dereference_protected(ops->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\t*list = &ftrace_list_end;\n\t\treturn 0;\n\t}\n\n\tfor (p = list; *p != &ftrace_list_end; p = &(*p)->next)\n\t\tif (*p == ops)\n\t\t\tbreak;\n\n\tif (*p != ops)\n\t\treturn -1;\n\n\t*p = (*p)->next;\n\treturn 0;\n}"
  },
  {
    "function_name": "add_ftrace_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "253-265",
    "snippet": "static void add_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t   struct ftrace_ops *ops)\n{\n\trcu_assign_pointer(ops->next, *list);\n\n\t/*\n\t * We are entering ops into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the ops->next pointer is valid before another CPU sees\n\t * the ops pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*list",
            "ops"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "ops->next",
            "*list"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void add_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t   struct ftrace_ops *ops)\n{\n\trcu_assign_pointer(ops->next, *list);\n\n\t/*\n\t * We are entering ops into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the ops->next pointer is valid before another CPU sees\n\t * the ops pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, ops);\n}"
  },
  {
    "function_name": "update_ftrace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "174-251",
    "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ftrace_ops *function_trace_op",
      "static struct ftrace_ops *set_function_trace_op;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "struct ftrace_ops __rcu *ftrace_ops_list",
      "ftrace_func_t ftrace_trace_function",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "ftrace_sync_ipi",
            "NULL",
            "1"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "1012-1017",
          "snippet": "void smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks_rude",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_rude",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "999-1002",
          "snippet": "void synchronize_rcu_tasks_rude(void)\n{\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_rude);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_rude(void)\n{\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_rude);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_function_graph_func",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "update_function_graph_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "462-486",
          "snippet": "void update_function_graph_func(void)\n{\n\tstruct ftrace_ops *op;\n\tbool do_test = false;\n\n\t/*\n\t * The graph and global ops share the same set of functions\n\t * to test. If any other ops is on the list, then\n\t * the graph tracing needs to test if its the function\n\t * it should call.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op != &global_ops && op != &graph_ops &&\n\t\t    op != &ftrace_list_end) {\n\t\t\tdo_test = true;\n\t\t\t/* in double loop, break out with goto */\n\t\t\tgoto out;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n out:\n\tif (do_test)\n\t\tftrace_graph_entry = ftrace_graph_entry_test;\n\telse\n\t\tftrace_graph_entry = __ftrace_graph_entry;\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid update_function_graph_func(void)\n{\n\tstruct ftrace_ops *op;\n\tbool do_test = false;\n\n\t/*\n\t * The graph and global ops share the same set of functions\n\t * to test. If any other ops is on the list, then\n\t * the graph tracing needs to test if its the function\n\t * it should call.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op != &global_ops && op != &graph_ops &&\n\t\t    op != &ftrace_list_end) {\n\t\t\tdo_test = true;\n\t\t\t/* in double loop, break out with goto */\n\t\t\tgoto out;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n out:\n\tif (do_test)\n\t\tftrace_graph_entry = ftrace_graph_entry_test;\n\telse\n\t\tftrace_graph_entry = __ftrace_graph_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_get_list_func",
          "args": [
            "ftrace_ops_list"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_get_list_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "161-172",
          "snippet": "static ftrace_func_t ftrace_ops_get_list_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If this is a dynamic, RCU, or per CPU ops, or we force list func,\n\t * then it needs to call the list anyway.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||\n\t    FTRACE_FORCE_LIST_FUNC)\n\t\treturn ftrace_ops_list_func;\n\n\treturn ftrace_ops_get_func(ops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic ftrace_func_t ftrace_ops_get_list_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If this is a dynamic, RCU, or per CPU ops, or we force list func,\n\t * then it needs to call the list anyway.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||\n\t    FTRACE_FORCE_LIST_FUNC)\n\t\treturn ftrace_ops_list_func;\n\n\treturn ftrace_ops_get_func(ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_ops_list->next",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_ops_list",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstruct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coordinate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tsynchronize_rcu_tasks_rude();\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
  },
  {
    "function_name": "ftrace_ops_get_list_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "161-172",
    "snippet": "static ftrace_func_t ftrace_ops_get_list_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If this is a dynamic, RCU, or per CPU ops, or we force list func,\n\t * then it needs to call the list anyway.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||\n\t    FTRACE_FORCE_LIST_FUNC)\n\t\treturn ftrace_ops_list_func;\n\n\treturn ftrace_ops_get_func(ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_ops_get_func",
          "args": [
            "ops"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_get_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7335-7346",
          "snippet": "ftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If the function does not handle recursion or needs to be RCU safe,\n\t * then we need to call the assist handler.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_RECURSION |\n\t\t\t  FTRACE_OPS_FL_RCU))\n\t\treturn ftrace_ops_assist_func;\n\n\treturn ops->func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If the function does not handle recursion or needs to be RCU safe,\n\t * then we need to call the assist handler.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_RECURSION |\n\t\t\t  FTRACE_OPS_FL_RCU))\n\t\treturn ftrace_ops_assist_func;\n\n\treturn ops->func;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic ftrace_func_t ftrace_ops_get_list_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If this is a dynamic, RCU, or per CPU ops, or we force list func,\n\t * then it needs to call the list anyway.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||\n\t    FTRACE_FORCE_LIST_FUNC)\n\t\treturn ftrace_ops_list_func;\n\n\treturn ftrace_ops_get_func(ops);\n}"
  },
  {
    "function_name": "ftrace_sync_ipi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "155-159",
    "snippet": "static void ftrace_sync_ipi(void *data)\n{\n\t/* Probably not needed, but do it anyway */\n\tsmp_rmb();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_sync_ipi(void *data)\n{\n\t/* Probably not needed, but do it anyway */\n\tsmp_rmb();\n}"
  },
  {
    "function_name": "ftrace_pid_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "137-153",
    "snippet": "static void ftrace_pid_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = op->private;\n\tint pid;\n\n\tif (tr) {\n\t\tpid = this_cpu_read(tr->array_buffer.data->ftrace_ignore_pid);\n\t\tif (pid == FTRACE_PID_IGNORE)\n\t\t\treturn;\n\t\tif (pid != FTRACE_PID_TRACE &&\n\t\t    pid != current->pid)\n\t\t\treturn;\n\t}\n\n\top->saved_func(ip, parent_ip, op, fregs);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "op->saved_func",
          "args": [
            "ip",
            "parent_ip",
            "op",
            "fregs"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tr->array_buffer.data->ftrace_ignore_pid"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *fregs);\n\nstatic void ftrace_pid_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = op->private;\n\tint pid;\n\n\tif (tr) {\n\t\tpid = this_cpu_read(tr->array_buffer.data->ftrace_ignore_pid);\n\t\tif (pid == FTRACE_PID_IGNORE)\n\t\t\treturn;\n\t\tif (pid != FTRACE_PID_TRACE &&\n\t\t    pid != current->pid)\n\t\t\treturn;\n\t}\n\n\top->saved_func(ip, parent_ip, op, fregs);\n}"
  },
  {
    "function_name": "ftrace_ops_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "126-135",
    "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ops->local_hash.regex_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
  },
  {
    "function_name": "ftrace_pids_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
    "lines": "96-106",
    "snippet": "static bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL || tr->function_no_pids != NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include \"ftrace_internal.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL || tr->function_no_pids != NULL;\n}"
  }
]