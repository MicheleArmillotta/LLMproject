[
  {
    "function_name": "watch_queue_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "648-663",
    "snippet": "int watch_queue_init(struct pipe_inode_info *pipe)\n{\n\tstruct watch_queue *wqueue;\n\n\twqueue = kzalloc(sizeof(*wqueue), GFP_KERNEL);\n\tif (!wqueue)\n\t\treturn -ENOMEM;\n\n\twqueue->pipe = pipe;\n\tkref_init(&wqueue->usage);\n\tspin_lock_init(&wqueue->lock);\n\tINIT_HLIST_HEAD(&wqueue->watches);\n\n\tpipe->watch_queue = wqueue;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&wqueue->watches"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&wqueue->lock"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&wqueue->usage"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wqueue)",
            "GFP_KERNEL"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint watch_queue_init(struct pipe_inode_info *pipe)\n{\n\tstruct watch_queue *wqueue;\n\n\twqueue = kzalloc(sizeof(*wqueue), GFP_KERNEL);\n\tif (!wqueue)\n\t\treturn -ENOMEM;\n\n\twqueue->pipe = pipe;\n\tkref_init(&wqueue->usage);\n\tspin_lock_init(&wqueue->lock);\n\tINIT_HLIST_HEAD(&wqueue->watches);\n\n\tpipe->watch_queue = wqueue;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_watch_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "625-642",
    "snippet": "struct watch_queue *get_watch_queue(int fd)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct watch_queue *wqueue = ERR_PTR(-EINVAL);\n\tstruct fd f;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tpipe = get_pipe_info(f.file, false);\n\t\tif (pipe && pipe->watch_queue) {\n\t\t\twqueue = pipe->watch_queue;\n\t\t\tkref_get(&wqueue->usage);\n\t\t}\n\t\tfdput(f);\n\t}\n\n\treturn wqueue;\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&wqueue->usage"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "f.file",
            "false"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct watch_queue *get_watch_queue(int fd)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct watch_queue *wqueue = ERR_PTR(-EINVAL);\n\tstruct fd f;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tpipe = get_pipe_info(f.file, false);\n\t\tif (pipe && pipe->watch_queue) {\n\t\t\twqueue = pipe->watch_queue;\n\t\t\tkref_get(&wqueue->usage);\n\t\t}\n\t\tfdput(f);\n\t}\n\n\treturn wqueue;\n}"
  },
  {
    "function_name": "watch_queue_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "560-619",
    "snippet": "void watch_queue_clear(struct watch_queue *wqueue)\n{\n\tstruct watch_list *wlist;\n\tstruct watch *watch;\n\tbool release;\n\n\trcu_read_lock();\n\tspin_lock_bh(&wqueue->lock);\n\n\t/* Prevent new additions and prevent notifications from happening */\n\twqueue->defunct = true;\n\n\twhile (!hlist_empty(&wqueue->watches)) {\n\t\twatch = hlist_entry(wqueue->watches.first, struct watch, queue_node);\n\t\thlist_del_init_rcu(&watch->queue_node);\n\t\t/* We now own a ref on the watch. */\n\t\tspin_unlock_bh(&wqueue->lock);\n\n\t\t/* We can't do the next bit under the queue lock as we need to\n\t\t * get the list lock - which would cause a deadlock if someone\n\t\t * was removing from the opposite direction at the same time or\n\t\t * posting a notification.\n\t\t */\n\t\twlist = rcu_dereference(watch->watch_list);\n\t\tif (wlist) {\n\t\t\tvoid (*release_watch)(struct watch *);\n\n\t\t\tspin_lock(&wlist->lock);\n\n\t\t\trelease = !hlist_unhashed(&watch->list_node);\n\t\t\tif (release) {\n\t\t\t\thlist_del_init_rcu(&watch->list_node);\n\t\t\t\trcu_assign_pointer(watch->watch_list, NULL);\n\n\t\t\t\t/* We now own a second ref on the watch. */\n\t\t\t}\n\n\t\t\trelease_watch = wlist->release_watch;\n\t\t\tspin_unlock(&wlist->lock);\n\n\t\t\tif (release) {\n\t\t\t\tif (release_watch) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\t/* This might need to call dput(), so\n\t\t\t\t\t * we have to drop all the locks.\n\t\t\t\t\t */\n\t\t\t\t\t(*release_watch)(watch);\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t}\n\t\t\t\tput_watch(watch);\n\t\t\t}\n\t\t}\n\n\t\tput_watch(watch);\n\t\tspin_lock_bh(&wqueue->lock);\n\t}\n\n\tspin_unlock_bh(&wqueue->lock);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&wqueue->lock"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&wqueue->lock"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_watch",
          "args": [
            "watch"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "put_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
          "lines": "410-413",
          "snippet": "static void put_watch(struct watch *watch)\n{\n\tkref_put(&watch->usage, __put_watch);\n}",
          "includes": [
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void put_watch(struct watch *watch)\n{\n\tkref_put(&watch->usage, __put_watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "watch"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wlist->lock"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "watch->watch_list",
            "NULL"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&watch->list_node"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&watch->list_node"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wlist->lock"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "watch->watch_list"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&watch->queue_node"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "wqueue->watches.first",
            "structwatch",
            "queue_node"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&wqueue->watches"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid watch_queue_clear(struct watch_queue *wqueue)\n{\n\tstruct watch_list *wlist;\n\tstruct watch *watch;\n\tbool release;\n\n\trcu_read_lock();\n\tspin_lock_bh(&wqueue->lock);\n\n\t/* Prevent new additions and prevent notifications from happening */\n\twqueue->defunct = true;\n\n\twhile (!hlist_empty(&wqueue->watches)) {\n\t\twatch = hlist_entry(wqueue->watches.first, struct watch, queue_node);\n\t\thlist_del_init_rcu(&watch->queue_node);\n\t\t/* We now own a ref on the watch. */\n\t\tspin_unlock_bh(&wqueue->lock);\n\n\t\t/* We can't do the next bit under the queue lock as we need to\n\t\t * get the list lock - which would cause a deadlock if someone\n\t\t * was removing from the opposite direction at the same time or\n\t\t * posting a notification.\n\t\t */\n\t\twlist = rcu_dereference(watch->watch_list);\n\t\tif (wlist) {\n\t\t\tvoid (*release_watch)(struct watch *);\n\n\t\t\tspin_lock(&wlist->lock);\n\n\t\t\trelease = !hlist_unhashed(&watch->list_node);\n\t\t\tif (release) {\n\t\t\t\thlist_del_init_rcu(&watch->list_node);\n\t\t\t\trcu_assign_pointer(watch->watch_list, NULL);\n\n\t\t\t\t/* We now own a second ref on the watch. */\n\t\t\t}\n\n\t\t\trelease_watch = wlist->release_watch;\n\t\t\tspin_unlock(&wlist->lock);\n\n\t\t\tif (release) {\n\t\t\t\tif (release_watch) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\t/* This might need to call dput(), so\n\t\t\t\t\t * we have to drop all the locks.\n\t\t\t\t\t */\n\t\t\t\t\t(*release_watch)(watch);\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t}\n\t\t\t\tput_watch(watch);\n\t\t\t}\n\t\t}\n\n\t\tput_watch(watch);\n\t\tspin_lock_bh(&wqueue->lock);\n\t}\n\n\tspin_unlock_bh(&wqueue->lock);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "remove_watch_from_object",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "484-552",
    "snippet": "int remove_watch_from_object(struct watch_list *wlist, struct watch_queue *wq,\n\t\t\t     u64 id, bool all)\n{\n\tstruct watch_notification_removal n;\n\tstruct watch_queue *wqueue;\n\tstruct watch *watch;\n\tint ret = -EBADSLT;\n\n\trcu_read_lock();\n\nagain:\n\tspin_lock(&wlist->lock);\n\thlist_for_each_entry(watch, &wlist->watchers, list_node) {\n\t\tif (all ||\n\t\t    (watch->id == id && rcu_access_pointer(watch->queue) == wq))\n\t\t\tgoto found;\n\t}\n\tspin_unlock(&wlist->lock);\n\tgoto out;\n\nfound:\n\tret = 0;\n\thlist_del_init_rcu(&watch->list_node);\n\trcu_assign_pointer(watch->watch_list, NULL);\n\tspin_unlock(&wlist->lock);\n\n\t/* We now own the reference on watch that used to belong to wlist. */\n\n\tn.watch.type = WATCH_TYPE_META;\n\tn.watch.subtype = WATCH_META_REMOVAL_NOTIFICATION;\n\tn.watch.info = watch->info_id | watch_sizeof(n.watch);\n\tn.id = id;\n\tif (id != 0)\n\t\tn.watch.info = watch->info_id | watch_sizeof(n);\n\n\twqueue = rcu_dereference(watch->queue);\n\n\t/* We don't need the watch list lock for the next bit as RCU is\n\t * protecting *wqueue from deallocation.\n\t */\n\tif (wqueue) {\n\t\tpost_one_notification(wqueue, &n.watch);\n\n\t\tspin_lock_bh(&wqueue->lock);\n\n\t\tif (!hlist_unhashed(&watch->queue_node)) {\n\t\t\thlist_del_init_rcu(&watch->queue_node);\n\t\t\tput_watch(watch);\n\t\t}\n\n\t\tspin_unlock_bh(&wqueue->lock);\n\t}\n\n\tif (wlist->release_watch) {\n\t\tvoid (*release_watch)(struct watch *);\n\n\t\trelease_watch = wlist->release_watch;\n\t\trcu_read_unlock();\n\t\t(*release_watch)(watch);\n\t\trcu_read_lock();\n\t}\n\tput_watch(watch);\n\n\tif (all && !hlist_empty(&wlist->watchers))\n\t\tgoto again;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&wlist->watchers"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_watch",
          "args": [
            "watch"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "put_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
          "lines": "410-413",
          "snippet": "static void put_watch(struct watch *watch)\n{\n\tkref_put(&watch->usage, __put_watch);\n}",
          "includes": [
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void put_watch(struct watch *watch)\n{\n\tkref_put(&watch->usage, __put_watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "watch"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&wqueue->lock"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&watch->queue_node"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&watch->queue_node"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&wqueue->lock"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_one_notification",
          "args": [
            "wqueue",
            "&n.watch"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "post_one_notification",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
          "lines": "72-134",
          "snippet": "static bool post_one_notification(struct watch_queue *wqueue,\n\t\t\t\t  struct watch_notification *n)\n{\n\tvoid *p;\n\tstruct pipe_inode_info *pipe = wqueue->pipe;\n\tstruct pipe_buffer *buf;\n\tstruct page *page;\n\tunsigned int head, tail, mask, note, offset, len;\n\tbool done = false;\n\n\tif (!pipe)\n\t\treturn false;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\n\tif (wqueue->defunct)\n\t\tgoto out;\n\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tif (pipe_full(head, tail, pipe->ring_size))\n\t\tgoto lost;\n\n\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);\n\tif (note >= wqueue->nr_notes)\n\t\tgoto lost;\n\n\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];\n\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;\n\tget_page(page);\n\tlen = n->info & WATCH_INFO_LENGTH;\n\tp = kmap_atomic(page);\n\tmemcpy(p + offset, n, len);\n\tkunmap_atomic(p);\n\n\tbuf = &pipe->bufs[head & mask];\n\tbuf->page = page;\n\tbuf->private = (unsigned long)wqueue;\n\tbuf->ops = &watch_queue_pipe_buf_ops;\n\tbuf->offset = offset;\n\tbuf->len = len;\n\tbuf->flags = PIPE_BUF_FLAG_WHOLE;\n\tpipe->head = head + 1;\n\n\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tBUG();\n\t}\n\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);\n\tdone = true;\n\nout:\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\tif (done)\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\treturn done;\n\nlost:\n\tbuf = &pipe->bufs[(head - 1) & mask];\n\tbuf->flags |= PIPE_BUF_FLAG_LOSS;\n\tgoto out;\n}",
          "includes": [
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)",
            "#define WATCH_QUEUE_NOTE_SIZE 128"
          ],
          "globals_used": [
            "static const struct pipe_buf_operations watch_queue_pipe_buf_ops = {\n\t.release\t= watch_queue_pipe_buf_release,\n\t.try_steal\t= watch_queue_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)\n#define WATCH_QUEUE_NOTE_SIZE 128\n\nstatic const struct pipe_buf_operations watch_queue_pipe_buf_ops = {\n\t.release\t= watch_queue_pipe_buf_release,\n\t.try_steal\t= watch_queue_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};\n\nstatic bool post_one_notification(struct watch_queue *wqueue,\n\t\t\t\t  struct watch_notification *n)\n{\n\tvoid *p;\n\tstruct pipe_inode_info *pipe = wqueue->pipe;\n\tstruct pipe_buffer *buf;\n\tstruct page *page;\n\tunsigned int head, tail, mask, note, offset, len;\n\tbool done = false;\n\n\tif (!pipe)\n\t\treturn false;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\n\tif (wqueue->defunct)\n\t\tgoto out;\n\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tif (pipe_full(head, tail, pipe->ring_size))\n\t\tgoto lost;\n\n\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);\n\tif (note >= wqueue->nr_notes)\n\t\tgoto lost;\n\n\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];\n\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;\n\tget_page(page);\n\tlen = n->info & WATCH_INFO_LENGTH;\n\tp = kmap_atomic(page);\n\tmemcpy(p + offset, n, len);\n\tkunmap_atomic(p);\n\n\tbuf = &pipe->bufs[head & mask];\n\tbuf->page = page;\n\tbuf->private = (unsigned long)wqueue;\n\tbuf->ops = &watch_queue_pipe_buf_ops;\n\tbuf->offset = offset;\n\tbuf->len = len;\n\tbuf->flags = PIPE_BUF_FLAG_WHOLE;\n\tpipe->head = head + 1;\n\n\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tBUG();\n\t}\n\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);\n\tdone = true;\n\nout:\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\tif (done)\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\treturn done;\n\nlost:\n\tbuf = &pipe->bufs[(head - 1) & mask];\n\tbuf->flags |= PIPE_BUF_FLAG_LOSS;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "watch->queue"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watch_sizeof",
          "args": [
            "n"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watch_sizeof",
          "args": [
            "n.watch"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wlist->lock"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "watch->watch_list",
            "NULL"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&watch->list_node"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "watch->queue"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "watch",
            "&wlist->watchers",
            "list_node"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wlist->lock"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint remove_watch_from_object(struct watch_list *wlist, struct watch_queue *wq,\n\t\t\t     u64 id, bool all)\n{\n\tstruct watch_notification_removal n;\n\tstruct watch_queue *wqueue;\n\tstruct watch *watch;\n\tint ret = -EBADSLT;\n\n\trcu_read_lock();\n\nagain:\n\tspin_lock(&wlist->lock);\n\thlist_for_each_entry(watch, &wlist->watchers, list_node) {\n\t\tif (all ||\n\t\t    (watch->id == id && rcu_access_pointer(watch->queue) == wq))\n\t\t\tgoto found;\n\t}\n\tspin_unlock(&wlist->lock);\n\tgoto out;\n\nfound:\n\tret = 0;\n\thlist_del_init_rcu(&watch->list_node);\n\trcu_assign_pointer(watch->watch_list, NULL);\n\tspin_unlock(&wlist->lock);\n\n\t/* We now own the reference on watch that used to belong to wlist. */\n\n\tn.watch.type = WATCH_TYPE_META;\n\tn.watch.subtype = WATCH_META_REMOVAL_NOTIFICATION;\n\tn.watch.info = watch->info_id | watch_sizeof(n.watch);\n\tn.id = id;\n\tif (id != 0)\n\t\tn.watch.info = watch->info_id | watch_sizeof(n);\n\n\twqueue = rcu_dereference(watch->queue);\n\n\t/* We don't need the watch list lock for the next bit as RCU is\n\t * protecting *wqueue from deallocation.\n\t */\n\tif (wqueue) {\n\t\tpost_one_notification(wqueue, &n.watch);\n\n\t\tspin_lock_bh(&wqueue->lock);\n\n\t\tif (!hlist_unhashed(&watch->queue_node)) {\n\t\t\thlist_del_init_rcu(&watch->queue_node);\n\t\t\tput_watch(watch);\n\t\t}\n\n\t\tspin_unlock_bh(&wqueue->lock);\n\t}\n\n\tif (wlist->release_watch) {\n\t\tvoid (*release_watch)(struct watch *);\n\n\t\trelease_watch = wlist->release_watch;\n\t\trcu_read_unlock();\n\t\t(*release_watch)(watch);\n\t\trcu_read_lock();\n\t}\n\tput_watch(watch);\n\n\tif (all && !hlist_empty(&wlist->watchers))\n\t\tgoto again;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "add_watch_to_object",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "442-471",
    "snippet": "int add_watch_to_object(struct watch *watch, struct watch_list *wlist)\n{\n\tstruct watch_queue *wqueue = rcu_access_pointer(watch->queue);\n\tstruct watch *w;\n\n\thlist_for_each_entry(w, &wlist->watchers, list_node) {\n\t\tstruct watch_queue *wq = rcu_access_pointer(w->queue);\n\t\tif (wqueue == wq && watch->id == w->id)\n\t\t\treturn -EBUSY;\n\t}\n\n\twatch->cred = get_current_cred();\n\trcu_assign_pointer(watch->watch_list, wlist);\n\n\tif (atomic_inc_return(&watch->cred->user->nr_watches) >\n\t    task_rlimit(current, RLIMIT_NOFILE)) {\n\t\tatomic_dec(&watch->cred->user->nr_watches);\n\t\tput_cred(watch->cred);\n\t\treturn -EAGAIN;\n\t}\n\n\tspin_lock_bh(&wqueue->lock);\n\tkref_get(&wqueue->usage);\n\tkref_get(&watch->usage);\n\thlist_add_head(&watch->queue_node, &wqueue->watches);\n\tspin_unlock_bh(&wqueue->lock);\n\n\thlist_add_head(&watch->list_node, &wlist->watchers);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&watch->list_node",
            "&wlist->watchers"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&wqueue->lock"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&watch->queue_node",
            "&wqueue->watches"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&watch->usage"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&wqueue->lock"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "watch->cred"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&watch->cred->user->nr_watches"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "current",
            "RLIMIT_NOFILE"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&watch->cred->user->nr_watches"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "watch->watch_list",
            "wlist"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_cred",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "w->queue"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "w",
            "&wlist->watchers",
            "list_node"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "watch->queue"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint add_watch_to_object(struct watch *watch, struct watch_list *wlist)\n{\n\tstruct watch_queue *wqueue = rcu_access_pointer(watch->queue);\n\tstruct watch *w;\n\n\thlist_for_each_entry(w, &wlist->watchers, list_node) {\n\t\tstruct watch_queue *wq = rcu_access_pointer(w->queue);\n\t\tif (wqueue == wq && watch->id == w->id)\n\t\t\treturn -EBUSY;\n\t}\n\n\twatch->cred = get_current_cred();\n\trcu_assign_pointer(watch->watch_list, wlist);\n\n\tif (atomic_inc_return(&watch->cred->user->nr_watches) >\n\t    task_rlimit(current, RLIMIT_NOFILE)) {\n\t\tatomic_dec(&watch->cred->user->nr_watches);\n\t\tput_cred(watch->cred);\n\t\treturn -EAGAIN;\n\t}\n\n\tspin_lock_bh(&wqueue->lock);\n\tkref_get(&wqueue->usage);\n\tkref_get(&watch->usage);\n\thlist_add_head(&watch->queue_node, &wqueue->watches);\n\tspin_unlock_bh(&wqueue->lock);\n\n\thlist_add_head(&watch->list_node, &wlist->watchers);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "422-428",
    "snippet": "void init_watch(struct watch *watch, struct watch_queue *wqueue)\n{\n\tkref_init(&watch->usage);\n\tINIT_HLIST_NODE(&watch->list_node);\n\tINIT_HLIST_NODE(&watch->queue_node);\n\trcu_assign_pointer(watch->queue, wqueue);\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "watch->queue",
            "wqueue"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&watch->queue_node"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&watch->list_node"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&watch->usage"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid init_watch(struct watch *watch, struct watch_queue *wqueue)\n{\n\tkref_init(&watch->usage);\n\tINIT_HLIST_NODE(&watch->list_node);\n\tINIT_HLIST_NODE(&watch->queue_node);\n\trcu_assign_pointer(watch->queue, wqueue);\n}"
  },
  {
    "function_name": "put_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "410-413",
    "snippet": "static void put_watch(struct watch *watch)\n{\n\tkref_put(&watch->usage, __put_watch);\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&watch->usage",
            "__put_watch"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void put_watch(struct watch *watch)\n{\n\tkref_put(&watch->usage, __put_watch);\n}"
  },
  {
    "function_name": "__put_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "400-405",
    "snippet": "static void __put_watch(struct kref *kref)\n{\n\tstruct watch *watch = container_of(kref, struct watch, usage);\n\n\tcall_rcu(&watch->rcu, free_watch);\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&watch->rcu",
            "free_watch"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structwatch",
            "usage"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void __put_watch(struct kref *kref)\n{\n\tstruct watch *watch = container_of(kref, struct watch, usage);\n\n\tcall_rcu(&watch->rcu, free_watch);\n}"
  },
  {
    "function_name": "free_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "391-398",
    "snippet": "static void free_watch(struct rcu_head *rcu)\n{\n\tstruct watch *watch = container_of(rcu, struct watch, rcu);\n\n\tput_watch_queue(rcu_access_pointer(watch->queue));\n\tatomic_dec(&watch->cred->user->nr_watches);\n\tput_cred(watch->cred);\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "watch->cred"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&watch->cred->user->nr_watches"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_watch_queue",
          "args": [
            "rcu_access_pointer(watch->queue)"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "put_watch_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
          "lines": "385-388",
          "snippet": "void put_watch_queue(struct watch_queue *wqueue)\n{\n\tkref_put(&wqueue->usage, __put_watch_queue);\n}",
          "includes": [
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid put_watch_queue(struct watch_queue *wqueue)\n{\n\tkref_put(&wqueue->usage, __put_watch_queue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "watch->queue"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structwatch",
            "rcu"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void free_watch(struct rcu_head *rcu)\n{\n\tstruct watch *watch = container_of(rcu, struct watch, rcu);\n\n\tput_watch_queue(rcu_access_pointer(watch->queue));\n\tatomic_dec(&watch->cred->user->nr_watches);\n\tput_cred(watch->cred);\n}"
  },
  {
    "function_name": "put_watch_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "385-388",
    "snippet": "void put_watch_queue(struct watch_queue *wqueue)\n{\n\tkref_put(&wqueue->usage, __put_watch_queue);\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wqueue->usage",
            "__put_watch_queue"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid put_watch_queue(struct watch_queue *wqueue)\n{\n\tkref_put(&wqueue->usage, __put_watch_queue);\n}"
  },
  {
    "function_name": "__put_watch_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "365-379",
    "snippet": "static void __put_watch_queue(struct kref *kref)\n{\n\tstruct watch_queue *wqueue =\n\t\tcontainer_of(kref, struct watch_queue, usage);\n\tstruct watch_filter *wfilter;\n\tint i;\n\n\tfor (i = 0; i < wqueue->nr_pages; i++)\n\t\t__free_page(wqueue->notes[i]);\n\n\twfilter = rcu_access_pointer(wqueue->filter);\n\tif (wfilter)\n\t\tkfree_rcu(wfilter, rcu);\n\tkfree_rcu(wqueue, rcu);\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "wqueue",
            "rcu"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "wqueue->filter"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "wqueue->notes[i]"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structwatch_queue",
            "usage"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void __put_watch_queue(struct kref *kref)\n{\n\tstruct watch_queue *wqueue =\n\t\tcontainer_of(kref, struct watch_queue, usage);\n\tstruct watch_filter *wfilter;\n\tint i;\n\n\tfor (i = 0; i < wqueue->nr_pages; i++)\n\t\t__free_page(wqueue->notes[i]);\n\n\twfilter = rcu_access_pointer(wqueue->filter);\n\tif (wfilter)\n\t\tkfree_rcu(wfilter, rcu);\n\tkfree_rcu(wqueue, rcu);\n}"
  },
  {
    "function_name": "watch_queue_set_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "286-363",
    "snippet": "long watch_queue_set_filter(struct pipe_inode_info *pipe,\n\t\t\t    struct watch_notification_filter __user *_filter)\n{\n\tstruct watch_notification_type_filter *tf;\n\tstruct watch_notification_filter filter;\n\tstruct watch_type_filter *q;\n\tstruct watch_filter *wfilter;\n\tstruct watch_queue *wqueue = pipe->watch_queue;\n\tint ret, nr_filter = 0, i;\n\n\tif (!wqueue)\n\t\treturn -ENODEV;\n\n\tif (!_filter) {\n\t\t/* Remove the old filter */\n\t\twfilter = NULL;\n\t\tgoto set;\n\t}\n\n\t/* Grab the user's filter specification */\n\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)\n\t\treturn -EFAULT;\n\tif (filter.nr_filters == 0 ||\n\t    filter.nr_filters > 16 ||\n\t    filter.__reserved != 0)\n\t\treturn -EINVAL;\n\n\ttf = memdup_user(_filter->filters, filter.nr_filters * sizeof(*tf));\n\tif (IS_ERR(tf))\n\t\treturn PTR_ERR(tf);\n\n\tret = -EINVAL;\n\tfor (i = 0; i < filter.nr_filters; i++) {\n\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||\n\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)\n\t\t\tgoto err_filter;\n\t\t/* Ignore any unknown types */\n\t\tif (tf[i].type >= sizeof(wfilter->type_filter) * 8)\n\t\t\tcontinue;\n\t\tnr_filter++;\n\t}\n\n\t/* Now we need to build the internal filter from only the relevant\n\t * user-specified filters.\n\t */\n\tret = -ENOMEM;\n\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);\n\tif (!wfilter)\n\t\tgoto err_filter;\n\twfilter->nr_filters = nr_filter;\n\n\tq = wfilter->filters;\n\tfor (i = 0; i < filter.nr_filters; i++) {\n\t\tif (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG)\n\t\t\tcontinue;\n\n\t\tq->type\t\t\t= tf[i].type;\n\t\tq->info_filter\t\t= tf[i].info_filter;\n\t\tq->info_mask\t\t= tf[i].info_mask;\n\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];\n\t\t__set_bit(q->type, wfilter->type_filter);\n\t\tq++;\n\t}\n\n\tkfree(tf);\nset:\n\tpipe_lock(pipe);\n\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,\n\t\t\t\t      lockdep_is_held(&pipe->mutex));\n\tpipe_unlock(pipe);\n\tif (wfilter)\n\t\tkfree_rcu(wfilter, rcu);\n\treturn 0;\n\nerr_filter:\n\tkfree(tf);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tf"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "wfilter",
            "rcu"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_replace_pointer",
          "args": [
            "wqueue->filter",
            "wfilter",
            "lockdep_is_held(&pipe->mutex)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&pipe->mutex"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "q->type",
            "wfilter->type_filter"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(wfilter, filters, nr_filter)",
            "GFP_KERNEL"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "wfilter",
            "filters",
            "nr_filter"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tf"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tf"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "_filter->filters",
            "filter.nr_filters * sizeof(*tf)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&filter",
            "_filter",
            "sizeof(filter)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong watch_queue_set_filter(struct pipe_inode_info *pipe,\n\t\t\t    struct watch_notification_filter __user *_filter)\n{\n\tstruct watch_notification_type_filter *tf;\n\tstruct watch_notification_filter filter;\n\tstruct watch_type_filter *q;\n\tstruct watch_filter *wfilter;\n\tstruct watch_queue *wqueue = pipe->watch_queue;\n\tint ret, nr_filter = 0, i;\n\n\tif (!wqueue)\n\t\treturn -ENODEV;\n\n\tif (!_filter) {\n\t\t/* Remove the old filter */\n\t\twfilter = NULL;\n\t\tgoto set;\n\t}\n\n\t/* Grab the user's filter specification */\n\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)\n\t\treturn -EFAULT;\n\tif (filter.nr_filters == 0 ||\n\t    filter.nr_filters > 16 ||\n\t    filter.__reserved != 0)\n\t\treturn -EINVAL;\n\n\ttf = memdup_user(_filter->filters, filter.nr_filters * sizeof(*tf));\n\tif (IS_ERR(tf))\n\t\treturn PTR_ERR(tf);\n\n\tret = -EINVAL;\n\tfor (i = 0; i < filter.nr_filters; i++) {\n\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||\n\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)\n\t\t\tgoto err_filter;\n\t\t/* Ignore any unknown types */\n\t\tif (tf[i].type >= sizeof(wfilter->type_filter) * 8)\n\t\t\tcontinue;\n\t\tnr_filter++;\n\t}\n\n\t/* Now we need to build the internal filter from only the relevant\n\t * user-specified filters.\n\t */\n\tret = -ENOMEM;\n\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);\n\tif (!wfilter)\n\t\tgoto err_filter;\n\twfilter->nr_filters = nr_filter;\n\n\tq = wfilter->filters;\n\tfor (i = 0; i < filter.nr_filters; i++) {\n\t\tif (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG)\n\t\t\tcontinue;\n\n\t\tq->type\t\t\t= tf[i].type;\n\t\tq->info_filter\t\t= tf[i].info_filter;\n\t\tq->info_mask\t\t= tf[i].info_mask;\n\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];\n\t\t__set_bit(q->type, wfilter->type_filter);\n\t\tq++;\n\t}\n\n\tkfree(tf);\nset:\n\tpipe_lock(pipe);\n\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,\n\t\t\t\t      lockdep_is_held(&pipe->mutex));\n\tpipe_unlock(pipe);\n\tif (wfilter)\n\t\tkfree_rcu(wfilter, rcu);\n\treturn 0;\n\nerr_filter:\n\tkfree(tf);\n\treturn ret;\n}"
  },
  {
    "function_name": "watch_queue_set_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "216-281",
    "snippet": "long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)\n{\n\tstruct watch_queue *wqueue = pipe->watch_queue;\n\tstruct page **pages;\n\tunsigned long *bitmap;\n\tunsigned long user_bufs;\n\tunsigned int bmsize;\n\tint ret, i, nr_pages;\n\n\tif (!wqueue)\n\t\treturn -ENODEV;\n\tif (wqueue->notes)\n\t\treturn -EBUSY;\n\n\tif (nr_notes < 1 ||\n\t    nr_notes > 512) /* TODO: choose a better hard limit */\n\t\treturn -EINVAL;\n\n\tnr_pages = (nr_notes + WATCH_QUEUE_NOTES_PER_PAGE - 1);\n\tnr_pages /= WATCH_QUEUE_NOTES_PER_PAGE;\n\tuser_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_pages);\n\n\tif (nr_pages > pipe->max_usage &&\n\t    (too_many_pipe_buffers_hard(user_bufs) ||\n\t     too_many_pipe_buffers_soft(user_bufs)) &&\n\t    pipe_is_unprivileged_user()) {\n\t\tret = -EPERM;\n\t\tgoto error;\n\t}\n\n\tret = pipe_resize_ring(pipe, nr_notes);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tpages = kcalloc(sizeof(struct page *), nr_pages, GFP_KERNEL);\n\tif (!pages)\n\t\tgoto error;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto error_p;\n\t\tpages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;\n\t}\n\n\tbmsize = (nr_notes + BITS_PER_LONG - 1) / BITS_PER_LONG;\n\tbmsize *= sizeof(unsigned long);\n\tbitmap = kmalloc(bmsize, GFP_KERNEL);\n\tif (!bitmap)\n\t\tgoto error_p;\n\n\tmemset(bitmap, 0xff, bmsize);\n\twqueue->notes = pages;\n\twqueue->notes_bitmap = bitmap;\n\twqueue->nr_pages = nr_pages;\n\twqueue->nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;\n\treturn 0;\n\nerror_p:\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkfree(pages);\nerror:\n\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->nr_accounted);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_pipe_buffers",
          "args": [
            "pipe->user",
            "nr_pages",
            "pipe->nr_accounted"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pages[i]"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bitmap",
            "0xff",
            "bmsize"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bmsize",
            "GFP_KERNEL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "relay_alloc_page_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "61-67",
          "snippet": "static struct page **relay_alloc_page_array(unsigned int n_pages)\n{\n\tconst size_t pa_size = n_pages * sizeof(struct page *);\n\tif (pa_size > PAGE_SIZE)\n\t\treturn vzalloc(pa_size);\n\treturn kzalloc(pa_size, GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct page **relay_alloc_page_array(unsigned int n_pages)\n{\n\tconst size_t pa_size = n_pages * sizeof(struct page *);\n\tif (pa_size > PAGE_SIZE)\n\t\treturn vzalloc(pa_size);\n\treturn kzalloc(pa_size, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "sizeof(struct page *)",
            "nr_pages",
            "GFP_KERNEL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_resize_ring",
          "args": [
            "pipe",
            "nr_notes"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_is_unprivileged_user",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "too_many_pipe_buffers_soft",
          "args": [
            "user_bufs"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "too_many_pipe_buffers_hard",
          "args": [
            "user_bufs"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_pipe_buffers",
          "args": [
            "pipe->user",
            "pipe->nr_accounted",
            "nr_pages"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)\n\nlong watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)\n{\n\tstruct watch_queue *wqueue = pipe->watch_queue;\n\tstruct page **pages;\n\tunsigned long *bitmap;\n\tunsigned long user_bufs;\n\tunsigned int bmsize;\n\tint ret, i, nr_pages;\n\n\tif (!wqueue)\n\t\treturn -ENODEV;\n\tif (wqueue->notes)\n\t\treturn -EBUSY;\n\n\tif (nr_notes < 1 ||\n\t    nr_notes > 512) /* TODO: choose a better hard limit */\n\t\treturn -EINVAL;\n\n\tnr_pages = (nr_notes + WATCH_QUEUE_NOTES_PER_PAGE - 1);\n\tnr_pages /= WATCH_QUEUE_NOTES_PER_PAGE;\n\tuser_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_pages);\n\n\tif (nr_pages > pipe->max_usage &&\n\t    (too_many_pipe_buffers_hard(user_bufs) ||\n\t     too_many_pipe_buffers_soft(user_bufs)) &&\n\t    pipe_is_unprivileged_user()) {\n\t\tret = -EPERM;\n\t\tgoto error;\n\t}\n\n\tret = pipe_resize_ring(pipe, nr_notes);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tpages = kcalloc(sizeof(struct page *), nr_pages, GFP_KERNEL);\n\tif (!pages)\n\t\tgoto error;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto error_p;\n\t\tpages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;\n\t}\n\n\tbmsize = (nr_notes + BITS_PER_LONG - 1) / BITS_PER_LONG;\n\tbmsize *= sizeof(unsigned long);\n\tbitmap = kmalloc(bmsize, GFP_KERNEL);\n\tif (!bitmap)\n\t\tgoto error_p;\n\n\tmemset(bitmap, 0xff, bmsize);\n\twqueue->notes = pages;\n\twqueue->notes_bitmap = bitmap;\n\twqueue->nr_pages = nr_pages;\n\twqueue->nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;\n\treturn 0;\n\nerror_p:\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkfree(pages);\nerror:\n\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->nr_accounted);\n\treturn ret;\n}"
  },
  {
    "function_name": "__post_watch_notification",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "175-209",
    "snippet": "void __post_watch_notification(struct watch_list *wlist,\n\t\t\t       struct watch_notification *n,\n\t\t\t       const struct cred *cred,\n\t\t\t       u64 id)\n{\n\tconst struct watch_filter *wf;\n\tstruct watch_queue *wqueue;\n\tstruct watch *watch;\n\n\tif (((n->info & WATCH_INFO_LENGTH) >> WATCH_INFO_LENGTH__SHIFT) == 0) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(watch, &wlist->watchers, list_node) {\n\t\tif (watch->id != id)\n\t\t\tcontinue;\n\t\tn->info &= ~WATCH_INFO_ID;\n\t\tn->info |= watch->info_id;\n\n\t\twqueue = rcu_dereference(watch->queue);\n\t\twf = rcu_dereference(wqueue->filter);\n\t\tif (wf && !filter_watch_notification(wf, n))\n\t\t\tcontinue;\n\n\t\tif (security_post_notification(watch->cred, cred, n) < 0)\n\t\t\tcontinue;\n\n\t\tpost_one_notification(wqueue, n);\n\t}\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_one_notification",
          "args": [
            "wqueue",
            "n"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "post_one_notification",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
          "lines": "72-134",
          "snippet": "static bool post_one_notification(struct watch_queue *wqueue,\n\t\t\t\t  struct watch_notification *n)\n{\n\tvoid *p;\n\tstruct pipe_inode_info *pipe = wqueue->pipe;\n\tstruct pipe_buffer *buf;\n\tstruct page *page;\n\tunsigned int head, tail, mask, note, offset, len;\n\tbool done = false;\n\n\tif (!pipe)\n\t\treturn false;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\n\tif (wqueue->defunct)\n\t\tgoto out;\n\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tif (pipe_full(head, tail, pipe->ring_size))\n\t\tgoto lost;\n\n\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);\n\tif (note >= wqueue->nr_notes)\n\t\tgoto lost;\n\n\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];\n\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;\n\tget_page(page);\n\tlen = n->info & WATCH_INFO_LENGTH;\n\tp = kmap_atomic(page);\n\tmemcpy(p + offset, n, len);\n\tkunmap_atomic(p);\n\n\tbuf = &pipe->bufs[head & mask];\n\tbuf->page = page;\n\tbuf->private = (unsigned long)wqueue;\n\tbuf->ops = &watch_queue_pipe_buf_ops;\n\tbuf->offset = offset;\n\tbuf->len = len;\n\tbuf->flags = PIPE_BUF_FLAG_WHOLE;\n\tpipe->head = head + 1;\n\n\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tBUG();\n\t}\n\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);\n\tdone = true;\n\nout:\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\tif (done)\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\treturn done;\n\nlost:\n\tbuf = &pipe->bufs[(head - 1) & mask];\n\tbuf->flags |= PIPE_BUF_FLAG_LOSS;\n\tgoto out;\n}",
          "includes": [
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)",
            "#define WATCH_QUEUE_NOTE_SIZE 128"
          ],
          "globals_used": [
            "static const struct pipe_buf_operations watch_queue_pipe_buf_ops = {\n\t.release\t= watch_queue_pipe_buf_release,\n\t.try_steal\t= watch_queue_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)\n#define WATCH_QUEUE_NOTE_SIZE 128\n\nstatic const struct pipe_buf_operations watch_queue_pipe_buf_ops = {\n\t.release\t= watch_queue_pipe_buf_release,\n\t.try_steal\t= watch_queue_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};\n\nstatic bool post_one_notification(struct watch_queue *wqueue,\n\t\t\t\t  struct watch_notification *n)\n{\n\tvoid *p;\n\tstruct pipe_inode_info *pipe = wqueue->pipe;\n\tstruct pipe_buffer *buf;\n\tstruct page *page;\n\tunsigned int head, tail, mask, note, offset, len;\n\tbool done = false;\n\n\tif (!pipe)\n\t\treturn false;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\n\tif (wqueue->defunct)\n\t\tgoto out;\n\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tif (pipe_full(head, tail, pipe->ring_size))\n\t\tgoto lost;\n\n\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);\n\tif (note >= wqueue->nr_notes)\n\t\tgoto lost;\n\n\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];\n\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;\n\tget_page(page);\n\tlen = n->info & WATCH_INFO_LENGTH;\n\tp = kmap_atomic(page);\n\tmemcpy(p + offset, n, len);\n\tkunmap_atomic(p);\n\n\tbuf = &pipe->bufs[head & mask];\n\tbuf->page = page;\n\tbuf->private = (unsigned long)wqueue;\n\tbuf->ops = &watch_queue_pipe_buf_ops;\n\tbuf->offset = offset;\n\tbuf->len = len;\n\tbuf->flags = PIPE_BUF_FLAG_WHOLE;\n\tpipe->head = head + 1;\n\n\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tBUG();\n\t}\n\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);\n\tdone = true;\n\nout:\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\tif (done)\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\treturn done;\n\nlost:\n\tbuf = &pipe->bufs[(head - 1) & mask];\n\tbuf->flags |= PIPE_BUF_FLAG_LOSS;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_post_notification",
          "args": [
            "watch->cred",
            "cred",
            "n"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_watch_notification",
          "args": [
            "wf",
            "n"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "filter_watch_notification",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
          "lines": "139-160",
          "snippet": "static bool filter_watch_notification(const struct watch_filter *wf,\n\t\t\t\t      const struct watch_notification *n)\n{\n\tconst struct watch_type_filter *wt;\n\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;\n\tunsigned int st_index = n->subtype / st_bits;\n\tunsigned int st_bit = 1U << (n->subtype % st_bits);\n\tint i;\n\n\tif (!test_bit(n->type, wf->type_filter))\n\t\treturn false;\n\n\tfor (i = 0; i < wf->nr_filters; i++) {\n\t\twt = &wf->filters[i];\n\t\tif (n->type == wt->type &&\n\t\t    (wt->subtype_filter[st_index] & st_bit) &&\n\t\t    (n->info & wt->info_mask) == wt->info_filter)\n\t\t\treturn true;\n\t}\n\n\treturn false; /* If there is a filter, the default is to reject. */\n}",
          "includes": [
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool filter_watch_notification(const struct watch_filter *wf,\n\t\t\t\t      const struct watch_notification *n)\n{\n\tconst struct watch_type_filter *wt;\n\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;\n\tunsigned int st_index = n->subtype / st_bits;\n\tunsigned int st_bit = 1U << (n->subtype % st_bits);\n\tint i;\n\n\tif (!test_bit(n->type, wf->type_filter))\n\t\treturn false;\n\n\tfor (i = 0; i < wf->nr_filters; i++) {\n\t\twt = &wf->filters[i];\n\t\tif (n->type == wt->type &&\n\t\t    (wt->subtype_filter[st_index] & st_bit) &&\n\t\t    (n->info & wt->info_mask) == wt->info_filter)\n\t\t\treturn true;\n\t}\n\n\treturn false; /* If there is a filter, the default is to reject. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "wqueue->filter"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "watch->queue"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "watch",
            "&wlist->watchers",
            "list_node"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid __post_watch_notification(struct watch_list *wlist,\n\t\t\t       struct watch_notification *n,\n\t\t\t       const struct cred *cred,\n\t\t\t       u64 id)\n{\n\tconst struct watch_filter *wf;\n\tstruct watch_queue *wqueue;\n\tstruct watch *watch;\n\n\tif (((n->info & WATCH_INFO_LENGTH) >> WATCH_INFO_LENGTH__SHIFT) == 0) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(watch, &wlist->watchers, list_node) {\n\t\tif (watch->id != id)\n\t\t\tcontinue;\n\t\tn->info &= ~WATCH_INFO_ID;\n\t\tn->info |= watch->info_id;\n\n\t\twqueue = rcu_dereference(watch->queue);\n\t\twf = rcu_dereference(wqueue->filter);\n\t\tif (wf && !filter_watch_notification(wf, n))\n\t\t\tcontinue;\n\n\t\tif (security_post_notification(watch->cred, cred, n) < 0)\n\t\t\tcontinue;\n\n\t\tpost_one_notification(wqueue, n);\n\t}\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "filter_watch_notification",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "139-160",
    "snippet": "static bool filter_watch_notification(const struct watch_filter *wf,\n\t\t\t\t      const struct watch_notification *n)\n{\n\tconst struct watch_type_filter *wt;\n\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;\n\tunsigned int st_index = n->subtype / st_bits;\n\tunsigned int st_bit = 1U << (n->subtype % st_bits);\n\tint i;\n\n\tif (!test_bit(n->type, wf->type_filter))\n\t\treturn false;\n\n\tfor (i = 0; i < wf->nr_filters; i++) {\n\t\twt = &wf->filters[i];\n\t\tif (n->type == wt->type &&\n\t\t    (wt->subtype_filter[st_index] & st_bit) &&\n\t\t    (n->info & wt->info_mask) == wt->info_filter)\n\t\t\treturn true;\n\t}\n\n\treturn false; /* If there is a filter, the default is to reject. */\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "n->type",
            "wf->type_filter"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool filter_watch_notification(const struct watch_filter *wf,\n\t\t\t\t      const struct watch_notification *n)\n{\n\tconst struct watch_type_filter *wt;\n\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;\n\tunsigned int st_index = n->subtype / st_bits;\n\tunsigned int st_bit = 1U << (n->subtype % st_bits);\n\tint i;\n\n\tif (!test_bit(n->type, wf->type_filter))\n\t\treturn false;\n\n\tfor (i = 0; i < wf->nr_filters; i++) {\n\t\twt = &wf->filters[i];\n\t\tif (n->type == wt->type &&\n\t\t    (wt->subtype_filter[st_index] & st_bit) &&\n\t\t    (n->info & wt->info_mask) == wt->info_filter)\n\t\t\treturn true;\n\t}\n\n\treturn false; /* If there is a filter, the default is to reject. */\n}"
  },
  {
    "function_name": "post_one_notification",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "72-134",
    "snippet": "static bool post_one_notification(struct watch_queue *wqueue,\n\t\t\t\t  struct watch_notification *n)\n{\n\tvoid *p;\n\tstruct pipe_inode_info *pipe = wqueue->pipe;\n\tstruct pipe_buffer *buf;\n\tstruct page *page;\n\tunsigned int head, tail, mask, note, offset, len;\n\tbool done = false;\n\n\tif (!pipe)\n\t\treturn false;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\n\tif (wqueue->defunct)\n\t\tgoto out;\n\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tif (pipe_full(head, tail, pipe->ring_size))\n\t\tgoto lost;\n\n\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);\n\tif (note >= wqueue->nr_notes)\n\t\tgoto lost;\n\n\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];\n\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;\n\tget_page(page);\n\tlen = n->info & WATCH_INFO_LENGTH;\n\tp = kmap_atomic(page);\n\tmemcpy(p + offset, n, len);\n\tkunmap_atomic(p);\n\n\tbuf = &pipe->bufs[head & mask];\n\tbuf->page = page;\n\tbuf->private = (unsigned long)wqueue;\n\tbuf->ops = &watch_queue_pipe_buf_ops;\n\tbuf->offset = offset;\n\tbuf->len = len;\n\tbuf->flags = PIPE_BUF_FLAG_WHOLE;\n\tpipe->head = head + 1;\n\n\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tBUG();\n\t}\n\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);\n\tdone = true;\n\nout:\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\tif (done)\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\treturn done;\n\nlost:\n\tbuf = &pipe->bufs[(head - 1) & mask];\n\tbuf->flags |= PIPE_BUF_FLAG_LOSS;\n\tgoto out;\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)",
      "#define WATCH_QUEUE_NOTE_SIZE 128"
    ],
    "globals_used": [
      "static const struct pipe_buf_operations watch_queue_pipe_buf_ops = {\n\t.release\t= watch_queue_pipe_buf_release,\n\t.try_steal\t= watch_queue_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_readers",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pipe->rd_wait.lock"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll_locked",
          "args": [
            "&pipe->rd_wait",
            "EPOLLIN | EPOLLRDNORM"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "note",
            "wqueue->notes_bitmap"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "p"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p + offset",
            "n",
            "len"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "perf_get_page_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "7266-7295",
          "snippet": "static u64 perf_get_page_size(unsigned long addr)\n{\n\tstruct mm_struct *mm;\n\tunsigned long flags;\n\tu64 size;\n\n\tif (!addr)\n\t\treturn 0;\n\n\t/*\n\t * Software page-table walkers must disable IRQs,\n\t * which prevents any tear down of the page tables.\n\t */\n\tlocal_irq_save(flags);\n\n\tmm = current->mm;\n\tif (!mm) {\n\t\t/*\n\t\t * For kernel threads and the like, use init_mm so that\n\t\t * we can find kernel memory.\n\t\t */\n\t\tmm = &init_mm;\n\t}\n\n\tsize = perf_get_pgtable_size(mm, addr);\n\n\tlocal_irq_restore(flags);\n\n\treturn size;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\n\nstatic u64 perf_get_page_size(unsigned long addr)\n{\n\tstruct mm_struct *mm;\n\tunsigned long flags;\n\tu64 size;\n\n\tif (!addr)\n\t\treturn 0;\n\n\t/*\n\t * Software page-table walkers must disable IRQs,\n\t * which prevents any tear down of the page tables.\n\t */\n\tlocal_irq_save(flags);\n\n\tmm = current->mm;\n\tif (!mm) {\n\t\t/*\n\t\t * For kernel threads and the like, use init_mm so that\n\t\t * we can find kernel memory.\n\t\t */\n\t\tmm = &init_mm;\n\t}\n\n\tsize = perf_get_pgtable_size(mm, addr);\n\n\tlocal_irq_restore(flags);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "wqueue->notes_bitmap",
            "wqueue->nr_notes"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_full",
          "args": [
            "head",
            "tail",
            "pipe->ring_size"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pipe->rd_wait.lock"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)\n#define WATCH_QUEUE_NOTE_SIZE 128\n\nstatic const struct pipe_buf_operations watch_queue_pipe_buf_ops = {\n\t.release\t= watch_queue_pipe_buf_release,\n\t.try_steal\t= watch_queue_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};\n\nstatic bool post_one_notification(struct watch_queue *wqueue,\n\t\t\t\t  struct watch_notification *n)\n{\n\tvoid *p;\n\tstruct pipe_inode_info *pipe = wqueue->pipe;\n\tstruct pipe_buffer *buf;\n\tstruct page *page;\n\tunsigned int head, tail, mask, note, offset, len;\n\tbool done = false;\n\n\tif (!pipe)\n\t\treturn false;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\n\tif (wqueue->defunct)\n\t\tgoto out;\n\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tif (pipe_full(head, tail, pipe->ring_size))\n\t\tgoto lost;\n\n\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);\n\tif (note >= wqueue->nr_notes)\n\t\tgoto lost;\n\n\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];\n\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;\n\tget_page(page);\n\tlen = n->info & WATCH_INFO_LENGTH;\n\tp = kmap_atomic(page);\n\tmemcpy(p + offset, n, len);\n\tkunmap_atomic(p);\n\n\tbuf = &pipe->bufs[head & mask];\n\tbuf->page = page;\n\tbuf->private = (unsigned long)wqueue;\n\tbuf->ops = &watch_queue_pipe_buf_ops;\n\tbuf->offset = offset;\n\tbuf->len = len;\n\tbuf->flags = PIPE_BUF_FLAG_WHOLE;\n\tpipe->head = head + 1;\n\n\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tBUG();\n\t}\n\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);\n\tdone = true;\n\nout:\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\tif (done)\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\treturn done;\n\nlost:\n\tbuf = &pipe->bufs[(head - 1) & mask];\n\tbuf->flags |= PIPE_BUF_FLAG_LOSS;\n\tgoto out;\n}"
  },
  {
    "function_name": "watch_queue_pipe_buf_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watch_queue.c",
    "lines": "37-57",
    "snippet": "static void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct pipe_buffer *buf)\n{\n\tstruct watch_queue *wqueue = (struct watch_queue *)buf->private;\n\tstruct page *page;\n\tunsigned int bit;\n\n\t/* We need to work out which note within the page this refers to, but\n\t * the note might have been maximum size, so merely ANDing the offset\n\t * off doesn't work.  OTOH, the note must've been more than zero size.\n\t */\n\tbit = buf->offset + buf->len;\n\tif ((bit & (WATCH_QUEUE_NOTE_SIZE - 1)) == 0)\n\t\tbit -= WATCH_QUEUE_NOTE_SIZE;\n\tbit /= WATCH_QUEUE_NOTE_SIZE;\n\n\tpage = buf->page;\n\tbit += page->index;\n\n\tset_bit(bit, wqueue->notes_bitmap);\n}",
    "includes": [
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/watch_queue.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/printk.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define WATCH_QUEUE_NOTE_SIZE 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit",
            "wqueue->notes_bitmap"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pipe_fs_i.h>\n#include <linux/watch_queue.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define WATCH_QUEUE_NOTE_SIZE 128\n\nstatic void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct pipe_buffer *buf)\n{\n\tstruct watch_queue *wqueue = (struct watch_queue *)buf->private;\n\tstruct page *page;\n\tunsigned int bit;\n\n\t/* We need to work out which note within the page this refers to, but\n\t * the note might have been maximum size, so merely ANDing the offset\n\t * off doesn't work.  OTOH, the note must've been more than zero size.\n\t */\n\tbit = buf->offset + buf->len;\n\tif ((bit & (WATCH_QUEUE_NOTE_SIZE - 1)) == 0)\n\t\tbit -= WATCH_QUEUE_NOTE_SIZE;\n\tbit /= WATCH_QUEUE_NOTE_SIZE;\n\n\tpage = buf->page;\n\tbit += page->index;\n\n\tset_bit(bit, wqueue->notes_bitmap);\n}"
  }
]