[
  {
    "function_name": "rcu_sysrq_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "964-969",
    "snippet": "static int __init rcu_sysrq_init(void)\n{\n\tif (sysrq_rcu)\n\t\treturn register_sysrq_key('y', &sysrq_rcudump_op);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool sysrq_rcu;",
      "static const struct sysrq_key_op sysrq_rcudump_op = {\n\t.handler = sysrq_show_rcu,\n\t.help_msg = \"show-rcu(y)\",\n\t.action_msg = \"Show RCU tree\",\n\t.enable_mask = SYSRQ_ENABLE_DUMP,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysrq_key",
          "args": [
            "'y'",
            "&sysrq_rcudump_op"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic bool sysrq_rcu;\nstatic const struct sysrq_key_op sysrq_rcudump_op = {\n\t.handler = sysrq_show_rcu,\n\t.help_msg = \"show-rcu(y)\",\n\t.action_msg = \"Show RCU tree\",\n\t.enable_mask = SYSRQ_ENABLE_DUMP,\n};\n\nstatic int __init rcu_sysrq_init(void)\n{\n\tif (sysrq_rcu)\n\t\treturn register_sysrq_key('y', &sysrq_rcudump_op);\n\treturn 0;\n}"
  },
  {
    "function_name": "sysrq_show_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "952-955",
    "snippet": "static void sysrq_show_rcu(int key)\n{\n\tshow_rcu_gp_kthreads();\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_rcu_gp_kthreads",
          "args": [],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_gp_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "782-844",
          "snippet": "void show_rcu_gp_kthreads(void)\n{\n\tunsigned long cbs = 0;\n\tint cpu;\n\tunsigned long j;\n\tunsigned long ja;\n\tunsigned long jr;\n\tunsigned long js;\n\tunsigned long jw;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tj = jiffies;\n\tja = j - data_race(READ_ONCE(rcu_state.gp_activity));\n\tjr = j - data_race(READ_ONCE(rcu_state.gp_req_activity));\n\tjs = j - data_race(READ_ONCE(rcu_state.gp_start));\n\tjw = j - data_race(READ_ONCE(rcu_state.gp_wake_time));\n\tpr_info(\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\",\n\t\trcu_state.name, gp_state_getname(rcu_state.gp_state),\n\t\tdata_race(READ_ONCE(rcu_state.gp_state)),\n\t\tt ? data_race(READ_ONCE(t->__state)) : 0x1ffff, t ? t->rt_priority : 0xffU,\n\t\tjs, ja, jr, jw, (long)data_race(READ_ONCE(rcu_state.gp_wake_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_state.gp_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_max)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_flags)));\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq), READ_ONCE(rnp->gp_seq_needed)) &&\n\t\t    !data_race(READ_ONCE(rnp->qsmask)) && !data_race(READ_ONCE(rnp->boost_tasks)) &&\n\t\t    !data_race(READ_ONCE(rnp->exp_tasks)) && !data_race(READ_ONCE(rnp->gp_tasks)))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\",\n\t\t\trnp->grplo, rnp->grphi,\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq)),\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq_needed)),\n\t\t\tdata_race(READ_ONCE(rnp->qsmask)),\n\t\t\t\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))],\n\t\t\t\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))],\n\t\t\t\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))],\n\t\t\t\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))],\n\t\t\tdata_race(READ_ONCE(rnp->n_boosts)));\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (READ_ONCE(rdp->gpwrap) ||\n\t\t\t    ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t READ_ONCE(rdp->gp_seq_needed)))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %ld\\n\",\n\t\t\t\tcpu, (long)data_race(READ_ONCE(rdp->gp_seq_needed)));\n\t\t}\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tcbs += data_race(READ_ONCE(rdp->n_cbs_invoked));\n\t\tif (rcu_segcblist_is_offloaded(&rdp->cblist))\n\t\t\tshow_rcu_nocb_state(rdp);\n\t}\n\tpr_info(\"RCU callbacks invoked since boot: %lu\\n\", cbs);\n\tshow_rcu_tasks_gp_kthreads();\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid show_rcu_gp_kthreads(void)\n{\n\tunsigned long cbs = 0;\n\tint cpu;\n\tunsigned long j;\n\tunsigned long ja;\n\tunsigned long jr;\n\tunsigned long js;\n\tunsigned long jw;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tj = jiffies;\n\tja = j - data_race(READ_ONCE(rcu_state.gp_activity));\n\tjr = j - data_race(READ_ONCE(rcu_state.gp_req_activity));\n\tjs = j - data_race(READ_ONCE(rcu_state.gp_start));\n\tjw = j - data_race(READ_ONCE(rcu_state.gp_wake_time));\n\tpr_info(\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\",\n\t\trcu_state.name, gp_state_getname(rcu_state.gp_state),\n\t\tdata_race(READ_ONCE(rcu_state.gp_state)),\n\t\tt ? data_race(READ_ONCE(t->__state)) : 0x1ffff, t ? t->rt_priority : 0xffU,\n\t\tjs, ja, jr, jw, (long)data_race(READ_ONCE(rcu_state.gp_wake_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_state.gp_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_max)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_flags)));\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq), READ_ONCE(rnp->gp_seq_needed)) &&\n\t\t    !data_race(READ_ONCE(rnp->qsmask)) && !data_race(READ_ONCE(rnp->boost_tasks)) &&\n\t\t    !data_race(READ_ONCE(rnp->exp_tasks)) && !data_race(READ_ONCE(rnp->gp_tasks)))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\",\n\t\t\trnp->grplo, rnp->grphi,\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq)),\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq_needed)),\n\t\t\tdata_race(READ_ONCE(rnp->qsmask)),\n\t\t\t\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))],\n\t\t\t\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))],\n\t\t\t\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))],\n\t\t\t\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))],\n\t\t\tdata_race(READ_ONCE(rnp->n_boosts)));\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (READ_ONCE(rdp->gpwrap) ||\n\t\t\t    ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t READ_ONCE(rdp->gp_seq_needed)))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %ld\\n\",\n\t\t\t\tcpu, (long)data_race(READ_ONCE(rdp->gp_seq_needed)));\n\t\t}\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tcbs += data_race(READ_ONCE(rdp->n_cbs_invoked));\n\t\tif (rcu_segcblist_is_offloaded(&rdp->cblist))\n\t\t\tshow_rcu_nocb_state(rdp);\n\t}\n\tpr_info(\"RCU callbacks invoked since boot: %lu\\n\", cbs);\n\tshow_rcu_tasks_gp_kthreads();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void sysrq_show_rcu(int key)\n{\n\tshow_rcu_gp_kthreads();\n}"
  },
  {
    "function_name": "rcu_fwd_progress_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "910-944",
    "snippet": "void rcu_fwd_progress_check(unsigned long j)\n{\n\tunsigned long cbs;\n\tint cpu;\n\tunsigned long max_cbs = 0;\n\tint max_cpu = -1;\n\tstruct rcu_data *rdp;\n\n\tif (rcu_gp_in_progress()) {\n\t\tpr_info(\"%s: GP age %lu jiffies\\n\",\n\t\t\t__func__, jiffies - data_race(READ_ONCE(rcu_state.gp_start)));\n\t\tshow_rcu_gp_kthreads();\n\t} else {\n\t\tpr_info(\"%s: Last GP end %lu jiffies ago\\n\",\n\t\t\t__func__, jiffies - data_race(READ_ONCE(rcu_state.gp_end)));\n\t\tpreempt_disable();\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_check_gp_start_stall(rdp->mynode, rdp, j);\n\t\tpreempt_enable();\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\tcbs = rcu_get_n_cbs_cpu(cpu);\n\t\tif (!cbs)\n\t\t\tcontinue;\n\t\tif (max_cpu < 0)\n\t\t\tpr_info(\"%s: callbacks\", __func__);\n\t\tpr_cont(\" %d: %lu\", cpu, cbs);\n\t\tif (cbs <= max_cbs)\n\t\t\tcontinue;\n\t\tmax_cbs = cbs;\n\t\tmax_cpu = cpu;\n\t}\n\tif (max_cpu >= 0)\n\t\tpr_cont(\"\\n\");\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %d: %lu\"",
            "cpu",
            "cbs"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: callbacks\"",
            "__func__"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_n_cbs_cpu",
          "args": [
            "cpu"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_n_cbs_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "238-245",
          "snippet": "static long rcu_get_n_cbs_cpu(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\tif (rcu_segcblist_is_enabled(&rdp->cblist))\n\t\treturn rcu_segcblist_n_cbs(&rdp->cblist);\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic long rcu_get_n_cbs_cpu(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\tif (rcu_segcblist_is_enabled(&rdp->cblist))\n\t\treturn rcu_segcblist_n_cbs(&rdp->cblist);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_start_stall",
          "args": [
            "rdp->mynode",
            "rdp",
            "j"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_start_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "851-903",
          "snippet": "static void rcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t\t     const unsigned long gpssdelay)\n{\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    !smp_load_acquire(&rcu_state.gp_kthread)) // Get stable kthread.\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\tif (rnp_root != rnp)\n\t\t\t/* irqs remain disabled. */\n\t\t\traw_spin_unlock_rcu_node(rnp_root);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tshow_rcu_gp_kthreads();\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t\t     const unsigned long gpssdelay)\n{\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    !smp_load_acquire(&rcu_state.gp_kthread)) // Get stable kthread.\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\tif (rnp_root != rnp)\n\t\t\t/* irqs remain disabled. */\n\t\t\traw_spin_unlock_rcu_node(rnp_root);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tshow_rcu_gp_kthreads();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Last GP end %lu jiffies ago\\n\"",
            "__func__",
            "jiffies - data_race(READ_ONCE(rcu_state.gp_end))"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "READ_ONCE(rcu_state.gp_end)"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_end"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_rcu_gp_kthreads",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_gp_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "782-844",
          "snippet": "void show_rcu_gp_kthreads(void)\n{\n\tunsigned long cbs = 0;\n\tint cpu;\n\tunsigned long j;\n\tunsigned long ja;\n\tunsigned long jr;\n\tunsigned long js;\n\tunsigned long jw;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tj = jiffies;\n\tja = j - data_race(READ_ONCE(rcu_state.gp_activity));\n\tjr = j - data_race(READ_ONCE(rcu_state.gp_req_activity));\n\tjs = j - data_race(READ_ONCE(rcu_state.gp_start));\n\tjw = j - data_race(READ_ONCE(rcu_state.gp_wake_time));\n\tpr_info(\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\",\n\t\trcu_state.name, gp_state_getname(rcu_state.gp_state),\n\t\tdata_race(READ_ONCE(rcu_state.gp_state)),\n\t\tt ? data_race(READ_ONCE(t->__state)) : 0x1ffff, t ? t->rt_priority : 0xffU,\n\t\tjs, ja, jr, jw, (long)data_race(READ_ONCE(rcu_state.gp_wake_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_state.gp_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_max)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_flags)));\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq), READ_ONCE(rnp->gp_seq_needed)) &&\n\t\t    !data_race(READ_ONCE(rnp->qsmask)) && !data_race(READ_ONCE(rnp->boost_tasks)) &&\n\t\t    !data_race(READ_ONCE(rnp->exp_tasks)) && !data_race(READ_ONCE(rnp->gp_tasks)))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\",\n\t\t\trnp->grplo, rnp->grphi,\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq)),\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq_needed)),\n\t\t\tdata_race(READ_ONCE(rnp->qsmask)),\n\t\t\t\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))],\n\t\t\t\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))],\n\t\t\t\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))],\n\t\t\t\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))],\n\t\t\tdata_race(READ_ONCE(rnp->n_boosts)));\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (READ_ONCE(rdp->gpwrap) ||\n\t\t\t    ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t READ_ONCE(rdp->gp_seq_needed)))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %ld\\n\",\n\t\t\t\tcpu, (long)data_race(READ_ONCE(rdp->gp_seq_needed)));\n\t\t}\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tcbs += data_race(READ_ONCE(rdp->n_cbs_invoked));\n\t\tif (rcu_segcblist_is_offloaded(&rdp->cblist))\n\t\t\tshow_rcu_nocb_state(rdp);\n\t}\n\tpr_info(\"RCU callbacks invoked since boot: %lu\\n\", cbs);\n\tshow_rcu_tasks_gp_kthreads();\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid show_rcu_gp_kthreads(void)\n{\n\tunsigned long cbs = 0;\n\tint cpu;\n\tunsigned long j;\n\tunsigned long ja;\n\tunsigned long jr;\n\tunsigned long js;\n\tunsigned long jw;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tj = jiffies;\n\tja = j - data_race(READ_ONCE(rcu_state.gp_activity));\n\tjr = j - data_race(READ_ONCE(rcu_state.gp_req_activity));\n\tjs = j - data_race(READ_ONCE(rcu_state.gp_start));\n\tjw = j - data_race(READ_ONCE(rcu_state.gp_wake_time));\n\tpr_info(\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\",\n\t\trcu_state.name, gp_state_getname(rcu_state.gp_state),\n\t\tdata_race(READ_ONCE(rcu_state.gp_state)),\n\t\tt ? data_race(READ_ONCE(t->__state)) : 0x1ffff, t ? t->rt_priority : 0xffU,\n\t\tjs, ja, jr, jw, (long)data_race(READ_ONCE(rcu_state.gp_wake_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_state.gp_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_max)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_flags)));\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq), READ_ONCE(rnp->gp_seq_needed)) &&\n\t\t    !data_race(READ_ONCE(rnp->qsmask)) && !data_race(READ_ONCE(rnp->boost_tasks)) &&\n\t\t    !data_race(READ_ONCE(rnp->exp_tasks)) && !data_race(READ_ONCE(rnp->gp_tasks)))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\",\n\t\t\trnp->grplo, rnp->grphi,\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq)),\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq_needed)),\n\t\t\tdata_race(READ_ONCE(rnp->qsmask)),\n\t\t\t\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))],\n\t\t\t\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))],\n\t\t\t\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))],\n\t\t\t\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))],\n\t\t\tdata_race(READ_ONCE(rnp->n_boosts)));\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (READ_ONCE(rdp->gpwrap) ||\n\t\t\t    ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t READ_ONCE(rdp->gp_seq_needed)))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %ld\\n\",\n\t\t\t\tcpu, (long)data_race(READ_ONCE(rdp->gp_seq_needed)));\n\t\t}\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tcbs += data_race(READ_ONCE(rdp->n_cbs_invoked));\n\t\tif (rcu_segcblist_is_offloaded(&rdp->cblist))\n\t\t\tshow_rcu_nocb_state(rdp);\n\t}\n\tpr_info(\"RCU callbacks invoked since boot: %lu\\n\", cbs);\n\tshow_rcu_tasks_gp_kthreads();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: GP age %lu jiffies\\n\"",
            "__func__",
            "jiffies - data_race(READ_ONCE(rcu_state.gp_start))"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_start"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid rcu_fwd_progress_check(unsigned long j)\n{\n\tunsigned long cbs;\n\tint cpu;\n\tunsigned long max_cbs = 0;\n\tint max_cpu = -1;\n\tstruct rcu_data *rdp;\n\n\tif (rcu_gp_in_progress()) {\n\t\tpr_info(\"%s: GP age %lu jiffies\\n\",\n\t\t\t__func__, jiffies - data_race(READ_ONCE(rcu_state.gp_start)));\n\t\tshow_rcu_gp_kthreads();\n\t} else {\n\t\tpr_info(\"%s: Last GP end %lu jiffies ago\\n\",\n\t\t\t__func__, jiffies - data_race(READ_ONCE(rcu_state.gp_end)));\n\t\tpreempt_disable();\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_check_gp_start_stall(rdp->mynode, rdp, j);\n\t\tpreempt_enable();\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\tcbs = rcu_get_n_cbs_cpu(cpu);\n\t\tif (!cbs)\n\t\t\tcontinue;\n\t\tif (max_cpu < 0)\n\t\t\tpr_info(\"%s: callbacks\", __func__);\n\t\tpr_cont(\" %d: %lu\", cpu, cbs);\n\t\tif (cbs <= max_cbs)\n\t\t\tcontinue;\n\t\tmax_cbs = cbs;\n\t\tmax_cpu = cpu;\n\t}\n\tif (max_cpu >= 0)\n\t\tpr_cont(\"\\n\");\n}"
  },
  {
    "function_name": "rcu_check_gp_start_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "851-903",
    "snippet": "static void rcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t\t     const unsigned long gpssdelay)\n{\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    !smp_load_acquire(&rcu_state.gp_kthread)) // Get stable kthread.\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\tif (rnp_root != rnp)\n\t\t\t/* irqs remain disabled. */\n\t\t\traw_spin_unlock_rcu_node(rnp_root);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tshow_rcu_gp_kthreads();\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_rcu_gp_kthreads",
          "args": [],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_gp_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "782-844",
          "snippet": "void show_rcu_gp_kthreads(void)\n{\n\tunsigned long cbs = 0;\n\tint cpu;\n\tunsigned long j;\n\tunsigned long ja;\n\tunsigned long jr;\n\tunsigned long js;\n\tunsigned long jw;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tj = jiffies;\n\tja = j - data_race(READ_ONCE(rcu_state.gp_activity));\n\tjr = j - data_race(READ_ONCE(rcu_state.gp_req_activity));\n\tjs = j - data_race(READ_ONCE(rcu_state.gp_start));\n\tjw = j - data_race(READ_ONCE(rcu_state.gp_wake_time));\n\tpr_info(\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\",\n\t\trcu_state.name, gp_state_getname(rcu_state.gp_state),\n\t\tdata_race(READ_ONCE(rcu_state.gp_state)),\n\t\tt ? data_race(READ_ONCE(t->__state)) : 0x1ffff, t ? t->rt_priority : 0xffU,\n\t\tjs, ja, jr, jw, (long)data_race(READ_ONCE(rcu_state.gp_wake_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_state.gp_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_max)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_flags)));\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq), READ_ONCE(rnp->gp_seq_needed)) &&\n\t\t    !data_race(READ_ONCE(rnp->qsmask)) && !data_race(READ_ONCE(rnp->boost_tasks)) &&\n\t\t    !data_race(READ_ONCE(rnp->exp_tasks)) && !data_race(READ_ONCE(rnp->gp_tasks)))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\",\n\t\t\trnp->grplo, rnp->grphi,\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq)),\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq_needed)),\n\t\t\tdata_race(READ_ONCE(rnp->qsmask)),\n\t\t\t\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))],\n\t\t\t\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))],\n\t\t\t\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))],\n\t\t\t\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))],\n\t\t\tdata_race(READ_ONCE(rnp->n_boosts)));\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (READ_ONCE(rdp->gpwrap) ||\n\t\t\t    ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t READ_ONCE(rdp->gp_seq_needed)))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %ld\\n\",\n\t\t\t\tcpu, (long)data_race(READ_ONCE(rdp->gp_seq_needed)));\n\t\t}\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tcbs += data_race(READ_ONCE(rdp->n_cbs_invoked));\n\t\tif (rcu_segcblist_is_offloaded(&rdp->cblist))\n\t\t\tshow_rcu_nocb_state(rdp);\n\t}\n\tpr_info(\"RCU callbacks invoked since boot: %lu\\n\", cbs);\n\tshow_rcu_tasks_gp_kthreads();\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid show_rcu_gp_kthreads(void)\n{\n\tunsigned long cbs = 0;\n\tint cpu;\n\tunsigned long j;\n\tunsigned long ja;\n\tunsigned long jr;\n\tunsigned long js;\n\tunsigned long jw;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tj = jiffies;\n\tja = j - data_race(READ_ONCE(rcu_state.gp_activity));\n\tjr = j - data_race(READ_ONCE(rcu_state.gp_req_activity));\n\tjs = j - data_race(READ_ONCE(rcu_state.gp_start));\n\tjw = j - data_race(READ_ONCE(rcu_state.gp_wake_time));\n\tpr_info(\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\",\n\t\trcu_state.name, gp_state_getname(rcu_state.gp_state),\n\t\tdata_race(READ_ONCE(rcu_state.gp_state)),\n\t\tt ? data_race(READ_ONCE(t->__state)) : 0x1ffff, t ? t->rt_priority : 0xffU,\n\t\tjs, ja, jr, jw, (long)data_race(READ_ONCE(rcu_state.gp_wake_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_state.gp_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_max)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_flags)));\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq), READ_ONCE(rnp->gp_seq_needed)) &&\n\t\t    !data_race(READ_ONCE(rnp->qsmask)) && !data_race(READ_ONCE(rnp->boost_tasks)) &&\n\t\t    !data_race(READ_ONCE(rnp->exp_tasks)) && !data_race(READ_ONCE(rnp->gp_tasks)))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\",\n\t\t\trnp->grplo, rnp->grphi,\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq)),\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq_needed)),\n\t\t\tdata_race(READ_ONCE(rnp->qsmask)),\n\t\t\t\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))],\n\t\t\t\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))],\n\t\t\t\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))],\n\t\t\t\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))],\n\t\t\tdata_race(READ_ONCE(rnp->n_boosts)));\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (READ_ONCE(rdp->gpwrap) ||\n\t\t\t    ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t READ_ONCE(rdp->gp_seq_needed)))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %ld\\n\",\n\t\t\t\tcpu, (long)data_race(READ_ONCE(rdp->gp_seq_needed)));\n\t\t}\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tcbs += data_race(READ_ONCE(rdp->n_cbs_invoked));\n\t\tif (rcu_segcblist_is_offloaded(&rdp->cblist))\n\t\t\tshow_rcu_nocb_state(rdp);\n\t}\n\tpr_info(\"RCU callbacks invoked since boot: %lu\\n\", cbs);\n\tshow_rcu_tasks_gp_kthreads();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp_root"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp_root"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&warned",
            "1"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_activity) + gpssdelay"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_req_activity) + gpssdelay"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_req_activity"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "READ_ONCE(rnp_root->gp_seq)",
            "READ_ONCE(rnp_root->gp_seq_needed)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->gp_seq_needed"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->gp_seq"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp_root"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&warned"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_activity) + gpssdelay"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_req_activity) + gpssdelay"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_req_activity"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "READ_ONCE(rnp_root->gp_seq)",
            "READ_ONCE(rnp_root->gp_seq_needed)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->gp_seq_needed"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->gp_seq"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&warned"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_activity) + gpssdelay"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_req_activity) + gpssdelay"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_req_activity"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rcu_state.gp_kthread"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "READ_ONCE(rnp_root->gp_seq)",
            "READ_ONCE(rnp_root->gp_seq_needed)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->gp_seq_needed"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->gp_seq"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PROVE_RCU"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "0"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t\t     const unsigned long gpssdelay)\n{\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    !smp_load_acquire(&rcu_state.gp_kthread)) // Get stable kthread.\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(READ_ONCE(rnp_root->gp_seq),\n\t\t\t READ_ONCE(rnp_root->gp_seq_needed)) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\tif (rnp_root != rnp)\n\t\t\t/* irqs remain disabled. */\n\t\t\traw_spin_unlock_rcu_node(rnp_root);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tshow_rcu_gp_kthreads();\n}"
  },
  {
    "function_name": "show_rcu_gp_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "782-844",
    "snippet": "void show_rcu_gp_kthreads(void)\n{\n\tunsigned long cbs = 0;\n\tint cpu;\n\tunsigned long j;\n\tunsigned long ja;\n\tunsigned long jr;\n\tunsigned long js;\n\tunsigned long jw;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tj = jiffies;\n\tja = j - data_race(READ_ONCE(rcu_state.gp_activity));\n\tjr = j - data_race(READ_ONCE(rcu_state.gp_req_activity));\n\tjs = j - data_race(READ_ONCE(rcu_state.gp_start));\n\tjw = j - data_race(READ_ONCE(rcu_state.gp_wake_time));\n\tpr_info(\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\",\n\t\trcu_state.name, gp_state_getname(rcu_state.gp_state),\n\t\tdata_race(READ_ONCE(rcu_state.gp_state)),\n\t\tt ? data_race(READ_ONCE(t->__state)) : 0x1ffff, t ? t->rt_priority : 0xffU,\n\t\tjs, ja, jr, jw, (long)data_race(READ_ONCE(rcu_state.gp_wake_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_state.gp_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_max)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_flags)));\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq), READ_ONCE(rnp->gp_seq_needed)) &&\n\t\t    !data_race(READ_ONCE(rnp->qsmask)) && !data_race(READ_ONCE(rnp->boost_tasks)) &&\n\t\t    !data_race(READ_ONCE(rnp->exp_tasks)) && !data_race(READ_ONCE(rnp->gp_tasks)))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\",\n\t\t\trnp->grplo, rnp->grphi,\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq)),\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq_needed)),\n\t\t\tdata_race(READ_ONCE(rnp->qsmask)),\n\t\t\t\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))],\n\t\t\t\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))],\n\t\t\t\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))],\n\t\t\t\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))],\n\t\t\tdata_race(READ_ONCE(rnp->n_boosts)));\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (READ_ONCE(rdp->gpwrap) ||\n\t\t\t    ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t READ_ONCE(rdp->gp_seq_needed)))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %ld\\n\",\n\t\t\t\tcpu, (long)data_race(READ_ONCE(rdp->gp_seq_needed)));\n\t\t}\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tcbs += data_race(READ_ONCE(rdp->n_cbs_invoked));\n\t\tif (rcu_segcblist_is_offloaded(&rdp->cblist))\n\t\t\tshow_rcu_nocb_state(rdp);\n\t}\n\tpr_info(\"RCU callbacks invoked since boot: %lu\\n\", cbs);\n\tshow_rcu_tasks_gp_kthreads();\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_rcu_tasks_gp_kthreads",
          "args": [],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_tasks_gp_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1617-1622",
          "snippet": "void show_rcu_tasks_gp_kthreads(void)\n{\n\tshow_rcu_tasks_classic_gp_kthread();\n\tshow_rcu_tasks_rude_gp_kthread();\n\tshow_rcu_tasks_trace_gp_kthread();\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid show_rcu_tasks_gp_kthreads(void)\n{\n\tshow_rcu_tasks_classic_gp_kthread();\n\tshow_rcu_tasks_rude_gp_kthread();\n\tshow_rcu_tasks_trace_gp_kthread();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"RCU callbacks invoked since boot: %lu\\n\"",
            "cbs"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_rcu_nocb_state",
          "args": [
            "rdp"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_nocb_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1544-1546",
          "snippet": "static void show_rcu_nocb_state(struct rcu_data *rdp)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void show_rcu_nocb_state(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_offloaded",
          "args": [
            "&rdp->cblist"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_offloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "87-94",
          "snippet": "static inline bool rcu_segcblist_is_offloaded(struct rcu_segcblist *rsclp)\n{\n\tif (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t    rcu_segcblist_test_flags(rsclp, SEGCBLIST_LOCKING))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_offloaded(struct rcu_segcblist *rsclp)\n{\n\tif (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t    rcu_segcblist_test_flags(rsclp, SEGCBLIST_LOCKING))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "READ_ONCE(rdp->n_cbs_invoked)"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->n_cbs_invoked"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tcpu %d ->gp_seq_needed %ld\\n\"",
            "cpu",
            "(long)data_race(READ_ONCE(rdp->gp_seq_needed))"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gp_seq_needed"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "READ_ONCE(rcu_state.gp_seq)",
            "READ_ONCE(rdp->gp_seq_needed)"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gp_seq_needed"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\"",
            "rnp->grplo",
            "rnp->grphi",
            "(long)data_race(READ_ONCE(rnp->gp_seq))",
            "(long)data_race(READ_ONCE(rnp->gp_seq_needed))",
            "data_race(READ_ONCE(rnp->qsmask))",
            "\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))]",
            "\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))]",
            "\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))]",
            "\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))]",
            "data_race(READ_ONCE(rnp->n_boosts))"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->n_boosts"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_tasks"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_tasks"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->boost_tasks"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->boost_kthread_task"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_seq_needed"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_seq"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_tasks"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_tasks"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->boost_tasks"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "READ_ONCE(rcu_state.gp_seq)",
            "READ_ONCE(rnp->gp_seq_needed)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_seq_needed"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\"",
            "rcu_state.name",
            "gp_state_getname(rcu_state.gp_state)",
            "data_race(READ_ONCE(rcu_state.gp_state))",
            "t ? data_race(READ_ONCE(t->__state)) : 0x1ffff",
            "t ? t->rt_priority : 0xffU",
            "js",
            "ja",
            "jr",
            "jw",
            "(long)data_race(READ_ONCE(rcu_state.gp_wake_seq))",
            "(long)data_race(READ_ONCE(rcu_state.gp_seq))",
            "(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed))",
            "data_race(READ_ONCE(rcu_state.gp_max))",
            "data_race(READ_ONCE(rcu_state.gp_flags))"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_max"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_get_root()->gp_seq_needed"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_wake_seq"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->__state"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_state"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gp_state_getname",
          "args": [
            "rcu_state.gp_state"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "gp_state_getname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "365-370",
          "snippet": "static const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const gp_state_names[] = {\n\t[RCU_GP_IDLE] = \"RCU_GP_IDLE\",\n\t[RCU_GP_WAIT_GPS] = \"RCU_GP_WAIT_GPS\",\n\t[RCU_GP_DONE_GPS] = \"RCU_GP_DONE_GPS\",\n\t[RCU_GP_ONOFF] = \"RCU_GP_ONOFF\",\n\t[RCU_GP_INIT] = \"RCU_GP_INIT\",\n\t[RCU_GP_WAIT_FQS] = \"RCU_GP_WAIT_FQS\",\n\t[RCU_GP_DOING_FQS] = \"RCU_GP_DOING_FQS\",\n\t[RCU_GP_CLEANUP] = \"RCU_GP_CLEANUP\",\n\t[RCU_GP_CLEANED] = \"RCU_GP_CLEANED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic const char * const gp_state_names[] = {\n\t[RCU_GP_IDLE] = \"RCU_GP_IDLE\",\n\t[RCU_GP_WAIT_GPS] = \"RCU_GP_WAIT_GPS\",\n\t[RCU_GP_DONE_GPS] = \"RCU_GP_DONE_GPS\",\n\t[RCU_GP_ONOFF] = \"RCU_GP_ONOFF\",\n\t[RCU_GP_INIT] = \"RCU_GP_INIT\",\n\t[RCU_GP_WAIT_FQS] = \"RCU_GP_WAIT_FQS\",\n\t[RCU_GP_DOING_FQS] = \"RCU_GP_DOING_FQS\",\n\t[RCU_GP_CLEANUP] = \"RCU_GP_CLEANUP\",\n\t[RCU_GP_CLEANED] = \"RCU_GP_CLEANED\",\n};\n\nstatic const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_wake_time"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_start"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_req_activity"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_kthread"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid show_rcu_gp_kthreads(void)\n{\n\tunsigned long cbs = 0;\n\tint cpu;\n\tunsigned long j;\n\tunsigned long ja;\n\tunsigned long jr;\n\tunsigned long js;\n\tunsigned long jw;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tj = jiffies;\n\tja = j - data_race(READ_ONCE(rcu_state.gp_activity));\n\tjr = j - data_race(READ_ONCE(rcu_state.gp_req_activity));\n\tjs = j - data_race(READ_ONCE(rcu_state.gp_start));\n\tjw = j - data_race(READ_ONCE(rcu_state.gp_wake_time));\n\tpr_info(\"%s: wait state: %s(%d) ->state: %#x ->rt_priority %u delta ->gp_start %lu ->gp_activity %lu ->gp_req_activity %lu ->gp_wake_time %lu ->gp_wake_seq %ld ->gp_seq %ld ->gp_seq_needed %ld ->gp_max %lu ->gp_flags %#x\\n\",\n\t\trcu_state.name, gp_state_getname(rcu_state.gp_state),\n\t\tdata_race(READ_ONCE(rcu_state.gp_state)),\n\t\tt ? data_race(READ_ONCE(t->__state)) : 0x1ffff, t ? t->rt_priority : 0xffU,\n\t\tjs, ja, jr, jw, (long)data_race(READ_ONCE(rcu_state.gp_wake_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_state.gp_seq)),\n\t\t(long)data_race(READ_ONCE(rcu_get_root()->gp_seq_needed)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_max)),\n\t\tdata_race(READ_ONCE(rcu_state.gp_flags)));\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq), READ_ONCE(rnp->gp_seq_needed)) &&\n\t\t    !data_race(READ_ONCE(rnp->qsmask)) && !data_race(READ_ONCE(rnp->boost_tasks)) &&\n\t\t    !data_race(READ_ONCE(rnp->exp_tasks)) && !data_race(READ_ONCE(rnp->gp_tasks)))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %ld ->gp_seq_needed %ld ->qsmask %#lx %c%c%c%c ->n_boosts %ld\\n\",\n\t\t\trnp->grplo, rnp->grphi,\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq)),\n\t\t\t(long)data_race(READ_ONCE(rnp->gp_seq_needed)),\n\t\t\tdata_race(READ_ONCE(rnp->qsmask)),\n\t\t\t\".b\"[!!data_race(READ_ONCE(rnp->boost_kthread_task))],\n\t\t\t\".B\"[!!data_race(READ_ONCE(rnp->boost_tasks))],\n\t\t\t\".E\"[!!data_race(READ_ONCE(rnp->exp_tasks))],\n\t\t\t\".G\"[!!data_race(READ_ONCE(rnp->gp_tasks))],\n\t\t\tdata_race(READ_ONCE(rnp->n_boosts)));\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (READ_ONCE(rdp->gpwrap) ||\n\t\t\t    ULONG_CMP_GE(READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t READ_ONCE(rdp->gp_seq_needed)))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %ld\\n\",\n\t\t\t\tcpu, (long)data_race(READ_ONCE(rdp->gp_seq_needed)));\n\t\t}\n\t}\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tcbs += data_race(READ_ONCE(rdp->n_cbs_invoked));\n\t\tif (rcu_segcblist_is_offloaded(&rdp->cblist))\n\t\t\tshow_rcu_nocb_state(rdp);\n\t}\n\tpr_info(\"RCU callbacks invoked since boot: %lu\\n\", cbs);\n\tshow_rcu_tasks_gp_kthreads();\n}"
  },
  {
    "function_name": "rcu_check_boost_fail",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "738-776",
    "snippet": "bool rcu_check_boost_fail(unsigned long gp_state, int *cpup)\n{\n\tbool atb = false;\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\tif (!cpup) {\n\t\t\tif (data_race(READ_ONCE(rnp->qsmask))) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (READ_ONCE(rnp->gp_tasks))\n\t\t\t\t\tatb = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t*cpup = -1;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->gp_tasks)\n\t\t\tatb = true;\n\t\tif (!rnp->qsmask) {\n\t\t\t// No CPUs without quiescent states for this rnp.\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\t// Find the first holdout CPU.\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\tif (rnp->qsmask & (1UL << (cpu - rnp->grplo))) {\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\t\t*cpup = cpu;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t// Can't blame CPUs, so must blame RCU priority boosting.\n\treturn atb;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->gp_tasks"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "READ_ONCE(rnp->qsmask)"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nbool rcu_check_boost_fail(unsigned long gp_state, int *cpup)\n{\n\tbool atb = false;\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\tif (!cpup) {\n\t\t\tif (data_race(READ_ONCE(rnp->qsmask))) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (READ_ONCE(rnp->gp_tasks))\n\t\t\t\t\tatb = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t*cpup = -1;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->gp_tasks)\n\t\t\tatb = true;\n\t\tif (!rnp->qsmask) {\n\t\t\t// No CPUs without quiescent states for this rnp.\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\t// Find the first holdout CPU.\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\tif (rnp->qsmask & (1UL << (cpu - rnp->grplo))) {\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\t\t*cpup = cpu;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t// Can't blame CPUs, so must blame RCU priority boosting.\n\treturn atb;\n}"
  },
  {
    "function_name": "check_cpu_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "626-715",
    "snippet": "static void check_cpu_stall(struct rcu_data *rdp)\n{\n\tbool didstall = false;\n\tunsigned long gs1;\n\tunsigned long gs2;\n\tunsigned long gps;\n\tunsigned long j;\n\tunsigned long jn;\n\tunsigned long js;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_disabled();\n\tif ((rcu_stall_is_suppressed() && !READ_ONCE(rcu_kick_kthreads)) ||\n\t    !rcu_gp_in_progress())\n\t\treturn;\n\trcu_stall_kick_kthreads();\n\tj = jiffies;\n\n\t/*\n\t * Lots of memory barriers to reject false positives.\n\t *\n\t * The idea is to pick up rcu_state.gp_seq, then\n\t * rcu_state.jiffies_stall, then rcu_state.gp_start, and finally\n\t * another copy of rcu_state.gp_seq.  These values are updated in\n\t * the opposite order with memory barriers (or equivalent) during\n\t * grace-period initialization and cleanup.  Now, a false positive\n\t * can occur if we get an new value of rcu_state.gp_start and a old\n\t * value of rcu_state.jiffies_stall.  But given the memory barriers,\n\t * the only way that this can happen is if one grace period ends\n\t * and another starts between these two fetches.  This is detected\n\t * by comparing the second fetch of rcu_state.gp_seq with the\n\t * previous fetch from rcu_state.gp_seq.\n\t *\n\t * Given this check, comparisons of jiffies, rcu_state.jiffies_stall,\n\t * and rcu_state.gp_start suffice to forestall false positives.\n\t */\n\tgs1 = READ_ONCE(rcu_state.gp_seq);\n\tsmp_rmb(); /* Pick up ->gp_seq first... */\n\tjs = READ_ONCE(rcu_state.jiffies_stall);\n\tsmp_rmb(); /* ...then ->jiffies_stall before the rest... */\n\tgps = READ_ONCE(rcu_state.gp_start);\n\tsmp_rmb(); /* ...and finally ->gp_start before ->gp_seq again. */\n\tgs2 = READ_ONCE(rcu_state.gp_seq);\n\tif (gs1 != gs2 ||\n\t    ULONG_CMP_LT(j, js) ||\n\t    ULONG_CMP_GE(gps, js))\n\t\treturn; /* No stall or GP completed since entering function. */\n\trnp = rdp->mynode;\n\tjn = jiffies + ULONG_MAX / 2;\n\tif (rcu_gp_in_progress() &&\n\t    (READ_ONCE(rnp->qsmask) & rdp->grpmask) &&\n\t    cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like an RCU stall. Check to see if the host\n\t\t * stopped the vm.\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn;\n\n\t\t/* We haven't checked in, so go dump stack. */\n\t\tprint_cpu_stall(gps);\n\t\tif (READ_ONCE(rcu_cpu_stall_ftrace_dump))\n\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\tdidstall = true;\n\n\t} else if (rcu_gp_in_progress() &&\n\t\t   ULONG_CMP_GE(j, js + RCU_STALL_RAT_DELAY) &&\n\t\t   cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like an RCU stall. Check to see if the host\n\t\t * stopped the vm.\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn;\n\n\t\t/* They had a few time units to dump stack, so complain. */\n\t\tprint_other_cpu_stall(gs2, gps);\n\t\tif (READ_ONCE(rcu_cpu_stall_ftrace_dump))\n\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\tdidstall = true;\n\t}\n\tif (didstall && READ_ONCE(rcu_state.jiffies_stall) == jn) {\n\t\tjn = jiffies + 3 * rcu_jiffies_till_stall_check() + 3;\n\t\tWRITE_ONCE(rcu_state.jiffies_stall, jn);\n\t}\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_stall",
            "jn"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "29-45",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t\t0",
            "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_stall"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_cpu_stall_ftrace_dump"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_other_cpu_stall",
          "args": [
            "gs2",
            "gps"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "print_other_cpu_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "497-568",
          "snippet": "static void print_other_cpu_stall(unsigned long gp_seq, unsigned long gps)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpa;\n\tunsigned long j;\n\tint ndetected = 0;\n\tstruct rcu_node *rnp;\n\tlong totqlen = 0;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_stall_is_suppressed())\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on our buddy...\n\t * See Documentation/RCU/stallwarn.rst for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"StallDetected\"));\n\tpr_err(\"INFO: %s detected stalls on CPUs/tasks:\\n\", rcu_state.name);\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->qsmask != 0) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(cpu);\n\t\t\t\t\tndetected++;\n\t\t\t\t}\n\t\t}\n\t\tndetected += rcu_print_task_stall(rnp, flags); // Releases rnp->lock.\n\t\tlockdep_assert_irqs_disabled();\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_get_n_cbs_cpu(cpu);\n\tpr_cont(\"\\t(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\",\n\t       smp_processor_id(), (long)(jiffies - gps),\n\t       (long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\tif (ndetected) {\n\t\trcu_dump_cpu_stacks();\n\n\t\t/* Complain about tasks blocking the grace period. */\n\t\trcu_for_each_leaf_node(rnp)\n\t\t\trcu_print_detail_task_stall_rnp(rnp);\n\t} else {\n\t\tif (rcu_seq_current(&rcu_state.gp_seq) != gp_seq) {\n\t\t\tpr_err(\"INFO: Stall ended before state dump start\\n\");\n\t\t} else {\n\t\t\tj = jiffies;\n\t\t\tgpa = data_race(READ_ONCE(rcu_state.gp_activity));\n\t\t\tpr_err(\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\",\n\t\t\t       rcu_state.name, j - gpa, j, gpa,\n\t\t\t       data_race(READ_ONCE(jiffies_till_next_fqs)),\n\t\t\t       data_race(READ_ONCE(rcu_get_root()->qsmask)));\n\t\t}\n\t}\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\n\trcu_check_gp_kthread_expired_fqs_timer();\n\trcu_check_gp_kthread_starvation();\n\n\tpanic_on_rcu_stall();\n\n\trcu_force_quiescent_state();  /* Kick them all. */\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void print_other_cpu_stall(unsigned long gp_seq, unsigned long gps)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpa;\n\tunsigned long j;\n\tint ndetected = 0;\n\tstruct rcu_node *rnp;\n\tlong totqlen = 0;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_stall_is_suppressed())\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on our buddy...\n\t * See Documentation/RCU/stallwarn.rst for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"StallDetected\"));\n\tpr_err(\"INFO: %s detected stalls on CPUs/tasks:\\n\", rcu_state.name);\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->qsmask != 0) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(cpu);\n\t\t\t\t\tndetected++;\n\t\t\t\t}\n\t\t}\n\t\tndetected += rcu_print_task_stall(rnp, flags); // Releases rnp->lock.\n\t\tlockdep_assert_irqs_disabled();\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_get_n_cbs_cpu(cpu);\n\tpr_cont(\"\\t(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\",\n\t       smp_processor_id(), (long)(jiffies - gps),\n\t       (long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\tif (ndetected) {\n\t\trcu_dump_cpu_stacks();\n\n\t\t/* Complain about tasks blocking the grace period. */\n\t\trcu_for_each_leaf_node(rnp)\n\t\t\trcu_print_detail_task_stall_rnp(rnp);\n\t} else {\n\t\tif (rcu_seq_current(&rcu_state.gp_seq) != gp_seq) {\n\t\t\tpr_err(\"INFO: Stall ended before state dump start\\n\");\n\t\t} else {\n\t\t\tj = jiffies;\n\t\t\tgpa = data_race(READ_ONCE(rcu_state.gp_activity));\n\t\t\tpr_err(\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\",\n\t\t\t       rcu_state.name, j - gpa, j, gpa,\n\t\t\t       data_race(READ_ONCE(jiffies_till_next_fqs)),\n\t\t\t       data_race(READ_ONCE(rcu_get_root()->qsmask)));\n\t\t}\n\t}\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\n\trcu_check_gp_kthread_expired_fqs_timer();\n\trcu_check_gp_kthread_starvation();\n\n\tpanic_on_rcu_stall();\n\n\trcu_force_quiescent_state();  /* Kick them all. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_and_clear_guest_paused",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&rcu_state.jiffies_stall",
            "js",
            "jn"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "j",
            "js + RCU_STALL_RAT_DELAY"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_cpu_stall_ftrace_dump"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cpu_stall",
          "args": [
            "gps"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "570-624",
          "snippet": "static void print_cpu_stall(unsigned long gps)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_stall_is_suppressed())\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on ourselves...\n\t * See Documentation/RCU/stallwarn.rst for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"SelfDetected\"));\n\tpr_err(\"INFO: %s self-detected stall on CPU\\n\", rcu_state.name);\n\traw_spin_lock_irqsave_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info(smp_processor_id());\n\traw_spin_unlock_irqrestore_rcu_node(rdp->mynode, flags);\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_get_n_cbs_cpu(cpu);\n\tpr_cont(\"\\t(t=%lu jiffies g=%ld q=%lu)\\n\",\n\t\tjiffies - gps,\n\t\t(long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\n\trcu_check_gp_kthread_expired_fqs_timer();\n\trcu_check_gp_kthread_starvation();\n\n\trcu_dump_cpu_stacks();\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\tpanic_on_rcu_stall();\n\n\t/*\n\t * Attempt to revive the RCU machinery by forcing a context switch.\n\t *\n\t * A context switch would normally allow the RCU state machine to make\n\t * progress and it could be we're stuck in kernel space without context\n\t * switches for an entirely unreasonable amount of time.\n\t */\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void print_cpu_stall(unsigned long gps)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_stall_is_suppressed())\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on ourselves...\n\t * See Documentation/RCU/stallwarn.rst for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"SelfDetected\"));\n\tpr_err(\"INFO: %s self-detected stall on CPU\\n\", rcu_state.name);\n\traw_spin_lock_irqsave_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info(smp_processor_id());\n\traw_spin_unlock_irqrestore_rcu_node(rdp->mynode, flags);\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_get_n_cbs_cpu(cpu);\n\tpr_cont(\"\\t(t=%lu jiffies g=%ld q=%lu)\\n\",\n\t\tjiffies - gps,\n\t\t(long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\n\trcu_check_gp_kthread_expired_fqs_timer();\n\trcu_check_gp_kthread_starvation();\n\n\trcu_dump_cpu_stacks();\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\tpanic_on_rcu_stall();\n\n\t/*\n\t * Attempt to revive the RCU machinery by forcing a context switch.\n\t *\n\t * A context switch would normally allow the RCU state machine to make\n\t * progress and it could be we're stuck in kernel space without context\n\t * switches for an entirely unreasonable amount of time.\n\t */\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_and_clear_guest_paused",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "gps",
            "js"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "j",
            "js"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_start"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_stall"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_stall_kick_kthreads",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_kick_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "162-177",
          "snippet": "static void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!READ_ONCE(rcu_kick_kthreads))\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!READ_ONCE(rcu_kick_kthreads))\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_kick_kthreads"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_stall_is_suppressed",
          "args": [],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_is_suppressed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "234-237",
          "snippet": "static inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void check_cpu_stall(struct rcu_data *rdp)\n{\n\tbool didstall = false;\n\tunsigned long gs1;\n\tunsigned long gs2;\n\tunsigned long gps;\n\tunsigned long j;\n\tunsigned long jn;\n\tunsigned long js;\n\tstruct rcu_node *rnp;\n\n\tlockdep_assert_irqs_disabled();\n\tif ((rcu_stall_is_suppressed() && !READ_ONCE(rcu_kick_kthreads)) ||\n\t    !rcu_gp_in_progress())\n\t\treturn;\n\trcu_stall_kick_kthreads();\n\tj = jiffies;\n\n\t/*\n\t * Lots of memory barriers to reject false positives.\n\t *\n\t * The idea is to pick up rcu_state.gp_seq, then\n\t * rcu_state.jiffies_stall, then rcu_state.gp_start, and finally\n\t * another copy of rcu_state.gp_seq.  These values are updated in\n\t * the opposite order with memory barriers (or equivalent) during\n\t * grace-period initialization and cleanup.  Now, a false positive\n\t * can occur if we get an new value of rcu_state.gp_start and a old\n\t * value of rcu_state.jiffies_stall.  But given the memory barriers,\n\t * the only way that this can happen is if one grace period ends\n\t * and another starts between these two fetches.  This is detected\n\t * by comparing the second fetch of rcu_state.gp_seq with the\n\t * previous fetch from rcu_state.gp_seq.\n\t *\n\t * Given this check, comparisons of jiffies, rcu_state.jiffies_stall,\n\t * and rcu_state.gp_start suffice to forestall false positives.\n\t */\n\tgs1 = READ_ONCE(rcu_state.gp_seq);\n\tsmp_rmb(); /* Pick up ->gp_seq first... */\n\tjs = READ_ONCE(rcu_state.jiffies_stall);\n\tsmp_rmb(); /* ...then ->jiffies_stall before the rest... */\n\tgps = READ_ONCE(rcu_state.gp_start);\n\tsmp_rmb(); /* ...and finally ->gp_start before ->gp_seq again. */\n\tgs2 = READ_ONCE(rcu_state.gp_seq);\n\tif (gs1 != gs2 ||\n\t    ULONG_CMP_LT(j, js) ||\n\t    ULONG_CMP_GE(gps, js))\n\t\treturn; /* No stall or GP completed since entering function. */\n\trnp = rdp->mynode;\n\tjn = jiffies + ULONG_MAX / 2;\n\tif (rcu_gp_in_progress() &&\n\t    (READ_ONCE(rnp->qsmask) & rdp->grpmask) &&\n\t    cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like an RCU stall. Check to see if the host\n\t\t * stopped the vm.\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn;\n\n\t\t/* We haven't checked in, so go dump stack. */\n\t\tprint_cpu_stall(gps);\n\t\tif (READ_ONCE(rcu_cpu_stall_ftrace_dump))\n\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\tdidstall = true;\n\n\t} else if (rcu_gp_in_progress() &&\n\t\t   ULONG_CMP_GE(j, js + RCU_STALL_RAT_DELAY) &&\n\t\t   cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like an RCU stall. Check to see if the host\n\t\t * stopped the vm.\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn;\n\n\t\t/* They had a few time units to dump stack, so complain. */\n\t\tprint_other_cpu_stall(gs2, gps);\n\t\tif (READ_ONCE(rcu_cpu_stall_ftrace_dump))\n\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\tdidstall = true;\n\t}\n\tif (didstall && READ_ONCE(rcu_state.jiffies_stall) == jn) {\n\t\tjn = jiffies + 3 * rcu_jiffies_till_stall_check() + 3;\n\t\tWRITE_ONCE(rcu_state.jiffies_stall, jn);\n\t}\n}"
  },
  {
    "function_name": "print_cpu_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "570-624",
    "snippet": "static void print_cpu_stall(unsigned long gps)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_stall_is_suppressed())\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on ourselves...\n\t * See Documentation/RCU/stallwarn.rst for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"SelfDetected\"));\n\tpr_err(\"INFO: %s self-detected stall on CPU\\n\", rcu_state.name);\n\traw_spin_lock_irqsave_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info(smp_processor_id());\n\traw_spin_unlock_irqrestore_rcu_node(rdp->mynode, flags);\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_get_n_cbs_cpu(cpu);\n\tpr_cont(\"\\t(t=%lu jiffies g=%ld q=%lu)\\n\",\n\t\tjiffies - gps,\n\t\t(long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\n\trcu_check_gp_kthread_expired_fqs_timer();\n\trcu_check_gp_kthread_starvation();\n\n\trcu_dump_cpu_stacks();\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\tpanic_on_rcu_stall();\n\n\t/*\n\t * Attempt to revive the RCU machinery by forcing a context switch.\n\t *\n\t * A context switch would normally allow the RCU state machine to make\n\t * progress and it could be we're stuck in kernel space without context\n\t * switches for an entirely unreasonable amount of time.\n\t */\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic_on_rcu_stall",
          "args": [],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "panic_on_rcu_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "110-119",
          "snippet": "static void panic_on_rcu_stall(void)\n{\n\tstatic int cpu_stall;\n\n\tif (++cpu_stall < sysctl_max_rcu_stall_to_panic)\n\t\treturn;\n\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_rcu_stall",
            "int sysctl_max_rcu_stall_to_panic"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nint sysctl_panic_on_rcu_stall;\nint sysctl_max_rcu_stall_to_panic;\n\nstatic void panic_on_rcu_stall(void)\n{\n\tstatic int cpu_stall;\n\n\tif (++cpu_stall < sysctl_max_rcu_stall_to_panic)\n\t\treturn;\n\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_stall",
            "jiffies + 3 * rcu_jiffies_till_stall_check() + 3"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "29-45",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t\t0",
            "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "jiffies",
            "READ_ONCE(rcu_state.jiffies_stall)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_stall"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dump_cpu_stacks",
          "args": [],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dump_cpu_stacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "331-348",
          "snippet": "static void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\tif (cpu_is_offline(cpu))\n\t\t\t\t\tpr_err(\"Offline CPU %d blocking current GP.\\n\", cpu);\n\t\t\t\telse if (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\tif (cpu_is_offline(cpu))\n\t\t\t\t\tpr_err(\"Offline CPU %d blocking current GP.\\n\", cpu);\n\t\t\t\telse if (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_kthread_starvation",
          "args": [],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_kthread_starvation",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "434-465",
          "snippet": "static void rcu_check_gp_kthread_starvation(void)\n{\n\tint cpu;\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tif (rcu_is_gp_kthread_starving(&j)) {\n\t\tcpu = gpk ? task_cpu(gpk) : -1;\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(READ_ONCE(rcu_state.gp_flags)),\n\t\t       gp_state_getname(rcu_state.gp_state),\n\t\t       data_race(READ_ONCE(rcu_state.gp_state)),\n\t\t       gpk ? data_race(READ_ONCE(gpk->__state)) : ~0, cpu);\n\t\tif (gpk) {\n\t\t\tpr_err(\"\\tUnless %s kthread gets sufficient CPU time, OOM is now expected behavior.\\n\", rcu_state.name);\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\tif (cpu >= 0) {\n\t\t\t\tif (cpu_is_offline(cpu)) {\n\t\t\t\t\tpr_err(\"RCU GP kthread last ran on offline CPU %d.\\n\", cpu);\n\t\t\t\t} else  {\n\t\t\t\t\tpr_err(\"Stack dump where RCU GP kthread last ran:\\n\");\n\t\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t\t}\n\t\t\t}\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_check_gp_kthread_starvation(void)\n{\n\tint cpu;\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tif (rcu_is_gp_kthread_starving(&j)) {\n\t\tcpu = gpk ? task_cpu(gpk) : -1;\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(READ_ONCE(rcu_state.gp_flags)),\n\t\t       gp_state_getname(rcu_state.gp_state),\n\t\t       data_race(READ_ONCE(rcu_state.gp_state)),\n\t\t       gpk ? data_race(READ_ONCE(gpk->__state)) : ~0, cpu);\n\t\tif (gpk) {\n\t\t\tpr_err(\"\\tUnless %s kthread gets sufficient CPU time, OOM is now expected behavior.\\n\", rcu_state.name);\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\tif (cpu >= 0) {\n\t\t\t\tif (cpu_is_offline(cpu)) {\n\t\t\t\t\tpr_err(\"RCU GP kthread last ran on offline CPU %d.\\n\", cpu);\n\t\t\t\t} else  {\n\t\t\t\t\tpr_err(\"Stack dump where RCU GP kthread last ran:\\n\");\n\t\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t\t}\n\t\t\t}\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_kthread_expired_fqs_timer",
          "args": [],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_kthread_expired_fqs_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "468-495",
          "snippet": "static void rcu_check_gp_kthread_expired_fqs_timer(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tshort gp_state;\n\tunsigned long jiffies_fqs;\n\tint cpu;\n\n\t/*\n\t * Order reads of .gp_state and .jiffies_force_qs.\n\t * Matching smp_wmb() is present in rcu_gp_fqs_loop().\n\t */\n\tgp_state = smp_load_acquire(&rcu_state.gp_state);\n\tjiffies_fqs = READ_ONCE(rcu_state.jiffies_force_qs);\n\n\tif (gp_state == RCU_GP_WAIT_FQS &&\n\t    time_after(jiffies, jiffies_fqs + RCU_STALL_MIGHT_MIN) &&\n\t    gpk && !READ_ONCE(gpk->on_rq)) {\n\t\tcpu = task_cpu(gpk);\n\t\tpr_err(\"%s kthread timer wakeup didn't happen for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x\\n\",\n\t\t       rcu_state.name, (jiffies - jiffies_fqs),\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(rcu_state.gp_flags),\n\t\t       gp_state_getname(RCU_GP_WAIT_FQS), RCU_GP_WAIT_FQS,\n\t\t       data_race(READ_ONCE(gpk->__state)));\n\t\tpr_err(\"\\tPossible timer handling issue on cpu=%d timer-softirq=%u\\n\",\n\t\t       cpu, kstat_softirqs_cpu(TIMER_SOFTIRQ, cpu));\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_MIGHT_MIN\t\t(2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_MIGHT_MIN\t\t(2 * HZ)\n\nstatic void rcu_check_gp_kthread_expired_fqs_timer(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tshort gp_state;\n\tunsigned long jiffies_fqs;\n\tint cpu;\n\n\t/*\n\t * Order reads of .gp_state and .jiffies_force_qs.\n\t * Matching smp_wmb() is present in rcu_gp_fqs_loop().\n\t */\n\tgp_state = smp_load_acquire(&rcu_state.gp_state);\n\tjiffies_fqs = READ_ONCE(rcu_state.jiffies_force_qs);\n\n\tif (gp_state == RCU_GP_WAIT_FQS &&\n\t    time_after(jiffies, jiffies_fqs + RCU_STALL_MIGHT_MIN) &&\n\t    gpk && !READ_ONCE(gpk->on_rq)) {\n\t\tcpu = task_cpu(gpk);\n\t\tpr_err(\"%s kthread timer wakeup didn't happen for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x\\n\",\n\t\t       rcu_state.name, (jiffies - jiffies_fqs),\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(rcu_state.gp_flags),\n\t\t       gp_state_getname(RCU_GP_WAIT_FQS), RCU_GP_WAIT_FQS,\n\t\t       data_race(READ_ONCE(gpk->__state)));\n\t\tpr_err(\"\\tPossible timer handling issue on cpu=%d timer-softirq=%u\\n\",\n\t\t       cpu, kstat_softirqs_cpu(TIMER_SOFTIRQ, cpu));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\t(t=%lu jiffies g=%ld q=%lu)\\n\"",
            "jiffies - gps",
            "(long)rcu_seq_current(&rcu_state.gp_seq)",
            "totqlen"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rdp->mynode",
            "flags"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_info",
          "args": [
            "smp_processor_id()"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "393-431",
          "snippet": "static void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tbool falsepositive;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tfalsepositive = rcu_is_gp_kthread_starving(NULL) &&\n\t\t\trcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       data_race(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       falsepositive ? \" (false positive?)\" : \"\");\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tbool falsepositive;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tfalsepositive = rcu_is_gp_kthread_starving(NULL) &&\n\t\t\trcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       data_race(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       falsepositive ? \" (false positive?)\" : \"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rdp->mynode",
            "flags"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: %s self-detected stall on CPU\\n\"",
            "rcu_state.name"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_stall_warning",
          "args": [
            "rcu_state.name",
            "TPS(\"SelfDetected\")"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"SelfDetected\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_stall_is_suppressed",
          "args": [],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_is_suppressed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "234-237",
          "snippet": "static inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_stall_kick_kthreads",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_kick_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "162-177",
          "snippet": "static void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!READ_ONCE(rcu_kick_kthreads))\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!READ_ONCE(rcu_kick_kthreads))\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void print_cpu_stall(unsigned long gps)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_stall_is_suppressed())\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on ourselves...\n\t * See Documentation/RCU/stallwarn.rst for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"SelfDetected\"));\n\tpr_err(\"INFO: %s self-detected stall on CPU\\n\", rcu_state.name);\n\traw_spin_lock_irqsave_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info(smp_processor_id());\n\traw_spin_unlock_irqrestore_rcu_node(rdp->mynode, flags);\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_get_n_cbs_cpu(cpu);\n\tpr_cont(\"\\t(t=%lu jiffies g=%ld q=%lu)\\n\",\n\t\tjiffies - gps,\n\t\t(long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\n\trcu_check_gp_kthread_expired_fqs_timer();\n\trcu_check_gp_kthread_starvation();\n\n\trcu_dump_cpu_stacks();\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\tpanic_on_rcu_stall();\n\n\t/*\n\t * Attempt to revive the RCU machinery by forcing a context switch.\n\t *\n\t * A context switch would normally allow the RCU state machine to make\n\t * progress and it could be we're stuck in kernel space without context\n\t * switches for an entirely unreasonable amount of time.\n\t */\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}"
  },
  {
    "function_name": "print_other_cpu_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "497-568",
    "snippet": "static void print_other_cpu_stall(unsigned long gp_seq, unsigned long gps)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpa;\n\tunsigned long j;\n\tint ndetected = 0;\n\tstruct rcu_node *rnp;\n\tlong totqlen = 0;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_stall_is_suppressed())\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on our buddy...\n\t * See Documentation/RCU/stallwarn.rst for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"StallDetected\"));\n\tpr_err(\"INFO: %s detected stalls on CPUs/tasks:\\n\", rcu_state.name);\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->qsmask != 0) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(cpu);\n\t\t\t\t\tndetected++;\n\t\t\t\t}\n\t\t}\n\t\tndetected += rcu_print_task_stall(rnp, flags); // Releases rnp->lock.\n\t\tlockdep_assert_irqs_disabled();\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_get_n_cbs_cpu(cpu);\n\tpr_cont(\"\\t(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\",\n\t       smp_processor_id(), (long)(jiffies - gps),\n\t       (long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\tif (ndetected) {\n\t\trcu_dump_cpu_stacks();\n\n\t\t/* Complain about tasks blocking the grace period. */\n\t\trcu_for_each_leaf_node(rnp)\n\t\t\trcu_print_detail_task_stall_rnp(rnp);\n\t} else {\n\t\tif (rcu_seq_current(&rcu_state.gp_seq) != gp_seq) {\n\t\t\tpr_err(\"INFO: Stall ended before state dump start\\n\");\n\t\t} else {\n\t\t\tj = jiffies;\n\t\t\tgpa = data_race(READ_ONCE(rcu_state.gp_activity));\n\t\t\tpr_err(\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\",\n\t\t\t       rcu_state.name, j - gpa, j, gpa,\n\t\t\t       data_race(READ_ONCE(jiffies_till_next_fqs)),\n\t\t\t       data_race(READ_ONCE(rcu_get_root()->qsmask)));\n\t\t}\n\t}\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\n\trcu_check_gp_kthread_expired_fqs_timer();\n\trcu_check_gp_kthread_starvation();\n\n\tpanic_on_rcu_stall();\n\n\trcu_force_quiescent_state();  /* Kick them all. */\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_force_quiescent_state",
          "args": [],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_force_quiescent_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "521-521",
          "snippet": "static inline void rcu_force_quiescent_state(void) { }",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_force_quiescent_state(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "panic_on_rcu_stall",
          "args": [],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "panic_on_rcu_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "110-119",
          "snippet": "static void panic_on_rcu_stall(void)\n{\n\tstatic int cpu_stall;\n\n\tif (++cpu_stall < sysctl_max_rcu_stall_to_panic)\n\t\treturn;\n\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_rcu_stall",
            "int sysctl_max_rcu_stall_to_panic"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nint sysctl_panic_on_rcu_stall;\nint sysctl_max_rcu_stall_to_panic;\n\nstatic void panic_on_rcu_stall(void)\n{\n\tstatic int cpu_stall;\n\n\tif (++cpu_stall < sysctl_max_rcu_stall_to_panic)\n\t\treturn;\n\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_kthread_starvation",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_kthread_starvation",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "434-465",
          "snippet": "static void rcu_check_gp_kthread_starvation(void)\n{\n\tint cpu;\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tif (rcu_is_gp_kthread_starving(&j)) {\n\t\tcpu = gpk ? task_cpu(gpk) : -1;\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(READ_ONCE(rcu_state.gp_flags)),\n\t\t       gp_state_getname(rcu_state.gp_state),\n\t\t       data_race(READ_ONCE(rcu_state.gp_state)),\n\t\t       gpk ? data_race(READ_ONCE(gpk->__state)) : ~0, cpu);\n\t\tif (gpk) {\n\t\t\tpr_err(\"\\tUnless %s kthread gets sufficient CPU time, OOM is now expected behavior.\\n\", rcu_state.name);\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\tif (cpu >= 0) {\n\t\t\t\tif (cpu_is_offline(cpu)) {\n\t\t\t\t\tpr_err(\"RCU GP kthread last ran on offline CPU %d.\\n\", cpu);\n\t\t\t\t} else  {\n\t\t\t\t\tpr_err(\"Stack dump where RCU GP kthread last ran:\\n\");\n\t\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t\t}\n\t\t\t}\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_check_gp_kthread_starvation(void)\n{\n\tint cpu;\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tif (rcu_is_gp_kthread_starving(&j)) {\n\t\tcpu = gpk ? task_cpu(gpk) : -1;\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(READ_ONCE(rcu_state.gp_flags)),\n\t\t       gp_state_getname(rcu_state.gp_state),\n\t\t       data_race(READ_ONCE(rcu_state.gp_state)),\n\t\t       gpk ? data_race(READ_ONCE(gpk->__state)) : ~0, cpu);\n\t\tif (gpk) {\n\t\t\tpr_err(\"\\tUnless %s kthread gets sufficient CPU time, OOM is now expected behavior.\\n\", rcu_state.name);\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\tif (cpu >= 0) {\n\t\t\t\tif (cpu_is_offline(cpu)) {\n\t\t\t\t\tpr_err(\"RCU GP kthread last ran on offline CPU %d.\\n\", cpu);\n\t\t\t\t} else  {\n\t\t\t\t\tpr_err(\"Stack dump where RCU GP kthread last ran:\\n\");\n\t\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t\t}\n\t\t\t}\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_kthread_expired_fqs_timer",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_kthread_expired_fqs_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "468-495",
          "snippet": "static void rcu_check_gp_kthread_expired_fqs_timer(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tshort gp_state;\n\tunsigned long jiffies_fqs;\n\tint cpu;\n\n\t/*\n\t * Order reads of .gp_state and .jiffies_force_qs.\n\t * Matching smp_wmb() is present in rcu_gp_fqs_loop().\n\t */\n\tgp_state = smp_load_acquire(&rcu_state.gp_state);\n\tjiffies_fqs = READ_ONCE(rcu_state.jiffies_force_qs);\n\n\tif (gp_state == RCU_GP_WAIT_FQS &&\n\t    time_after(jiffies, jiffies_fqs + RCU_STALL_MIGHT_MIN) &&\n\t    gpk && !READ_ONCE(gpk->on_rq)) {\n\t\tcpu = task_cpu(gpk);\n\t\tpr_err(\"%s kthread timer wakeup didn't happen for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x\\n\",\n\t\t       rcu_state.name, (jiffies - jiffies_fqs),\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(rcu_state.gp_flags),\n\t\t       gp_state_getname(RCU_GP_WAIT_FQS), RCU_GP_WAIT_FQS,\n\t\t       data_race(READ_ONCE(gpk->__state)));\n\t\tpr_err(\"\\tPossible timer handling issue on cpu=%d timer-softirq=%u\\n\",\n\t\t       cpu, kstat_softirqs_cpu(TIMER_SOFTIRQ, cpu));\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_MIGHT_MIN\t\t(2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_MIGHT_MIN\t\t(2 * HZ)\n\nstatic void rcu_check_gp_kthread_expired_fqs_timer(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tshort gp_state;\n\tunsigned long jiffies_fqs;\n\tint cpu;\n\n\t/*\n\t * Order reads of .gp_state and .jiffies_force_qs.\n\t * Matching smp_wmb() is present in rcu_gp_fqs_loop().\n\t */\n\tgp_state = smp_load_acquire(&rcu_state.gp_state);\n\tjiffies_fqs = READ_ONCE(rcu_state.jiffies_force_qs);\n\n\tif (gp_state == RCU_GP_WAIT_FQS &&\n\t    time_after(jiffies, jiffies_fqs + RCU_STALL_MIGHT_MIN) &&\n\t    gpk && !READ_ONCE(gpk->on_rq)) {\n\t\tcpu = task_cpu(gpk);\n\t\tpr_err(\"%s kthread timer wakeup didn't happen for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x\\n\",\n\t\t       rcu_state.name, (jiffies - jiffies_fqs),\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(rcu_state.gp_flags),\n\t\t       gp_state_getname(RCU_GP_WAIT_FQS), RCU_GP_WAIT_FQS,\n\t\t       data_race(READ_ONCE(gpk->__state)));\n\t\tpr_err(\"\\tPossible timer handling issue on cpu=%d timer-softirq=%u\\n\",\n\t\t       cpu, kstat_softirqs_cpu(TIMER_SOFTIRQ, cpu));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_stall",
            "jiffies + 3 * rcu_jiffies_till_stall_check() + 3"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "29-45",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t\t0",
            "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "jiffies",
            "READ_ONCE(rcu_state.jiffies_stall)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_stall"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\"",
            "rcu_state.name",
            "j - gpa",
            "j",
            "gpa",
            "data_race(READ_ONCE(jiffies_till_next_fqs))",
            "data_race(READ_ONCE(rcu_get_root()->qsmask))"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "READ_ONCE(rcu_get_root()->qsmask)"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_get_root()->qsmask"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_next_fqs"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: Stall ended before state dump start\\n\""
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dump_cpu_stacks",
          "args": [],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dump_cpu_stacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "331-348",
          "snippet": "static void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\tif (cpu_is_offline(cpu))\n\t\t\t\t\tpr_err(\"Offline CPU %d blocking current GP.\\n\", cpu);\n\t\t\t\telse if (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\tif (cpu_is_offline(cpu))\n\t\t\t\t\tpr_err(\"Offline CPU %d blocking current GP.\\n\", cpu);\n\t\t\t\telse if (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\t(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\"",
            "smp_processor_id()",
            "(long)(jiffies - gps)",
            "(long)rcu_seq_current(&rcu_state.gp_seq)",
            "totqlen"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_print_task_stall",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_print_task_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "317-322",
          "snippet": "static int rcu_print_task_stall(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic int rcu_print_task_stall(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_info",
          "args": [
            "cpu"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "393-431",
          "snippet": "static void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tbool falsepositive;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tfalsepositive = rcu_is_gp_kthread_starving(NULL) &&\n\t\t\trcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       data_race(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       falsepositive ? \" (false positive?)\" : \"\");\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tbool falsepositive;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tfalsepositive = rcu_is_gp_kthread_starving(NULL) &&\n\t\t\trcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       data_race(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       falsepositive ? \" (false positive?)\" : \"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: %s detected stalls on CPUs/tasks:\\n\"",
            "rcu_state.name"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_stall_warning",
          "args": [
            "rcu_state.name",
            "TPS(\"StallDetected\")"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"StallDetected\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_stall_is_suppressed",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_is_suppressed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "234-237",
          "snippet": "static inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_stall_kick_kthreads",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_kick_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "162-177",
          "snippet": "static void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!READ_ONCE(rcu_kick_kthreads))\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!READ_ONCE(rcu_kick_kthreads))\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void print_other_cpu_stall(unsigned long gp_seq, unsigned long gps)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpa;\n\tunsigned long j;\n\tint ndetected = 0;\n\tstruct rcu_node *rnp;\n\tlong totqlen = 0;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_stall_is_suppressed())\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on our buddy...\n\t * See Documentation/RCU/stallwarn.rst for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"StallDetected\"));\n\tpr_err(\"INFO: %s detected stalls on CPUs/tasks:\\n\", rcu_state.name);\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->qsmask != 0) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(cpu);\n\t\t\t\t\tndetected++;\n\t\t\t\t}\n\t\t}\n\t\tndetected += rcu_print_task_stall(rnp, flags); // Releases rnp->lock.\n\t\tlockdep_assert_irqs_disabled();\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_get_n_cbs_cpu(cpu);\n\tpr_cont(\"\\t(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\",\n\t       smp_processor_id(), (long)(jiffies - gps),\n\t       (long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\tif (ndetected) {\n\t\trcu_dump_cpu_stacks();\n\n\t\t/* Complain about tasks blocking the grace period. */\n\t\trcu_for_each_leaf_node(rnp)\n\t\t\trcu_print_detail_task_stall_rnp(rnp);\n\t} else {\n\t\tif (rcu_seq_current(&rcu_state.gp_seq) != gp_seq) {\n\t\t\tpr_err(\"INFO: Stall ended before state dump start\\n\");\n\t\t} else {\n\t\t\tj = jiffies;\n\t\t\tgpa = data_race(READ_ONCE(rcu_state.gp_activity));\n\t\t\tpr_err(\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\",\n\t\t\t       rcu_state.name, j - gpa, j, gpa,\n\t\t\t       data_race(READ_ONCE(jiffies_till_next_fqs)),\n\t\t\t       data_race(READ_ONCE(rcu_get_root()->qsmask)));\n\t\t}\n\t}\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\n\trcu_check_gp_kthread_expired_fqs_timer();\n\trcu_check_gp_kthread_starvation();\n\n\tpanic_on_rcu_stall();\n\n\trcu_force_quiescent_state();  /* Kick them all. */\n}"
  },
  {
    "function_name": "rcu_check_gp_kthread_expired_fqs_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "468-495",
    "snippet": "static void rcu_check_gp_kthread_expired_fqs_timer(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tshort gp_state;\n\tunsigned long jiffies_fqs;\n\tint cpu;\n\n\t/*\n\t * Order reads of .gp_state and .jiffies_force_qs.\n\t * Matching smp_wmb() is present in rcu_gp_fqs_loop().\n\t */\n\tgp_state = smp_load_acquire(&rcu_state.gp_state);\n\tjiffies_fqs = READ_ONCE(rcu_state.jiffies_force_qs);\n\n\tif (gp_state == RCU_GP_WAIT_FQS &&\n\t    time_after(jiffies, jiffies_fqs + RCU_STALL_MIGHT_MIN) &&\n\t    gpk && !READ_ONCE(gpk->on_rq)) {\n\t\tcpu = task_cpu(gpk);\n\t\tpr_err(\"%s kthread timer wakeup didn't happen for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x\\n\",\n\t\t       rcu_state.name, (jiffies - jiffies_fqs),\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(rcu_state.gp_flags),\n\t\t       gp_state_getname(RCU_GP_WAIT_FQS), RCU_GP_WAIT_FQS,\n\t\t       data_race(READ_ONCE(gpk->__state)));\n\t\tpr_err(\"\\tPossible timer handling issue on cpu=%d timer-softirq=%u\\n\",\n\t\t       cpu, kstat_softirqs_cpu(TIMER_SOFTIRQ, cpu));\n\t}\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [
      "#define RCU_STALL_MIGHT_MIN\t\t(2 * HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\tPossible timer handling issue on cpu=%d timer-softirq=%u\\n\"",
            "cpu",
            "kstat_softirqs_cpu(TIMER_SOFTIRQ, cpu)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_softirqs_cpu",
          "args": [
            "TIMER_SOFTIRQ",
            "cpu"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s kthread timer wakeup didn't happen for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x\\n\"",
            "rcu_state.name",
            "(jiffies - jiffies_fqs)",
            "(long)rcu_seq_current(&rcu_state.gp_seq)",
            "data_race(rcu_state.gp_flags)",
            "gp_state_getname(RCU_GP_WAIT_FQS)",
            "RCU_GP_WAIT_FQS",
            "data_race(READ_ONCE(gpk->__state))"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "READ_ONCE(gpk->__state)"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "gpk->__state"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gp_state_getname",
          "args": [
            "RCU_GP_WAIT_FQS"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "gp_state_getname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "365-370",
          "snippet": "static const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const gp_state_names[] = {\n\t[RCU_GP_IDLE] = \"RCU_GP_IDLE\",\n\t[RCU_GP_WAIT_GPS] = \"RCU_GP_WAIT_GPS\",\n\t[RCU_GP_DONE_GPS] = \"RCU_GP_DONE_GPS\",\n\t[RCU_GP_ONOFF] = \"RCU_GP_ONOFF\",\n\t[RCU_GP_INIT] = \"RCU_GP_INIT\",\n\t[RCU_GP_WAIT_FQS] = \"RCU_GP_WAIT_FQS\",\n\t[RCU_GP_DOING_FQS] = \"RCU_GP_DOING_FQS\",\n\t[RCU_GP_CLEANUP] = \"RCU_GP_CLEANUP\",\n\t[RCU_GP_CLEANED] = \"RCU_GP_CLEANED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic const char * const gp_state_names[] = {\n\t[RCU_GP_IDLE] = \"RCU_GP_IDLE\",\n\t[RCU_GP_WAIT_GPS] = \"RCU_GP_WAIT_GPS\",\n\t[RCU_GP_DONE_GPS] = \"RCU_GP_DONE_GPS\",\n\t[RCU_GP_ONOFF] = \"RCU_GP_ONOFF\",\n\t[RCU_GP_INIT] = \"RCU_GP_INIT\",\n\t[RCU_GP_WAIT_FQS] = \"RCU_GP_WAIT_FQS\",\n\t[RCU_GP_DOING_FQS] = \"RCU_GP_DOING_FQS\",\n\t[RCU_GP_CLEANUP] = \"RCU_GP_CLEANUP\",\n\t[RCU_GP_CLEANED] = \"RCU_GP_CLEANED\",\n};\n\nstatic const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "gpk"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "gpk->on_rq"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "jiffies_fqs + RCU_STALL_MIGHT_MIN"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_force_qs"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rcu_state.gp_state"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_MIGHT_MIN\t\t(2 * HZ)\n\nstatic void rcu_check_gp_kthread_expired_fqs_timer(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tshort gp_state;\n\tunsigned long jiffies_fqs;\n\tint cpu;\n\n\t/*\n\t * Order reads of .gp_state and .jiffies_force_qs.\n\t * Matching smp_wmb() is present in rcu_gp_fqs_loop().\n\t */\n\tgp_state = smp_load_acquire(&rcu_state.gp_state);\n\tjiffies_fqs = READ_ONCE(rcu_state.jiffies_force_qs);\n\n\tif (gp_state == RCU_GP_WAIT_FQS &&\n\t    time_after(jiffies, jiffies_fqs + RCU_STALL_MIGHT_MIN) &&\n\t    gpk && !READ_ONCE(gpk->on_rq)) {\n\t\tcpu = task_cpu(gpk);\n\t\tpr_err(\"%s kthread timer wakeup didn't happen for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x\\n\",\n\t\t       rcu_state.name, (jiffies - jiffies_fqs),\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(rcu_state.gp_flags),\n\t\t       gp_state_getname(RCU_GP_WAIT_FQS), RCU_GP_WAIT_FQS,\n\t\t       data_race(READ_ONCE(gpk->__state)));\n\t\tpr_err(\"\\tPossible timer handling issue on cpu=%d timer-softirq=%u\\n\",\n\t\t       cpu, kstat_softirqs_cpu(TIMER_SOFTIRQ, cpu));\n\t}\n}"
  },
  {
    "function_name": "rcu_check_gp_kthread_starvation",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "434-465",
    "snippet": "static void rcu_check_gp_kthread_starvation(void)\n{\n\tint cpu;\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tif (rcu_is_gp_kthread_starving(&j)) {\n\t\tcpu = gpk ? task_cpu(gpk) : -1;\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(READ_ONCE(rcu_state.gp_flags)),\n\t\t       gp_state_getname(rcu_state.gp_state),\n\t\t       data_race(READ_ONCE(rcu_state.gp_state)),\n\t\t       gpk ? data_race(READ_ONCE(gpk->__state)) : ~0, cpu);\n\t\tif (gpk) {\n\t\t\tpr_err(\"\\tUnless %s kthread gets sufficient CPU time, OOM is now expected behavior.\\n\", rcu_state.name);\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\tif (cpu >= 0) {\n\t\t\t\tif (cpu_is_offline(cpu)) {\n\t\t\t\t\tpr_err(\"RCU GP kthread last ran on offline CPU %d.\\n\", cpu);\n\t\t\t\t} else  {\n\t\t\t\t\tpr_err(\"Stack dump where RCU GP kthread last ran:\\n\");\n\t\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t\t}\n\t\t\t}\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "gpk"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cpu_task",
          "args": [
            "cpu"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cpu_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "10875-10879",
          "snippet": "void dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_single_cpu_backtrace",
          "args": [
            "cpu"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Stack dump where RCU GP kthread last ran:\\n\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"RCU GP kthread last ran on offline CPU %d.\\n\"",
            "cpu"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "gpk"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8544-8572",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (task_is_running(p))\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\tread_task_thread_flags(p));\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (task_is_running(p))\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\tread_task_thread_flags(p));\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"RCU grace-period kthread stack dump:\\n\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\tUnless %s kthread gets sufficient CPU time, OOM is now expected behavior.\\n\"",
            "rcu_state.name"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x ->cpu=%d\\n\"",
            "rcu_state.name",
            "j",
            "(long)rcu_seq_current(&rcu_state.gp_seq)",
            "data_race(READ_ONCE(rcu_state.gp_flags))",
            "gp_state_getname(rcu_state.gp_state)",
            "data_race(READ_ONCE(rcu_state.gp_state))",
            "gpk ? data_race(READ_ONCE(gpk->__state)) : ~0",
            "cpu"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "READ_ONCE(gpk->__state)"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "gpk->__state"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_state"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gp_state_getname",
          "args": [
            "rcu_state.gp_state"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "gp_state_getname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "365-370",
          "snippet": "static const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const gp_state_names[] = {\n\t[RCU_GP_IDLE] = \"RCU_GP_IDLE\",\n\t[RCU_GP_WAIT_GPS] = \"RCU_GP_WAIT_GPS\",\n\t[RCU_GP_DONE_GPS] = \"RCU_GP_DONE_GPS\",\n\t[RCU_GP_ONOFF] = \"RCU_GP_ONOFF\",\n\t[RCU_GP_INIT] = \"RCU_GP_INIT\",\n\t[RCU_GP_WAIT_FQS] = \"RCU_GP_WAIT_FQS\",\n\t[RCU_GP_DOING_FQS] = \"RCU_GP_DOING_FQS\",\n\t[RCU_GP_CLEANUP] = \"RCU_GP_CLEANUP\",\n\t[RCU_GP_CLEANED] = \"RCU_GP_CLEANED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic const char * const gp_state_names[] = {\n\t[RCU_GP_IDLE] = \"RCU_GP_IDLE\",\n\t[RCU_GP_WAIT_GPS] = \"RCU_GP_WAIT_GPS\",\n\t[RCU_GP_DONE_GPS] = \"RCU_GP_DONE_GPS\",\n\t[RCU_GP_ONOFF] = \"RCU_GP_ONOFF\",\n\t[RCU_GP_INIT] = \"RCU_GP_INIT\",\n\t[RCU_GP_WAIT_FQS] = \"RCU_GP_WAIT_FQS\",\n\t[RCU_GP_DOING_FQS] = \"RCU_GP_DOING_FQS\",\n\t[RCU_GP_CLEANUP] = \"RCU_GP_CLEANUP\",\n\t[RCU_GP_CLEANED] = \"RCU_GP_CLEANED\",\n};\n\nstatic const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "gpk"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_gp_kthread_starving",
          "args": [
            "&j"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_gp_kthread_starving",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "373-380",
          "snippet": "static bool rcu_is_gp_kthread_starving(unsigned long *jp)\n{\n\tunsigned long j = jiffies - READ_ONCE(rcu_state.gp_activity);\n\n\tif (jp)\n\t\t*jp = j;\n\treturn j > 2 * HZ;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic bool rcu_is_gp_kthread_starving(unsigned long *jp)\n{\n\tunsigned long j = jiffies - READ_ONCE(rcu_state.gp_activity);\n\n\tif (jp)\n\t\t*jp = j;\n\treturn j > 2 * HZ;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_check_gp_kthread_starvation(void)\n{\n\tint cpu;\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tif (rcu_is_gp_kthread_starving(&j)) {\n\t\tcpu = gpk ? task_cpu(gpk) : -1;\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#x ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       data_race(READ_ONCE(rcu_state.gp_flags)),\n\t\t       gp_state_getname(rcu_state.gp_state),\n\t\t       data_race(READ_ONCE(rcu_state.gp_state)),\n\t\t       gpk ? data_race(READ_ONCE(gpk->__state)) : ~0, cpu);\n\t\tif (gpk) {\n\t\t\tpr_err(\"\\tUnless %s kthread gets sufficient CPU time, OOM is now expected behavior.\\n\", rcu_state.name);\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\tif (cpu >= 0) {\n\t\t\t\tif (cpu_is_offline(cpu)) {\n\t\t\t\t\tpr_err(\"RCU GP kthread last ran on offline CPU %d.\\n\", cpu);\n\t\t\t\t} else  {\n\t\t\t\t\tpr_err(\"Stack dump where RCU GP kthread last ran:\\n\");\n\t\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t\t}\n\t\t\t}\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "print_cpu_stall_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "393-431",
    "snippet": "static void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tbool falsepositive;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tfalsepositive = rcu_is_gp_kthread_starving(NULL) &&\n\t\t\trcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       data_race(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       falsepositive ? \" (false positive?)\" : \"\");\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\"",
            "cpu",
            "\"O.\"[!!cpu_online(cpu)]",
            "\"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)]",
            "\"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)]",
            "!IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta]",
            "ticks_value",
            "ticks_title",
            "rcu_dynticks_snap(rdp) & 0xfff",
            "rdp->dynticks_nesting",
            "rdp->dynticks_nmi_nesting",
            "rdp->softirq_snap",
            "kstat_softirqs_cpu(RCU_SOFTIRQ, cpu)",
            "data_race(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart",
            "falsepositive ? \" (false positive?)\" : \"\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "rcu_state.n_force_qs"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstat_softirqs_cpu",
          "args": [
            "RCU_SOFTIRQ",
            "cpu"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "337-341",
          "snippet": "static int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "delta",
            "9UL"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IRQ_WORK"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs",
          "args": [
            "rcu_dynticks_snap(rdp)"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "347-350",
          "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_gp_kthread_starving",
          "args": [
            "NULL"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_gp_kthread_starving",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "373-380",
          "snippet": "static bool rcu_is_gp_kthread_starving(unsigned long *jp)\n{\n\tunsigned long j = jiffies - READ_ONCE(rcu_state.gp_activity);\n\n\tif (jp)\n\t\t*jp = j;\n\treturn j > 2 * HZ;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic bool rcu_is_gp_kthread_starving(unsigned long *jp)\n{\n\tunsigned long j = jiffies - READ_ONCE(rcu_state.gp_activity);\n\n\tif (jp)\n\t\t*jp = j;\n\treturn j > 2 * HZ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tbool falsepositive;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tfalsepositive = rcu_is_gp_kthread_starving(NULL) &&\n\t\t\trcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       data_race(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       falsepositive ? \" (false positive?)\" : \"\");\n}"
  },
  {
    "function_name": "rcu_is_gp_kthread_starving",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "373-380",
    "snippet": "static bool rcu_is_gp_kthread_starving(unsigned long *jp)\n{\n\tunsigned long j = jiffies - READ_ONCE(rcu_state.gp_activity);\n\n\tif (jp)\n\t\t*jp = j;\n\treturn j > 2 * HZ;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic bool rcu_is_gp_kthread_starving(unsigned long *jp)\n{\n\tunsigned long j = jiffies - READ_ONCE(rcu_state.gp_activity);\n\n\tif (jp)\n\t\t*jp = j;\n\treturn j > 2 * HZ;\n}"
  },
  {
    "function_name": "gp_state_getname",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "365-370",
    "snippet": "static const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const gp_state_names[] = {\n\t[RCU_GP_IDLE] = \"RCU_GP_IDLE\",\n\t[RCU_GP_WAIT_GPS] = \"RCU_GP_WAIT_GPS\",\n\t[RCU_GP_DONE_GPS] = \"RCU_GP_DONE_GPS\",\n\t[RCU_GP_ONOFF] = \"RCU_GP_ONOFF\",\n\t[RCU_GP_INIT] = \"RCU_GP_INIT\",\n\t[RCU_GP_WAIT_FQS] = \"RCU_GP_WAIT_FQS\",\n\t[RCU_GP_DOING_FQS] = \"RCU_GP_DOING_FQS\",\n\t[RCU_GP_CLEANUP] = \"RCU_GP_CLEANUP\",\n\t[RCU_GP_CLEANED] = \"RCU_GP_CLEANED\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "gp_state_names"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic const char * const gp_state_names[] = {\n\t[RCU_GP_IDLE] = \"RCU_GP_IDLE\",\n\t[RCU_GP_WAIT_GPS] = \"RCU_GP_WAIT_GPS\",\n\t[RCU_GP_DONE_GPS] = \"RCU_GP_DONE_GPS\",\n\t[RCU_GP_ONOFF] = \"RCU_GP_ONOFF\",\n\t[RCU_GP_INIT] = \"RCU_GP_INIT\",\n\t[RCU_GP_WAIT_FQS] = \"RCU_GP_WAIT_FQS\",\n\t[RCU_GP_DOING_FQS] = \"RCU_GP_DOING_FQS\",\n\t[RCU_GP_CLEANUP] = \"RCU_GP_CLEANUP\",\n\t[RCU_GP_CLEANED] = \"RCU_GP_CLEANED\",\n};\n\nstatic const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}"
  },
  {
    "function_name": "rcu_dump_cpu_stacks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "331-348",
    "snippet": "static void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\tif (cpu_is_offline(cpu))\n\t\t\t\t\tpr_err(\"Offline CPU %d blocking current GP.\\n\", cpu);\n\t\t\t\telse if (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_cpu_task",
          "args": [
            "cpu"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cpu_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "10875-10879",
          "snippet": "void dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_single_cpu_backtrace",
          "args": [
            "cpu"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Offline CPU %d blocking current GP.\\n\"",
            "cpu"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\tif (cpu_is_offline(cpu))\n\t\t\t\t\tpr_err(\"Offline CPU %d blocking current GP.\\n\", cpu);\n\t\t\t\telse if (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}"
  },
  {
    "function_name": "rcu_print_task_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "317-322",
    "snippet": "static int rcu_print_task_stall(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic int rcu_print_task_stall(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_print_detail_task_stall_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "309-311",
    "snippet": "static void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)\n{\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)\n{\n}"
  },
  {
    "function_name": "rcu_print_task_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "259-301",
    "snippet": "static int rcu_print_task_stall(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tint i = 0;\n\tint ndetected = 0;\n\tstruct rcu_stall_chk_rdr rscr;\n\tstruct task_struct *t;\n\tstruct task_struct *ts[8];\n\n\tlockdep_assert_irqs_disabled();\n\tif (!rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn 0;\n\t}\n\tpr_err(\"\\tTasks blocked on level-%d rcu_node (CPUs %d-%d):\",\n\t       rnp->level, rnp->grplo, rnp->grphi);\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\tget_task_struct(t);\n\t\tts[i++] = t;\n\t\tif (i >= ARRAY_SIZE(ts))\n\t\t\tbreak;\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\twhile (i) {\n\t\tt = ts[--i];\n\t\tif (task_call_func(t, check_slow_task, &rscr))\n\t\t\tpr_cont(\" P%d\", t->pid);\n\t\telse\n\t\t\tpr_cont(\" P%d/%d:%c%c%c%c\",\n\t\t\t\tt->pid, rscr.nesting,\n\t\t\t\t\".b\"[rscr.rs.b.blocked],\n\t\t\t\t\".q\"[rscr.rs.b.need_qs],\n\t\t\t\t\".e\"[rscr.rs.b.exp_hint],\n\t\t\t\t\".l\"[rscr.on_blkd_list]);\n\t\tlockdep_assert_irqs_disabled();\n\t\tput_task_struct(t);\n\t\tndetected++;\n\t}\n\tpr_cont(\"\\n\");\n\treturn ndetected;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "t"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" P%d/%d:%c%c%c%c\"",
            "t->pid",
            "rscr.nesting",
            "\".b\"[rscr.rs.b.blocked]",
            "\".q\"[rscr.rs.b.need_qs]",
            "\".e\"[rscr.rs.b.exp_hint]",
            "\".l\"[rscr.on_blkd_list]"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" P%d\"",
            "t->pid"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_call_func",
          "args": [
            "t",
            "check_slow_task",
            "&rscr"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "task_call_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4158-4202",
          "snippet": "int task_call_func(struct task_struct *p, task_call_f func, void *arg)\n{\n\tstruct rq *rq = NULL;\n\tunsigned int state;\n\tstruct rq_flags rf;\n\tint ret;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\n\tstate = READ_ONCE(p->__state);\n\n\t/*\n\t * Ensure we load p->on_rq after p->__state, otherwise it would be\n\t * possible to, falsely, observe p->on_rq == 0.\n\t *\n\t * See try_to_wake_up() for a longer comment.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * Since pi->lock blocks try_to_wake_up(), we don't need rq->lock when\n\t * the task is blocked. Make sure to check @state since ttwu() can drop\n\t * locks at the end, see ttwu_queue_wakelist().\n\t */\n\tif (state == TASK_RUNNING || state == TASK_WAKING || p->on_rq)\n\t\trq = __task_rq_lock(p, &rf);\n\n\t/*\n\t * At this point the task is pinned; either:\n\t *  - blocked and we're holding off wakeups\t (pi->lock)\n\t *  - woken, and we're holding off enqueue\t (rq->lock)\n\t *  - queued, and we're holding off schedule\t (rq->lock)\n\t *  - running, and we're holding off de-schedule (rq->lock)\n\t *\n\t * The called function (@func) can use: task_curr(), p->on_rq and\n\t * p->__state to differentiate between these states.\n\t */\n\tret = func(p, arg);\n\n\tif (rq)\n\t\trq_unlock(rq, &rf);\n\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint task_call_func(struct task_struct *p, task_call_f func, void *arg)\n{\n\tstruct rq *rq = NULL;\n\tunsigned int state;\n\tstruct rq_flags rf;\n\tint ret;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\n\tstate = READ_ONCE(p->__state);\n\n\t/*\n\t * Ensure we load p->on_rq after p->__state, otherwise it would be\n\t * possible to, falsely, observe p->on_rq == 0.\n\t *\n\t * See try_to_wake_up() for a longer comment.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * Since pi->lock blocks try_to_wake_up(), we don't need rq->lock when\n\t * the task is blocked. Make sure to check @state since ttwu() can drop\n\t * locks at the end, see ttwu_queue_wakelist().\n\t */\n\tif (state == TASK_RUNNING || state == TASK_WAKING || p->on_rq)\n\t\trq = __task_rq_lock(p, &rf);\n\n\t/*\n\t * At this point the task is pinned; either:\n\t *  - blocked and we're holding off wakeups\t (pi->lock)\n\t *  - woken, and we're holding off enqueue\t (rq->lock)\n\t *  - queued, and we're holding off schedule\t (rq->lock)\n\t *  - running, and we're holding off de-schedule (rq->lock)\n\t *\n\t * The called function (@func) can use: task_curr(), p->on_rq and\n\t * p->__state to differentiate between these states.\n\t */\n\tret = func(p, arg);\n\n\tif (rq)\n\t\trq_unlock(rq, &rf);\n\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ts"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "t"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "t",
            "&rnp->blkd_tasks",
            "rcu_node_entry"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rnp->gp_tasks->prev",
            "structtask_struct",
            "rcu_node_entry"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\tTasks blocked on level-%d rcu_node (CPUs %d-%d):\"",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "907-910",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic int rcu_print_task_stall(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tint i = 0;\n\tint ndetected = 0;\n\tstruct rcu_stall_chk_rdr rscr;\n\tstruct task_struct *t;\n\tstruct task_struct *ts[8];\n\n\tlockdep_assert_irqs_disabled();\n\tif (!rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn 0;\n\t}\n\tpr_err(\"\\tTasks blocked on level-%d rcu_node (CPUs %d-%d):\",\n\t       rnp->level, rnp->grplo, rnp->grphi);\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\tget_task_struct(t);\n\t\tts[i++] = t;\n\t\tif (i >= ARRAY_SIZE(ts))\n\t\t\tbreak;\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\twhile (i) {\n\t\tt = ts[--i];\n\t\tif (task_call_func(t, check_slow_task, &rscr))\n\t\t\tpr_cont(\" P%d\", t->pid);\n\t\telse\n\t\t\tpr_cont(\" P%d/%d:%c%c%c%c\",\n\t\t\t\tt->pid, rscr.nesting,\n\t\t\t\t\".b\"[rscr.rs.b.blocked],\n\t\t\t\t\".q\"[rscr.rs.b.need_qs],\n\t\t\t\t\".e\"[rscr.rs.b.exp_hint],\n\t\t\t\t\".l\"[rscr.on_blkd_list]);\n\t\tlockdep_assert_irqs_disabled();\n\t\tput_task_struct(t);\n\t\tndetected++;\n\t}\n\tpr_cont(\"\\n\");\n\treturn ndetected;\n}"
  },
  {
    "function_name": "check_slow_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "243-253",
    "snippet": "static int check_slow_task(struct task_struct *t, void *arg)\n{\n\tstruct rcu_stall_chk_rdr *rscrp = arg;\n\n\tif (task_curr(t))\n\t\treturn -EBUSY; // It is running, so decline to inspect it.\n\trscrp->nesting = t->rcu_read_lock_nesting;\n\trscrp->rs = t->rcu_read_unlock_special;\n\trscrp->on_blkd_list = !list_empty(&t->rcu_node_entry);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&t->rcu_node_entry"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "t"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2099-2102",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic int check_slow_task(struct task_struct *t, void *arg)\n{\n\tstruct rcu_stall_chk_rdr *rscrp = arg;\n\n\tif (task_curr(t))\n\t\treturn -EBUSY; // It is running, so decline to inspect it.\n\trscrp->nesting = t->rcu_read_lock_nesting;\n\trscrp->rs = t->rcu_read_unlock_special;\n\trscrp->on_blkd_list = !list_empty(&t->rcu_node_entry);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_print_detail_task_stall_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "209-230",
    "snippet": "static void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tstruct task_struct *t;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\t/*\n\t\t * We could be printing a lot while holding a spinlock.\n\t\t * Avoid triggering hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\tsched_show_task(t);\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "t"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8544-8572",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (task_is_running(p))\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\tread_task_thread_flags(p));\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (task_is_running(p))\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\tread_task_thread_flags(p));\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "t",
            "&rnp->blkd_tasks",
            "rcu_node_entry"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rnp->gp_tasks->prev",
            "structtask_struct",
            "rcu_node_entry"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "907-910",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tstruct task_struct *t;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\t/*\n\t\t * We could be printing a lot while holding a spinlock.\n\t\t * Avoid triggering hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\tsched_show_task(t);\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
  },
  {
    "function_name": "rcu_iw_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "184-197",
    "snippet": "static void rcu_iw_handler(struct irq_work *iwp)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = container_of(iwp, struct rcu_data, rcu_iw);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\n\tif (!WARN_ON_ONCE(!rdp->rcu_iw_pending)) {\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\trdp->rcu_iw_pending = false;\n\t}\n\traw_spin_unlock_rcu_node(rnp);\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rdp->rcu_iw_pending"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "iwp",
            "structrcu_data",
            "rcu_iw"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_iw_handler(struct irq_work *iwp)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = container_of(iwp, struct rcu_data, rcu_iw);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\n\tif (!WARN_ON_ONCE(!rdp->rcu_iw_pending)) {\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\trdp->rcu_iw_pending = false;\n\t}\n\traw_spin_unlock_rcu_node(rnp);\n}"
  },
  {
    "function_name": "rcu_stall_kick_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "162-177",
    "snippet": "static void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!READ_ONCE(rcu_kick_kthreads))\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_kick_kthreads",
            "j + HZ"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "rcu_state.gp_kthread"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Kicking %s grace-period kthread\\n\"",
            "rcu_state.name"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "j"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_kick_kthreads"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_kick_kthreads"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!READ_ONCE(rcu_kick_kthreads))\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}"
  },
  {
    "function_name": "zero_cpu_stall_ticks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "151-156",
    "snippet": "static void zero_cpu_stall_ticks(struct rcu_data *rdp)\n{\n\trdp->ticks_this_gp = 0;\n\trdp->softirq_snap = kstat_softirqs_cpu(RCU_SOFTIRQ, smp_processor_id());\n\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->last_fqs_resched",
            "jiffies"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_softirqs_cpu",
          "args": [
            "RCU_SOFTIRQ",
            "smp_processor_id()"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void zero_cpu_stall_ticks(struct rcu_data *rdp)\n{\n\trdp->ticks_this_gp = 0;\n\trdp->softirq_snap = kstat_softirqs_cpu(RCU_SOFTIRQ, smp_processor_id());\n\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n}"
  },
  {
    "function_name": "record_gp_stall_check_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "137-148",
    "snippet": "static void record_gp_stall_check_time(void)\n{\n\tunsigned long j = jiffies;\n\tunsigned long j1;\n\n\tWRITE_ONCE(rcu_state.gp_start, j);\n\tj1 = rcu_jiffies_till_stall_check();\n\tsmp_mb(); // ->gp_start before ->jiffies_stall and caller's ->gp_seq.\n\tWRITE_ONCE(rcu_state.jiffies_stall, j + j1);\n\trcu_state.jiffies_resched = j + j1 / 2;\n\trcu_state.n_force_qs_gpstart = READ_ONCE(rcu_state.n_force_qs);\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.n_force_qs"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_stall",
            "j + j1"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "29-45",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t\t0",
            "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_start",
            "j"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic void record_gp_stall_check_time(void)\n{\n\tunsigned long j = jiffies;\n\tunsigned long j1;\n\n\tWRITE_ONCE(rcu_state.gp_start, j);\n\tj1 = rcu_jiffies_till_stall_check();\n\tsmp_mb(); // ->gp_start before ->jiffies_stall and caller's ->gp_seq.\n\tWRITE_ONCE(rcu_state.jiffies_stall, j + j1);\n\trcu_state.jiffies_resched = j + j1 / 2;\n\trcu_state.n_force_qs_gpstart = READ_ONCE(rcu_state.n_force_qs);\n}"
  },
  {
    "function_name": "rcu_cpu_stall_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "126-130",
    "snippet": "void rcu_cpu_stall_reset(void)\n{\n\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t   jiffies + rcu_jiffies_till_stall_check());\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_stall",
            "jiffies + rcu_jiffies_till_stall_check()"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "29-45",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t\t0",
            "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid rcu_cpu_stall_reset(void)\n{\n\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t   jiffies + rcu_jiffies_till_stall_check());\n}"
  },
  {
    "function_name": "panic_on_rcu_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "110-119",
    "snippet": "static void panic_on_rcu_stall(void)\n{\n\tstatic int cpu_stall;\n\n\tif (++cpu_stall < sysctl_max_rcu_stall_to_panic)\n\t\treturn;\n\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_panic_on_rcu_stall",
      "int sysctl_max_rcu_stall_to_panic"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"RCU Stall\\n\""
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nint sysctl_panic_on_rcu_stall;\nint sysctl_max_rcu_stall_to_panic;\n\nstatic void panic_on_rcu_stall(void)\n{\n\tstatic int cpu_stall;\n\n\tif (++cpu_stall < sysctl_max_rcu_stall_to_panic)\n\t\treturn;\n\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}"
  },
  {
    "function_name": "check_cpu_stall_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "102-106",
    "snippet": "static int __init check_cpu_stall_init(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &rcu_panic_block);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block rcu_panic_block = {\n\t.notifier_call = rcu_panic,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_chain_register",
          "args": [
            "&panic_notifier_list",
            "&rcu_panic_block"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "140-150",
          "snippet": "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic struct notifier_block rcu_panic_block = {\n\t.notifier_call = rcu_panic,\n};\n\nstatic int __init check_cpu_stall_init(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &rcu_panic_block);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_panic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "92-96",
    "snippet": "static int rcu_panic(struct notifier_block *this, unsigned long ev, void *ptr)\n{\n\trcu_cpu_stall_suppress = 1;\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nstatic int rcu_panic(struct notifier_block *this, unsigned long ev, void *ptr)\n{\n\trcu_cpu_stall_suppress = 1;\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "rcu_sysrq_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "85-89",
    "snippet": "void rcu_sysrq_end(void)\n{\n\tif (rcu_cpu_stall_suppress == 2)\n\t\trcu_cpu_stall_suppress = 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid rcu_sysrq_end(void)\n{\n\tif (rcu_cpu_stall_suppress == 2)\n\t\trcu_cpu_stall_suppress = 0;\n}"
  },
  {
    "function_name": "rcu_sysrq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "79-83",
    "snippet": "void rcu_sysrq_start(void)\n{\n\tif (!rcu_cpu_stall_suppress)\n\t\trcu_cpu_stall_suppress = 2;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid rcu_sysrq_start(void)\n{\n\tif (!rcu_cpu_stall_suppress)\n\t\trcu_cpu_stall_suppress = 2;\n}"
  },
  {
    "function_name": "rcu_gp_might_be_stalled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "61-76",
    "snippet": "bool rcu_gp_might_be_stalled(void)\n{\n\tunsigned long d = rcu_jiffies_till_stall_check() / RCU_STALL_MIGHT_DIV;\n\tunsigned long j = jiffies;\n\n\tif (d < RCU_STALL_MIGHT_MIN)\n\t\td = RCU_STALL_MIGHT_MIN;\n\tsmp_mb(); // jiffies before .gp_seq to avoid false positives.\n\tif (!rcu_gp_in_progress())\n\t\treturn false;\n\t// Long delays at this point avoids false positive, but a delay\n\t// of ULONG_MAX/4 jiffies voids your no-false-positive warranty.\n\tsmp_mb(); // .gp_seq before second .gp_start\n\t// And ditto here.\n\treturn !time_before(j, READ_ONCE(rcu_state.gp_start) + d);\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [
      "#define RCU_STALL_MIGHT_MIN\t\t(2 * HZ)",
      "#define RCU_STALL_MIGHT_DIV\t\t8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_start) + d"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_start"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "229-232",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "29-45",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t\t0",
            "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_MIGHT_MIN\t\t(2 * HZ)\n#define RCU_STALL_MIGHT_DIV\t\t8\n\nbool rcu_gp_might_be_stalled(void)\n{\n\tunsigned long d = rcu_jiffies_till_stall_check() / RCU_STALL_MIGHT_DIV;\n\tunsigned long j = jiffies;\n\n\tif (d < RCU_STALL_MIGHT_MIN)\n\t\td = RCU_STALL_MIGHT_MIN;\n\tsmp_mb(); // jiffies before .gp_seq to avoid false positives.\n\tif (!rcu_gp_in_progress())\n\t\treturn false;\n\t// Long delays at this point avoids false positive, but a delay\n\t// of ULONG_MAX/4 jiffies voids your no-false-positive warranty.\n\tsmp_mb(); // .gp_seq before second .gp_start\n\t// And ditto here.\n\treturn !time_before(j, READ_ONCE(rcu_state.gp_start) + d);\n}"
  },
  {
    "function_name": "rcu_jiffies_till_stall_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
    "lines": "29-45",
    "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
    "includes": [
      "#include <linux/kvm_para.h>"
    ],
    "macros_used": [
      "#define RCU_STALL_DELAY_DELTA\t\t0",
      "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_cpu_stall_timeout",
            "300"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_cpu_stall_timeout",
            "3"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_cpu_stall_timeout"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
  }
]