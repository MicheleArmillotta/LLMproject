[
  {
    "function_name": "init_osnoise_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2350-2377",
    "snippet": "__init static int init_osnoise_tracer(void)\n{\n\tint ret;\n\n\tmutex_init(&interface_lock);\n\n\tcpumask_copy(&osnoise_cpumask, cpu_all_mask);\n\n\tret = register_tracer(&osnoise_tracer);\n\tif (ret) {\n\t\tpr_err(BANNER \"Error registering osnoise!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = init_timerlat_tracer();\n\tif (ret) {\n\t\tpr_err(BANNER \"Error registering timerlat!\\n\");\n\t\treturn ret;\n\t}\n\n\tosnoise_init_hotplug_support();\n\n\tINIT_LIST_HEAD_RCU(&osnoise_instances);\n\n\tinit_tracefs();\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"osnoise: \""
    ],
    "globals_used": [
      "static struct list_head osnoise_instances;",
      "struct mutex interface_lock;",
      "static struct cpumask osnoise_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_tracefs",
          "args": [],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "init_tracefs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2043-2090",
          "snippet": "static int init_tracefs(void)\n{\n\tstruct dentry *top_dir;\n\tstruct dentry *tmp;\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"osnoise\", NULL);\n\tif (!top_dir)\n\t\treturn 0;\n\n\ttmp = tracefs_create_file(\"period_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_period, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"runtime_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_runtime, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_in, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_total_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_total, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = trace_create_file(\"cpus\", TRACE_MODE_WRITE, top_dir, NULL, &cpus_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\tret = init_timerlat_tracefs(top_dir);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_min_max_param osnoise_runtime = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_runtime,\n\t.max\t= &osnoise_data.sample_period,\n\t.min\t= NULL,\n};",
            "static struct trace_min_max_param osnoise_period = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_period,\n\t.max\t= NULL,\n\t.min\t= &osnoise_data.sample_runtime,\n};",
            "static struct trace_min_max_param osnoise_stop_tracing_in = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};",
            "static struct trace_min_max_param osnoise_stop_tracing_total = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing_total,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};",
            "static const struct file_operations cpus_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= osnoise_cpus_read,\n\t.write\t\t= osnoise_cpus_write,\n\t.llseek\t\t= generic_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct trace_min_max_param osnoise_runtime = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_runtime,\n\t.max\t= &osnoise_data.sample_period,\n\t.min\t= NULL,\n};\nstatic struct trace_min_max_param osnoise_period = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_period,\n\t.max\t= NULL,\n\t.min\t= &osnoise_data.sample_runtime,\n};\nstatic struct trace_min_max_param osnoise_stop_tracing_in = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};\nstatic struct trace_min_max_param osnoise_stop_tracing_total = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing_total,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};\nstatic const struct file_operations cpus_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= osnoise_cpus_read,\n\t.write\t\t= osnoise_cpus_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int init_tracefs(void)\n{\n\tstruct dentry *top_dir;\n\tstruct dentry *tmp;\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"osnoise\", NULL);\n\tif (!top_dir)\n\t\treturn 0;\n\n\ttmp = tracefs_create_file(\"period_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_period, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"runtime_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_runtime, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_in, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_total_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_total, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = trace_create_file(\"cpus\", TRACE_MODE_WRITE, top_dir, NULL, &cpus_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\tret = init_timerlat_tracefs(top_dir);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD_RCU",
          "args": [
            "&osnoise_instances"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osnoise_init_hotplug_support",
          "args": [],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_init_hotplug_support",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1807-1810",
          "snippet": "static void osnoise_init_hotplug_support(void)\n{\n\treturn;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void osnoise_init_hotplug_support(void)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "BANNER \"Error registering timerlat!\\n\""
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_timerlat_tracer",
          "args": [],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "init_timerlat_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2344-2347",
          "snippet": "__init static int init_timerlat_tracer(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n__init static int init_timerlat_tracer(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "BANNER \"Error registering osnoise!\\n\""
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&osnoise_tracer"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&osnoise_cpumask",
            "cpu_all_mask"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&interface_lock"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic struct list_head osnoise_instances;\nstruct mutex interface_lock;\nstatic struct cpumask osnoise_cpumask;\n\n__init static int init_osnoise_tracer(void)\n{\n\tint ret;\n\n\tmutex_init(&interface_lock);\n\n\tcpumask_copy(&osnoise_cpumask, cpu_all_mask);\n\n\tret = register_tracer(&osnoise_tracer);\n\tif (ret) {\n\t\tpr_err(BANNER \"Error registering osnoise!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = init_timerlat_tracer();\n\tif (ret) {\n\t\tpr_err(BANNER \"Error registering timerlat!\\n\");\n\t\treturn ret;\n\t}\n\n\tosnoise_init_hotplug_support();\n\n\tINIT_LIST_HEAD_RCU(&osnoise_instances);\n\n\tinit_tracefs();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "init_timerlat_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2344-2347",
    "snippet": "__init static int init_timerlat_tracer(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n__init static int init_timerlat_tracer(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "init_timerlat_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2339-2342",
    "snippet": "__init static int init_timerlat_tracer(void)\n{\n\treturn register_tracer(&timerlat_tracer);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&timerlat_tracer"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n__init static int init_timerlat_tracer(void)\n{\n\treturn register_tracer(&timerlat_tracer);\n}"
  },
  {
    "function_name": "timerlat_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2317-2327",
    "snippet": "static void timerlat_tracer_reset(struct trace_array *tr)\n{\n\ttimerlat_tracer_stop(tr);\n\n\t/*\n\t * If this is the last instance, reset timerlat_tracer allowing\n\t * osnoise to be started.\n\t */\n\tif (!osnoise_has_registered_instances())\n\t\tosnoise_data.timerlat_tracer = 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_has_registered_instances",
          "args": [],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_has_registered_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "61-66",
          "snippet": "static bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerlat_tracer_stop",
          "args": [
            "tr"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_tracer_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2279-2294",
          "snippet": "static void timerlat_tracer_stop(struct trace_array *tr)\n{\n\tint cpu;\n\n\tosnoise_unregister_instance(tr);\n\n\t/*\n\t * Instruct the threads to stop only if this is the last instance.\n\t */\n\tif (!osnoise_has_registered_instances()) {\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu(per_cpu_osnoise_var, cpu).sampling = 0;\n\t}\n\n\tosnoise_workload_stop();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void timerlat_tracer_stop(struct trace_array *tr)\n{\n\tint cpu;\n\n\tosnoise_unregister_instance(tr);\n\n\t/*\n\t * Instruct the threads to stop only if this is the last instance.\n\t */\n\tif (!osnoise_has_registered_instances()) {\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu(per_cpu_osnoise_var, cpu).sampling = 0;\n\t}\n\n\tosnoise_workload_stop();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic void timerlat_tracer_reset(struct trace_array *tr)\n{\n\ttimerlat_tracer_stop(tr);\n\n\t/*\n\t * If this is the last instance, reset timerlat_tracer allowing\n\t * osnoise to be started.\n\t */\n\tif (!osnoise_has_registered_instances())\n\t\tosnoise_data.timerlat_tracer = 0;\n}"
  },
  {
    "function_name": "timerlat_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2296-2315",
    "snippet": "static int timerlat_tracer_init(struct trace_array *tr)\n{\n\t/*\n\t * Only allow timerlat tracer if osnoise tracer is not running already.\n\t */\n\tif (osnoise_has_registered_instances() && !osnoise_data.timerlat_tracer)\n\t\treturn -EBUSY;\n\n\t/*\n\t * If this is the first instance, set timerlat_tracer to block\n\t * osnoise tracer start.\n\t */\n\tif (!osnoise_has_registered_instances())\n\t\tosnoise_data.timerlat_tracer = 1;\n\n\ttr->max_latency = 0;\n\ttimerlat_tracer_start(tr);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerlat_tracer_start",
          "args": [
            "tr"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_tracer_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2259-2277",
          "snippet": "static void timerlat_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t/*\n\t * If the instance is already registered, there is no need to\n\t * register it again.\n\t */\n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting timerlat tracer\\n\");\n\n\tosnoise_register_instance(tr);\n\n\treturn;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"osnoise: \""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic void timerlat_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t/*\n\t * If the instance is already registered, there is no need to\n\t * register it again.\n\t */\n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting timerlat tracer\\n\");\n\n\tosnoise_register_instance(tr);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_has_registered_instances",
          "args": [],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_has_registered_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "61-66",
          "snippet": "static bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic int timerlat_tracer_init(struct trace_array *tr)\n{\n\t/*\n\t * Only allow timerlat tracer if osnoise tracer is not running already.\n\t */\n\tif (osnoise_has_registered_instances() && !osnoise_data.timerlat_tracer)\n\t\treturn -EBUSY;\n\n\t/*\n\t * If this is the first instance, set timerlat_tracer to block\n\t * osnoise tracer start.\n\t */\n\tif (!osnoise_has_registered_instances())\n\t\tosnoise_data.timerlat_tracer = 1;\n\n\ttr->max_latency = 0;\n\ttimerlat_tracer_start(tr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "timerlat_tracer_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2279-2294",
    "snippet": "static void timerlat_tracer_stop(struct trace_array *tr)\n{\n\tint cpu;\n\n\tosnoise_unregister_instance(tr);\n\n\t/*\n\t * Instruct the threads to stop only if this is the last instance.\n\t */\n\tif (!osnoise_has_registered_instances()) {\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu(per_cpu_osnoise_var, cpu).sampling = 0;\n\t}\n\n\tosnoise_workload_stop();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_workload_stop",
          "args": [],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_workload_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2180-2202",
          "snippet": "static void osnoise_workload_stop(void)\n{\n\t/*\n\t * Instances need to be unregistered before calling\n\t * stop. Hence, if there is a registered instance, more\n\t * than one instance is running, and the workload will not\n\t * yet stop. Otherwise, this code is on the way to disable\n\t * the last instance, and the workload can stop.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn;\n\n\ttrace_osnoise_callback_enabled = false;\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see\n\t * trace_osnoise_callback_enabled as false before continuing.\n\t */\n\tbarrier();\n\n\tstop_per_cpu_kthreads();\n\n\tosnoise_unhook_events();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool trace_osnoise_callback_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nbool trace_osnoise_callback_enabled;\n\nstatic void osnoise_workload_stop(void)\n{\n\t/*\n\t * Instances need to be unregistered before calling\n\t * stop. Hence, if there is a registered instance, more\n\t * than one instance is running, and the workload will not\n\t * yet stop. Otherwise, this code is on the way to disable\n\t * the last instance, and the workload can stop.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn;\n\n\ttrace_osnoise_callback_enabled = false;\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see\n\t * trace_osnoise_callback_enabled as false before continuing.\n\t */\n\tbarrier();\n\n\tstop_per_cpu_kthreads();\n\n\tosnoise_unhook_events();\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_has_registered_instances",
          "args": [],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_has_registered_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "61-66",
          "snippet": "static bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_unregister_instance",
          "args": [
            "tr"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_unregister_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "119-142",
          "snippet": "static void osnoise_unregister_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr) {\n\t\t\tlist_del_rcu(&inst->list);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\tkvfree_rcu(inst);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void osnoise_unregister_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr) {\n\t\t\tlist_del_rcu(&inst->list);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\tkvfree_rcu(inst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void timerlat_tracer_stop(struct trace_array *tr)\n{\n\tint cpu;\n\n\tosnoise_unregister_instance(tr);\n\n\t/*\n\t * Instruct the threads to stop only if this is the last instance.\n\t */\n\tif (!osnoise_has_registered_instances()) {\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu(per_cpu_osnoise_var, cpu).sampling = 0;\n\t}\n\n\tosnoise_workload_stop();\n}"
  },
  {
    "function_name": "timerlat_tracer_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2259-2277",
    "snippet": "static void timerlat_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t/*\n\t * If the instance is already registered, there is no need to\n\t * register it again.\n\t */\n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting timerlat tracer\\n\");\n\n\tosnoise_register_instance(tr);\n\n\treturn;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"osnoise: \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_register_instance",
          "args": [
            "tr"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_register_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "92-111",
          "snippet": "static int osnoise_register_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tinst = kmalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD_RCU(&inst->list);\n\tinst->tr = tr;\n\tlist_add_tail_rcu(&inst->list, &osnoise_instances);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic int osnoise_register_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tinst = kmalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD_RCU(&inst->list);\n\tinst->tr = tr;\n\tlist_add_tail_rcu(&inst->list, &osnoise_instances);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "BANNER \"Error starting timerlat tracer\\n\""
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osnoise_workload_start",
          "args": [],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_workload_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2134-2175",
          "snippet": "static int osnoise_workload_start(void)\n{\n\tint retval;\n\n\t/*\n\t * Instances need to be registered after calling workload\n\t * start. Hence, if there is already an instance, the\n\t * workload was already registered. Otherwise, this\n\t * code is on the way to register the first instance,\n\t * and the workload will start.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn 0;\n\n\tosn_var_reset_all();\n\n\tretval = osnoise_hook_events();\n\tif (retval)\n\t\treturn retval;\n\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see reset values\n\t * before enabling trace_osnoise_callback_enabled.\n\t */\n\tbarrier();\n\ttrace_osnoise_callback_enabled = true;\n\n\tretval = start_per_cpu_kthreads();\n\tif (retval) {\n\t\ttrace_osnoise_callback_enabled = false;\n\t\t/*\n\t\t * Make sure that ftrace_nmi_enter/exit() see\n\t\t * trace_osnoise_callback_enabled as false before continuing.\n\t\t */\n\t\tbarrier();\n\n\t\tosnoise_unhook_events();\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool trace_osnoise_callback_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nbool trace_osnoise_callback_enabled;\n\nstatic int osnoise_workload_start(void)\n{\n\tint retval;\n\n\t/*\n\t * Instances need to be registered after calling workload\n\t * start. Hence, if there is already an instance, the\n\t * workload was already registered. Otherwise, this\n\t * code is on the way to register the first instance,\n\t * and the workload will start.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn 0;\n\n\tosn_var_reset_all();\n\n\tretval = osnoise_hook_events();\n\tif (retval)\n\t\treturn retval;\n\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see reset values\n\t * before enabling trace_osnoise_callback_enabled.\n\t */\n\tbarrier();\n\ttrace_osnoise_callback_enabled = true;\n\n\tretval = start_per_cpu_kthreads();\n\tif (retval) {\n\t\ttrace_osnoise_callback_enabled = false;\n\t\t/*\n\t\t * Make sure that ftrace_nmi_enter/exit() see\n\t\t * trace_osnoise_callback_enabled as false before continuing.\n\t\t */\n\t\tbarrier();\n\n\t\tosnoise_unhook_events();\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_instance_registered",
          "args": [
            "tr"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_instance_registered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "71-84",
          "snippet": "static int osnoise_instance_registered(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr)\n\t\t\tfound = 1;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic int osnoise_instance_registered(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr)\n\t\t\tfound = 1;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic void timerlat_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t/*\n\t * If the instance is already registered, there is no need to\n\t * register it again.\n\t */\n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting timerlat tracer\\n\");\n\n\tosnoise_register_instance(tr);\n\n\treturn;\n}"
  },
  {
    "function_name": "osnoise_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2243-2246",
    "snippet": "static void osnoise_tracer_reset(struct trace_array *tr)\n{\n\tosnoise_tracer_stop(tr);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_tracer_stop",
          "args": [
            "tr"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_tracer_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2222-2226",
          "snippet": "static void osnoise_tracer_stop(struct trace_array *tr)\n{\n\tosnoise_unregister_instance(tr);\n\tosnoise_workload_stop();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void osnoise_tracer_stop(struct trace_array *tr)\n{\n\tosnoise_unregister_instance(tr);\n\tosnoise_workload_stop();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void osnoise_tracer_reset(struct trace_array *tr)\n{\n\tosnoise_tracer_stop(tr);\n}"
  },
  {
    "function_name": "osnoise_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2228-2241",
    "snippet": "static int osnoise_tracer_init(struct trace_array *tr)\n{\n\t/*\n\t * Only allow osnoise tracer if timerlat tracer is not running\n\t * already.\n\t */\n\tif (timerlat_enabled())\n\t\treturn -EBUSY;\n\n\ttr->max_latency = 0;\n\n\tosnoise_tracer_start(tr);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_tracer_start",
          "args": [
            "tr"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_tracer_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2204-2220",
          "snippet": "static void osnoise_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t/*\n\t * If the instance is already registered, there is no need to\n\t * register it again.\n\t */\n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting osnoise tracer\\n\");\n\n\tosnoise_register_instance(tr);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"osnoise: \""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic void osnoise_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t/*\n\t * If the instance is already registered, there is no need to\n\t * register it again.\n\t */\n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting osnoise tracer\\n\");\n\n\tosnoise_register_instance(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerlat_enabled",
          "args": [],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "378-381",
          "snippet": "static inline bool timerlat_enabled(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline bool timerlat_enabled(void)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int osnoise_tracer_init(struct trace_array *tr)\n{\n\t/*\n\t * Only allow osnoise tracer if timerlat tracer is not running\n\t * already.\n\t */\n\tif (timerlat_enabled())\n\t\treturn -EBUSY;\n\n\ttr->max_latency = 0;\n\n\tosnoise_tracer_start(tr);\n\treturn 0;\n}"
  },
  {
    "function_name": "osnoise_tracer_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2222-2226",
    "snippet": "static void osnoise_tracer_stop(struct trace_array *tr)\n{\n\tosnoise_unregister_instance(tr);\n\tosnoise_workload_stop();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_workload_stop",
          "args": [],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_workload_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2180-2202",
          "snippet": "static void osnoise_workload_stop(void)\n{\n\t/*\n\t * Instances need to be unregistered before calling\n\t * stop. Hence, if there is a registered instance, more\n\t * than one instance is running, and the workload will not\n\t * yet stop. Otherwise, this code is on the way to disable\n\t * the last instance, and the workload can stop.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn;\n\n\ttrace_osnoise_callback_enabled = false;\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see\n\t * trace_osnoise_callback_enabled as false before continuing.\n\t */\n\tbarrier();\n\n\tstop_per_cpu_kthreads();\n\n\tosnoise_unhook_events();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool trace_osnoise_callback_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nbool trace_osnoise_callback_enabled;\n\nstatic void osnoise_workload_stop(void)\n{\n\t/*\n\t * Instances need to be unregistered before calling\n\t * stop. Hence, if there is a registered instance, more\n\t * than one instance is running, and the workload will not\n\t * yet stop. Otherwise, this code is on the way to disable\n\t * the last instance, and the workload can stop.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn;\n\n\ttrace_osnoise_callback_enabled = false;\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see\n\t * trace_osnoise_callback_enabled as false before continuing.\n\t */\n\tbarrier();\n\n\tstop_per_cpu_kthreads();\n\n\tosnoise_unhook_events();\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_unregister_instance",
          "args": [
            "tr"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_unregister_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "119-142",
          "snippet": "static void osnoise_unregister_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr) {\n\t\t\tlist_del_rcu(&inst->list);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\tkvfree_rcu(inst);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void osnoise_unregister_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr) {\n\t\t\tlist_del_rcu(&inst->list);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\tkvfree_rcu(inst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void osnoise_tracer_stop(struct trace_array *tr)\n{\n\tosnoise_unregister_instance(tr);\n\tosnoise_workload_stop();\n}"
  },
  {
    "function_name": "osnoise_tracer_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2204-2220",
    "snippet": "static void osnoise_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t/*\n\t * If the instance is already registered, there is no need to\n\t * register it again.\n\t */\n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting osnoise tracer\\n\");\n\n\tosnoise_register_instance(tr);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"osnoise: \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_register_instance",
          "args": [
            "tr"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_register_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "92-111",
          "snippet": "static int osnoise_register_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tinst = kmalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD_RCU(&inst->list);\n\tinst->tr = tr;\n\tlist_add_tail_rcu(&inst->list, &osnoise_instances);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic int osnoise_register_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tinst = kmalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD_RCU(&inst->list);\n\tinst->tr = tr;\n\tlist_add_tail_rcu(&inst->list, &osnoise_instances);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "BANNER \"Error starting osnoise tracer\\n\""
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osnoise_workload_start",
          "args": [],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_workload_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2134-2175",
          "snippet": "static int osnoise_workload_start(void)\n{\n\tint retval;\n\n\t/*\n\t * Instances need to be registered after calling workload\n\t * start. Hence, if there is already an instance, the\n\t * workload was already registered. Otherwise, this\n\t * code is on the way to register the first instance,\n\t * and the workload will start.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn 0;\n\n\tosn_var_reset_all();\n\n\tretval = osnoise_hook_events();\n\tif (retval)\n\t\treturn retval;\n\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see reset values\n\t * before enabling trace_osnoise_callback_enabled.\n\t */\n\tbarrier();\n\ttrace_osnoise_callback_enabled = true;\n\n\tretval = start_per_cpu_kthreads();\n\tif (retval) {\n\t\ttrace_osnoise_callback_enabled = false;\n\t\t/*\n\t\t * Make sure that ftrace_nmi_enter/exit() see\n\t\t * trace_osnoise_callback_enabled as false before continuing.\n\t\t */\n\t\tbarrier();\n\n\t\tosnoise_unhook_events();\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool trace_osnoise_callback_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nbool trace_osnoise_callback_enabled;\n\nstatic int osnoise_workload_start(void)\n{\n\tint retval;\n\n\t/*\n\t * Instances need to be registered after calling workload\n\t * start. Hence, if there is already an instance, the\n\t * workload was already registered. Otherwise, this\n\t * code is on the way to register the first instance,\n\t * and the workload will start.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn 0;\n\n\tosn_var_reset_all();\n\n\tretval = osnoise_hook_events();\n\tif (retval)\n\t\treturn retval;\n\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see reset values\n\t * before enabling trace_osnoise_callback_enabled.\n\t */\n\tbarrier();\n\ttrace_osnoise_callback_enabled = true;\n\n\tretval = start_per_cpu_kthreads();\n\tif (retval) {\n\t\ttrace_osnoise_callback_enabled = false;\n\t\t/*\n\t\t * Make sure that ftrace_nmi_enter/exit() see\n\t\t * trace_osnoise_callback_enabled as false before continuing.\n\t\t */\n\t\tbarrier();\n\n\t\tosnoise_unhook_events();\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_instance_registered",
          "args": [
            "tr"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_instance_registered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "71-84",
          "snippet": "static int osnoise_instance_registered(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr)\n\t\t\tfound = 1;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic int osnoise_instance_registered(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr)\n\t\t\tfound = 1;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic void osnoise_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t/*\n\t * If the instance is already registered, there is no need to\n\t * register it again.\n\t */\n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting osnoise tracer\\n\");\n\n\tosnoise_register_instance(tr);\n}"
  },
  {
    "function_name": "osnoise_workload_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2180-2202",
    "snippet": "static void osnoise_workload_stop(void)\n{\n\t/*\n\t * Instances need to be unregistered before calling\n\t * stop. Hence, if there is a registered instance, more\n\t * than one instance is running, and the workload will not\n\t * yet stop. Otherwise, this code is on the way to disable\n\t * the last instance, and the workload can stop.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn;\n\n\ttrace_osnoise_callback_enabled = false;\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see\n\t * trace_osnoise_callback_enabled as false before continuing.\n\t */\n\tbarrier();\n\n\tstop_per_cpu_kthreads();\n\n\tosnoise_unhook_events();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool trace_osnoise_callback_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_unhook_events",
          "args": [],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_unhook_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2124-2129",
          "snippet": "static void osnoise_unhook_events(void)\n{\n\tunhook_thread_events();\n\tunhook_softirq_events();\n\tunhook_irq_events();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void osnoise_unhook_events(void)\n{\n\tunhook_thread_events();\n\tunhook_softirq_events();\n\tunhook_irq_events();\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_per_cpu_kthreads",
          "args": [],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "stop_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1675-1685",
          "snippet": "static void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_has_registered_instances",
          "args": [],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_has_registered_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "61-66",
          "snippet": "static bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nbool trace_osnoise_callback_enabled;\n\nstatic void osnoise_workload_stop(void)\n{\n\t/*\n\t * Instances need to be unregistered before calling\n\t * stop. Hence, if there is a registered instance, more\n\t * than one instance is running, and the workload will not\n\t * yet stop. Otherwise, this code is on the way to disable\n\t * the last instance, and the workload can stop.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn;\n\n\ttrace_osnoise_callback_enabled = false;\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see\n\t * trace_osnoise_callback_enabled as false before continuing.\n\t */\n\tbarrier();\n\n\tstop_per_cpu_kthreads();\n\n\tosnoise_unhook_events();\n}"
  },
  {
    "function_name": "osnoise_workload_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2134-2175",
    "snippet": "static int osnoise_workload_start(void)\n{\n\tint retval;\n\n\t/*\n\t * Instances need to be registered after calling workload\n\t * start. Hence, if there is already an instance, the\n\t * workload was already registered. Otherwise, this\n\t * code is on the way to register the first instance,\n\t * and the workload will start.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn 0;\n\n\tosn_var_reset_all();\n\n\tretval = osnoise_hook_events();\n\tif (retval)\n\t\treturn retval;\n\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see reset values\n\t * before enabling trace_osnoise_callback_enabled.\n\t */\n\tbarrier();\n\ttrace_osnoise_callback_enabled = true;\n\n\tretval = start_per_cpu_kthreads();\n\tif (retval) {\n\t\ttrace_osnoise_callback_enabled = false;\n\t\t/*\n\t\t * Make sure that ftrace_nmi_enter/exit() see\n\t\t * trace_osnoise_callback_enabled as false before continuing.\n\t\t */\n\t\tbarrier();\n\n\t\tosnoise_unhook_events();\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool trace_osnoise_callback_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_unhook_events",
          "args": [],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_unhook_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2124-2129",
          "snippet": "static void osnoise_unhook_events(void)\n{\n\tunhook_thread_events();\n\tunhook_softirq_events();\n\tunhook_irq_events();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void osnoise_unhook_events(void)\n{\n\tunhook_thread_events();\n\tunhook_softirq_events();\n\tunhook_irq_events();\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_per_cpu_kthreads",
          "args": [],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "start_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1722-1748",
          "snippet": "static int start_per_cpu_kthreads(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tint retval = 0;\n\tint cpu;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on online CPUs in which osnoise is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, &osnoise_cpumask);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_kthread(cpu);\n\t\tif (retval) {\n\t\t\tstop_per_cpu_kthreads();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcpus_read_unlock();\n\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpumask osnoise_cpumask;",
            "static struct cpumask save_cpumask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct cpumask osnoise_cpumask;\nstatic struct cpumask save_cpumask;\n\nstatic int start_per_cpu_kthreads(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tint retval = 0;\n\tint cpu;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on online CPUs in which osnoise is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, &osnoise_cpumask);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_kthread(cpu);\n\t\tif (retval) {\n\t\t\tstop_per_cpu_kthreads();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcpus_read_unlock();\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_hook_events",
          "args": [],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_hook_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2092-2122",
          "snippet": "static int osnoise_hook_events(void)\n{\n\tint retval;\n\n\t/*\n\t * Trace is already hooked, we are re-enabling from\n\t * a stop_tracing_*.\n\t */\n\tif (trace_osnoise_callback_enabled)\n\t\treturn 0;\n\n\tretval = hook_irq_events();\n\tif (retval)\n\t\treturn -EINVAL;\n\n\tretval = hook_softirq_events();\n\tif (retval)\n\t\tgoto out_unhook_irq;\n\n\tretval = hook_thread_events();\n\t/*\n\t * All fine!\n\t */\n\tif (!retval)\n\t\treturn 0;\n\n\tunhook_softirq_events();\nout_unhook_irq:\n\tunhook_irq_events();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool trace_osnoise_callback_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nbool trace_osnoise_callback_enabled;\n\nstatic int osnoise_hook_events(void)\n{\n\tint retval;\n\n\t/*\n\t * Trace is already hooked, we are re-enabling from\n\t * a stop_tracing_*.\n\t */\n\tif (trace_osnoise_callback_enabled)\n\t\treturn 0;\n\n\tretval = hook_irq_events();\n\tif (retval)\n\t\treturn -EINVAL;\n\n\tretval = hook_softirq_events();\n\tif (retval)\n\t\tgoto out_unhook_irq;\n\n\tretval = hook_thread_events();\n\t/*\n\t * All fine!\n\t */\n\tif (!retval)\n\t\treturn 0;\n\n\tunhook_softirq_events();\nout_unhook_irq:\n\tunhook_irq_events();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "osn_var_reset_all",
          "args": [],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "osn_var_reset_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "273-277",
          "snippet": "static inline void osn_var_reset_all(void)\n{\n\tosn_var_reset();\n\ttlat_var_reset();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void osn_var_reset_all(void)\n{\n\tosn_var_reset();\n\ttlat_var_reset();\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_has_registered_instances",
          "args": [],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_has_registered_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "61-66",
          "snippet": "static bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nbool trace_osnoise_callback_enabled;\n\nstatic int osnoise_workload_start(void)\n{\n\tint retval;\n\n\t/*\n\t * Instances need to be registered after calling workload\n\t * start. Hence, if there is already an instance, the\n\t * workload was already registered. Otherwise, this\n\t * code is on the way to register the first instance,\n\t * and the workload will start.\n\t */\n\tif (osnoise_has_registered_instances())\n\t\treturn 0;\n\n\tosn_var_reset_all();\n\n\tretval = osnoise_hook_events();\n\tif (retval)\n\t\treturn retval;\n\n\t/*\n\t * Make sure that ftrace_nmi_enter/exit() see reset values\n\t * before enabling trace_osnoise_callback_enabled.\n\t */\n\tbarrier();\n\ttrace_osnoise_callback_enabled = true;\n\n\tretval = start_per_cpu_kthreads();\n\tif (retval) {\n\t\ttrace_osnoise_callback_enabled = false;\n\t\t/*\n\t\t * Make sure that ftrace_nmi_enter/exit() see\n\t\t * trace_osnoise_callback_enabled as false before continuing.\n\t\t */\n\t\tbarrier();\n\n\t\tosnoise_unhook_events();\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "osnoise_unhook_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2124-2129",
    "snippet": "static void osnoise_unhook_events(void)\n{\n\tunhook_thread_events();\n\tunhook_softirq_events();\n\tunhook_irq_events();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhook_irq_events",
          "args": [],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "unhook_irq_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1008-1013",
          "snippet": "static void unhook_irq_events(void)\n{\n\tosnoise_arch_unregister();\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_irq_events(void)\n{\n\tosnoise_arch_unregister();\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhook_softirq_events",
          "args": [],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "unhook_softirq_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1111-1113",
          "snippet": "static void unhook_softirq_events(void)\n{\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_softirq_events(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhook_thread_events",
          "args": [],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "unhook_thread_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1205-1208",
          "snippet": "static void unhook_thread_events(void)\n{\n\tunregister_trace_sched_switch(trace_sched_switch_callback, NULL);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_thread_events(void)\n{\n\tunregister_trace_sched_switch(trace_sched_switch_callback, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void osnoise_unhook_events(void)\n{\n\tunhook_thread_events();\n\tunhook_softirq_events();\n\tunhook_irq_events();\n}"
  },
  {
    "function_name": "osnoise_hook_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2092-2122",
    "snippet": "static int osnoise_hook_events(void)\n{\n\tint retval;\n\n\t/*\n\t * Trace is already hooked, we are re-enabling from\n\t * a stop_tracing_*.\n\t */\n\tif (trace_osnoise_callback_enabled)\n\t\treturn 0;\n\n\tretval = hook_irq_events();\n\tif (retval)\n\t\treturn -EINVAL;\n\n\tretval = hook_softirq_events();\n\tif (retval)\n\t\tgoto out_unhook_irq;\n\n\tretval = hook_thread_events();\n\t/*\n\t * All fine!\n\t */\n\tif (!retval)\n\t\treturn 0;\n\n\tunhook_softirq_events();\nout_unhook_irq:\n\tunhook_irq_events();\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool trace_osnoise_callback_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhook_irq_events",
          "args": [],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "unhook_irq_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1008-1013",
          "snippet": "static void unhook_irq_events(void)\n{\n\tosnoise_arch_unregister();\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_irq_events(void)\n{\n\tosnoise_arch_unregister();\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhook_softirq_events",
          "args": [],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "unhook_softirq_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1111-1113",
          "snippet": "static void unhook_softirq_events(void)\n{\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_softirq_events(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "hook_thread_events",
          "args": [],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "unhook_thread_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1205-1208",
          "snippet": "static void unhook_thread_events(void)\n{\n\tunregister_trace_sched_switch(trace_sched_switch_callback, NULL);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_thread_events(void)\n{\n\tunregister_trace_sched_switch(trace_sched_switch_callback, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nbool trace_osnoise_callback_enabled;\n\nstatic int osnoise_hook_events(void)\n{\n\tint retval;\n\n\t/*\n\t * Trace is already hooked, we are re-enabling from\n\t * a stop_tracing_*.\n\t */\n\tif (trace_osnoise_callback_enabled)\n\t\treturn 0;\n\n\tretval = hook_irq_events();\n\tif (retval)\n\t\treturn -EINVAL;\n\n\tretval = hook_softirq_events();\n\tif (retval)\n\t\tgoto out_unhook_irq;\n\n\tretval = hook_thread_events();\n\t/*\n\t * All fine!\n\t */\n\tif (!retval)\n\t\treturn 0;\n\n\tunhook_softirq_events();\nout_unhook_irq:\n\tunhook_irq_events();\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "init_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2043-2090",
    "snippet": "static int init_tracefs(void)\n{\n\tstruct dentry *top_dir;\n\tstruct dentry *tmp;\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"osnoise\", NULL);\n\tif (!top_dir)\n\t\treturn 0;\n\n\ttmp = tracefs_create_file(\"period_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_period, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"runtime_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_runtime, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_in, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_total_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_total, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = trace_create_file(\"cpus\", TRACE_MODE_WRITE, top_dir, NULL, &cpus_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\tret = init_timerlat_tracefs(top_dir);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_min_max_param osnoise_runtime = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_runtime,\n\t.max\t= &osnoise_data.sample_period,\n\t.min\t= NULL,\n};",
      "static struct trace_min_max_param osnoise_period = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_period,\n\t.max\t= NULL,\n\t.min\t= &osnoise_data.sample_runtime,\n};",
      "static struct trace_min_max_param osnoise_stop_tracing_in = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};",
      "static struct trace_min_max_param osnoise_stop_tracing_total = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing_total,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};",
      "static const struct file_operations cpus_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= osnoise_cpus_read,\n\t.write\t\t= osnoise_cpus_write,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracefs_remove",
          "args": [
            "top_dir"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_timerlat_tracefs",
          "args": [
            "top_dir"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "init_timerlat_tracefs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2030-2033",
          "snippet": "static int init_timerlat_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int init_timerlat_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"cpus\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "NULL",
            "&cpus_fops"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"stop_tracing_total_us\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "&osnoise_stop_tracing_total",
            "&trace_min_max_fops"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"stop_tracing_us\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "&osnoise_stop_tracing_in",
            "&trace_min_max_fops"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"runtime_us\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "&osnoise_runtime",
            "&trace_min_max_fops"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"period_us\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "&osnoise_period",
            "&trace_min_max_fops"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "\"osnoise\"",
            "NULL"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct trace_min_max_param osnoise_runtime = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_runtime,\n\t.max\t= &osnoise_data.sample_period,\n\t.min\t= NULL,\n};\nstatic struct trace_min_max_param osnoise_period = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_period,\n\t.max\t= NULL,\n\t.min\t= &osnoise_data.sample_runtime,\n};\nstatic struct trace_min_max_param osnoise_stop_tracing_in = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};\nstatic struct trace_min_max_param osnoise_stop_tracing_total = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing_total,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};\nstatic const struct file_operations cpus_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= osnoise_cpus_read,\n\t.write\t\t= osnoise_cpus_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int init_tracefs(void)\n{\n\tstruct dentry *top_dir;\n\tstruct dentry *tmp;\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"osnoise\", NULL);\n\tif (!top_dir)\n\t\treturn 0;\n\n\ttmp = tracefs_create_file(\"period_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_period, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"runtime_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_runtime, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_in, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_total_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_total, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = trace_create_file(\"cpus\", TRACE_MODE_WRITE, top_dir, NULL, &cpus_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\tret = init_timerlat_tracefs(top_dir);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "init_timerlat_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2030-2033",
    "snippet": "static int init_timerlat_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int init_timerlat_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "init_timerlat_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2018-2028",
    "snippet": "static int init_timerlat_tracefs(struct dentry *top_dir)\n{\n\tstruct dentry *tmp;\n\n\ttmp = tracefs_create_file(\"timerlat_period_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &timerlat_period, &trace_min_max_fops);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\treturn init_timerlat_stack_tracefs(top_dir);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_timerlat_stack_tracefs",
          "args": [
            "top_dir"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "init_timerlat_stack_tracefs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "2009-2012",
          "snippet": "static int init_timerlat_stack_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int init_timerlat_stack_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"timerlat_period_us\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "&timerlat_period",
            "&trace_min_max_fops"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int init_timerlat_tracefs(struct dentry *top_dir)\n{\n\tstruct dentry *tmp;\n\n\ttmp = tracefs_create_file(\"timerlat_period_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &timerlat_period, &trace_min_max_fops);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\treturn init_timerlat_stack_tracefs(top_dir);\n}"
  },
  {
    "function_name": "init_timerlat_stack_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "2009-2012",
    "snippet": "static int init_timerlat_stack_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int init_timerlat_stack_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "init_timerlat_stack_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1997-2007",
    "snippet": "static int init_timerlat_stack_tracefs(struct dentry *top_dir)\n{\n\tstruct dentry *tmp;\n\n\ttmp = tracefs_create_file(\"print_stack\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_print_stack, &trace_min_max_fops);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"print_stack\"",
            "TRACE_MODE_WRITE",
            "top_dir",
            "&osnoise_print_stack",
            "&trace_min_max_fops"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int init_timerlat_stack_tracefs(struct dentry *top_dir)\n{\n\tstruct dentry *tmp;\n\n\ttmp = tracefs_create_file(\"print_stack\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_print_stack, &trace_min_max_fops);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "osnoise_cpus_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1870-1921",
    "snippet": "static ssize_t\nosnoise_cpus_write(struct file *filp, const char __user *ubuf, size_t count,\n\t\t   loff_t *ppos)\n{\n\tcpumask_var_t osnoise_cpumask_new;\n\tint running, err;\n\tchar buf[256];\n\n\tif (count >= 256)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, count))\n\t\treturn -EFAULT;\n\n\tif (!zalloc_cpumask_var(&osnoise_cpumask_new, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpulist_parse(buf, osnoise_cpumask_new);\n\tif (err)\n\t\tgoto err_free;\n\n\t/*\n\t * trace_types_lock is taken to avoid concurrency on start/stop.\n\t */\n\tmutex_lock(&trace_types_lock);\n\trunning = osnoise_has_registered_instances();\n\tif (running)\n\t\tstop_per_cpu_kthreads();\n\n\tmutex_lock(&interface_lock);\n\t/*\n\t * osnoise_cpumask is read by CPU hotplug operations.\n\t */\n\tcpus_read_lock();\n\n\tcpumask_copy(&osnoise_cpumask, osnoise_cpumask_new);\n\n\tcpus_read_unlock();\n\tmutex_unlock(&interface_lock);\n\n\tif (running)\n\t\tstart_per_cpu_kthreads();\n\tmutex_unlock(&trace_types_lock);\n\n\tfree_cpumask_var(osnoise_cpumask_new);\n\treturn count;\n\nerr_free:\n\tfree_cpumask_var(osnoise_cpumask_new);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mutex interface_lock;",
      "static struct cpumask osnoise_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "osnoise_cpumask_new"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "osnoise_cpumask_new"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_per_cpu_kthreads",
          "args": [],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "start_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1722-1748",
          "snippet": "static int start_per_cpu_kthreads(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tint retval = 0;\n\tint cpu;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on online CPUs in which osnoise is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, &osnoise_cpumask);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_kthread(cpu);\n\t\tif (retval) {\n\t\t\tstop_per_cpu_kthreads();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcpus_read_unlock();\n\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpumask osnoise_cpumask;",
            "static struct cpumask save_cpumask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct cpumask osnoise_cpumask;\nstatic struct cpumask save_cpumask;\n\nstatic int start_per_cpu_kthreads(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tint retval = 0;\n\tint cpu;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on online CPUs in which osnoise is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, &osnoise_cpumask);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_kthread(cpu);\n\t\tif (retval) {\n\t\t\tstop_per_cpu_kthreads();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcpus_read_unlock();\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&osnoise_cpumask",
            "osnoise_cpumask_new"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&interface_lock"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_per_cpu_kthreads",
          "args": [],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "stop_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1675-1685",
          "snippet": "static void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_has_registered_instances",
          "args": [],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_has_registered_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "61-66",
          "snippet": "static bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpulist_parse",
          "args": [
            "buf",
            "osnoise_cpumask_new"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&osnoise_cpumask_new",
            "GFP_KERNEL"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "ubuf",
            "count"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstruct mutex interface_lock;\nstatic struct cpumask osnoise_cpumask;\n\nstatic ssize_t\nosnoise_cpus_write(struct file *filp, const char __user *ubuf, size_t count,\n\t\t   loff_t *ppos)\n{\n\tcpumask_var_t osnoise_cpumask_new;\n\tint running, err;\n\tchar buf[256];\n\n\tif (count >= 256)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, count))\n\t\treturn -EFAULT;\n\n\tif (!zalloc_cpumask_var(&osnoise_cpumask_new, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpulist_parse(buf, osnoise_cpumask_new);\n\tif (err)\n\t\tgoto err_free;\n\n\t/*\n\t * trace_types_lock is taken to avoid concurrency on start/stop.\n\t */\n\tmutex_lock(&trace_types_lock);\n\trunning = osnoise_has_registered_instances();\n\tif (running)\n\t\tstop_per_cpu_kthreads();\n\n\tmutex_lock(&interface_lock);\n\t/*\n\t * osnoise_cpumask is read by CPU hotplug operations.\n\t */\n\tcpus_read_lock();\n\n\tcpumask_copy(&osnoise_cpumask, osnoise_cpumask_new);\n\n\tcpus_read_unlock();\n\tmutex_unlock(&interface_lock);\n\n\tif (running)\n\t\tstart_per_cpu_kthreads();\n\tmutex_unlock(&trace_types_lock);\n\n\tfree_cpumask_var(osnoise_cpumask_new);\n\treturn count;\n\nerr_free:\n\tfree_cpumask_var(osnoise_cpumask_new);\n\n\treturn err;\n}"
  },
  {
    "function_name": "osnoise_cpus_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1822-1852",
    "snippet": "static ssize_t\nosnoise_cpus_read(struct file *filp, char __user *ubuf, size_t count,\n\t\t  loff_t *ppos)\n{\n\tchar *mask_str;\n\tint len;\n\n\tmutex_lock(&interface_lock);\n\n\tlen = snprintf(NULL, 0, \"%*pbl\\n\", cpumask_pr_args(&osnoise_cpumask)) + 1;\n\tmask_str = kmalloc(len, GFP_KERNEL);\n\tif (!mask_str) {\n\t\tcount = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = snprintf(mask_str, len, \"%*pbl\\n\", cpumask_pr_args(&osnoise_cpumask));\n\tif (len >= count) {\n\t\tcount = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tcount = simple_read_from_buffer(ubuf, count, ppos, mask_str, len);\n\nout_free:\n\tkfree(mask_str);\nout_unlock:\n\tmutex_unlock(&interface_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mutex interface_lock;",
      "static struct cpumask osnoise_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&interface_lock"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mask_str"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "count",
            "ppos",
            "mask_str",
            "len"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mask_str",
            "len",
            "\"%*pbl\\n\"",
            "cpumask_pr_args(&osnoise_cpumask)"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "&osnoise_cpumask"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\"%*pbl\\n\"",
            "cpumask_pr_args(&osnoise_cpumask)"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "&osnoise_cpumask"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&interface_lock"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstruct mutex interface_lock;\nstatic struct cpumask osnoise_cpumask;\n\nstatic ssize_t\nosnoise_cpus_read(struct file *filp, char __user *ubuf, size_t count,\n\t\t  loff_t *ppos)\n{\n\tchar *mask_str;\n\tint len;\n\n\tmutex_lock(&interface_lock);\n\n\tlen = snprintf(NULL, 0, \"%*pbl\\n\", cpumask_pr_args(&osnoise_cpumask)) + 1;\n\tmask_str = kmalloc(len, GFP_KERNEL);\n\tif (!mask_str) {\n\t\tcount = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = snprintf(mask_str, len, \"%*pbl\\n\", cpumask_pr_args(&osnoise_cpumask));\n\tif (len >= count) {\n\t\tcount = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tcount = simple_read_from_buffer(ubuf, count, ppos, mask_str, len);\n\nout_free:\n\tkfree(mask_str);\nout_unlock:\n\tmutex_unlock(&interface_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "osnoise_init_hotplug_support",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1807-1810",
    "snippet": "static void osnoise_init_hotplug_support(void)\n{\n\treturn;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void osnoise_init_hotplug_support(void)\n{\n\treturn;\n}"
  },
  {
    "function_name": "osnoise_init_hotplug_support",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1795-1805",
    "snippet": "static void osnoise_init_hotplug_support(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"trace/osnoise:online\",\n\t\t\t\tosnoise_cpu_init, osnoise_cpu_die);\n\tif (ret < 0)\n\t\tpr_warn(BANNER \"Error to init cpu hotplug support\\n\");\n\n\treturn;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"osnoise: \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "BANNER \"Error to init cpu hotplug support\\n\""
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"trace/osnoise:online\"",
            "osnoise_cpu_init",
            "osnoise_cpu_die"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic void osnoise_init_hotplug_support(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"trace/osnoise:online\",\n\t\t\t\tosnoise_cpu_init, osnoise_cpu_die);\n\tif (ret < 0)\n\t\tpr_warn(BANNER \"Error to init cpu hotplug support\\n\");\n\n\treturn;\n}"
  },
  {
    "function_name": "osnoise_cpu_die",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1789-1793",
    "snippet": "static int osnoise_cpu_die(unsigned int cpu)\n{\n\tstop_kthread(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_kthread",
          "args": [
            "cpu"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1659-1667",
          "snippet": "static void stop_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(per_cpu_osnoise_var, cpu).kthread;\n\tif (kthread)\n\t\tkthread_stop(kthread);\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(per_cpu_osnoise_var, cpu).kthread;\n\tif (kthread)\n\t\tkthread_stop(kthread);\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int osnoise_cpu_die(unsigned int cpu)\n{\n\tstop_kthread(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "osnoise_cpu_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1780-1784",
    "snippet": "static int osnoise_cpu_init(unsigned int cpu)\n{\n\tschedule_work_on(cpu, &osnoise_hotplug_work);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work_on",
          "args": [
            "cpu",
            "&osnoise_hotplug_work"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int osnoise_cpu_init(unsigned int cpu)\n{\n\tschedule_work_on(cpu, &osnoise_hotplug_work);\n\treturn 0;\n}"
  },
  {
    "function_name": "osnoise_hotplug_workfn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1751-1773",
    "snippet": "static void osnoise_hotplug_workfn(struct work_struct *dummy)\n{\n\tunsigned int cpu = smp_processor_id();\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (!osnoise_has_registered_instances())\n\t\tgoto out_unlock_trace;\n\n\tmutex_lock(&interface_lock);\n\tcpus_read_lock();\n\n\tif (!cpumask_test_cpu(cpu, &osnoise_cpumask))\n\t\tgoto out_unlock;\n\n\tstart_kthread(cpu);\n\nout_unlock:\n\tcpus_read_unlock();\n\tmutex_unlock(&interface_lock);\nout_unlock_trace:\n\tmutex_unlock(&trace_types_lock);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mutex interface_lock;",
      "static struct cpumask osnoise_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_kthread",
          "args": [
            "cpu"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "start_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1690-1714",
          "snippet": "static int start_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\tvoid *main = osnoise_main;\n\tchar comm[24];\n\n\tif (timerlat_enabled()) {\n\t\tsnprintf(comm, 24, \"timerlat/%d\", cpu);\n\t\tmain = timerlat_main;\n\t} else {\n\t\tsnprintf(comm, 24, \"osnoise/%d\", cpu);\n\t}\n\n\tkthread = kthread_run_on_cpu(main, NULL, cpu, comm);\n\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tstop_per_cpu_kthreads();\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = kthread;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"osnoise: \""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic int start_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\tvoid *main = osnoise_main;\n\tchar comm[24];\n\n\tif (timerlat_enabled()) {\n\t\tsnprintf(comm, 24, \"timerlat/%d\", cpu);\n\t\tmain = timerlat_main;\n\t} else {\n\t\tsnprintf(comm, 24, \"osnoise/%d\", cpu);\n\t}\n\n\tkthread = kthread_run_on_cpu(main, NULL, cpu, comm);\n\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tstop_per_cpu_kthreads();\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = kthread;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&osnoise_cpumask"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&interface_lock"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_has_registered_instances",
          "args": [],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_has_registered_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "61-66",
          "snippet": "static bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstruct mutex interface_lock;\nstatic struct cpumask osnoise_cpumask;\n\nstatic void osnoise_hotplug_workfn(struct work_struct *dummy)\n{\n\tunsigned int cpu = smp_processor_id();\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (!osnoise_has_registered_instances())\n\t\tgoto out_unlock_trace;\n\n\tmutex_lock(&interface_lock);\n\tcpus_read_lock();\n\n\tif (!cpumask_test_cpu(cpu, &osnoise_cpumask))\n\t\tgoto out_unlock;\n\n\tstart_kthread(cpu);\n\nout_unlock:\n\tcpus_read_unlock();\n\tmutex_unlock(&interface_lock);\nout_unlock_trace:\n\tmutex_unlock(&trace_types_lock);\n}"
  },
  {
    "function_name": "start_per_cpu_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1722-1748",
    "snippet": "static int start_per_cpu_kthreads(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tint retval = 0;\n\tint cpu;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on online CPUs in which osnoise is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, &osnoise_cpumask);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_kthread(cpu);\n\t\tif (retval) {\n\t\t\tstop_per_cpu_kthreads();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcpus_read_unlock();\n\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpumask osnoise_cpumask;",
      "static struct cpumask save_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_per_cpu_kthreads",
          "args": [],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "stop_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1675-1685",
          "snippet": "static void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_kthread",
          "args": [
            "cpu"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "start_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1690-1714",
          "snippet": "static int start_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\tvoid *main = osnoise_main;\n\tchar comm[24];\n\n\tif (timerlat_enabled()) {\n\t\tsnprintf(comm, 24, \"timerlat/%d\", cpu);\n\t\tmain = timerlat_main;\n\t} else {\n\t\tsnprintf(comm, 24, \"osnoise/%d\", cpu);\n\t}\n\n\tkthread = kthread_run_on_cpu(main, NULL, cpu, comm);\n\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tstop_per_cpu_kthreads();\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = kthread;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define BANNER\t\t\t\"osnoise: \""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic int start_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\tvoid *main = osnoise_main;\n\tchar comm[24];\n\n\tif (timerlat_enabled()) {\n\t\tsnprintf(comm, 24, \"timerlat/%d\", cpu);\n\t\tmain = timerlat_main;\n\t} else {\n\t\tsnprintf(comm, 24, \"osnoise/%d\", cpu);\n\t}\n\n\tkthread = kthread_run_on_cpu(main, NULL, cpu, comm);\n\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tstop_per_cpu_kthreads();\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = kthread;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "current_mask",
            "cpu_online_mask",
            "&osnoise_cpumask"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct cpumask osnoise_cpumask;\nstatic struct cpumask save_cpumask;\n\nstatic int start_per_cpu_kthreads(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tint retval = 0;\n\tint cpu;\n\n\tcpus_read_lock();\n\t/*\n\t * Run only on online CPUs in which osnoise is allowed to run.\n\t */\n\tcpumask_and(current_mask, cpu_online_mask, &osnoise_cpumask);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_kthread(cpu);\n\t\tif (retval) {\n\t\t\tstop_per_cpu_kthreads();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcpus_read_unlock();\n\n\treturn retval;\n}"
  },
  {
    "function_name": "start_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1690-1714",
    "snippet": "static int start_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\tvoid *main = osnoise_main;\n\tchar comm[24];\n\n\tif (timerlat_enabled()) {\n\t\tsnprintf(comm, 24, \"timerlat/%d\", cpu);\n\t\tmain = timerlat_main;\n\t} else {\n\t\tsnprintf(comm, 24, \"osnoise/%d\", cpu);\n\t}\n\n\tkthread = kthread_run_on_cpu(main, NULL, cpu, comm);\n\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tstop_per_cpu_kthreads();\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = kthread;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define BANNER\t\t\t\"osnoise: \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "per_cpu_osnoise_var",
            "cpu"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_per_cpu_kthreads",
          "args": [],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "stop_per_cpu_kthreads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1675-1685",
          "snippet": "static void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "BANNER \"could not start sampling thread\\n\""
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kthread"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run_on_cpu",
          "args": [
            "main",
            "NULL",
            "cpu",
            "comm"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "comm",
            "24",
            "\"osnoise/%d\"",
            "cpu"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "comm",
            "24",
            "\"timerlat/%d\"",
            "cpu"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerlat_enabled",
          "args": [],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "378-381",
          "snippet": "static inline bool timerlat_enabled(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline bool timerlat_enabled(void)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define BANNER\t\t\t\"osnoise: \"\n\nstatic int start_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\tvoid *main = osnoise_main;\n\tchar comm[24];\n\n\tif (timerlat_enabled()) {\n\t\tsnprintf(comm, 24, \"timerlat/%d\", cpu);\n\t\tmain = timerlat_main;\n\t} else {\n\t\tsnprintf(comm, 24, \"osnoise/%d\", cpu);\n\t}\n\n\tkthread = kthread_run_on_cpu(main, NULL, cpu, comm);\n\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tstop_per_cpu_kthreads();\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = kthread;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stop_per_cpu_kthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1675-1685",
    "snippet": "static void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "stop_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1659-1667",
    "snippet": "static void stop_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(per_cpu_osnoise_var, cpu).kthread;\n\tif (kthread)\n\t\tkthread_stop(kthread);\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "per_cpu_osnoise_var",
            "cpu"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "kthread"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void stop_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(per_cpu_osnoise_var, cpu).kthread;\n\tif (kthread)\n\t\tkthread_stop(kthread);\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n}"
  },
  {
    "function_name": "timerlat_main",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1650-1653",
    "snippet": "static int timerlat_main(void *data)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int timerlat_main(void *data)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "timerlat_main",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1596-1648",
    "snippet": "static int timerlat_main(void *data)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tstruct timerlat_variables *tlat = this_cpu_tmr_var();\n\tstruct timerlat_sample s;\n\tstruct sched_param sp;\n\tu64 now, diff;\n\n\t/*\n\t * Make the thread RT, that is how cyclictest is usually used.\n\t */\n\tsp.sched_priority = DEFAULT_TIMERLAT_PRIO;\n\tsched_setscheduler_nocheck(current, SCHED_FIFO, &sp);\n\n\ttlat->count = 0;\n\ttlat->tracing_thread = false;\n\n\thrtimer_init(&tlat->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED_HARD);\n\ttlat->timer.function = timerlat_irq;\n\ttlat->kthread = current;\n\tosn_var->pid = current->pid;\n\t/*\n\t * Anotate the arrival time.\n\t */\n\ttlat->abs_period = hrtimer_cb_get_time(&tlat->timer);\n\n\twait_next_period(tlat);\n\n\tosn_var->sampling = 1;\n\n\twhile (!kthread_should_stop()) {\n\t\tnow = ktime_to_ns(hrtimer_cb_get_time(&tlat->timer));\n\t\tdiff = now - tlat->abs_period;\n\n\t\ts.seqnum = tlat->count;\n\t\ts.timer_latency = diff;\n\t\ts.context = THREAD_CONTEXT;\n\n\t\ttrace_timerlat_sample(&s);\n\n\t\ttimerlat_dump_stack(time_to_us(diff));\n\n\t\ttlat->tracing_thread = false;\n\t\tif (osnoise_data.stop_tracing_total)\n\t\t\tif (time_to_us(diff) >= osnoise_data.stop_tracing_total)\n\t\t\t\tosnoise_stop_tracing();\n\n\t\twait_next_period(tlat);\n\t}\n\n\thrtimer_cancel(&tlat->timer);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define THREAD_CONTEXT\t1",
      "#define DEFAULT_TIMERLAT_PRIO\t95\t\t\t/* FIFO 95 */"
    ],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&tlat->timer"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_next_period",
          "args": [
            "tlat"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "wait_next_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1565-1591",
          "snippet": "static int wait_next_period(struct timerlat_variables *tlat)\n{\n\tktime_t next_abs_period, now;\n\tu64 rel_period = osnoise_data.timerlat_period * 1000;\n\n\tnow = hrtimer_cb_get_time(&tlat->timer);\n\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\n\t/*\n\t * Save the next abs_period.\n\t */\n\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\n\t/*\n\t * If the new abs_period is in the past, skip the activation.\n\t */\n\twhile (ktime_compare(now, next_abs_period) > 0) {\n\t\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\t\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\t}\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\thrtimer_start(&tlat->timer, next_abs_period, HRTIMER_MODE_ABS_PINNED_HARD);\n\tschedule();\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic int wait_next_period(struct timerlat_variables *tlat)\n{\n\tktime_t next_abs_period, now;\n\tu64 rel_period = osnoise_data.timerlat_period * 1000;\n\n\tnow = hrtimer_cb_get_time(&tlat->timer);\n\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\n\t/*\n\t * Save the next abs_period.\n\t */\n\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\n\t/*\n\t * If the new abs_period is in the past, skip the activation.\n\t */\n\twhile (ktime_compare(now, next_abs_period) > 0) {\n\t\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\t\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\t}\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\thrtimer_start(&tlat->timer, next_abs_period, HRTIMER_MODE_ABS_PINNED_HARD);\n\tschedule();\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_stop_tracing",
          "args": [],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_stop_tracing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1245-1259",
          "snippet": "static __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "diff"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerlat_dump_stack",
          "args": [
            "time_to_us(diff)"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_dump_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "649-674",
          "snippet": "static void timerlat_dump_stack(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\tstruct trace_stack *fstack;\n\tunsigned int size;\n\n\t/*\n\t * trace only if latency > print_stack config, if enabled.\n\t */\n\tif (!osnoise_data.print_stack || osnoise_data.print_stack > latency)\n\t\treturn;\n\n\tpreempt_disable_notrace();\n\tfstack = this_cpu_ptr(&trace_stack);\n\tsize = fstack->stack_size;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__timerlat_dump_stack(buffer, fstack, size);\n\n\t}\n\trcu_read_unlock();\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;",
            "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic void timerlat_dump_stack(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\tstruct trace_stack *fstack;\n\tunsigned int size;\n\n\t/*\n\t * trace only if latency > print_stack config, if enabled.\n\t */\n\tif (!osnoise_data.print_stack || osnoise_data.print_stack > latency)\n\t\treturn;\n\n\tpreempt_disable_notrace();\n\tfstack = this_cpu_ptr(&trace_stack);\n\tsize = fstack->stack_size;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__timerlat_dump_stack(buffer, fstack, size);\n\n\t}\n\trcu_read_unlock();\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "diff"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_timerlat_sample",
          "args": [
            "&s"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "trace_timerlat_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "572-583",
          "snippet": "static void trace_timerlat_sample(struct timerlat_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_timerlat_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void trace_timerlat_sample(struct timerlat_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_timerlat_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_cb_get_time(&tlat->timer)"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cb_get_time",
          "args": [
            "&tlat->timer"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cb_get_time",
          "args": [
            "&tlat->timer"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&tlat->timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS_PINNED_HARD"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "current",
            "SCHED_FIFO",
            "&sp"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7565-7569",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_tmr_var",
          "args": [],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_tmr_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "227-230",
          "snippet": "static inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define THREAD_CONTEXT\t1\n#define DEFAULT_TIMERLAT_PRIO\t95\t\t\t/* FIFO 95 */\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic int timerlat_main(void *data)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tstruct timerlat_variables *tlat = this_cpu_tmr_var();\n\tstruct timerlat_sample s;\n\tstruct sched_param sp;\n\tu64 now, diff;\n\n\t/*\n\t * Make the thread RT, that is how cyclictest is usually used.\n\t */\n\tsp.sched_priority = DEFAULT_TIMERLAT_PRIO;\n\tsched_setscheduler_nocheck(current, SCHED_FIFO, &sp);\n\n\ttlat->count = 0;\n\ttlat->tracing_thread = false;\n\n\thrtimer_init(&tlat->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED_HARD);\n\ttlat->timer.function = timerlat_irq;\n\ttlat->kthread = current;\n\tosn_var->pid = current->pid;\n\t/*\n\t * Anotate the arrival time.\n\t */\n\ttlat->abs_period = hrtimer_cb_get_time(&tlat->timer);\n\n\twait_next_period(tlat);\n\n\tosn_var->sampling = 1;\n\n\twhile (!kthread_should_stop()) {\n\t\tnow = ktime_to_ns(hrtimer_cb_get_time(&tlat->timer));\n\t\tdiff = now - tlat->abs_period;\n\n\t\ts.seqnum = tlat->count;\n\t\ts.timer_latency = diff;\n\t\ts.context = THREAD_CONTEXT;\n\n\t\ttrace_timerlat_sample(&s);\n\n\t\ttimerlat_dump_stack(time_to_us(diff));\n\n\t\ttlat->tracing_thread = false;\n\t\tif (osnoise_data.stop_tracing_total)\n\t\t\tif (time_to_us(diff) >= osnoise_data.stop_tracing_total)\n\t\t\t\tosnoise_stop_tracing();\n\n\t\twait_next_period(tlat);\n\t}\n\n\thrtimer_cancel(&tlat->timer);\n\treturn 0;\n}"
  },
  {
    "function_name": "wait_next_period",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1565-1591",
    "snippet": "static int wait_next_period(struct timerlat_variables *tlat)\n{\n\tktime_t next_abs_period, now;\n\tu64 rel_period = osnoise_data.timerlat_period * 1000;\n\n\tnow = hrtimer_cb_get_time(&tlat->timer);\n\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\n\t/*\n\t * Save the next abs_period.\n\t */\n\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\n\t/*\n\t * If the new abs_period is in the past, skip the activation.\n\t */\n\twhile (ktime_compare(now, next_abs_period) > 0) {\n\t\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\t\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\t}\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\thrtimer_start(&tlat->timer, next_abs_period, HRTIMER_MODE_ABS_PINNED_HARD);\n\tschedule();\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&tlat->timer",
            "next_abs_period",
            "HRTIMER_MODE_ABS_PINNED_HARD"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "next_abs_period"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "tlat->abs_period + rel_period"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_compare",
          "args": [
            "now",
            "next_abs_period"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "next_abs_period"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "tlat->abs_period + rel_period"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cb_get_time",
          "args": [
            "&tlat->timer"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic int wait_next_period(struct timerlat_variables *tlat)\n{\n\tktime_t next_abs_period, now;\n\tu64 rel_period = osnoise_data.timerlat_period * 1000;\n\n\tnow = hrtimer_cb_get_time(&tlat->timer);\n\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\n\t/*\n\t * Save the next abs_period.\n\t */\n\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\n\t/*\n\t * If the new abs_period is in the past, skip the activation.\n\t */\n\twhile (ktime_compare(now, next_abs_period) > 0) {\n\t\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\t\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\t}\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\thrtimer_start(&tlat->timer, next_abs_period, HRTIMER_MODE_ABS_PINNED_HARD);\n\tschedule();\n\treturn 1;\n}"
  },
  {
    "function_name": "timerlat_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1480-1560",
    "snippet": "static enum hrtimer_restart timerlat_irq(struct hrtimer *timer)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tstruct timerlat_variables *tlat;\n\tstruct timerlat_sample s;\n\tu64 now;\n\tu64 diff;\n\n\t/*\n\t * I am not sure if the timer was armed for this CPU. So, get\n\t * the timerlat struct from the timer itself, not from this\n\t * CPU.\n\t */\n\ttlat = container_of(timer, struct timerlat_variables, timer);\n\n\tnow = ktime_to_ns(hrtimer_cb_get_time(&tlat->timer));\n\n\t/*\n\t * Enable the osnoise: events for thread an softirq.\n\t */\n\ttlat->tracing_thread = true;\n\n\tosn_var->thread.arrival_time = time_get();\n\n\t/*\n\t * A hardirq is running: the timer IRQ. It is for sure preempting\n\t * a thread, and potentially preempting a softirq.\n\t *\n\t * At this point, it is not interesting to know the duration of the\n\t * preempted thread (and maybe softirq), but how much time they will\n\t * delay the beginning of the execution of the timer thread.\n\t *\n\t * To get the correct (net) delay added by the softirq, its delta_start\n\t * is set as the IRQ one. In this way, at the return of the IRQ, the delta\n\t * start of the sofitrq will be zeroed, accounting then only the time\n\t * after that.\n\t *\n\t * The thread follows the same principle. However, if a softirq is\n\t * running, the thread needs to receive the softirq delta_start. The\n\t * reason being is that the softirq will be the last to be unfolded,\n\t * resseting the thread delay to zero.\n\t *\n\t * The PREEMPT_RT is a special case, though. As softirqs run as threads\n\t * on RT, moving the thread is enough.\n\t */\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT) && osn_var->softirq.delta_start) {\n\t\tcopy_int_safe_time(osn_var, &osn_var->thread.delta_start,\n\t\t\t\t   &osn_var->softirq.delta_start);\n\n\t\tcopy_int_safe_time(osn_var, &osn_var->softirq.delta_start,\n\t\t\t\t    &osn_var->irq.delta_start);\n\t} else {\n\t\tcopy_int_safe_time(osn_var, &osn_var->thread.delta_start,\n\t\t\t\t    &osn_var->irq.delta_start);\n\t}\n\n\t/*\n\t * Compute the current time with the expected time.\n\t */\n\tdiff = now - tlat->abs_period;\n\n\ttlat->count++;\n\ts.seqnum = tlat->count;\n\ts.timer_latency = diff;\n\ts.context = IRQ_CONTEXT;\n\n\ttrace_timerlat_sample(&s);\n\n\tnotify_new_max_latency(diff);\n\n\tif (osnoise_data.stop_tracing)\n\t\tif (time_to_us(diff) >= osnoise_data.stop_tracing)\n\t\t\tosnoise_stop_tracing();\n\n\twake_up_process(tlat->kthread);\n\n\tif (osnoise_data.print_stack)\n\t\ttimerlat_save_stack(0);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define IRQ_CONTEXT\t0"
    ],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerlat_save_stack",
          "args": [
            "0"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_save_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "607-623",
          "snippet": "static void timerlat_save_stack(int skip)\n{\n\tunsigned int size, nr_entries;\n\tstruct trace_stack *fstack;\n\n\tfstack = this_cpu_ptr(&trace_stack);\n\n\tsize = ARRAY_SIZE(fstack->calls);\n\n\tnr_entries = stack_trace_save(fstack->calls, size, skip);\n\n\tfstack->stack_size = nr_entries * sizeof(unsigned long);\n\tfstack->nr_entries = nr_entries;\n\n\treturn;\n\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void timerlat_save_stack(int skip)\n{\n\tunsigned int size, nr_entries;\n\tstruct trace_stack *fstack;\n\n\tfstack = this_cpu_ptr(&trace_stack);\n\n\tsize = ARRAY_SIZE(fstack->calls);\n\n\tnr_entries = stack_trace_save(fstack->calls, size, skip);\n\n\tfstack->stack_size = nr_entries * sizeof(unsigned long);\n\tfstack->nr_entries = nr_entries;\n\n\treturn;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tlat->kthread"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "osnoise_stop_tracing",
          "args": [],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_stop_tracing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1245-1259",
          "snippet": "static __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "diff"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_new_max_latency",
          "args": [
            "diff"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "notify_new_max_latency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1264-1278",
          "snippet": "static void notify_new_max_latency(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\tif (tr->max_latency < latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void notify_new_max_latency(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\tif (tr->max_latency < latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_timerlat_sample",
          "args": [
            "&s"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "trace_timerlat_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "572-583",
          "snippet": "static void trace_timerlat_sample(struct timerlat_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_timerlat_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void trace_timerlat_sample(struct timerlat_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_timerlat_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_int_safe_time",
          "args": [
            "osn_var",
            "&osn_var->thread.delta_start",
            "&osn_var->irq.delta_start"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "copy_int_safe_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "826-843",
          "snippet": "static u64\ncopy_int_safe_time(struct osnoise_variables *osn_var, u64 *dst, u64 *src)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*dst = *src;\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic u64\ncopy_int_safe_time(struct osnoise_variables *osn_var, u64 *dst, u64 *src)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*dst = *src;\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_cb_get_time(&tlat->timer)"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cb_get_time",
          "args": [
            "&tlat->timer"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structtimerlat_variables",
            "timer"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\n#define IRQ_CONTEXT\t0\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic enum hrtimer_restart timerlat_irq(struct hrtimer *timer)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tstruct timerlat_variables *tlat;\n\tstruct timerlat_sample s;\n\tu64 now;\n\tu64 diff;\n\n\t/*\n\t * I am not sure if the timer was armed for this CPU. So, get\n\t * the timerlat struct from the timer itself, not from this\n\t * CPU.\n\t */\n\ttlat = container_of(timer, struct timerlat_variables, timer);\n\n\tnow = ktime_to_ns(hrtimer_cb_get_time(&tlat->timer));\n\n\t/*\n\t * Enable the osnoise: events for thread an softirq.\n\t */\n\ttlat->tracing_thread = true;\n\n\tosn_var->thread.arrival_time = time_get();\n\n\t/*\n\t * A hardirq is running: the timer IRQ. It is for sure preempting\n\t * a thread, and potentially preempting a softirq.\n\t *\n\t * At this point, it is not interesting to know the duration of the\n\t * preempted thread (and maybe softirq), but how much time they will\n\t * delay the beginning of the execution of the timer thread.\n\t *\n\t * To get the correct (net) delay added by the softirq, its delta_start\n\t * is set as the IRQ one. In this way, at the return of the IRQ, the delta\n\t * start of the sofitrq will be zeroed, accounting then only the time\n\t * after that.\n\t *\n\t * The thread follows the same principle. However, if a softirq is\n\t * running, the thread needs to receive the softirq delta_start. The\n\t * reason being is that the softirq will be the last to be unfolded,\n\t * resseting the thread delay to zero.\n\t *\n\t * The PREEMPT_RT is a special case, though. As softirqs run as threads\n\t * on RT, moving the thread is enough.\n\t */\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT) && osn_var->softirq.delta_start) {\n\t\tcopy_int_safe_time(osn_var, &osn_var->thread.delta_start,\n\t\t\t\t   &osn_var->softirq.delta_start);\n\n\t\tcopy_int_safe_time(osn_var, &osn_var->softirq.delta_start,\n\t\t\t\t    &osn_var->irq.delta_start);\n\t} else {\n\t\tcopy_int_safe_time(osn_var, &osn_var->thread.delta_start,\n\t\t\t\t    &osn_var->irq.delta_start);\n\t}\n\n\t/*\n\t * Compute the current time with the expected time.\n\t */\n\tdiff = now - tlat->abs_period;\n\n\ttlat->count++;\n\ts.seqnum = tlat->count;\n\ts.timer_latency = diff;\n\ts.context = IRQ_CONTEXT;\n\n\ttrace_timerlat_sample(&s);\n\n\tnotify_new_max_latency(diff);\n\n\tif (osnoise_data.stop_tracing)\n\t\tif (time_to_us(diff) >= osnoise_data.stop_tracing)\n\t\t\tosnoise_stop_tracing();\n\n\twake_up_process(tlat->kthread);\n\n\tif (osnoise_data.print_stack)\n\t\ttimerlat_save_stack(0);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "osnoise_main",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1445-1474",
    "snippet": "static int osnoise_main(void *data)\n{\n\tu64 interval;\n\n\twhile (!kthread_should_stop()) {\n\n\t\trun_osnoise();\n\n\t\tmutex_lock(&interface_lock);\n\t\tinterval = osnoise_data.sample_period - osnoise_data.sample_runtime;\n\t\tmutex_unlock(&interface_lock);\n\n\t\tdo_div(interval, USEC_PER_MSEC);\n\n\t\t/*\n\t\t * differently from hwlat_detector, the osnoise tracer can run\n\t\t * without a pause because preemption is on.\n\t\t */\n\t\tif (interval < 1) {\n\t\t\t/* Let synchronize_rcu_tasks() make progress */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (msleep_interruptible(interval))\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mutex interface_lock;",
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep_interruptible",
          "args": [
            "interval"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "interval",
            "USEC_PER_MSEC"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&interface_lock"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&interface_lock"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_osnoise",
          "args": [],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "run_osnoise",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1288-1434",
          "snippet": "static int run_osnoise(void)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tu64 start, sample, last_sample;\n\tu64 last_int_count, int_count;\n\ts64 noise = 0, max_noise = 0;\n\ts64 total, last_total = 0;\n\tstruct osnoise_sample s;\n\tunsigned int threshold;\n\tu64 runtime, stop_in;\n\tu64 sum_noise = 0;\n\tint hw_count = 0;\n\tint ret = -1;\n\n\t/*\n\t * Considers the current thread as the workload.\n\t */\n\tosn_var->pid = current->pid;\n\n\t/*\n\t * Save the current stats for the diff\n\t */\n\tsave_osn_sample_stats(osn_var, &s);\n\n\t/*\n\t * if threshold is 0, use the default value of 5 us.\n\t */\n\tthreshold = tracing_thresh ? : 5000;\n\n\t/*\n\t * Make sure NMIs see sampling first\n\t */\n\tosn_var->sampling = true;\n\tbarrier();\n\n\t/*\n\t * Transform the *_us config to nanoseconds to avoid the\n\t * division on the main loop.\n\t */\n\truntime = osnoise_data.sample_runtime * NSEC_PER_USEC;\n\tstop_in = osnoise_data.stop_tracing * NSEC_PER_USEC;\n\n\t/*\n\t * Start timestemp\n\t */\n\tstart = time_get();\n\n\t/*\n\t * \"previous\" loop.\n\t */\n\tlast_int_count = set_int_safe_time(osn_var, &last_sample);\n\n\tdo {\n\t\t/*\n\t\t * Get sample!\n\t\t */\n\t\tint_count = set_int_safe_time(osn_var, &sample);\n\n\t\tnoise = time_sub(sample, last_sample);\n\n\t\t/*\n\t\t * This shouldn't happen.\n\t\t */\n\t\tif (noise < 0) {\n\t\t\tosnoise_taint(\"negative noise!\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Sample runtime.\n\t\t */\n\t\ttotal = time_sub(sample, start);\n\n\t\t/*\n\t\t * Check for possible overflows.\n\t\t */\n\t\tif (total < last_total) {\n\t\t\tosnoise_taint(\"total overflow!\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_total = total;\n\n\t\tif (noise >= threshold) {\n\t\t\tint interference = int_count - last_int_count;\n\n\t\t\tif (noise > max_noise)\n\t\t\t\tmax_noise = noise;\n\n\t\t\tif (!interference)\n\t\t\t\thw_count++;\n\n\t\t\tsum_noise += noise;\n\n\t\t\ttrace_sample_threshold(last_sample, noise, interference);\n\n\t\t\tif (osnoise_data.stop_tracing)\n\t\t\t\tif (noise > stop_in)\n\t\t\t\t\tosnoise_stop_tracing();\n\t\t}\n\n\t\t/*\n\t\t * For the non-preemptive kernel config: let threads runs, if\n\t\t * they so wish.\n\t\t */\n\t\tcond_resched();\n\n\t\tlast_sample = sample;\n\t\tlast_int_count = int_count;\n\n\t} while (total < runtime && !kthread_should_stop());\n\n\t/*\n\t * Finish the above in the view for interrupts.\n\t */\n\tbarrier();\n\n\tosn_var->sampling = false;\n\n\t/*\n\t * Make sure sampling data is no longer updated.\n\t */\n\tbarrier();\n\n\t/*\n\t * Save noise info.\n\t */\n\ts.noise = time_to_us(sum_noise);\n\ts.runtime = time_to_us(total);\n\ts.max_sample = time_to_us(max_noise);\n\ts.hw_count = hw_count;\n\n\t/* Save interference stats info */\n\tdiff_osn_sample_stats(osn_var, &s);\n\n\ttrace_osnoise_sample(&s);\n\n\tnotify_new_max_latency(max_noise);\n\n\tif (osnoise_data.stop_tracing_total)\n\t\tif (s.noise > osnoise_data.stop_tracing_total)\n\t\t\tosnoise_stop_tracing();\n\n\treturn 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic int run_osnoise(void)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tu64 start, sample, last_sample;\n\tu64 last_int_count, int_count;\n\ts64 noise = 0, max_noise = 0;\n\ts64 total, last_total = 0;\n\tstruct osnoise_sample s;\n\tunsigned int threshold;\n\tu64 runtime, stop_in;\n\tu64 sum_noise = 0;\n\tint hw_count = 0;\n\tint ret = -1;\n\n\t/*\n\t * Considers the current thread as the workload.\n\t */\n\tosn_var->pid = current->pid;\n\n\t/*\n\t * Save the current stats for the diff\n\t */\n\tsave_osn_sample_stats(osn_var, &s);\n\n\t/*\n\t * if threshold is 0, use the default value of 5 us.\n\t */\n\tthreshold = tracing_thresh ? : 5000;\n\n\t/*\n\t * Make sure NMIs see sampling first\n\t */\n\tosn_var->sampling = true;\n\tbarrier();\n\n\t/*\n\t * Transform the *_us config to nanoseconds to avoid the\n\t * division on the main loop.\n\t */\n\truntime = osnoise_data.sample_runtime * NSEC_PER_USEC;\n\tstop_in = osnoise_data.stop_tracing * NSEC_PER_USEC;\n\n\t/*\n\t * Start timestemp\n\t */\n\tstart = time_get();\n\n\t/*\n\t * \"previous\" loop.\n\t */\n\tlast_int_count = set_int_safe_time(osn_var, &last_sample);\n\n\tdo {\n\t\t/*\n\t\t * Get sample!\n\t\t */\n\t\tint_count = set_int_safe_time(osn_var, &sample);\n\n\t\tnoise = time_sub(sample, last_sample);\n\n\t\t/*\n\t\t * This shouldn't happen.\n\t\t */\n\t\tif (noise < 0) {\n\t\t\tosnoise_taint(\"negative noise!\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Sample runtime.\n\t\t */\n\t\ttotal = time_sub(sample, start);\n\n\t\t/*\n\t\t * Check for possible overflows.\n\t\t */\n\t\tif (total < last_total) {\n\t\t\tosnoise_taint(\"total overflow!\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_total = total;\n\n\t\tif (noise >= threshold) {\n\t\t\tint interference = int_count - last_int_count;\n\n\t\t\tif (noise > max_noise)\n\t\t\t\tmax_noise = noise;\n\n\t\t\tif (!interference)\n\t\t\t\thw_count++;\n\n\t\t\tsum_noise += noise;\n\n\t\t\ttrace_sample_threshold(last_sample, noise, interference);\n\n\t\t\tif (osnoise_data.stop_tracing)\n\t\t\t\tif (noise > stop_in)\n\t\t\t\t\tosnoise_stop_tracing();\n\t\t}\n\n\t\t/*\n\t\t * For the non-preemptive kernel config: let threads runs, if\n\t\t * they so wish.\n\t\t */\n\t\tcond_resched();\n\n\t\tlast_sample = sample;\n\t\tlast_int_count = int_count;\n\n\t} while (total < runtime && !kthread_should_stop());\n\n\t/*\n\t * Finish the above in the view for interrupts.\n\t */\n\tbarrier();\n\n\tosn_var->sampling = false;\n\n\t/*\n\t * Make sure sampling data is no longer updated.\n\t */\n\tbarrier();\n\n\t/*\n\t * Save noise info.\n\t */\n\ts.noise = time_to_us(sum_noise);\n\ts.runtime = time_to_us(total);\n\ts.max_sample = time_to_us(max_noise);\n\ts.hw_count = hw_count;\n\n\t/* Save interference stats info */\n\tdiff_osn_sample_stats(osn_var, &s);\n\n\ttrace_osnoise_sample(&s);\n\n\tnotify_new_max_latency(max_noise);\n\n\tif (osnoise_data.stop_tracing_total)\n\t\tif (s.noise > osnoise_data.stop_tracing_total)\n\t\t\tosnoise_stop_tracing();\n\n\treturn 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstruct mutex interface_lock;\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic int osnoise_main(void *data)\n{\n\tu64 interval;\n\n\twhile (!kthread_should_stop()) {\n\n\t\trun_osnoise();\n\n\t\tmutex_lock(&interface_lock);\n\t\tinterval = osnoise_data.sample_period - osnoise_data.sample_runtime;\n\t\tmutex_unlock(&interface_lock);\n\n\t\tdo_div(interval, USEC_PER_MSEC);\n\n\t\t/*\n\t\t * differently from hwlat_detector, the osnoise tracer can run\n\t\t * without a pause because preemption is on.\n\t\t */\n\t\tif (interval < 1) {\n\t\t\t/* Let synchronize_rcu_tasks() make progress */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (msleep_interruptible(interval))\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "run_osnoise",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1288-1434",
    "snippet": "static int run_osnoise(void)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tu64 start, sample, last_sample;\n\tu64 last_int_count, int_count;\n\ts64 noise = 0, max_noise = 0;\n\ts64 total, last_total = 0;\n\tstruct osnoise_sample s;\n\tunsigned int threshold;\n\tu64 runtime, stop_in;\n\tu64 sum_noise = 0;\n\tint hw_count = 0;\n\tint ret = -1;\n\n\t/*\n\t * Considers the current thread as the workload.\n\t */\n\tosn_var->pid = current->pid;\n\n\t/*\n\t * Save the current stats for the diff\n\t */\n\tsave_osn_sample_stats(osn_var, &s);\n\n\t/*\n\t * if threshold is 0, use the default value of 5 us.\n\t */\n\tthreshold = tracing_thresh ? : 5000;\n\n\t/*\n\t * Make sure NMIs see sampling first\n\t */\n\tosn_var->sampling = true;\n\tbarrier();\n\n\t/*\n\t * Transform the *_us config to nanoseconds to avoid the\n\t * division on the main loop.\n\t */\n\truntime = osnoise_data.sample_runtime * NSEC_PER_USEC;\n\tstop_in = osnoise_data.stop_tracing * NSEC_PER_USEC;\n\n\t/*\n\t * Start timestemp\n\t */\n\tstart = time_get();\n\n\t/*\n\t * \"previous\" loop.\n\t */\n\tlast_int_count = set_int_safe_time(osn_var, &last_sample);\n\n\tdo {\n\t\t/*\n\t\t * Get sample!\n\t\t */\n\t\tint_count = set_int_safe_time(osn_var, &sample);\n\n\t\tnoise = time_sub(sample, last_sample);\n\n\t\t/*\n\t\t * This shouldn't happen.\n\t\t */\n\t\tif (noise < 0) {\n\t\t\tosnoise_taint(\"negative noise!\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Sample runtime.\n\t\t */\n\t\ttotal = time_sub(sample, start);\n\n\t\t/*\n\t\t * Check for possible overflows.\n\t\t */\n\t\tif (total < last_total) {\n\t\t\tosnoise_taint(\"total overflow!\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_total = total;\n\n\t\tif (noise >= threshold) {\n\t\t\tint interference = int_count - last_int_count;\n\n\t\t\tif (noise > max_noise)\n\t\t\t\tmax_noise = noise;\n\n\t\t\tif (!interference)\n\t\t\t\thw_count++;\n\n\t\t\tsum_noise += noise;\n\n\t\t\ttrace_sample_threshold(last_sample, noise, interference);\n\n\t\t\tif (osnoise_data.stop_tracing)\n\t\t\t\tif (noise > stop_in)\n\t\t\t\t\tosnoise_stop_tracing();\n\t\t}\n\n\t\t/*\n\t\t * For the non-preemptive kernel config: let threads runs, if\n\t\t * they so wish.\n\t\t */\n\t\tcond_resched();\n\n\t\tlast_sample = sample;\n\t\tlast_int_count = int_count;\n\n\t} while (total < runtime && !kthread_should_stop());\n\n\t/*\n\t * Finish the above in the view for interrupts.\n\t */\n\tbarrier();\n\n\tosn_var->sampling = false;\n\n\t/*\n\t * Make sure sampling data is no longer updated.\n\t */\n\tbarrier();\n\n\t/*\n\t * Save noise info.\n\t */\n\ts.noise = time_to_us(sum_noise);\n\ts.runtime = time_to_us(total);\n\ts.max_sample = time_to_us(max_noise);\n\ts.hw_count = hw_count;\n\n\t/* Save interference stats info */\n\tdiff_osn_sample_stats(osn_var, &s);\n\n\ttrace_osnoise_sample(&s);\n\n\tnotify_new_max_latency(max_noise);\n\n\tif (osnoise_data.stop_tracing_total)\n\t\tif (s.noise > osnoise_data.stop_tracing_total)\n\t\t\tosnoise_stop_tracing();\n\n\treturn 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_stop_tracing",
          "args": [],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_stop_tracing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1245-1259",
          "snippet": "static __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_new_max_latency",
          "args": [
            "max_noise"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "notify_new_max_latency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1264-1278",
          "snippet": "static void notify_new_max_latency(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\tif (tr->max_latency < latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void notify_new_max_latency(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\tif (tr->max_latency < latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_osnoise_sample",
          "args": [
            "&s"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "trace_osnoise_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "498-509",
          "snippet": "static void trace_osnoise_sample(struct osnoise_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_osnoise_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head osnoise_instances;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void trace_osnoise_sample(struct osnoise_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_osnoise_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_osn_sample_stats",
          "args": [
            "osn_var",
            "&s"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "diff_osn_sample_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1233-1240",
          "snippet": "static void\ndiff_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count - s->nmi_count;\n\ts->irq_count = osn_var->irq.count - s->irq_count;\n\ts->softirq_count = osn_var->softirq.count - s->softirq_count;\n\ts->thread_count = osn_var->thread.count - s->thread_count;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\ndiff_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count - s->nmi_count;\n\ts->irq_count = osn_var->irq.count - s->irq_count;\n\ts->softirq_count = osn_var->softirq.count - s->softirq_count;\n\ts->thread_count = osn_var->thread.count - s->thread_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "max_noise"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "total"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_to_us",
          "args": [
            "sum_noise"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sample_threshold",
          "args": [
            "last_sample",
            "noise",
            "interference"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osnoise_taint",
          "args": [
            "\"total overflow!\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_sub",
          "args": [
            "sample",
            "start"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osnoise_taint",
          "args": [
            "\"negative noise!\""
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_sub",
          "args": [
            "sample",
            "last_sample"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_int_safe_time",
          "args": [
            "osn_var",
            "&sample"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "set_int_safe_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "803-820",
          "snippet": "static u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_osn_sample_stats",
          "args": [
            "osn_var",
            "&s"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "save_osn_sample_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1217-1224",
          "snippet": "static void\nsave_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count;\n\ts->irq_count = osn_var->irq.count;\n\ts->softirq_count = osn_var->softirq.count;\n\ts->thread_count = osn_var->thread.count;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\nsave_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count;\n\ts->irq_count = osn_var->irq.count;\n\ts->softirq_count = osn_var->softirq.count;\n\ts->thread_count = osn_var->thread.count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic int run_osnoise(void)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tu64 start, sample, last_sample;\n\tu64 last_int_count, int_count;\n\ts64 noise = 0, max_noise = 0;\n\ts64 total, last_total = 0;\n\tstruct osnoise_sample s;\n\tunsigned int threshold;\n\tu64 runtime, stop_in;\n\tu64 sum_noise = 0;\n\tint hw_count = 0;\n\tint ret = -1;\n\n\t/*\n\t * Considers the current thread as the workload.\n\t */\n\tosn_var->pid = current->pid;\n\n\t/*\n\t * Save the current stats for the diff\n\t */\n\tsave_osn_sample_stats(osn_var, &s);\n\n\t/*\n\t * if threshold is 0, use the default value of 5 us.\n\t */\n\tthreshold = tracing_thresh ? : 5000;\n\n\t/*\n\t * Make sure NMIs see sampling first\n\t */\n\tosn_var->sampling = true;\n\tbarrier();\n\n\t/*\n\t * Transform the *_us config to nanoseconds to avoid the\n\t * division on the main loop.\n\t */\n\truntime = osnoise_data.sample_runtime * NSEC_PER_USEC;\n\tstop_in = osnoise_data.stop_tracing * NSEC_PER_USEC;\n\n\t/*\n\t * Start timestemp\n\t */\n\tstart = time_get();\n\n\t/*\n\t * \"previous\" loop.\n\t */\n\tlast_int_count = set_int_safe_time(osn_var, &last_sample);\n\n\tdo {\n\t\t/*\n\t\t * Get sample!\n\t\t */\n\t\tint_count = set_int_safe_time(osn_var, &sample);\n\n\t\tnoise = time_sub(sample, last_sample);\n\n\t\t/*\n\t\t * This shouldn't happen.\n\t\t */\n\t\tif (noise < 0) {\n\t\t\tosnoise_taint(\"negative noise!\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Sample runtime.\n\t\t */\n\t\ttotal = time_sub(sample, start);\n\n\t\t/*\n\t\t * Check for possible overflows.\n\t\t */\n\t\tif (total < last_total) {\n\t\t\tosnoise_taint(\"total overflow!\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_total = total;\n\n\t\tif (noise >= threshold) {\n\t\t\tint interference = int_count - last_int_count;\n\n\t\t\tif (noise > max_noise)\n\t\t\t\tmax_noise = noise;\n\n\t\t\tif (!interference)\n\t\t\t\thw_count++;\n\n\t\t\tsum_noise += noise;\n\n\t\t\ttrace_sample_threshold(last_sample, noise, interference);\n\n\t\t\tif (osnoise_data.stop_tracing)\n\t\t\t\tif (noise > stop_in)\n\t\t\t\t\tosnoise_stop_tracing();\n\t\t}\n\n\t\t/*\n\t\t * For the non-preemptive kernel config: let threads runs, if\n\t\t * they so wish.\n\t\t */\n\t\tcond_resched();\n\n\t\tlast_sample = sample;\n\t\tlast_int_count = int_count;\n\n\t} while (total < runtime && !kthread_should_stop());\n\n\t/*\n\t * Finish the above in the view for interrupts.\n\t */\n\tbarrier();\n\n\tosn_var->sampling = false;\n\n\t/*\n\t * Make sure sampling data is no longer updated.\n\t */\n\tbarrier();\n\n\t/*\n\t * Save noise info.\n\t */\n\ts.noise = time_to_us(sum_noise);\n\ts.runtime = time_to_us(total);\n\ts.max_sample = time_to_us(max_noise);\n\ts.hw_count = hw_count;\n\n\t/* Save interference stats info */\n\tdiff_osn_sample_stats(osn_var, &s);\n\n\ttrace_osnoise_sample(&s);\n\n\tnotify_new_max_latency(max_noise);\n\n\tif (osnoise_data.stop_tracing_total)\n\t\tif (s.noise > osnoise_data.stop_tracing_total)\n\t\t\tosnoise_stop_tracing();\n\n\treturn 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "notify_new_max_latency",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1264-1278",
    "snippet": "static void notify_new_max_latency(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\tif (tr->max_latency < latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "latency_fsnotify",
          "args": [
            "tr"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "latency_fsnotify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1714-1724",
          "snippet": "void latency_fsnotify(struct trace_array *tr)\n{\n\tif (!fsnotify_wq)\n\t\treturn;\n\t/*\n\t * We cannot call queue_work(&tr->fsnotify_work) from here because it's\n\t * possible that we are called from __schedule() or do_idle(), which\n\t * could cause a deadlock.\n\t */\n\tirq_work_queue(&tr->fsnotify_irqwork);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid latency_fsnotify(struct trace_array *tr)\n{\n\tif (!fsnotify_wq)\n\t\treturn;\n\t/*\n\t * We cannot call queue_work(&tr->fsnotify_work) from here because it's\n\t * possible that we are called from __schedule() or do_idle(), which\n\t * could cause a deadlock.\n\t */\n\tirq_work_queue(&tr->fsnotify_irqwork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "inst",
            "&osnoise_instances",
            "list"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void notify_new_max_latency(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\tif (tr->max_latency < latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "osnoise_stop_tracing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1245-1259",
    "snippet": "static __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_off",
          "args": [
            "tr"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1404-1419",
          "snippet": "void tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_printk_buf",
          "args": [
            "tr->array_buffer.buffer",
            "_THIS_IP_",
            "\"stop tracing hit on cpu %d\\n\"",
            "smp_processor_id()"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_printk_buf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3519-3532",
          "snippet": "int trace_array_printk_buf(struct trace_buffer *buffer,\n\t\t\t   unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!(global_trace.trace_flags & TRACE_ITER_PRINTK))\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = __trace_array_vprintk(buffer, ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint trace_array_printk_buf(struct trace_buffer *buffer,\n\t\t\t   unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!(global_trace.trace_flags & TRACE_ITER_PRINTK))\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = __trace_array_vprintk(buffer, ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "inst",
            "&osnoise_instances",
            "list"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "diff_osn_sample_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1233-1240",
    "snippet": "static void\ndiff_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count - s->nmi_count;\n\ts->irq_count = osn_var->irq.count - s->irq_count;\n\ts->softirq_count = osn_var->softirq.count - s->softirq_count;\n\ts->thread_count = osn_var->thread.count - s->thread_count;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\ndiff_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count - s->nmi_count;\n\ts->irq_count = osn_var->irq.count - s->irq_count;\n\ts->softirq_count = osn_var->softirq.count - s->softirq_count;\n\ts->thread_count = osn_var->thread.count - s->thread_count;\n}"
  },
  {
    "function_name": "save_osn_sample_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1217-1224",
    "snippet": "static void\nsave_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count;\n\ts->irq_count = osn_var->irq.count;\n\ts->softirq_count = osn_var->softirq.count;\n\ts->thread_count = osn_var->thread.count;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\nsave_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count;\n\ts->irq_count = osn_var->irq.count;\n\ts->softirq_count = osn_var->softirq.count;\n\ts->thread_count = osn_var->thread.count;\n}"
  },
  {
    "function_name": "unhook_thread_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1205-1208",
    "snippet": "static void unhook_thread_events(void)\n{\n\tunregister_trace_sched_switch(trace_sched_switch_callback, NULL);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "trace_sched_switch_callback",
            "NULL"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_thread_events(void)\n{\n\tunregister_trace_sched_switch(trace_sched_switch_callback, NULL);\n}"
  },
  {
    "function_name": "hook_thread_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1188-1197",
    "snippet": "static int hook_thread_events(void)\n{\n\tint ret;\n\n\tret = register_trace_sched_switch(trace_sched_switch_callback, NULL);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_trace_sched_switch",
          "args": [
            "trace_sched_switch_callback",
            "NULL"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int hook_thread_events(void)\n{\n\tint ret;\n\n\tret = register_trace_sched_switch(trace_sched_switch_callback, NULL);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_sched_switch_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1169-1180",
    "snippet": "static void\ntrace_sched_switch_callback(void *data, bool preempt, struct task_struct *p,\n\t\t\t    struct task_struct *n)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (p->pid != osn_var->pid)\n\t\tthread_exit(osn_var, p);\n\n\tif (n->pid != osn_var->pid)\n\t\tthread_entry(osn_var, n);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_entry",
          "args": [
            "osn_var",
            "n"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "thread_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1122-1137",
          "snippet": "static void\nthread_entry(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * The arrival time will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->thread.arrival_time = time_get();\n\n\tset_int_safe_time(osn_var, &osn_var->thread.delta_start);\n\n\tosn_var->thread.count++;\n\tlocal_inc(&osn_var->int_counter);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\nthread_entry(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * The arrival time will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->thread.arrival_time = time_get();\n\n\tset_int_safe_time(osn_var, &osn_var->thread.delta_start);\n\n\tosn_var->thread.count++;\n\tlocal_inc(&osn_var->int_counter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_exit",
          "args": [
            "osn_var",
            "p"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "thread_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "1144-1161",
          "snippet": "static void\nthread_exit(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tif (unlikely(timerlat_enabled()))\n\t\tif (!timerlat_thread_exit(osn_var))\n\t\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->thread.delta_start);\n\n\ttrace_thread_noise(t, osn_var->thread.arrival_time, duration);\n\n\tosn_var->thread.arrival_time = 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\nthread_exit(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tif (unlikely(timerlat_enabled()))\n\t\tif (!timerlat_thread_exit(osn_var))\n\t\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->thread.delta_start);\n\n\ttrace_thread_noise(t, osn_var->thread.arrival_time, duration);\n\n\tosn_var->thread.arrival_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\ntrace_sched_switch_callback(void *data, bool preempt, struct task_struct *p,\n\t\t\t    struct task_struct *n)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (p->pid != osn_var->pid)\n\t\tthread_exit(osn_var, p);\n\n\tif (n->pid != osn_var->pid)\n\t\tthread_entry(osn_var, n);\n}"
  },
  {
    "function_name": "thread_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1144-1161",
    "snippet": "static void\nthread_exit(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tif (unlikely(timerlat_enabled()))\n\t\tif (!timerlat_thread_exit(osn_var))\n\t\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->thread.delta_start);\n\n\ttrace_thread_noise(t, osn_var->thread.arrival_time, duration);\n\n\tosn_var->thread.arrival_time = 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_thread_noise",
          "args": [
            "t",
            "osn_var->thread.arrival_time",
            "duration"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int_safe_duration",
          "args": [
            "osn_var",
            "&osn_var->thread.delta_start"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_safe_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "764-792",
          "snippet": "static inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t/*\n\t * This is an evidence of race conditions that cause\n\t * a value to be \"discounted\" too much.\n\t */\n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t/*\n\t * This is an evidence of race conditions that cause\n\t * a value to be \"discounted\" too much.\n\t */\n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerlat_thread_exit",
          "args": [
            "osn_var"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_thread_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "387-390",
          "snippet": "static inline int timerlat_thread_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline int timerlat_thread_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timerlat_enabled()"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerlat_enabled",
          "args": [],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "378-381",
          "snippet": "static inline bool timerlat_enabled(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline bool timerlat_enabled(void)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\nthread_exit(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tif (unlikely(timerlat_enabled()))\n\t\tif (!timerlat_thread_exit(osn_var))\n\t\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->thread.delta_start);\n\n\ttrace_thread_noise(t, osn_var->thread.arrival_time, duration);\n\n\tosn_var->thread.arrival_time = 0;\n}"
  },
  {
    "function_name": "thread_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1122-1137",
    "snippet": "static void\nthread_entry(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * The arrival time will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->thread.arrival_time = time_get();\n\n\tset_int_safe_time(osn_var, &osn_var->thread.delta_start);\n\n\tosn_var->thread.count++;\n\tlocal_inc(&osn_var->int_counter);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_int_safe_time",
          "args": [
            "osn_var",
            "&osn_var->thread.delta_start"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "set_int_safe_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "803-820",
          "snippet": "static u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\nthread_entry(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * The arrival time will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->thread.arrival_time = time_get();\n\n\tset_int_safe_time(osn_var, &osn_var->thread.delta_start);\n\n\tosn_var->thread.count++;\n\tlocal_inc(&osn_var->int_counter);\n}"
  },
  {
    "function_name": "unhook_softirq_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1111-1113",
    "snippet": "static void unhook_softirq_events(void)\n{\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_softirq_events(void)\n{\n}"
  },
  {
    "function_name": "hook_softirq_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1107-1110",
    "snippet": "static int hook_softirq_events(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int hook_softirq_events(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "unhook_softirq_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1098-1102",
    "snippet": "static void unhook_softirq_events(void)\n{\n\tunregister_trace_softirq_entry(trace_softirq_entry_callback, NULL);\n\tunregister_trace_softirq_exit(trace_softirq_exit_callback, NULL);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_softirq_exit",
          "args": [
            "trace_softirq_exit_callback",
            "NULL"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_softirq_entry",
          "args": [
            "trace_softirq_entry_callback",
            "NULL"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_softirq_events(void)\n{\n\tunregister_trace_softirq_entry(trace_softirq_entry_callback, NULL);\n\tunregister_trace_softirq_exit(trace_softirq_exit_callback, NULL);\n}"
  },
  {
    "function_name": "hook_softirq_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1072-1090",
    "snippet": "static int hook_softirq_events(void)\n{\n\tint ret;\n\n\tret = register_trace_softirq_entry(trace_softirq_entry_callback, NULL);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = register_trace_softirq_exit(trace_softirq_exit_callback, NULL);\n\tif (ret)\n\t\tgoto out_unreg_entry;\n\n\treturn 0;\n\nout_unreg_entry:\n\tunregister_trace_softirq_entry(trace_softirq_entry_callback, NULL);\nout_err:\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_softirq_entry",
          "args": [
            "trace_softirq_entry_callback",
            "NULL"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_softirq_exit",
          "args": [
            "trace_softirq_exit_callback",
            "NULL"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_softirq_entry",
          "args": [
            "trace_softirq_entry_callback",
            "NULL"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int hook_softirq_events(void)\n{\n\tint ret;\n\n\tret = register_trace_softirq_entry(trace_softirq_entry_callback, NULL);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = register_trace_softirq_exit(trace_softirq_exit_callback, NULL);\n\tif (ret)\n\t\tgoto out_unreg_entry;\n\n\treturn 0;\n\nout_unreg_entry:\n\tunregister_trace_softirq_entry(trace_softirq_entry_callback, NULL);\nout_err:\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "trace_softirq_exit_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1048-1064",
    "snippet": "static void trace_softirq_exit_callback(void *data, unsigned int vec_nr)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tif (unlikely(timerlat_enabled()))\n\t\tif (!timerlat_softirq_exit(osn_var))\n\t\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->softirq.delta_start);\n\ttrace_softirq_noise(vec_nr, osn_var->softirq.arrival_time, duration);\n\tcond_move_thread_delta_start(osn_var, duration);\n\tosn_var->softirq.arrival_time = 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_move_thread_delta_start",
          "args": [
            "osn_var",
            "duration"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "cond_move_thread_delta_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "730-735",
          "snippet": "static inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_softirq_noise",
          "args": [
            "vec_nr",
            "osn_var->softirq.arrival_time",
            "duration"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int_safe_duration",
          "args": [
            "osn_var",
            "&osn_var->softirq.delta_start"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_safe_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "764-792",
          "snippet": "static inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t/*\n\t * This is an evidence of race conditions that cause\n\t * a value to be \"discounted\" too much.\n\t */\n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t/*\n\t * This is an evidence of race conditions that cause\n\t * a value to be \"discounted\" too much.\n\t */\n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerlat_softirq_exit",
          "args": [
            "osn_var"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_softirq_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "383-386",
          "snippet": "static inline int timerlat_softirq_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline int timerlat_softirq_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timerlat_enabled()"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerlat_enabled",
          "args": [],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "timerlat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "378-381",
          "snippet": "static inline bool timerlat_enabled(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline bool timerlat_enabled(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void trace_softirq_exit_callback(void *data, unsigned int vec_nr)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tif (unlikely(timerlat_enabled()))\n\t\tif (!timerlat_softirq_exit(osn_var))\n\t\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->softirq.delta_start);\n\ttrace_softirq_noise(vec_nr, osn_var->softirq.arrival_time, duration);\n\tcond_move_thread_delta_start(osn_var, duration);\n\tosn_var->softirq.arrival_time = 0;\n}"
  },
  {
    "function_name": "trace_softirq_entry_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1025-1040",
    "snippet": "static void trace_softirq_entry_callback(void *data, unsigned int vec_nr)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * This value will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->softirq.arrival_time = time_get();\n\tset_int_safe_time(osn_var, &osn_var->softirq.delta_start);\n\tosn_var->softirq.count++;\n\n\tlocal_inc(&osn_var->int_counter);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_int_safe_time",
          "args": [
            "osn_var",
            "&osn_var->softirq.delta_start"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "set_int_safe_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "803-820",
          "snippet": "static u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void trace_softirq_entry_callback(void *data, unsigned int vec_nr)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * This value will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->softirq.arrival_time = time_get();\n\tset_int_safe_time(osn_var, &osn_var->softirq.delta_start);\n\tosn_var->softirq.count++;\n\n\tlocal_inc(&osn_var->int_counter);\n}"
  },
  {
    "function_name": "unhook_irq_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "1008-1013",
    "snippet": "static void unhook_irq_events(void)\n{\n\tosnoise_arch_unregister();\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_irq_handler_entry",
          "args": [
            "trace_irqentry_callback",
            "NULL"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_irq_handler_exit",
          "args": [
            "trace_irqexit_callback",
            "NULL"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osnoise_arch_unregister",
          "args": [],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_arch_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "965-968",
          "snippet": "void __weak osnoise_arch_unregister(void)\n{\n\treturn;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nvoid __weak osnoise_arch_unregister(void)\n{\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void unhook_irq_events(void)\n{\n\tosnoise_arch_unregister();\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n}"
  },
  {
    "function_name": "hook_irq_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "976-1000",
    "snippet": "static int hook_irq_events(void)\n{\n\tint ret;\n\n\tret = register_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = register_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tif (ret)\n\t\tgoto out_unregister_entry;\n\n\tret = osnoise_arch_register();\n\tif (ret)\n\t\tgoto out_irq_exit;\n\n\treturn 0;\n\nout_irq_exit:\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\nout_unregister_entry:\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\nout_err:\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_irq_handler_entry",
          "args": [
            "trace_irqentry_callback",
            "NULL"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_irq_handler_exit",
          "args": [
            "trace_irqexit_callback",
            "NULL"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osnoise_arch_register",
          "args": [],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_arch_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "957-960",
          "snippet": "int __weak osnoise_arch_register(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nint __weak osnoise_arch_register(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_irq_handler_exit",
          "args": [
            "trace_irqexit_callback",
            "NULL"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_irq_handler_entry",
          "args": [
            "trace_irqentry_callback",
            "NULL"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic int hook_irq_events(void)\n{\n\tint ret;\n\n\tret = register_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = register_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tif (ret)\n\t\tgoto out_unregister_entry;\n\n\tret = osnoise_arch_register();\n\tif (ret)\n\t\tgoto out_irq_exit;\n\n\treturn 0;\n\nout_irq_exit:\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\nout_unregister_entry:\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\nout_err:\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "osnoise_arch_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "965-968",
    "snippet": "void __weak osnoise_arch_unregister(void)\n{\n\treturn;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nvoid __weak osnoise_arch_unregister(void)\n{\n\treturn;\n}"
  },
  {
    "function_name": "osnoise_arch_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "957-960",
    "snippet": "int __weak osnoise_arch_register(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nint __weak osnoise_arch_register(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_irqexit_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "948-952",
    "snippet": "static void trace_irqexit_callback(void *data, int irq,\n\t\t\t\t   struct irqaction *action, int ret)\n{\n\tosnoise_trace_irq_exit(irq, action->name);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_trace_irq_exit",
          "args": [
            "irq",
            "action->name"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_trace_irq_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "917-930",
          "snippet": "void osnoise_trace_irq_exit(int id, const char *desc)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->irq.delta_start);\n\ttrace_irq_noise(id, desc, osn_var->irq.arrival_time, duration);\n\tosn_var->irq.arrival_time = 0;\n\tcond_move_softirq_delta_start(osn_var, duration);\n\tcond_move_thread_delta_start(osn_var, duration);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nvoid osnoise_trace_irq_exit(int id, const char *desc)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->irq.delta_start);\n\ttrace_irq_noise(id, desc, osn_var->irq.arrival_time, duration);\n\tosn_var->irq.arrival_time = 0;\n\tcond_move_softirq_delta_start(osn_var, duration);\n\tcond_move_thread_delta_start(osn_var, duration);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void trace_irqexit_callback(void *data, int irq,\n\t\t\t\t   struct irqaction *action, int ret)\n{\n\tosnoise_trace_irq_exit(irq, action->name);\n}"
  },
  {
    "function_name": "trace_irqentry_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "937-941",
    "snippet": "static void trace_irqentry_callback(void *data, int irq,\n\t\t\t\t    struct irqaction *action)\n{\n\tosnoise_trace_irq_entry(irq);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_trace_irq_entry",
          "args": [
            "irq"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "osnoise_trace_irq_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "894-909",
          "snippet": "void osnoise_trace_irq_entry(int id)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * This value will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->irq.arrival_time = time_get();\n\tset_int_safe_time(osn_var, &osn_var->irq.delta_start);\n\tosn_var->irq.count++;\n\n\tlocal_inc(&osn_var->int_counter);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nvoid osnoise_trace_irq_entry(int id)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * This value will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->irq.arrival_time = time_get();\n\tset_int_safe_time(osn_var, &osn_var->irq.delta_start);\n\tosn_var->irq.count++;\n\n\tlocal_inc(&osn_var->int_counter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void trace_irqentry_callback(void *data, int irq,\n\t\t\t\t    struct irqaction *action)\n{\n\tosnoise_trace_irq_entry(irq);\n}"
  },
  {
    "function_name": "osnoise_trace_irq_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "917-930",
    "snippet": "void osnoise_trace_irq_exit(int id, const char *desc)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->irq.delta_start);\n\ttrace_irq_noise(id, desc, osn_var->irq.arrival_time, duration);\n\tosn_var->irq.arrival_time = 0;\n\tcond_move_softirq_delta_start(osn_var, duration);\n\tcond_move_thread_delta_start(osn_var, duration);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_move_thread_delta_start",
          "args": [
            "osn_var",
            "duration"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "cond_move_thread_delta_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "730-735",
          "snippet": "static inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_move_softirq_delta_start",
          "args": [
            "osn_var",
            "duration"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "cond_move_softirq_delta_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "712-717",
          "snippet": "static inline void\ncond_move_softirq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->softirq.delta_start)\n\t\tosn_var->softirq.delta_start += duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_softirq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->softirq.delta_start)\n\t\tosn_var->softirq.delta_start += duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_noise",
          "args": [
            "id",
            "desc",
            "osn_var->irq.arrival_time",
            "duration"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int_safe_duration",
          "args": [
            "osn_var",
            "&osn_var->irq.delta_start"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_safe_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "764-792",
          "snippet": "static inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t/*\n\t * This is an evidence of race conditions that cause\n\t * a value to be \"discounted\" too much.\n\t */\n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t/*\n\t * This is an evidence of race conditions that cause\n\t * a value to be \"discounted\" too much.\n\t */\n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nvoid osnoise_trace_irq_exit(int id, const char *desc)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tint duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->irq.delta_start);\n\ttrace_irq_noise(id, desc, osn_var->irq.arrival_time, duration);\n\tosn_var->irq.arrival_time = 0;\n\tcond_move_softirq_delta_start(osn_var, duration);\n\tcond_move_thread_delta_start(osn_var, duration);\n}"
  },
  {
    "function_name": "osnoise_trace_irq_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "894-909",
    "snippet": "void osnoise_trace_irq_entry(int id)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * This value will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->irq.arrival_time = time_get();\n\tset_int_safe_time(osn_var, &osn_var->irq.delta_start);\n\tosn_var->irq.count++;\n\n\tlocal_inc(&osn_var->int_counter);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_int_safe_time",
          "args": [
            "osn_var",
            "&osn_var->irq.delta_start"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "set_int_safe_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "803-820",
          "snippet": "static u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nvoid osnoise_trace_irq_entry(int id)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\t/*\n\t * This value will be used in the report, but not to compute\n\t * the execution time, so it is safe to get it unsafe.\n\t */\n\tosn_var->irq.arrival_time = time_get();\n\tset_int_safe_time(osn_var, &osn_var->irq.delta_start);\n\tosn_var->irq.count++;\n\n\tlocal_inc(&osn_var->int_counter);\n}"
  },
  {
    "function_name": "trace_osnoise_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "854-883",
    "snippet": "void trace_osnoise_callback(bool enter)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tu64 duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\t/*\n\t * Currently trace_clock_local() calls sched_clock() and the\n\t * generic version is not NMI safe.\n\t */\n\tif (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK)) {\n\t\tif (enter) {\n\t\t\tosn_var->nmi.delta_start = time_get();\n\t\t\tlocal_inc(&osn_var->int_counter);\n\t\t} else {\n\t\t\tduration = time_get() - osn_var->nmi.delta_start;\n\n\t\t\ttrace_nmi_noise(osn_var->nmi.delta_start, duration);\n\n\t\t\tcond_move_irq_delta_start(osn_var, duration);\n\t\t\tcond_move_softirq_delta_start(osn_var, duration);\n\t\t\tcond_move_thread_delta_start(osn_var, duration);\n\t\t}\n\t}\n\n\tif (enter)\n\t\tosn_var->nmi.count++;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_move_thread_delta_start",
          "args": [
            "osn_var",
            "duration"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "cond_move_thread_delta_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "730-735",
          "snippet": "static inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_move_softirq_delta_start",
          "args": [
            "osn_var",
            "duration"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "cond_move_softirq_delta_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "712-717",
          "snippet": "static inline void\ncond_move_softirq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->softirq.delta_start)\n\t\tosn_var->softirq.delta_start += duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_softirq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->softirq.delta_start)\n\t\tosn_var->softirq.delta_start += duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_move_irq_delta_start",
          "args": [
            "osn_var",
            "duration"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "cond_move_irq_delta_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "696-701",
          "snippet": "static inline void\ncond_move_irq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->irq.delta_start)\n\t\tosn_var->irq.delta_start += duration;\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_irq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->irq.delta_start)\n\t\tosn_var->irq.delta_start += duration;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nmi_noise",
          "args": [
            "osn_var->nmi.delta_start",
            "duration"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_GENERIC_SCHED_CLOCK"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_osn_var",
          "args": [],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_osn_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "204-207",
          "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nvoid trace_osnoise_callback(bool enter)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tu64 duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\t/*\n\t * Currently trace_clock_local() calls sched_clock() and the\n\t * generic version is not NMI safe.\n\t */\n\tif (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK)) {\n\t\tif (enter) {\n\t\t\tosn_var->nmi.delta_start = time_get();\n\t\t\tlocal_inc(&osn_var->int_counter);\n\t\t} else {\n\t\t\tduration = time_get() - osn_var->nmi.delta_start;\n\n\t\t\ttrace_nmi_noise(osn_var->nmi.delta_start, duration);\n\n\t\t\tcond_move_irq_delta_start(osn_var, duration);\n\t\t\tcond_move_softirq_delta_start(osn_var, duration);\n\t\t\tcond_move_thread_delta_start(osn_var, duration);\n\t\t}\n\t}\n\n\tif (enter)\n\t\tosn_var->nmi.count++;\n}"
  },
  {
    "function_name": "copy_int_safe_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "826-843",
    "snippet": "static u64\ncopy_int_safe_time(struct osnoise_variables *osn_var, u64 *dst, u64 *src)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*dst = *src;\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic u64\ncopy_int_safe_time(struct osnoise_variables *osn_var, u64 *dst, u64 *src)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*dst = *src;\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}"
  },
  {
    "function_name": "set_int_safe_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "803-820",
    "snippet": "static u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}"
  },
  {
    "function_name": "get_int_safe_duration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "764-792",
    "snippet": "static inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t/*\n\t * This is an evidence of race conditions that cause\n\t * a value to be \"discounted\" too much.\n\t */\n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osnoise_taint",
          "args": [
            "\"Negative duration!\\n\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_get",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&osn_var->int_counter"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t/* synchronize with interrupts */\n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t/*\n\t * This is an evidence of race conditions that cause\n\t * a value to be \"discounted\" too much.\n\t */\n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}"
  },
  {
    "function_name": "cond_move_thread_delta_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "730-735",
    "snippet": "static inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}"
  },
  {
    "function_name": "cond_move_softirq_delta_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "712-717",
    "snippet": "static inline void\ncond_move_softirq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->softirq.delta_start)\n\t\tosn_var->softirq.delta_start += duration;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_softirq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->softirq.delta_start)\n\t\tosn_var->softirq.delta_start += duration;\n}"
  },
  {
    "function_name": "cond_move_irq_delta_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "696-701",
    "snippet": "static inline void\ncond_move_irq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->irq.delta_start)\n\t\tosn_var->irq.delta_start += duration;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void\ncond_move_irq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->irq.delta_start)\n\t\tosn_var->irq.delta_start += duration;\n}"
  },
  {
    "function_name": "timerlat_dump_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "649-674",
    "snippet": "static void timerlat_dump_stack(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\tstruct trace_stack *fstack;\n\tunsigned int size;\n\n\t/*\n\t * trace only if latency > print_stack config, if enabled.\n\t */\n\tif (!osnoise_data.print_stack || osnoise_data.print_stack > latency)\n\t\treturn;\n\n\tpreempt_disable_notrace();\n\tfstack = this_cpu_ptr(&trace_stack);\n\tsize = fstack->stack_size;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__timerlat_dump_stack(buffer, fstack, size);\n\n\t}\n\trcu_read_unlock();\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;",
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__timerlat_dump_stack",
          "args": [
            "buffer",
            "fstack",
            "size"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "__timerlat_dump_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "625-644",
          "snippet": "static void\n__timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, unsigned int size)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct stack_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_STACK, sizeof(*entry) + size,\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\n\tmemcpy(&entry->caller, fstack->calls, size);\n\tentry->size = fstack->nr_entries;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\n__timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, unsigned int size)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct stack_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_STACK, sizeof(*entry) + size,\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\n\tmemcpy(&entry->caller, fstack->calls, size);\n\tentry->size = fstack->nr_entries;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "inst",
            "&osnoise_instances",
            "list"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&trace_stack"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic void timerlat_dump_stack(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\tstruct trace_stack *fstack;\n\tunsigned int size;\n\n\t/*\n\t * trace only if latency > print_stack config, if enabled.\n\t */\n\tif (!osnoise_data.print_stack || osnoise_data.print_stack > latency)\n\t\treturn;\n\n\tpreempt_disable_notrace();\n\tfstack = this_cpu_ptr(&trace_stack);\n\tsize = fstack->stack_size;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__timerlat_dump_stack(buffer, fstack, size);\n\n\t}\n\trcu_read_unlock();\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "__timerlat_dump_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "625-644",
    "snippet": "static void\n__timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, unsigned int size)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct stack_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_STACK, sizeof(*entry) + size,\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\n\tmemcpy(&entry->caller, fstack->calls, size);\n\tentry->size = fstack->nr_entries;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2948-2953",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&entry->caller",
            "fstack->calls",
            "size"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_STACK",
            "sizeof(*entry) + size",
            "tracing_gen_ctx()"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\n__timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, unsigned int size)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct stack_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_STACK, sizeof(*entry) + size,\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\n\tmemcpy(&entry->caller, fstack->calls, size);\n\tentry->size = fstack->nr_entries;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
  },
  {
    "function_name": "timerlat_save_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "607-623",
    "snippet": "static void timerlat_save_stack(int skip)\n{\n\tunsigned int size, nr_entries;\n\tstruct trace_stack *fstack;\n\n\tfstack = this_cpu_ptr(&trace_stack);\n\n\tsize = ARRAY_SIZE(fstack->calls);\n\n\tnr_entries = stack_trace_save(fstack->calls, size, skip);\n\n\tfstack->stack_size = nr_entries * sizeof(unsigned long);\n\tfstack->nr_entries = nr_entries;\n\n\treturn;\n\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack_trace_save",
          "args": [
            "fstack->calls",
            "size",
            "skip"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_save_tsk_reliable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "343-353",
          "snippet": "int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nint stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "fstack->calls"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&trace_stack"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void timerlat_save_stack(int skip)\n{\n\tunsigned int size, nr_entries;\n\tstruct trace_stack *fstack;\n\n\tfstack = this_cpu_ptr(&trace_stack);\n\n\tsize = ARRAY_SIZE(fstack->calls);\n\n\tnr_entries = stack_trace_save(fstack->calls, size, skip);\n\n\tfstack->stack_size = nr_entries * sizeof(unsigned long);\n\tfstack->nr_entries = nr_entries;\n\n\treturn;\n\n}"
  },
  {
    "function_name": "trace_timerlat_sample",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "572-583",
    "snippet": "static void trace_timerlat_sample(struct timerlat_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_timerlat_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_timerlat_sample",
          "args": [
            "sample",
            "buffer"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_timerlat_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "549-567",
          "snippet": "static void\n__trace_timerlat_sample(struct timerlat_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct timerlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_TIMERLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->context\t\t\t= sample->context;\n\tentry->timer_latency\t\t= sample->timer_latency;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\n__trace_timerlat_sample(struct timerlat_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct timerlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_TIMERLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->context\t\t\t= sample->context;\n\tentry->timer_latency\t\t= sample->timer_latency;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "inst",
            "&osnoise_instances",
            "list"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void trace_timerlat_sample(struct timerlat_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_timerlat_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "__trace_timerlat_sample",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "549-567",
    "snippet": "static void\n__trace_timerlat_sample(struct timerlat_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct timerlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_TIMERLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->context\t\t\t= sample->context;\n\tentry->timer_latency\t\t= sample->timer_latency;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2948-2953",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_TIMERLAT",
            "sizeof(*entry)",
            "tracing_gen_ctx()"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\n__trace_timerlat_sample(struct timerlat_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct timerlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_TIMERLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->context\t\t\t= sample->context;\n\tentry->timer_latency\t\t= sample->timer_latency;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
  },
  {
    "function_name": "print_timerlat_headers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "533-546",
    "snippet": "static void print_timerlat_headers(struct seq_file *s)\n{\n\tseq_puts(s, \"#                                _-----=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _----=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _---=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              || / _--=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              ||| / _-=> migrate-disable\\n\");\n\tseq_puts(s, \"#                              |||| /     delay\\n\");\n\tseq_puts(s, \"#                              |||||            ACTIVATION\\n\");\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||   TIMESTAMP   ID      \");\n\tseq_puts(s, \"      CONTEXT                 LATENCY\\n\");\n\tseq_puts(s, \"#              | |         |   |||||      |         |      \");\n\tseq_puts(s, \"            |                       |\\n\");\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"            |                       |\\n\""
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void print_timerlat_headers(struct seq_file *s)\n{\n\tseq_puts(s, \"#                                _-----=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _----=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _---=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              || / _--=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              ||| / _-=> migrate-disable\\n\");\n\tseq_puts(s, \"#                              |||| /     delay\\n\");\n\tseq_puts(s, \"#                              |||||            ACTIVATION\\n\");\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||   TIMESTAMP   ID      \");\n\tseq_puts(s, \"      CONTEXT                 LATENCY\\n\");\n\tseq_puts(s, \"#              | |         |   |||||      |         |      \");\n\tseq_puts(s, \"            |                       |\\n\");\n}"
  },
  {
    "function_name": "print_timerlat_headers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "516-531",
    "snippet": "static void print_timerlat_headers(struct seq_file *s)\n{\n\tseq_puts(s, \"#                                _-------=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _------=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _-----=> need-resched-lazy\\n\");\n\tseq_puts(s, \"#                              || / _----=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              ||| / _---=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              |||| / _--=> preempt-lazy-depth\\n\");\n\tseq_puts(s, \"#                              ||||| / _-=> migrate-disable\\n\");\n\tseq_puts(s, \"#                              |||||| /\\n\");\n\tseq_puts(s, \"#                              |||||||             ACTIVATION\\n\");\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||||   TIMESTAMP    ID     \");\n\tseq_puts(s, \"       CONTEXT                LATENCY\\n\");\n\tseq_puts(s, \"#              | |         |   |||||||      |         |      \");\n\tseq_puts(s, \"            |                       |\\n\");\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"            |                       |\\n\""
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void print_timerlat_headers(struct seq_file *s)\n{\n\tseq_puts(s, \"#                                _-------=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _------=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _-----=> need-resched-lazy\\n\");\n\tseq_puts(s, \"#                              || / _----=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              ||| / _---=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              |||| / _--=> preempt-lazy-depth\\n\");\n\tseq_puts(s, \"#                              ||||| / _-=> migrate-disable\\n\");\n\tseq_puts(s, \"#                              |||||| /\\n\");\n\tseq_puts(s, \"#                              |||||||             ACTIVATION\\n\");\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||||   TIMESTAMP    ID     \");\n\tseq_puts(s, \"       CONTEXT                LATENCY\\n\");\n\tseq_puts(s, \"#              | |         |   |||||||      |         |      \");\n\tseq_puts(s, \"            |                       |\\n\");\n}"
  },
  {
    "function_name": "trace_osnoise_sample",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "498-509",
    "snippet": "static void trace_osnoise_sample(struct osnoise_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_osnoise_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_osnoise_sample",
          "args": [
            "sample",
            "buffer"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_osnoise_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "470-493",
          "snippet": "static void\n__trace_osnoise_sample(struct osnoise_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct osnoise_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_OSNOISE, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->runtime\t\t= sample->runtime;\n\tentry->noise\t\t= sample->noise;\n\tentry->max_sample\t= sample->max_sample;\n\tentry->hw_count\t\t= sample->hw_count;\n\tentry->nmi_count\t= sample->nmi_count;\n\tentry->irq_count\t= sample->irq_count;\n\tentry->softirq_count\t= sample->softirq_count;\n\tentry->thread_count\t= sample->thread_count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\n__trace_osnoise_sample(struct osnoise_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct osnoise_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_OSNOISE, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->runtime\t\t= sample->runtime;\n\tentry->noise\t\t= sample->noise;\n\tentry->max_sample\t= sample->max_sample;\n\tentry->hw_count\t\t= sample->hw_count;\n\tentry->nmi_count\t= sample->nmi_count;\n\tentry->irq_count\t= sample->irq_count;\n\tentry->softirq_count\t= sample->softirq_count;\n\tentry->thread_count\t= sample->thread_count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "inst",
            "&osnoise_instances",
            "list"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void trace_osnoise_sample(struct osnoise_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_osnoise_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "__trace_osnoise_sample",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "470-493",
    "snippet": "static void\n__trace_osnoise_sample(struct osnoise_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct osnoise_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_OSNOISE, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->runtime\t\t= sample->runtime;\n\tentry->noise\t\t= sample->noise;\n\tentry->max_sample\t= sample->max_sample;\n\tentry->hw_count\t\t= sample->hw_count;\n\tentry->nmi_count\t= sample->nmi_count;\n\tentry->irq_count\t= sample->irq_count;\n\tentry->softirq_count\t= sample->softirq_count;\n\tentry->thread_count\t= sample->thread_count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2948-2953",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_OSNOISE",
            "sizeof(*entry)",
            "tracing_gen_ctx()"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic void\n__trace_osnoise_sample(struct osnoise_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct osnoise_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_OSNOISE, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->runtime\t\t= sample->runtime;\n\tentry->noise\t\t= sample->noise;\n\tentry->max_sample\t= sample->max_sample;\n\tentry->hw_count\t\t= sample->hw_count;\n\tentry->nmi_count\t= sample->nmi_count;\n\tentry->irq_count\t= sample->irq_count;\n\tentry->softirq_count\t= sample->softirq_count;\n\tentry->thread_count\t= sample->thread_count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
  },
  {
    "function_name": "print_osnoise_headers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "426-448",
    "snippet": "static void print_osnoise_headers(struct seq_file *s)\n{\n\tif (osnoise_data.tainted)\n\t\tseq_puts(s, \"# osnoise is tainted!\\n\");\n\n\tseq_puts(s, \"#                                _-----=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _----=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _---=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              || / _--=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              ||| / _-=> migrate-disable     \");\n\tseq_puts(s, \"                    MAX\\n\");\n\tseq_puts(s, \"#                              |||| /     delay               \");\n\tseq_puts(s, \"                    SINGLE      Interference counters:\\n\");\n\n\tseq_puts(s, \"#                              |||||               RUNTIME   \");\n\tseq_puts(s, \"   NOISE  %% OF CPU  NOISE    +-----------------------------+\\n\");\n\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||   TIMESTAMP    IN US    \");\n\tseq_puts(s, \"   IN US  AVAILABLE  IN US     HW    NMI    IRQ   SIRQ THREAD\\n\");\n\n\tseq_puts(s, \"#              | |         |   |||||      |           |      \");\n\tseq_puts(s, \"       |    |            |      |      |      |      |      |\\n\");\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"       |    |            |      |      |      |      |      |\\n\""
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic void print_osnoise_headers(struct seq_file *s)\n{\n\tif (osnoise_data.tainted)\n\t\tseq_puts(s, \"# osnoise is tainted!\\n\");\n\n\tseq_puts(s, \"#                                _-----=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _----=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _---=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              || / _--=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              ||| / _-=> migrate-disable     \");\n\tseq_puts(s, \"                    MAX\\n\");\n\tseq_puts(s, \"#                              |||| /     delay               \");\n\tseq_puts(s, \"                    SINGLE      Interference counters:\\n\");\n\n\tseq_puts(s, \"#                              |||||               RUNTIME   \");\n\tseq_puts(s, \"   NOISE  %% OF CPU  NOISE    +-----------------------------+\\n\");\n\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||   TIMESTAMP    IN US    \");\n\tseq_puts(s, \"   IN US  AVAILABLE  IN US     HW    NMI    IRQ   SIRQ THREAD\\n\");\n\n\tseq_puts(s, \"#              | |         |   |||||      |           |      \");\n\tseq_puts(s, \"       |    |            |      |      |      |      |      |\\n\");\n}"
  },
  {
    "function_name": "print_osnoise_headers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "397-424",
    "snippet": "static void print_osnoise_headers(struct seq_file *s)\n{\n\tif (osnoise_data.tainted)\n\t\tseq_puts(s, \"# osnoise is tainted!\\n\");\n\n\tseq_puts(s, \"#                                _-------=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _------=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _-----=> need-resched-lazy\\n\");\n\tseq_puts(s, \"#                              || / _----=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              ||| / _---=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              |||| / _--=> preempt-lazy-depth\\n\");\n\tseq_puts(s, \"#                              ||||| / _-=> migrate-disable\\n\");\n\n\tseq_puts(s, \"#                              |||||| /          \");\n\tseq_puts(s, \"                                     MAX\\n\");\n\n\tseq_puts(s, \"#                              ||||| /                         \");\n\tseq_puts(s, \"                    SINGLE      Interference counters:\\n\");\n\n\tseq_puts(s, \"#                              |||||||               RUNTIME   \");\n\tseq_puts(s, \"   NOISE  %% OF CPU  NOISE    +-----------------------------+\\n\");\n\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||||   TIMESTAMP    IN US    \");\n\tseq_puts(s, \"   IN US  AVAILABLE  IN US     HW    NMI    IRQ   SIRQ THREAD\\n\");\n\n\tseq_puts(s, \"#              | |         |   |||||||      |           |      \");\n\tseq_puts(s, \"       |    |            |      |      |      |      |      |\\n\");\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"       |    |            |      |      |      |      |      |\\n\""
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic void print_osnoise_headers(struct seq_file *s)\n{\n\tif (osnoise_data.tainted)\n\t\tseq_puts(s, \"# osnoise is tainted!\\n\");\n\n\tseq_puts(s, \"#                                _-------=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _------=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _-----=> need-resched-lazy\\n\");\n\tseq_puts(s, \"#                              || / _----=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              ||| / _---=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              |||| / _--=> preempt-lazy-depth\\n\");\n\tseq_puts(s, \"#                              ||||| / _-=> migrate-disable\\n\");\n\n\tseq_puts(s, \"#                              |||||| /          \");\n\tseq_puts(s, \"                                     MAX\\n\");\n\n\tseq_puts(s, \"#                              ||||| /                         \");\n\tseq_puts(s, \"                    SINGLE      Interference counters:\\n\");\n\n\tseq_puts(s, \"#                              |||||||               RUNTIME   \");\n\tseq_puts(s, \"   NOISE  %% OF CPU  NOISE    +-----------------------------+\\n\");\n\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||||   TIMESTAMP    IN US    \");\n\tseq_puts(s, \"   IN US  AVAILABLE  IN US     HW    NMI    IRQ   SIRQ THREAD\\n\");\n\n\tseq_puts(s, \"#              | |         |   |||||||      |           |      \");\n\tseq_puts(s, \"       |    |            |      |      |      |      |      |\\n\");\n}"
  },
  {
    "function_name": "timerlat_thread_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "387-390",
    "snippet": "static inline int timerlat_thread_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline int timerlat_thread_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "timerlat_softirq_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "383-386",
    "snippet": "static inline int timerlat_softirq_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline int timerlat_softirq_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "timerlat_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "378-381",
    "snippet": "static inline bool timerlat_enabled(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline bool timerlat_enabled(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "timerlat_thread_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "363-376",
    "snippet": "static inline int timerlat_thread_exit(struct osnoise_variables *osn_var)\n{\n\tstruct timerlat_variables *tlat_var = this_cpu_tmr_var();\n\t/*\n\t * If the timerlat is enabled, but the irq handler did\n\t * not run yet enabling timerlat_tracer, do not trace.\n\t */\n\tif (!tlat_var->tracing_thread) {\n\t\tosn_var->thread.delta_start = 0;\n\t\tosn_var->thread.arrival_time = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_tmr_var",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_tmr_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "227-230",
          "snippet": "static inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline int timerlat_thread_exit(struct osnoise_variables *osn_var)\n{\n\tstruct timerlat_variables *tlat_var = this_cpu_tmr_var();\n\t/*\n\t * If the timerlat is enabled, but the irq handler did\n\t * not run yet enabling timerlat_tracer, do not trace.\n\t */\n\tif (!tlat_var->tracing_thread) {\n\t\tosn_var->thread.delta_start = 0;\n\t\tosn_var->thread.arrival_time = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "timerlat_softirq_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "348-361",
    "snippet": "static inline int timerlat_softirq_exit(struct osnoise_variables *osn_var)\n{\n\tstruct timerlat_variables *tlat_var = this_cpu_tmr_var();\n\t/*\n\t * If the timerlat is enabled, but the irq handler did\n\t * not run yet enabling timerlat_tracer, do not trace.\n\t */\n\tif (!tlat_var->tracing_thread) {\n\t\tosn_var->softirq.arrival_time = 0;\n\t\tosn_var->softirq.delta_start = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_tmr_var",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "this_cpu_tmr_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "227-230",
          "snippet": "static inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline int timerlat_softirq_exit(struct osnoise_variables *osn_var)\n{\n\tstruct timerlat_variables *tlat_var = this_cpu_tmr_var();\n\t/*\n\t * If the timerlat is enabled, but the irq handler did\n\t * not run yet enabling timerlat_tracer, do not trace.\n\t */\n\tif (!tlat_var->tracing_thread) {\n\t\tosn_var->softirq.arrival_time = 0;\n\t\tosn_var->softirq.delta_start = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "timerlat_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "343-346",
    "snippet": "static inline bool timerlat_enabled(void)\n{\n\treturn osnoise_data.timerlat_tracer;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t/* total sampling period */\n\tu64\tsample_runtime;\t\t/* active sampling portion of period */\n\tu64\tstop_tracing;\t\t/* stop trace in the internal operation (loop/irq) */\n\tu64\tstop_tracing_total;\t/* stop trace in the final operation (report/thread) */\n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t/* timerlat period */\n\tu64\tprint_stack;\t\t/* print IRQ stack if total > */\n\tint\ttimerlat_tracer;\t/* timerlat tracer */\n#endif\n\tbool\ttainted;\t\t/* infor users and developers about a problem */\n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\nstatic inline bool timerlat_enabled(void)\n{\n\treturn osnoise_data.timerlat_tracer;\n}"
  },
  {
    "function_name": "osn_var_reset_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "273-277",
    "snippet": "static inline void osn_var_reset_all(void)\n{\n\tosn_var_reset();\n\ttlat_var_reset();\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlat_var_reset",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "tlat_var_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "235-247",
          "snippet": "static inline void tlat_var_reset(void)\n{\n\tstruct timerlat_variables *tlat_var;\n\tint cpu;\n\t/*\n\t * So far, all the values are initialized as 0, so\n\t * zeroing the structure is perfect.\n\t */\n\tfor_each_cpu(cpu, cpu_online_mask) {\n\t\ttlat_var = per_cpu_ptr(&per_cpu_timerlat_var, cpu);\n\t\tmemset(tlat_var, 0, sizeof(*tlat_var));\n\t}\n}",
          "includes": [
            "#include <trace/events/osnoise.h>",
            "#include <trace/events/sched.h>",
            "#include <trace/events/irq.h>",
            "#include <asm/trace/irq_vectors.h>",
            "#include \"trace.h\"",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void tlat_var_reset(void)\n{\n\tstruct timerlat_variables *tlat_var;\n\tint cpu;\n\t/*\n\t * So far, all the values are initialized as 0, so\n\t * zeroing the structure is perfect.\n\t */\n\tfor_each_cpu(cpu, cpu_online_mask) {\n\t\ttlat_var = per_cpu_ptr(&per_cpu_timerlat_var, cpu);\n\t\tmemset(tlat_var, 0, sizeof(*tlat_var));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "osn_var_reset",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "osn_var_reset_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
          "lines": "273-277",
          "snippet": "static inline void osn_var_reset_all(void)\n{\n\tosn_var_reset();\n\ttlat_var_reset();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void osn_var_reset_all(void)\n{\n\tosn_var_reset();\n\ttlat_var_reset();\n}"
  },
  {
    "function_name": "osn_var_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "255-268",
    "snippet": "static inline void osn_var_reset(void)\n{\n\tstruct osnoise_variables *osn_var;\n\tint cpu;\n\n\t/*\n\t * So far, all the values are initialized as 0, so\n\t * zeroing the structure is perfect.\n\t */\n\tfor_each_cpu(cpu, cpu_online_mask) {\n\t\tosn_var = per_cpu_ptr(&per_cpu_osnoise_var, cpu);\n\t\tmemset(osn_var, 0, sizeof(*osn_var));\n\t}\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "osn_var",
            "0",
            "sizeof(*osn_var)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&per_cpu_osnoise_var",
            "cpu"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpu_online_mask"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void osn_var_reset(void)\n{\n\tstruct osnoise_variables *osn_var;\n\tint cpu;\n\n\t/*\n\t * So far, all the values are initialized as 0, so\n\t * zeroing the structure is perfect.\n\t */\n\tfor_each_cpu(cpu, cpu_online_mask) {\n\t\tosn_var = per_cpu_ptr(&per_cpu_osnoise_var, cpu);\n\t\tmemset(osn_var, 0, sizeof(*osn_var));\n\t}\n}"
  },
  {
    "function_name": "tlat_var_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "235-247",
    "snippet": "static inline void tlat_var_reset(void)\n{\n\tstruct timerlat_variables *tlat_var;\n\tint cpu;\n\t/*\n\t * So far, all the values are initialized as 0, so\n\t * zeroing the structure is perfect.\n\t */\n\tfor_each_cpu(cpu, cpu_online_mask) {\n\t\ttlat_var = per_cpu_ptr(&per_cpu_timerlat_var, cpu);\n\t\tmemset(tlat_var, 0, sizeof(*tlat_var));\n\t}\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tlat_var",
            "0",
            "sizeof(*tlat_var)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&per_cpu_timerlat_var",
            "cpu"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpu_online_mask"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline void tlat_var_reset(void)\n{\n\tstruct timerlat_variables *tlat_var;\n\tint cpu;\n\t/*\n\t * So far, all the values are initialized as 0, so\n\t * zeroing the structure is perfect.\n\t */\n\tfor_each_cpu(cpu, cpu_online_mask) {\n\t\ttlat_var = per_cpu_ptr(&per_cpu_timerlat_var, cpu);\n\t\tmemset(tlat_var, 0, sizeof(*tlat_var));\n\t}\n}"
  },
  {
    "function_name": "this_cpu_tmr_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "227-230",
    "snippet": "static inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&per_cpu_timerlat_var"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}"
  },
  {
    "function_name": "this_cpu_osn_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "204-207",
    "snippet": "static inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&per_cpu_osnoise_var"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}"
  },
  {
    "function_name": "osnoise_unregister_instance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "119-142",
    "snippet": "static void osnoise_unregister_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr) {\n\t\t\tlist_del_rcu(&inst->list);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\tkvfree_rcu(inst);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree_rcu",
          "args": [
            "inst"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&inst->list"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "inst",
            "&osnoise_instances",
            "list"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&trace_types_lock"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic void osnoise_unregister_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr) {\n\t\t\tlist_del_rcu(&inst->list);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\tkvfree_rcu(inst);\n}"
  },
  {
    "function_name": "osnoise_register_instance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "92-111",
    "snippet": "static int osnoise_register_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tinst = kmalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD_RCU(&inst->list);\n\tinst->tr = tr;\n\tlist_add_tail_rcu(&inst->list, &osnoise_instances);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&inst->list",
            "&osnoise_instances"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD_RCU",
          "args": [
            "&inst->list"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*inst)",
            "GFP_KERNEL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&trace_types_lock"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic int osnoise_register_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\n\t/*\n\t * register/unregister serialization is provided by trace's\n\t * trace_types_lock.\n\t */\n\tlockdep_assert_held(&trace_types_lock);\n\n\tinst = kmalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD_RCU(&inst->list);\n\tinst->tr = tr;\n\tlist_add_tail_rcu(&inst->list, &osnoise_instances);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "osnoise_instance_registered",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "71-84",
    "snippet": "static int osnoise_instance_registered(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr)\n\t\t\tfound = 1;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "inst",
            "&osnoise_instances",
            "list"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic int osnoise_instance_registered(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr)\n\t\t\tfound = 1;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}"
  },
  {
    "function_name": "osnoise_has_registered_instances",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_osnoise.c",
    "lines": "61-66",
    "snippet": "static bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}",
    "includes": [
      "#include <trace/events/osnoise.h>",
      "#include <trace/events/sched.h>",
      "#include <trace/events/irq.h>",
      "#include <asm/trace/irq_vectors.h>",
      "#include \"trace.h\"",
      "#include <linux/sched.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head osnoise_instances;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_or_null_rcu",
          "args": [
            "&osnoise_instances",
            "structosnoise_instance",
            "list"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/osnoise.h>\n#include <trace/events/sched.h>\n#include <trace/events/irq.h>\n#include <asm/trace/irq_vectors.h>\n#include \"trace.h\"\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}"
  }
]